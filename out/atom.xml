<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><id>hnrss.org/frontpage</id><title>Hacker News: Front Page</title><updated>2025-10-24T16:44:00.618974+00:00</updated><link href="https://news.ycombinator.com/" rel="alternate"/><link href="https://raw.githubusercontent.com/Prabesh01/hnrss-content-extract/refs/heads/main/out/rss.xml" rel="self"/><generator uri="https://lkiesow.github.io/python-feedgen" version="1.0.0">python-feedgen</generator><subtitle>Hacker News RSS</subtitle><entry><id>https://news.ycombinator.com/item?id=45676841</id><title>The key to universe exists may lie in an 1800s knot idea science once dismissed</title><updated>2025-10-24T16:44:11.871014+00:00</updated><content>&lt;doc fingerprint="afbc878ba10f0779"&gt;
  &lt;main&gt;
    &lt;head rend="h1"&gt;The key to why the universe exists may lie in an 1800s knot idea science once dismissed&lt;/head&gt;
    &lt;head rend="h5"&gt;Sadie Harley&lt;/head&gt;
    &lt;p&gt;scientific editor&lt;/p&gt;
    &lt;head rend="h5"&gt;Robert Egan&lt;/head&gt;
    &lt;p&gt;associate editor&lt;/p&gt;
    &lt;p&gt;In 1867, Lord Kelvin imagined atoms as knots in the aether. The idea was soon disproven. Atoms turned out to be something else entirely. But his discarded vision may yet hold the key to why the universe exists.&lt;/p&gt;
    &lt;p&gt;Now, for the first time, Japanese physicists have shown that knots can arise in a realistic particle physics framework, one that also tackles deep puzzles such as neutrino masses, dark matter, and the strong CP problem.&lt;/p&gt;
    &lt;p&gt;Their findings, in Physical Review Letters, suggest these "cosmic knots" could have formed and briefly dominated in the turbulent newborn universe, collapsing in ways that favored matter over antimatter and leaving behind a unique hum in spacetime that future detectors could listen for—a rarity for a physics mystery that's notoriously hard to probe.&lt;/p&gt;
    &lt;p&gt;"This study addresses one of the most fundamental mysteries in physics: why our universe is made of matter and not antimatter," said study corresponding author Muneto Nitta, professor (special appointment) at Hiroshima University's International Institute for Sustainability with Knotted Chiral Meta Matter (WPI-SKCM2) in Japan.&lt;/p&gt;
    &lt;p&gt;"This question is important because it touches directly on why stars, galaxies, and we ourselves exist at all."&lt;/p&gt;
    &lt;head rend="h2"&gt;The universe's missing antimatter&lt;/head&gt;
    &lt;p&gt;The Big Bang should have produced equal amounts of matter and antimatter, each particle destroying its twin until only radiation remained. Yet the universe is overwhelmingly made of matter, with almost no antimatter in sight. Calculations show that everything we see today, from atoms to galaxies, exists because just one extra particle of matter survived for every billion matter–antimatter pairs.&lt;/p&gt;
    &lt;p&gt;The Standard Model of particle physics, despite its extraordinary success, cannot account for that discrepancy. Its predictions fall many orders of magnitude short. Explaining the origin of that tiny excess of matter, known as baryogenesis, is one of physics' greatest unsolved puzzles.&lt;/p&gt;
    &lt;p&gt;Nitta and Minoru Eto of Hiroshima University's WPI-SKCM2, an institute created to study knotted and chiral phenomena across scales and disciplines, working with Yu Hamada of the Deutsches Elektronen-Synchrotron in Germany, believe they have found an answer hiding in plain sight.&lt;/p&gt;
    &lt;p&gt;By combining a gauged Baryon Number Minus Lepton Number (B-L) symmetry, with the Peccei–Quinn (PQ) symmetry, the team showed that knots could naturally form in the early universe and generate the observed surplus.&lt;/p&gt;
    &lt;p&gt;Eto is also a professor at Yamagata University, and all three researchers are affiliated with Keio University in Japan.&lt;/p&gt;
    &lt;head rend="h2"&gt;Ghost particles&lt;/head&gt;
    &lt;p&gt;These two long-studied extensions of the Standard Model patch some of its most puzzling gaps. The PQ symmetry solves the strong CP problem, the conundrum of why experiments don't detect the tiny electric dipole moment that theory predicts for the neutron, and in the process, introduces the axion, a leading dark matter candidate. Meanwhile, the B–L symmetry explains why neutrinos, ghostlike particles that can slip through entire planets unnoticed, have mass.&lt;/p&gt;
    &lt;p&gt;Keeping the PQ symmetry global, rather than gauging it, preserves the delicate axion physics that solves the strong-CP problem. In physics, "gauging" a symmetry means letting it act freely at every point in spacetime. But that local freedom comes at a cost. To preserve consistency, nature must introduce a new force carrier to smooth out the equations.&lt;/p&gt;
    &lt;p&gt;By gauging the B–L symmetry, the researchers not only guaranteed the presence of heavy right-handed neutrinos—required to keep the theory anomaly-free and central to leading baryogenesis models—but also introduced a superconducting behavior that provided the magnetic backbone for possibly some of the universe's earliest knots.&lt;/p&gt;
    &lt;head rend="h2"&gt;Writhing cosmic relics&lt;/head&gt;
    &lt;p&gt;As the universe cooled after the Big Bang, its symmetries fractured through a series of phase transitions and, like ice freezing unevenly, may have left behind thread-like defects called cosmic strings, hypothetical cracks in spacetime that many cosmologists believe may still be out there. Though thinner than a proton, an inch of string could outweigh mountains.&lt;/p&gt;
    &lt;p&gt;As the cosmos expanded, a writhing web of these filaments would have stretched and tangled, carrying imprints of the primordial conditions that once prevailed.&lt;/p&gt;
    &lt;p&gt;The breaking of the B–L symmetry produced magnetic flux tube strings, while the PQ symmetry gave rise to flux-free superfluid vortices. Their very contrast is what makes them compatible.&lt;/p&gt;
    &lt;p&gt;The B-L flux tube gives the PQ superfluid vortex's Chern–Simons coupling something to latch on to. And in turn, the coupling lets the PQ superfluid vortex pump charge into the B-L flux tube, countering the tension that would normally make the loop snap. The result was a metastable, topologically locked configuration called a knot soliton.&lt;/p&gt;
    &lt;p&gt;"Nobody had studied these two symmetries at the same time," Nitta said. "That was kind of lucky for us. Putting them together revealed a stable knot."&lt;/p&gt;
    &lt;head rend="h2"&gt;Phantom-like barrier crossings&lt;/head&gt;
    &lt;p&gt;While radiation lost energy as its waves stretched with spacetime, the knots behaved like matter, fading far more slowly. They soon overtook everything else, ushering in a knot-dominated era when their energy density, not radiation's, ruled the cosmos. But that reign didn't last.&lt;/p&gt;
    &lt;p&gt;The knots eventually untangled through quantum tunneling, a phantom-like process in which particles slip through energy barriers as if they weren't there at all.&lt;/p&gt;
    &lt;p&gt;Their collapse generated heavy right-handed neutrinos, a built-in consequence of the B–L symmetry woven into their structure. These massive ghostly particles then decayed into lighter, more stable forms with a faint bias toward matter over antimatter, giving us the universe we now know.&lt;/p&gt;
    &lt;p&gt;"Basically, this collapse produces a lot of particles, including the right-handed neutrinos, the scalar bosons, and the gauge boson, like a shower," study co-author Hamada explains.&lt;/p&gt;
    &lt;p&gt;"Among them, the right-handed neutrinos are special because their decay can naturally generate the imbalance between matter and antimatter. These heavy neutrinos decay into lighter particles, such as electrons and photons, creating a secondary cascade that reheats the universe."&lt;/p&gt;
    &lt;p&gt;"In this sense," he added, "they are the parents of all matter in the universe today, including our own bodies, while the knots can be thought of as our grandparents."&lt;/p&gt;
    &lt;head rend="h2"&gt;Tying it together&lt;/head&gt;
    &lt;p&gt;When the researchers followed the math encoded in their model—how efficiently the knots produced right-handed neutrinos, how massive those neutrinos were, and how hot the cosmos reheated after they decayed—the matter–antimatter imbalance we observe today emerged naturally from the equation.&lt;/p&gt;
    &lt;p&gt;Rearranging the formula and plugging in a realistic mass of 1012 giga-electronvolts (GeV) for the heavy right-handed neutrinos, and assuming the knots channeled most of their stored energy into creating these particles, the model naturally landed at a reheating temperature of 100 GeV.&lt;/p&gt;
    &lt;p&gt;That temperature coincidentally marks the universe's final window for making matter. Any colder, and the electroweak reactions that convert a neutrino imbalance into matter would shut down for good.&lt;/p&gt;
    &lt;p&gt;Reheating to 100 GeV would also have reshaped the universe's gravitational-wave chorus, tilting it toward higher frequencies. Future observatories such as the Laser Interferometer Space Antenna (LISA) in Europe, Cosmic Explorer in the United States, and the Deci-hertz Interferometer Gravitational-wave Observatory (DECIGO) in Japan could one day listen for that subtle change in tune.&lt;/p&gt;
    &lt;p&gt;"Cosmic strings are a kind of topological soliton, objects defined by quantities that stay the same no matter how much you twist or stretch them," Eto said.&lt;/p&gt;
    &lt;p&gt;"That property not only ensures their stability, it also means our result isn't tied to the model's specifics. Even though the work is still theoretical, the underlying topology doesn't change, so we see this as an important step toward future developments."&lt;/p&gt;
    &lt;p&gt;While Kelvin originally conjectured knots as the fundamental building blocks of matter, the researchers argued that their findings "provide, for the first time, a realistic particle physics model in which knots may play a crucial role in the origin of matter."&lt;/p&gt;
    &lt;p&gt;"The next step is to refine theoretical models and simulations to better predict the formation and decay of these knots, and to connect their signatures with observational signals," Nitta said.&lt;/p&gt;
    &lt;p&gt;"In particular, upcoming gravitational-wave experiments such as LISA, Cosmic Explorer, and DECIGO will be able to test whether the universe really passed through a knot-dominated era."&lt;/p&gt;
    &lt;p&gt;The researchers hope to unravel whether knots were essential to the origin of matter and, in doing so, tie together a fuller story of the universe's beginnings.&lt;/p&gt;
    &lt;p&gt;More information: Minoru Eto et al, Tying Knots in Particle Physics, Physical Review Letters (2025). DOI: 10.1103/s3vd-brsn&lt;/p&gt;
    &lt;p&gt;Journal information: Physical Review Letters&lt;/p&gt;
    &lt;p&gt;Provided by Hiroshima University&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://phys.org/news/2025-10-key-universe-1800s-idea-science.html"/><published>2025-10-23T00:26:24+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45678001</id><title>Clojure Zippers (2021)</title><updated>2025-10-24T16:44:11.126835+00:00</updated><content>&lt;doc fingerprint="bf039b1a1c1d8f21"&gt;
  &lt;main&gt;
    &lt;head rend="h1"&gt;Clojure Zippers&lt;/head&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Part 1. The Basics of Navigation&lt;/item&gt;
      &lt;item&gt;Part 2. Automatic navigation&lt;/item&gt;
      &lt;item&gt;Part 3. XML zippers&lt;/item&gt;
      &lt;item&gt;Part 4. XML search&lt;/item&gt;
      &lt;item&gt;Part 5. Editing&lt;/item&gt;
      &lt;item&gt;Part 6. Virtual Trees. Currency Exchange&lt;/item&gt;
      &lt;item&gt;Part 7. Breadth-First Traversal. Improved Currency Exchange&lt;/item&gt;
      &lt;item&gt;Part 8. Summary&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h2"&gt;Part 1. The Basics of Navigation&lt;/head&gt;
    &lt;p&gt;In this article, we will discuss zippers in the Clojure language. These are an unusual way to work with collections. Using a zipper, you can traverse a data structure arbitrarily and modify its content as well as search in it. A zipper is a powerful abstraction that pays off over time. However, it is not as straightforward as regular tools and requires training to deal with.&lt;/p&gt;
    &lt;p&gt;Let’s talk about a zipper in simple terms. It is a wrapper that offers a variety of data manipulations. Let’s list the main ones:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;moving vertically: down to children or up to a parent;&lt;/item&gt;
      &lt;item&gt;moving horizontally: left or right among children;&lt;/item&gt;
      &lt;item&gt;traversal of the entire data structure;&lt;/item&gt;
      &lt;item&gt;adding, editing and deleting nodes.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;This is a partial list, and you will see the most interesting solutions more later. Note: these capabilities are available when working with arbitrary data, whether it’s a combination of vectors and maps, XML, or a tree. This makes zippers a powerful tool. If you figure out how to handle them, you will boost your skills and open new doors.&lt;/p&gt;
    &lt;p&gt;The good news is that zippers are available in the base Clojure package. It’s better than a third party library that needs to be included. Zippers are easy to add to a project with no fear of license issues or new dependencies.&lt;/p&gt;
    &lt;p&gt;Clojure zippers harness the power of immutable collections. Technically, a zipper is a collection that stores data and the position of the pointer. Together they are called a location. A step in either direction returns a new location, just like the &lt;code&gt;assoc&lt;/code&gt; or &lt;code&gt;update&lt;/code&gt; functions generate new data from old data.&lt;/p&gt;
    &lt;p&gt;From the current location, you can get a node, that is, a piece of data that the pointer refers to. Let’s clarify their difference to avoid confusing beginners. Location is the source data and the position in it. Moving around the location generates a new location. From the location, you can retrieve a node — the data that is in this area.&lt;/p&gt;
    &lt;p&gt;Below is an example with the vector &lt;code&gt;[1 2 3]&lt;/code&gt;. To move to the second item, the two, you need to wrap the data in a zipper and execute the &lt;code&gt;zip/down&lt;/code&gt; and&lt;code&gt; zip/right&lt;/code&gt; commands. In the first step, we’ll get into the vector and find ourselves on element 1. A step to the right will move us to 2. Let’s express it in code: include the package with the alias &lt;code&gt;zip&lt;/code&gt; and traverse the vector.&lt;/p&gt;
    &lt;code&gt;(require '[clojure.zip :as zip])

(-&amp;gt; [1 2 3]
    zip/vector-zip
    zip/down
    zip/right
    zip/node)
;; 2
&lt;/code&gt;
    &lt;p&gt;Chaining these functions will return 2 as expected. The last action — &lt;code&gt;zip/node&lt;/code&gt; — outputs the value (a node) from the current location. If we remove &lt;code&gt;zip/node&lt;/code&gt;, we’ll get a location that corresponds to 2. It looks like this:&lt;/p&gt;
    &lt;code&gt;(-&amp;gt; [1 2 3]
    zip/vector-zip
    zip/down
    zip/right)

;; [2 {:l [1], :pnodes [[1 2 3]], :ppath nil, :r (3)}]
&lt;/code&gt;
    &lt;p&gt;Maybe you have some questions: how do we know the path to the 2 when it could have been elsewhere in the vector? What happens if we go outside the collection? You’ll find the answers to these questions below. For now, if something is not clear to you, do not panic: we’ll clarify more than once everything happening here.&lt;/p&gt;
    &lt;p&gt;So, the zipper suggests navigating through the data. Despite its power, it doesn’t know how to do this for a specific collection, so you need to teach it. In addition to data, a zipper requires answers to two questions:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;
        &lt;p&gt;Is the current element a branch? This is the name of the element from which you can get other ones.&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;If it’s a branch, how do you fetch children from it?&lt;/p&gt;
      &lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;That’s all a zipper needs to know to navigate. Note, for changing the zipper itself, you need to know the answer to one more question — how to attach children to a branch. However, we are only looking at navigation, so the third question can wait.&lt;/p&gt;
    &lt;p&gt;Technically, functions give the answers to the first and second questions. The first one takes a node and returns &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. If it returns &lt;code&gt;true&lt;/code&gt;, the zipper calls the second function. It takes the same node but should return a sequence of child nodes or &lt;code&gt;nil&lt;/code&gt; if they don’t exist. In code, these functions are called &lt;code&gt;branch?&lt;/code&gt; and &lt;code&gt;children&lt;/code&gt;.&lt;/p&gt;
    &lt;p&gt;To get a zipper, you need to tell it input data and the two functions just described. As long as we only read a zipper, the third function can be &lt;code&gt;nil&lt;/code&gt;. The zippers locate in the &lt;code&gt;clojure.zip&lt;/code&gt; package. Include it into namespace:&lt;/p&gt;
    &lt;code&gt;(ns my.project
  (:require [clojure.zip :as zip]))
&lt;/code&gt;
    &lt;p&gt;Explore the source code for this module in your leisure time. It is only 280 lines long!&lt;/p&gt;
    &lt;p&gt;The &lt;code&gt;zip/zipper&lt;/code&gt; function creates a zipper from source data and functions. This is the module’s main point, its building blocks. For common cases, the module offers some predefined zippers that only expect data. &lt;code&gt;Vector-zip&lt;/code&gt; for nested vectors is a good example. Here is its code without the third parameter:&lt;/p&gt;
    &lt;code&gt;(defn vector-zip
  [root]
  (zipper vector?
          seq
          ...
          root))
&lt;/code&gt;
    &lt;p&gt;We replaced it with three dots. The third parameter is a function that attaches child nodes to the branch on change (ignore it for now). If you pass the vector &lt;code&gt;[1 2 3]&lt;/code&gt; to &lt;code&gt;vector-zip&lt;/code&gt;, the following happens:&lt;/p&gt;
    &lt;p&gt;The zipper will wrap the vector and expose a pointer to it. From the starting position, you can only traverse down, because at the top a zipper has no parent (up) and neighbors (left and right). When navigating down, the zipper first checks if the branch is the current node. That triggers the expression &lt;code&gt;(vector? [1 2 3])&lt;/code&gt; that gets evaluated to &lt;code&gt;true&lt;/code&gt;. In this case, the zipper will execute &lt;code&gt;(seq [1 2 3])&lt;/code&gt; to get children. They will be the sequence &lt;code&gt;(1 2 3)&lt;/code&gt;. Once the children are found, the zipper will set the pointer to the leftmost child — 1.&lt;/p&gt;
    &lt;p&gt;Let’s show this in the diagram. Start position, a pointer is on the source vector:&lt;/p&gt;
    &lt;code&gt;                ┌───────┐
                │  nil  │
                └───────┘
                    ▲
                    │
 ┌───────┐    ┏━━━━━━━━━━━┓    ┌───────┐
 │  nil  │◀───┃  [1 2 3]  ┃───▶│  nil  │
 └───────┘    ┗━━━━━━━━━━━┛    └───────┘
                    │
                    ▼
                ┌───────┐
                │   1   │
                └───────┘
&lt;/code&gt;
    &lt;p&gt;Step down, the pointer is at 1:&lt;/p&gt;
    &lt;code&gt;                ┌───────┐
                │[1 2 3]│
                └───────┘
                    ▲
                    │
 ┌───────┐    ┏━━━━━━━━━━━┓    ┌───────┐
 │  nil  │◀───┃     1     ┃───▶│   2   │
 └───────┘    ┗━━━━━━━━━━━┛    └───────┘
                    │
                    ▼
                ┌───────┐
                │  nil  │
                └───────┘
&lt;/code&gt;
    &lt;p&gt;Step to the right, the pointer on 2:&lt;/p&gt;
    &lt;code&gt;                ┌───────┐
                │[1 2 3]│
                └───────┘
                    ▲
                    │
 ┌───────┐    ┏━━━━━━━━━━━┓    ┌───────┐
 │  nil  │◀───┃     2     ┃───▶│   3   │
 └───────┘    ┗━━━━━━━━━━━┛    └───────┘
                    │
                    ▼
                ┌───────┐
                │  nil  │
                └───────┘
&lt;/code&gt;
    &lt;p&gt;So, we are on 2 and can move horizontally. A step to the right will move us to 3, to the left — to 1. In the code, it looks like this:&lt;/p&gt;
    &lt;code&gt;(def loc2
  (-&amp;gt; [1 2 3]
      zip/vector-zip
      zip/down
      zip/right))

(-&amp;gt; loc2 zip/node)
;; 2

(-&amp;gt; loc2 zip/right zip/node)
;; 3

(-&amp;gt; loc2 zip/left zip/node)
;; 1
&lt;/code&gt;
    &lt;p&gt;When trying to move down, the zipper will execute the &lt;code&gt;(vector? 2)&lt;/code&gt; predicate. The result
will be &lt;code&gt;false&lt;/code&gt;, which means that the current element is not a branch and no downward movement is allowed.&lt;/p&gt;
    &lt;p&gt;Remember the following as you traverse. Each step creates a new location without changing the old one. If you save any particular location in a variable, subsequent calls to &lt;code&gt;zip/right,&lt;/code&gt; &lt;code&gt;zip/down&lt;/code&gt;, and others will not change it in any way. Above, we have declared the &lt;code&gt;loc2&lt;/code&gt; variable,
which points to 2. You can use it to get the source vector.&lt;/p&gt;
    &lt;code&gt;(-&amp;gt; loc2 zip/up zip/node)
;; [1 2 3]
&lt;/code&gt;
    &lt;p&gt;If you move along manually, chances are good that you will go outside the collection. A step to nowhere will return &lt;code&gt;nil&lt;/code&gt; instead of a location:&lt;/p&gt;
    &lt;code&gt;(-&amp;gt; [1 2 3]
    zip/vector-zip
    zip/down
    zip/left)
nil
&lt;/code&gt;
    &lt;p&gt;This is a signal that you are on the wrong route. The bad news is that you cannot go back from &lt;code&gt;nil&lt;/code&gt;. &lt;code&gt;Nil&lt;/code&gt; signifies an empty location, and there is no reference to the previous step in it. The &lt;code&gt;zip/up&lt;/code&gt;, &lt;code&gt;zip/right&lt;/code&gt; and other functions also return &lt;code&gt;nil&lt;/code&gt; for an empty location. If you iterate in a cycle and do not take this into account, you’ll just end up spinning your wheels.&lt;/p&gt;
    &lt;code&gt;(-&amp;gt; [1 2 3]
zip/vector-zip
zip/down
zip/left
zip/left
zip/left
zip/left)
&lt;/code&gt;
    &lt;p&gt;The &lt;code&gt;zip/down&lt;/code&gt; function is an exception: if you try to descend from &lt;code&gt;nil&lt;/code&gt;, you’ll get a &lt;code&gt;NullPointerException&lt;/code&gt; error. This is a slight defect that probably will be fixed on day.&lt;/p&gt;
    &lt;code&gt;(-&amp;gt; [1 2 3]
zip/vector-zip
zip/down
zip/left
zip/down)

;; Execution error (NullPointerException)...
&lt;/code&gt;
    &lt;p&gt;Let’s take a look at a more complex vector. One of its children is another vector — &lt;code&gt;[1 [2 3] 4]&lt;/code&gt;. To move the pointer to 3, make the steps &lt;code&gt;down&lt;/code&gt;, &lt;code&gt;right&lt;/code&gt;, &lt;code&gt;down&lt;/code&gt;, and &lt;code&gt;right&lt;/code&gt;. Let’s store a location in a variable:&lt;/p&gt;
    &lt;code&gt;(def loc3
  (-&amp;gt; [1 [2 3] 4]
      zip/vector-zip
      zip/down
      zip/right
      zip/down
      zip/right))

(zip/node loc3)
3
&lt;/code&gt;
    &lt;p&gt;The pictures below show what happens at each step. Starting position:&lt;/p&gt;
    &lt;code&gt;                ┌───────┐
                │  nil  │
                └───────┘
                    ▲
                    │
 ┌───────┐    ┏━━━━━━━━━━━┓    ┌───────┐
 │  nil  │◀───┃[1 [2 3] 4]┃───▶│  nil  │
 └───────┘    ┗━━━━━━━━━━━┛    └───────┘
                    │
                    ▼
                ┌───────┐
                │   1   │
                └───────┘
&lt;/code&gt;
    &lt;p&gt;Step down:&lt;/p&gt;
    &lt;code&gt;              ┌───────────┐
              │[1 [2 3] 4]│
              └───────────┘
                    ▲
                    │
 ┌───────┐    ┏━━━━━━━━━━━┓    ┌───────┐
 │  nil  │◀───┃     1     ┃───▶│ [2 3] │
 └───────┘    ┗━━━━━━━━━━━┛    └───────┘
                    │
                    ▼
                ┌───────┐
                │  nil  │
                └───────┘
&lt;/code&gt;
    &lt;p&gt;To the right:&lt;/p&gt;
    &lt;code&gt;              ┌───────────┐
              │[1 [2 3] 4]│
              └───────────┘
                    ▲
                    │
 ┌───────┐    ┏━━━━━━━━━━━┓    ┌───────┐
 │   1   │◀───┃   [2 3]   ┃───▶│   4   │
 └───────┘    ┗━━━━━━━━━━━┛    └───────┘
                    │
                    ▼
                ┌───────┐
                │   2   │
                └───────┘
&lt;/code&gt;
    &lt;p&gt;Down:&lt;/p&gt;
    &lt;code&gt;              ┌───────────┐
              │   [2 3]   │
              └───────────┘
                    ▲
                    │
 ┌───────┐    ┏━━━━━━━━━━━┓    ┌───────┐
 │   1   │◀───┃     2     ┃───▶│   3   │
 └───────┘    ┗━━━━━━━━━━━┛    └───────┘
                    │
                    ▼
                ┌───────┐
                │  nil  │
                └───────┘
&lt;/code&gt;
    &lt;p&gt;To the right. We are at our goal:&lt;/p&gt;
    &lt;code&gt;              ┌───────────┐
              │   [2 3]   │
              └───────────┘
                    ▲
                    │
 ┌───────┐    ┏━━━━━━━━━━━┓    ┌───────┐
 │   2   │◀───┃     3     ┃───▶│  nil  │
 └───────┘    ┗━━━━━━━━━━━┛    └───────┘
                    │
                    ▼
                ┌───────┐
                │  nil  │
                └───────┘
&lt;/code&gt;
    &lt;p&gt;To move to 4 from the current position, you first need to go up. The pointer will move to vector &lt;code&gt;[2 3]&lt;/code&gt;. Now we are among the children of the original vector and can move horizontally. Let’s take a step to the right and find ourselves at number 4.&lt;/p&gt;
    &lt;p&gt;Here the same actions are shown graphically. The current location (i.e., 3):&lt;/p&gt;
    &lt;code&gt;              ┌───────────┐
              │   [2 3]   │
              └───────────┘
                    ▲
                    │
 ┌───────┐    ┏━━━━━━━━━━━┓    ┌───────┐
 │   2   │◀───┃     3     ┃───▶│  nil  │
 └───────┘    ┗━━━━━━━━━━━┛    └───────┘
                    │
                    ▼
                ┌───────┐
                │  nil  │
                └───────┘
&lt;/code&gt;
    &lt;p&gt;Step up:&lt;/p&gt;
    &lt;code&gt;              ┌───────────┐
              │[1 [2 3] 4]│
              └───────────┘
                    ▲
                    │
 ┌───────┐    ┏━━━━━━━━━━━┓    ┌───────┐
 │   1   │◀───┃   [2 3]   ┃───▶│   4   │
 └───────┘    ┗━━━━━━━━━━━┛    └───────┘
                    │
                    ▼
                ┌───────┐
                │   2   │
                └───────┘
&lt;/code&gt;
    &lt;p&gt;Step to the right:&lt;/p&gt;
    &lt;code&gt;              ┌───────────┐
              │[1 [2 3] 4]│
              └───────────┘
                    ▲
                    │
 ┌───────┐    ┏━━━━━━━━━━━┓    ┌───────┐
 │ [2 3] │◀───┃     4     ┃───▶│  nil  │
 └───────┘    ┗━━━━━━━━━━━┛    └───────┘
                    │
                    ▼
                ┌───────┐
                │  nil  │
                └───────┘
&lt;/code&gt;
    &lt;p&gt;The original vector can be of any nesting. As an exercise, replace 3 with another vector and go down into it.&lt;/p&gt;
    &lt;p&gt;What does happen if you pass something other than a vector to &lt;code&gt;vector-zip&lt;/code&gt;?  For example, it might be a string, nil, or a number. Before traversing, the zipper checks to see if the node is a branch and if it has child nodes. For &lt;code&gt;vector-zip&lt;/code&gt;, it checks the data with the &lt;code&gt;vector?&lt;/code&gt; function, which returns &lt;code&gt;nil&lt;/code&gt; for all non-vector values. As a result, we get a location from where we can’t step anywhere: neither down nor laterally. This dead end must be avoided.&lt;/p&gt;
    &lt;code&gt;(-&amp;gt; "test"
    zip/vector-zip
    zip/down)
nil
&lt;/code&gt;
    &lt;p&gt;The &lt;code&gt;clojure.zip&lt;/code&gt; module also offers other built-in zippers. The &lt;code&gt;xml-zip&lt;/code&gt; is especially interesting for navigating XML trees. We’ll discuss it separately when you get to know the other zipper features.&lt;/p&gt;
    &lt;head rend="h2"&gt;Part 2. Automatic navigation&lt;/head&gt;
    &lt;p&gt;We figured out how to navigate through the collection. However, you might wonder how the path goes? How do you know in advance in which direction to go?&lt;/p&gt;
    &lt;p&gt;The main message of this section is: Manual navigation through data makes no sense. If you know the path beforehand, you don’t need a zipper.&lt;/p&gt;
    &lt;p&gt;For data whose structure you know in advance, Clojure offers an easier way to work with. For example, if we know for sure that the input data structure is a vector, and its second element is another vector, we’ll use &lt;code&gt;get-in&lt;/code&gt;:&lt;/p&gt;
    &lt;code&gt;(def data [1 [2 3] 4])

(get-in data [1 1])
;; 3
&lt;/code&gt;
    &lt;p&gt;The same goes for other data types. It doesn’t matter what combination lists and maps make. If the structure is known in advance, the data you need can be easily reached with a &lt;code&gt;get-in&lt;/code&gt; or threading macro. In this case, zippers will only complicate the code.&lt;/p&gt;
    &lt;code&gt;(def data {:users [{:name "Ivan"}]})

(-&amp;gt; data :users first :name)
;; "Ivan"
&lt;/code&gt;
    &lt;p&gt;What is the advantage of zippers? Their strengths are manifested in situations where &lt;code&gt;get-in&lt;/code&gt; can’t work. It’s about data with an unknown structure. Let’s say there is an arbitrary vector as input, and you need to find a string in it. For example, it might be at the first nesting level, or at the third, and so on. Another example is an XML document. The required tag can be located anywhere in it, but you need to find it somehow. In short, the ideal situation for a zipper is a fuzzy data structure that we’re only guessing about.&lt;/p&gt;
    &lt;p&gt;Together, the functions &lt;code&gt;zip/up&lt;/code&gt;, &lt;code&gt;zip/down&lt;/code&gt;, and others form the universal function — &lt;code&gt;zip/next&lt;/code&gt;. It
moves the pointer so that sooner or later we’ll traverse the entire structure. When traversing, repetitions are excluded: we’ll visit each place only once. Here is an example with a vector:&lt;/p&gt;
    &lt;code&gt;(def vzip (zip/vector-zip [1 [2 3] 4]))

(-&amp;gt; vzip zip/node)
;; [1 [2 3] 4]

(-&amp;gt; vzip zip/next zip/node)
;; 1

(-&amp;gt; vzip zip/next zip/next zip/node)
;; [2 3]

(-&amp;gt; vzip zip/next zip/next zip/next zip/node)
;; 2
&lt;/code&gt;
    &lt;p&gt;We don’t know how many times to call &lt;code&gt;zip/next&lt;/code&gt;, so let’s resort to a ploy. The &lt;code&gt;iterate&lt;/code&gt; function takes the &lt;code&gt;f&lt;/code&gt; function and an &lt;code&gt;x&lt;/code&gt; value. It returns a sequence where the first element is &lt;code&gt;x&lt;/code&gt;, and each next is an &lt;code&gt;f(x)&lt;/code&gt; from the previous one. For a zipper, we get the initial location, then &lt;code&gt;zip/next&lt;/code&gt; from it, then &lt;code&gt;zip/next&lt;/code&gt; from the previous movement, and so on.&lt;/p&gt;
    &lt;p&gt;Below, the variable &lt;code&gt;loc-seq&lt;/code&gt; is the location chain of the source zipper. To get the nodes, we take the first six elements (the number we take randomly) and call &lt;code&gt;zip/node&lt;/code&gt; for each.&lt;/p&gt;
    &lt;code&gt;(def loc-seq (iterate zip/next vzip))

(-&amp;gt;&amp;gt; loc-seq
     (take 6)
     (map zip/node))

;; ([1 [2 3] 4]
;;   1
;;   [2 3]
;;   2
;;   3
;;   4)
&lt;/code&gt;
    &lt;p&gt;&lt;code&gt;Iterate&lt;/code&gt; returns a lazy and infinite sequence. Both characteristics are important. Laziness means that the next shift (i.e., calling &lt;code&gt;zip/next&lt;/code&gt;) will not happen until you reach an element in the chain. Infinity means that &lt;code&gt;zip/next&lt;/code&gt; is called an unlimited number of times. We need a flag to indicate that we need to stop calling &lt;code&gt;zip/next&lt;/code&gt;, otherwise the stream of locations will never end.&lt;/p&gt;
    &lt;p&gt;In addition, at some point, &lt;code&gt;zip/next&lt;/code&gt; stops moving the pointer. Take, for example, the hundredth and thousandth elements of an iteration. Their node will be the initial vector:&lt;/p&gt;
    &lt;code&gt;(-&amp;gt; loc-seq (nth 100) zip/node)
;; [1 [2 3] 4]

(-&amp;gt; loc-seq (nth 1000) zip/node)
;; [1 [2 3] 4]
&lt;/code&gt;
    &lt;p&gt;The reason lies in how the zipper traversal works. The &lt;code&gt;zip/next&lt;/code&gt; function acts like a ring. When it reaches the initial location, the loop ends. In this case, the location will get a completion flag, and the next calling &lt;code&gt;zip/next&lt;/code&gt; will return the same location. You can check a flag presence with the &lt;code&gt;zip/end?&lt;/code&gt; function:&lt;/p&gt;
    &lt;code&gt;(def loc-end
  (-&amp;gt; [1 2 3]
      zip/vector-zip
      zip/next
      zip/next
      zip/next
      zip/next))

loc-end
;; [[1 2 3] :end]

(zip/end? loc-end)
&lt;/code&gt;
    &lt;p&gt;To create the finite chain of locations, we’ll keep moving the pointer until we get the last location. Together, this gives the following function:&lt;/p&gt;
    &lt;code&gt;(defn iter-zip [zipper]
  (-&amp;gt;&amp;gt; zipper
       (iterate zip/next)
       (take-while (complement zip/end?))))
&lt;/code&gt;
    &lt;p&gt;This function returns all locations in the data structure. Recall that a location stores a node (a data element) that we can get using &lt;code&gt;zip/node&lt;/code&gt;. The example below shows how to convert locations into data:&lt;/p&gt;
    &lt;code&gt;(-&amp;gt;&amp;gt; [1 [2 3] 4]
     zip/vector-zip
     iter-zip
     (map zip/node))

;; ([1 [2 3] 4]
;;  1
;;  [2 3]
;;  2
;;  3
;;  4)
&lt;/code&gt;
    &lt;p&gt;Now we have a chain of locations. Let’s write a search. Suppose you want to check if the vector contains the &lt;code&gt;:error&lt;/code&gt; keyword. First, let’s write a predicate for a location to know whether its node is equal to this value.&lt;/p&gt;
    &lt;code&gt;(defn loc-error? [loc]
  (-&amp;gt; loc zip/node (= :error)))
&lt;/code&gt;
    &lt;p&gt;Well, let’s check if there is one in the chain of locations that matches our predicate. To do this, call &lt;code&gt;some&lt;/code&gt;:&lt;/p&gt;
    &lt;code&gt;(def data [1 [2 3 [:test [:foo :error]]] 4])

(some loc-error?
      (-&amp;gt; data zip/vector-zip iter-zip))

;; true
&lt;/code&gt;
    &lt;p&gt;Note that due to laziness, we are not scanning the entire tree. If the required node appears in the middle, &lt;code&gt;iter-zip&lt;/code&gt; ends the iteration and stops making calls, and further &lt;code&gt;zip/next&lt;/code&gt; calls won’t happen.&lt;/p&gt;
    &lt;p&gt;It’s useful to know that &lt;code&gt;zip/next&lt;/code&gt; traverses a tree in depth-first order. As it moves, it tends to go down or to the right, but up only when steps in these directions return &lt;code&gt;nil&lt;/code&gt;. As we’ll see later, sometimes the traversal order is important. There’re tasks where we have to traverse in breadth-first order. There’re no other default options for traversal in &lt;code&gt;clojure.zip&lt;/code&gt;, but we can easily write
our own. We’ll look at a task that requires traversal in breadth later.&lt;/p&gt;
    &lt;p&gt;The built-in &lt;code&gt;vector-zip&lt;/code&gt; zipper is for nested vectors. But nested maps are much more common. Let’s write a zipper to traverse such data:&lt;/p&gt;
    &lt;code&gt;(def map-data
  {:foo 1
   :bar 2
   :baz {:test "hello"
         :word {:nested true}}})
&lt;/code&gt;
    &lt;p&gt;Let’s take the familiar vector-zip as a basis. These zippers are similar, the only difference is the collection type they work with. Let’s think about how to define functions that answer the questions. The map is a branch whose children are &lt;code&gt;MapEntry&lt;/code&gt; elements. This type represents a key-value pair. If the value is a map, we get a chain of nested &lt;code&gt;MapEntry&lt;/code&gt; from it and so on.&lt;/p&gt;
    &lt;p&gt;To warm up, let’s write a predicate for checking the &lt;code&gt;MapEntry&lt;/code&gt; type:&lt;/p&gt;
    &lt;code&gt;(def entry?
  (partial instance? clojure.lang.MapEntry))
&lt;/code&gt;
    &lt;p&gt;The &lt;code&gt;map-zip&lt;/code&gt; zipper looks like this:&lt;/p&gt;
    &lt;code&gt;(defn map-zip [mapping]
  (zip/zipper
   (some-fn entry? map?)
   (fn [x]
     (cond
       (map? x) (seq x)

       (and (entry? x)
            (-&amp;gt; x val map?))
       (-&amp;gt; x val seq)))
   nil
   mapping))
&lt;/code&gt;
    &lt;p&gt;Let’s discuss the main points. The &lt;code&gt;(some-fn ...)&lt;/code&gt; composition returns &lt;code&gt;true&lt;/code&gt; if one of the predicate-parameters works positively. In other words, we consider only the map or its entry (key-value pair) as a branch.&lt;/p&gt;
    &lt;p&gt;In the second function, which looks for children, we have to check some conditions. If the current value is a map, we return a sequence of map entries using the &lt;code&gt;seq&lt;/code&gt; function. If we are already in &lt;code&gt;MapEntry&lt;/code&gt;, then check if the value is a nested map. If it is, we should get its children with the same &lt;code&gt;seq&lt;/code&gt; function.&lt;/p&gt;
    &lt;p&gt;When traversing the tree, we’ll get all the key-value pairs. If the value is a nested dictionary, we’ll fall into it when traversing. Here is an example:&lt;/p&gt;
    &lt;code&gt;(-&amp;gt;&amp;gt; {:foo 42
      :bar {:baz 11
            :user/name "Ivan"}}
     map-zip
     iter-zip
     rest
     (map zip/node))

;; ([:foo 42]
;;  [:bar {:baz 11, :user/name "Ivan"}]
;;  [:baz 11]
;;  [:user/name "Ivan"])
&lt;/code&gt;
    &lt;p&gt;Notice the &lt;code&gt;rest&lt;/code&gt; function after &lt;code&gt;iter-zip&lt;/code&gt;. We skipped the first location that contains the original data. Since they are already known, their printing makes no sense.&lt;/p&gt;
    &lt;p&gt;Using our &lt;code&gt;map-zip&lt;/code&gt;, we can check if the map contains the &lt;code&gt;:error&lt;/code&gt; key with the &lt;code&gt;:auth&lt;/code&gt; value. Each of these keywords can be anywhere, both in keys and in values at any level. However, we are interested in their combination. To do this, let’s write a predicate:&lt;/p&gt;
    &lt;code&gt;(defn loc-err-auth? [loc]
  (-&amp;gt; loc zip/node (= [:error :auth])))
&lt;/code&gt;
    &lt;p&gt;Let’s make sure that there is no such pair in the first dictionary, even if the values appear separately:&lt;/p&gt;
    &lt;code&gt;(-&amp;gt;&amp;gt; {:response {:error :expired
                 :auth :failed}}
     map-zip
     iter-zip
     (some loc-err-auth?))

;; nil
&lt;/code&gt;
    &lt;p&gt;We’ll find this pair, even if it is deeply nested:&lt;/p&gt;
    &lt;code&gt;(def data
  {:response {:info {:message "Auth error"
                     :error :auth
                     :code 1005}}})

(-&amp;gt;&amp;gt; data
     map-zip
     iter-zip
     (some loc-err-auth?))

;; true
&lt;/code&gt;
    &lt;p&gt;Below are a few tasks for independent work.&lt;/p&gt;
    &lt;p&gt;1. The &lt;code&gt;map-zip&lt;/code&gt; zipper ignores the situation where the map key is another map.
For example:&lt;/p&gt;
    &lt;code&gt;{{:alg "MD5" :salt "***"} "deprecated"
{:alg "SHA2" :salt "****"} "deprecated"
{:alg "HMAC-SHA256" :key "xxx"} "ok"}
&lt;/code&gt;
    &lt;p&gt;Such collections, although rarely, are used sometimes. Modify &lt;code&gt;map-zip&lt;/code&gt; so that it checks not only the value of &lt;code&gt;MapEntry&lt;/code&gt; but also the key.&lt;/p&gt;
    &lt;p&gt;2. In practice, we work with a combination of vectors and maps. Write a universal zipper that takes into account both the map and the vector when traversing.&lt;/p&gt;
    &lt;head rend="h2"&gt;Part 3. XML zippers&lt;/head&gt;
    &lt;p&gt;The power of zippers is fully revealed when working with XML. Unlike other formats, it is specified recursively. For example, JSON, YAML, and other formats offer data types (numbers, strings, collections) with different syntax and structure. In XML, wherever we are, the current node always consists of three components: tag, attributes, and content. Content is a set of strings or other nodes. Here’s a recursive pseudocode notation:&lt;/p&gt;
    &lt;code&gt;XML = [Tag, Attrs, [String|XML]]
&lt;/code&gt;
    &lt;p&gt;To make sure the XML is homogeneous, consider an abstract file with vendor items:&lt;/p&gt;
    &lt;code&gt;&amp;lt;?xml version="1.0" encoding="UTF-8"?&amp;gt;
&amp;lt;catalog&amp;gt;
  &amp;lt;organization name="re-Store"&amp;gt;
    &amp;lt;product type="iphone"&amp;gt;iPhone 11 Pro&amp;lt;/product&amp;gt;
    &amp;lt;product type="iphone"&amp;gt;iPhone SE&amp;lt;/product&amp;gt;
  &amp;lt;/organization&amp;gt;
  &amp;lt;organization name="DNS"&amp;gt;
    &amp;lt;product type="tablet"&amp;gt;iPad 3&amp;lt;/product&amp;gt;
    &amp;lt;product type="notebook"&amp;gt;Macbook Pro&amp;lt;/product&amp;gt;
  &amp;lt;/organization&amp;gt;
&amp;lt;/catalog&amp;gt;
&lt;/code&gt;
    &lt;p&gt;At the top of the XML is the &lt;code&gt;catalog&lt;/code&gt; node. It’s just a grouping tag; we need it because there can’t be multiple tags at the top. The &lt;code&gt;catalog&lt;/code&gt; children are organizations. The &lt;code&gt;name&lt;/code&gt; attribute of the organization contains its name. Products are under the organization. A product is a node with a &lt;code&gt;product&lt;/code&gt; tag and a description of the product type. Instead of children, it has text content — its description. It’s impossible to go down below a product.&lt;/p&gt;
    &lt;p&gt;Clojure offers an XML parser that returns a structure similar to the &lt;code&gt;[Tag, Attrs, Content]&lt;/code&gt; schema above. Each node becomes a map with the keys :tag, :attrs, and &lt;code&gt;:content&lt;/code&gt;. The &lt;code&gt;:content&lt;/code&gt; key stores a vector where an element is either a string or a nested map.&lt;/p&gt;
    &lt;p&gt;We put the XML data with products in the &lt;code&gt;resources/products.xml&lt;/code&gt; file. Let’s write a function to parse a file into an XML zipper. Add module imports:&lt;/p&gt;
    &lt;code&gt;(:require
 [clojure.java.io :as io]
 [clojure.xml :as xml])
&lt;/code&gt;
    &lt;p&gt;Both come with Clojure and therefore do not require dependencies. To get the zipper, we pass the &lt;code&gt;path&lt;/code&gt; parameter through a series of functions:&lt;/p&gt;
    &lt;code&gt;(defn -&amp;gt;xml-zipper [path]
  (-&amp;gt; path
      io/resource
      io/file
      xml/parse
      zip/xml-zip))
&lt;/code&gt;
    &lt;p&gt;The &lt;code&gt;xml/parse&lt;/code&gt; function should return a nested structure consisting of maps with keys &lt;code&gt;: tag&lt;/code&gt;,
&lt;code&gt;:attrs&lt;/code&gt;, and &lt;code&gt;:content&lt;/code&gt;. Note that text content such as a product name, is also a vector with one string. This achieves the homogeneity of each node.&lt;/p&gt;
    &lt;p&gt;This is what we should get after calling &lt;code&gt;xml/parse&lt;/code&gt;:&lt;/p&gt;
    &lt;code&gt;{:tag :catalog
 :attrs nil
 :content
 [{:tag :organization
   :attrs {:name "re-Store"}
   :content
   [{:tag :product
     :attrs {:type "iphone"}
     :content ["iPhone 11 Pro"]}
    {:tag :product :attrs {:type "iphone"} :content ["iPhone SE"]}]}
  {:tag :organization
   :attrs {:name "DNS"}
   :content
   [{:tag :product :attrs {:type "tablet"} :content ["iPad 3"]}
    {:tag :product
     :attrs {:type "notebook"}
     :content ["Macbook Pro"]}]}]}
&lt;/code&gt;
    &lt;p&gt;The call of &lt;code&gt;(-&amp;gt;xml-zipper "products.xml")&lt;/code&gt; creates the initial location of the XML zipper from the data above. First, let’s take a look at the definition of &lt;code&gt;xml-zip&lt;/code&gt; to understand how it works. Here we present code excerpts:&lt;/p&gt;
    &lt;code&gt;(defn xml-zip
  [root]
  (zipper (complement string?)
          (comp seq :content)
          ...
          root))
&lt;/code&gt;
    &lt;p&gt;As you might guess, the children of the node are its &lt;code&gt;:content&lt;/code&gt;, additionally wrapped in &lt;code&gt;seq&lt;/code&gt;. A string can’t have children, so &lt;code&gt;(complement string?)&lt;/code&gt; means — search for children only in non-string nodes.&lt;/p&gt;
    &lt;p&gt;Look at how we would find all products from a given XML. First, let’s get a lazy iteration over its zipper. Recall that at each step we get not a map with &lt;code&gt;:tag&lt;/code&gt; and other fields, but a zip location with a pointer to it. It remains only to filter out the locations which nodes contain the product tag. To do this let’s write a predicate:&lt;/p&gt;
    &lt;code&gt;(defn loc-product? [loc]
  (-&amp;gt; loc zip/node :tag (= :product)))
&lt;/code&gt;
    &lt;p&gt;And let’s write a transforming selection:&lt;/p&gt;
    &lt;code&gt;(-&amp;gt;&amp;gt; "products.xml"
     -&amp;gt;xml-zipper
     iter-zip
     (filter loc-product?)
     (map loc-&amp;gt;product))

;; ("iPhone 11 Pro" "iPhone SE" "iPad 3" "Macbook Pro")
&lt;/code&gt;
    &lt;p&gt;At first glance, there is nothing special here. The XML structure is known in advance, so we can do it without zipper. Let’s select catalog children and get organizations, then we’ll get organizations’ children (i.e., goods). Here’s this simple code:&lt;/p&gt;
    &lt;code&gt;(def xml-data
  (-&amp;gt; "products.xml"
      io/resource
      io/file
      xml/parse))

(def orgs
  (:content xml-data))

(def products
  (mapcat :content orgs))

(def product-names
  (mapcat :content products))
&lt;/code&gt;
    &lt;p&gt;To make the code more concise, you can remove the intermediate variables and narrow it down to one form:&lt;/p&gt;
    &lt;code&gt;(-&amp;gt;&amp;gt; "products.xml"
     io/resource
     io/file
     xml/parse
     :content
     (mapcat :content)
     (mapcat :content))

;; ("iPhone 11 Pro" "iPhone SE" "iPad 3" "Macbook Pro")
&lt;/code&gt;
    &lt;p&gt;In practice, the structure of XML always changes. Suppose a super-large dealer breaks down products by branch. In this case, the XML looks like this (a snippet):&lt;/p&gt;
    &lt;code&gt;&amp;lt;organization name="DNS"&amp;gt;
  &amp;lt;branch name="Office 1"&amp;gt;
    &amp;lt;product type="tablet"&amp;gt;iPad 3&amp;lt;/product&amp;gt;
    &amp;lt;product type="notebook"&amp;gt;Macbook Pro&amp;lt;/product&amp;gt;
  &amp;lt;/branch&amp;gt;
  &amp;lt;branch name="Office 2"&amp;gt;
    &amp;lt;product type="tablet"&amp;gt;iPad 4&amp;lt;/product&amp;gt;
    &amp;lt;product type="phone"&amp;gt;Samsung A6+&amp;lt;/product&amp;gt;
  &amp;lt;/branch&amp;gt;
&amp;lt;/organization&amp;gt;
&lt;/code&gt;
    &lt;p&gt;The above code that selected data only by level won’t work anymore. If we run it against the new XML, we’ll get a branch node along with the products:&lt;/p&gt;
    &lt;code&gt;("iPhone 11 Pro"
 "iPhone SE"
 {:tag :product, :attrs {:type "tablet"}, :content ["iPad 3"]} ...)
&lt;/code&gt;
    &lt;p&gt;If we used a zipper, it would return only products, including those from the branch:&lt;/p&gt;
    &lt;code&gt;(-&amp;gt;&amp;gt; "products-branch.xml"
     -&amp;gt;xml-zipper
     iter-zip
     (filter loc-product?)
     (map loc-&amp;gt;product))

("iPhone 11 Pro" "iPhone SE" "iPad 3" "Macbook Pro" "iPad 4" "Samsung A6+")
&lt;/code&gt;
    &lt;p&gt;Obviously, it’s beneficial to use code that works with both XML rather than maintaining a separate version for a large dealer. In the latter case, you have to store the flag, which supplier is normal and which is large, and promptly update it.&lt;/p&gt;
    &lt;p&gt;However, this example doesn’t cover the full capacity of the zippers. The &lt;code&gt;xml-seq&lt;/code&gt; function from the core Clojure module also provides XML traversal. The function returns a lazy sequence of XML nodes in the same form (a map with &lt;code&gt;:tag&lt;/code&gt;, &lt;code&gt;:attr&lt;/code&gt;, and &lt;code&gt;:content&lt;/code&gt;). &lt;code&gt;Xml-seq&lt;/code&gt; is a special case of the more abstract &lt;code&gt;tree-seq&lt;/code&gt; function. The latter is similar to a zipper in that it takes similar functions to determine if a node can be a branch and how to get its children. As you can see from the code, the &lt;code&gt;xml-seq&lt;/code&gt; and &lt;code&gt;xml-zip&lt;/code&gt; definitions are similar:&lt;/p&gt;
    &lt;code&gt;(defn xml-seq
  [root]
  (tree-seq
    (complement string?)
    (comp seq :content)
    root))
&lt;/code&gt;
    &lt;p&gt;The difference between a zipper and &lt;code&gt;tree-seq&lt;/code&gt; is that when iterating, the zipper returns a location — a more abstract and more informative element. Instead, &lt;code&gt;tree-seq&lt;/code&gt; produces unwrapped elements during iteration. For ordinary searches, &lt;code&gt;tree-seq&lt;/code&gt; is even preferable, since it doesn’t generate unnecessary abstractions. The selection of goods, taking into account branches, looks like this:&lt;/p&gt;
    &lt;code&gt;(defn node-product? [node]
  (some-&amp;gt; node :tag (= :product)))

(-&amp;gt;&amp;gt; "products-branch.xml"
     io/resource
     io/file
     xml/parse
     xml-seq
     (filter node-product?)
     (mapcat :content))

("iPhone 11 Pro" "iPhone SE" "iPad 3" "Macbook Pro" "iPad 4" "Samsung A6+")
&lt;/code&gt;
    &lt;p&gt;To get back to zippers, let’s pick a problem where &lt;code&gt;tree-seq&lt;/code&gt; loses its benefits. Manual search can be such a task.&lt;/p&gt;
    &lt;head rend="h2"&gt;Part 4. XML search&lt;/head&gt;
    &lt;p&gt;Let’s say we need to select the stores that sell iPhones from an XML with products. Note: this is the first time we’ve touched on the relationship between nodes. That’s important! It’s easy to select the data individually. Shops are locations that have the &lt;code&gt;organization&lt;/code&gt; tag. iPhones are locations that have a node with the &lt;code&gt;product&lt;/code&gt; tag and the &lt;code&gt;type="tablet"&lt;/code&gt; attribute. But how to find a relationship between them?&lt;/p&gt;
    &lt;p&gt;The previous time, we decomposed the XML into a sequence using &lt;code&gt;xml-seq&lt;/code&gt;. The problem is that the function returns a collection of nodes with no relationship, which prevents us from solving our task. Let’s show this with an example: First, let’s get a chain of nodes:&lt;/p&gt;
    &lt;code&gt;(def xml-nodes
  (-&amp;gt;&amp;gt; "products-branch.xml"
     io/resource
     io/file
     xml/parse
     xml-seq))
&lt;/code&gt;
    &lt;p&gt;Let’s say the product we want is in one of the elements. For example, we’ll find an iPhone in the third (second from zero) node:&lt;/p&gt;
    &lt;code&gt;(-&amp;gt; xml-nodes (nth 2))
;; {:tag :product :attrs {:type "iphone"} :content ["iPhone 11 Pro"]}
&lt;/code&gt;
    &lt;p&gt;However, it is difficult to find out which store it is from. You can guess that the store is to the left of the product, because when traversing the tree, it precedes the product. This becomes clear if you print the node tags:&lt;/p&gt;
    &lt;code&gt;(-&amp;gt;&amp;gt; xml-nodes (mapv :tag) (remove nil?) (run! print))
;; :catalog :organization :product :product :organization ...
&lt;/code&gt;
    &lt;p&gt;This is a more or less correct assumption, but you shouldn’t rely on it too much because the result depends on the XML traversal order. In addition, solving the problem becomes more complicated. When traversing, you need not only to select the desired products but also to move back in search of a store. Then you will have to move forward again, skipping the found product, otherwise, you’ll find yourself in an infinite loop. This approach is stateful and works well in imperative languages but not in Clojure.&lt;/p&gt;
    &lt;p&gt;This is where a zipper comes in. A location, which it returns at each step, remembers its position in the structure. This means that we can navigate from the location to the required place using the functions &lt;code&gt;zip/up&lt;/code&gt;, &lt;code&gt;zip/right&lt;/code&gt;, and others, which we discussed in the first part. In this case, the use of manual navigation is reasonable.&lt;/p&gt;
    &lt;p&gt;Let’s go back to XML with a simple catalog-organization-products structure. Let’s refresh it in memory.&lt;/p&gt;
    &lt;code&gt;&amp;lt;?xml version="1.0" encoding="UTF-8"?&amp;gt;
&amp;lt;catalog&amp;gt;
  &amp;lt;organization name="re-Store"&amp;gt;
    &amp;lt;product type="iphone"&amp;gt;iPhone 11 Pro&amp;lt;/product&amp;gt;
    &amp;lt;product type="iphone"&amp;gt;iPhone SE&amp;lt;/product&amp;gt;
  &amp;lt;/organization&amp;gt;
  &amp;lt;organization name="DNS"&amp;gt;
    &amp;lt;product type="tablet"&amp;gt;iPad 3&amp;lt;/product&amp;gt;
    &amp;lt;product type="notebook"&amp;gt;Macbook Pro&amp;lt;/product&amp;gt;
  &amp;lt;/organization&amp;gt;
&amp;lt;/catalog&amp;gt;
&lt;/code&gt;
    &lt;p&gt;First of all, let’s find iPhones-locations and write the predicate for the iPhone:&lt;/p&gt;
    &lt;code&gt;(defn loc-iphone? [loc]
  (let [node (zip/node loc)]
    (and (-&amp;gt; node :tag (= :product))
         (-&amp;gt; node :attrs :type (= "iphone")))))
&lt;/code&gt;
    &lt;p&gt;Get locations with iPhones:&lt;/p&gt;
    &lt;code&gt;(def loc-iphones
  (-&amp;gt;&amp;gt; "products.xml"
       -&amp;gt;xml-zipper
       iter-zip
       (filter loc-iphone?)))

(count loc-iphones)
2
&lt;/code&gt;
    &lt;p&gt;Now, to find an organization by the product, just go up one level using &lt;code&gt;zip/up&lt;/code&gt;. This is true because the organization is the parent of the product:&lt;/p&gt;
    &lt;code&gt;(def loc-orgs
  (-&amp;gt;&amp;gt; loc-iphones
       (map zip/up)
       (map (comp :attrs zip/node))))

({:name "re-Store"} {:name "re-Store"})
&lt;/code&gt;
    &lt;p&gt;For each iPhone, we should get the organization that sells it. We got duplicates because both iPhones are sold in the re:Store shop. To make the result unique, wrap it in &lt;code&gt;set&lt;/code&gt;.&lt;/p&gt;
    &lt;code&gt;
(set loc-orgs)
#{{:name "re-Store"}}

&lt;/code&gt;
    &lt;p&gt;This is the answer to the question: iPhones can be bought at re:Store. If you add an iPhone to the DNS organization, the latter also appears in &lt;code&gt;loc-orgs&lt;/code&gt;.&lt;/p&gt;
    &lt;p&gt;Let’s solve the same problem for XML with branches. Now we can’t call &lt;code&gt;zip/up&lt;/code&gt; on a product to get the organization, because in some cases we’ll get a branch and it will take one more step up. In order not to guess how many steps to take up, let’s write the function &lt;code&gt;loc-&amp;gt;org&lt;/code&gt;. It’ll step up until we find the required tag:&lt;/p&gt;
    &lt;code&gt;(defn loc-org? [loc]
  (-&amp;gt; loc zip/node :tag (= :organization)))

(defn loc-&amp;gt;org [loc]
  (-&amp;gt;&amp;gt; loc
       (iterate zip/up)
       (find-first loc-org?)))
&lt;/code&gt;
    &lt;p&gt;The &lt;code&gt;find-first&lt;/code&gt; utility function finds the first collection element that matches the predicate. We’ll use this function more than once.&lt;/p&gt;
    &lt;code&gt;(defn find-first [pred coll]
  (some (fn [x]
          (when (pred x)
            x))
        coll))
&lt;/code&gt;
    &lt;p&gt;To shorten the code, we won’t declare the variables &lt;code&gt;loc-iphones&lt;/code&gt; and others. Let’s express the search in one form:&lt;/p&gt;
    &lt;code&gt;(-&amp;gt;&amp;gt; "products-branch.xml"
     -&amp;gt;xml-zipper
     iter-zip
     (filter loc-iphone?)
     (map loc-&amp;gt;org)
     (map (comp :attrs zip/node))
     (set))
&lt;/code&gt;
    &lt;p&gt;In the new solution, we have replaced &lt;code&gt;zip/up&lt;/code&gt; with a function of a more complex climbing algorithm. Otherwise, nothing has changed.&lt;/p&gt;
    &lt;p&gt;Notice how convenient XML is for searching and navigating. If we store data in JSON, it is a combination of lists and dictionaries, and the versions with and without branches are different.&lt;/p&gt;
    &lt;p&gt;Here are products without branch stores:&lt;/p&gt;
    &lt;code&gt;[{"name": "re-Store",
  "products": [{"type": "iphone", "name": "iPhone 11 Pro"},
               {"type": "iphone", "name": "iPhone SE"}]},
 {"name": "DNS",
  "products": [{"type": "tablet", "name": "iPad 3"},
               {"type": "notebook", "name": "Macbook Pro"}]}]
&lt;/code&gt;
    &lt;p&gt;Here are products with them:&lt;/p&gt;
    &lt;code&gt;[{"name": "re-Store",
  "products": [{"type": "iphone", "name": "iPhone 11 Pro"},
               {"type": "iphone", "name": "iPhone SE"}]},
 {"name": "DNS",
  "branches": [{"name": "Office 1",
                "products": [{"type": "tablet", "name": "iPad 3"},
                             {"type": "notebook", "name": "Macbook Pro"}]},
               {"name": "Office 2",
                "products": [{"type": "tablet", "name": "iPad 3"},
                             {"type": "notebook", "name": "Macbook Pro"}]}]}]
&lt;/code&gt;
    &lt;p&gt;It goes without saying that traversing these structures requires different code. In the case of XML, its structure is homogeneous: adding a branch only changes the depth of goods nesting, but the traversal rules remain unchanged.&lt;/p&gt;
    &lt;p&gt;Let’s complicate the problem requirements: there’re bundles of products among individual ones. A bundle product can’t be purchased separately. For example, screen cleaning wipes are usually sold with the device. They ask us to find a store where a wipe is sold separately.&lt;/p&gt;
    &lt;p&gt;Here is an example:&lt;/p&gt;
    &lt;code&gt;&amp;lt;?xml version="1.0" encoding="UTF-8"?&amp;gt;
&amp;lt;catalog&amp;gt;
  &amp;lt;organization name="re-Store"&amp;gt;
    &amp;lt;product type="fiber"&amp;gt;VIP Fiber Plus&amp;lt;/product&amp;gt;
    &amp;lt;product type="iphone"&amp;gt;iPhone 11 Pro&amp;lt;/product&amp;gt;
  &amp;lt;/organization&amp;gt;
  &amp;lt;organization name="DNS"&amp;gt;
    &amp;lt;branch name="Office 2"&amp;gt;
      &amp;lt;bundle&amp;gt;
        &amp;lt;product type="fiber"&amp;gt;Premium iFiber&amp;lt;/product&amp;gt;
        &amp;lt;product type="iphone"&amp;gt;iPhone 11 Pro&amp;lt;/product&amp;gt;
      &amp;lt;/bundle&amp;gt;
    &amp;lt;/branch&amp;gt;
  &amp;lt;/organization&amp;gt;
&amp;lt;/catalog&amp;gt;
&lt;/code&gt;
    &lt;p&gt;As an exercise let’s find all the wipes. Among them will be both individual products and a set.&lt;/p&gt;
    &lt;code&gt;(defn loc-fiber? [loc]
  (some-&amp;gt; loc zip/node :attrs :type (= "fiber")))

(-&amp;gt;&amp;gt; "products-bundle.xml"
     -&amp;gt;xml-zipper
     iter-zip
     (filter loc-fiber?)
     (map (comp first :content zip/node)))

("VIP Fiber Plus" "Premium iFiber")
&lt;/code&gt;
    &lt;p&gt;Let’s start solving the problem. First, we find all the wipes as we did above. Then we cut off those that are included in the bundle. In terms of a zipper, this means that this location’s parent doesn’t have the &lt;code&gt;:bundle&lt;/code&gt; tag. After that, we move on from the rest wipes to stores.&lt;/p&gt;
    &lt;p&gt;The &lt;code&gt;loc-in-bundle?&lt;/code&gt; predicate checks if a location is included in the bundle:&lt;/p&gt;
    &lt;code&gt;(defn loc-in-bundle? [loc]
  (some-&amp;gt; loc zip/up zip/node :tag (= :bundle)))
&lt;/code&gt;
    &lt;p&gt;The final solution:&lt;/p&gt;
    &lt;code&gt;(-&amp;gt;&amp;gt; "products-bundle.xml"
     -&amp;gt;xml-zipper
     iter-zip
     (filter loc-fiber?)
     (remove loc-in-bundle?)
     (map loc-&amp;gt;org)
     (map (comp :attrs zip/node))
     (set))


#{{:name "re-Store"}}

&lt;/code&gt;
    &lt;p&gt;The DNS store wasn’t included in the result because it sells wipes in a bundle only.&lt;/p&gt;
    &lt;p&gt;New complication: we want to buy an iPhone, but only in a bundle with a wipe. Which store should you direct a buyer to?&lt;/p&gt;
    &lt;p&gt;Solution: First, look for all iPhones. Select only those that present in a bundle. Next, we are looking for a wipe among the neighbors of the iPhone. If you find it, go up to the store from the iPhone or the wipe. Most of the functions required for this search are ready: these are predicates for checking a bundle, product type, and other small things. But we have not yet considered how to get the neighbors of the location.&lt;/p&gt;
    &lt;p&gt;The functions &lt;code&gt;zip/lefts&lt;/code&gt; and &lt;code&gt;zip/rights&lt;/code&gt; return the nodes to the left and right of the current location. If we &lt;code&gt;concat&lt;/code&gt; them, we get all the neighbors (also called peers):&lt;/p&gt;
    &lt;code&gt;(defn node-neighbors [loc]
  (concat (zip/lefts loc)
          (zip/rights loc)))
&lt;/code&gt;
    &lt;p&gt;Note: These are nodes, not locations. Let’s make a quick check with a vector:&lt;/p&gt;
    &lt;code&gt;(-&amp;gt; [1 2 3]
    zip/vector-zip
    zip/down
    zip/right ;; node 2
    node-neighbors)

;; (1 3)
&lt;/code&gt;
    &lt;p&gt;The zipper is designed in such a way that getting the right and left nodes is easier than moving the location to the left or right. Therefore, when looking for neighbors, it is better to work with nodes (values) rather than locations.&lt;/p&gt;
    &lt;p&gt;Let’s add functions to check if there is a wipe that is adjacent to the location:&lt;/p&gt;
    &lt;code&gt;(defn node-fiber? [node]
  (some-&amp;gt; node :attrs :type (= "fiber")))

(defn with-fiber? [loc]
  (let [nodes (node-neighbors loc)]
    (find-first node-fiber? nodes)))
&lt;/code&gt;
    &lt;p&gt;Here’s the final expression:&lt;/p&gt;
    &lt;code&gt;(-&amp;gt;&amp;gt; "products-bundle.xml"
     -&amp;gt;xml-zipper
     iter-zip
     (filter loc-iphone?)
     (filter loc-in-bundle?)
     (filter with-fiber?)
     (map loc-&amp;gt;org)
     (map (comp :name :attrs zip/node))
     (set))

;; #{"DNS"}
&lt;/code&gt;
    &lt;p&gt;As a result, we get the DNS store, because it sells the bundles including an iPhone and a wipe. Both of these products are available in re:Store, but separately. It doesn’t suit us. If we replace a wipe with a headset in the bundle, we’ll get no store.&lt;/p&gt;
    &lt;p&gt;Finally, we can add new constraints. For example, from the found stores, select those that are located within a radius of 300 meters from the customer. To do this, we need the store locations on the map and a function checking if a point is inside a circle. You can choose only open stores or those that offer delivery. Let’s write these features into the attributes of organizations and add selection functions.&lt;/p&gt;
    &lt;p&gt;Our XML zipper has become like a database. It provides answers to complex queries, and at the same time, the code grows slower than the semantic load. Because of its regular structure, XML is highly traversable, and zippers further enhance this property. Pay attention to the convenient transitions and relationships between nodes. Imagine the effort it took to split the data into tables and build SQL queries with many JOINs.&lt;/p&gt;
    &lt;p&gt;Of course, compared to a true database, XML has a drawback: it has no indexes and only a linear search works in it, not a binary tree one. Besides, in our approach, all data is in memory. It won’t work well for very large documents with millions of records, but we don’t care about that yet.&lt;/p&gt;
    &lt;head rend="h2"&gt;Part 5. Editing&lt;/head&gt;
    &lt;p&gt;So far, we’ve ignored another zipper possibility. During the traversal, you can not only parse but also change locations. In broad terms, all CRUD (Create, Read, Update, Delete) operations familiar from web development are available to us. Below we’ll discuss how they work in zippers.&lt;/p&gt;
    &lt;p&gt;As you remember, a zipper accepts a third function — &lt;code&gt;make-node&lt;/code&gt;. Until now, we’ve passed &lt;code&gt;nil&lt;/code&gt; to it. We didn’t use it because we only read the data. The zipper will call the function when we ask to return the data with the changes made to the locations. The function takes two parameters: a branch and children. Its task is to relate them in the way it is customary in a tree.&lt;/p&gt;
    &lt;p&gt;For simple collections like a vector, the function is simple. It only wraps the children in &lt;code&gt;vec&lt;/code&gt; to get a vector from the sequence. In &lt;code&gt;vector-zip&lt;/code&gt;, the function is a little more complex because it takes metadata into account. Here is the entire code of this zipper.&lt;/p&gt;
    &lt;code&gt;(defn vector-zip
  [root]
  (zipper vector?
          seq
          (fn [node children]
            (with-meta (vec children) (meta node)))
          root))
&lt;/code&gt;
    &lt;p&gt;You see that the new vector (form &lt;code&gt;(vec children)&lt;/code&gt;) copies the metadata of the old vector (variable &lt;code&gt;node&lt;/code&gt;). If you supplement the original with &lt;code&gt;assoc&lt;/code&gt; or &lt;code&gt;conj&lt;/code&gt;, the metadata is preserved. In the case of &lt;code&gt;vector-zip&lt;/code&gt;, we are building a new vector,  so we wrap it in &lt;code&gt;with-meta&lt;/code&gt;. If we remove &lt;code&gt;with-meta&lt;/code&gt;, the output will be a vector with no metadata, which may affect the program logic.&lt;/p&gt;
    &lt;p&gt;The XML zipper has a slightly different build: the children are in the &lt;code&gt;:content&lt;/code&gt; field.&lt;/p&gt;
    &lt;code&gt;(fn [node children]
  (assoc node :content (and children (apply vector children))))
&lt;/code&gt;
    &lt;p&gt;For our zipper &lt;code&gt;map-zip&lt;/code&gt; that we developed at the beginning, the build function would look like &lt;code&gt;assoc&lt;/code&gt; or &lt;code&gt;into&lt;/code&gt; with a collection of &lt;code&gt;MapEntry&lt;/code&gt; pairs.&lt;/p&gt;
    &lt;p&gt;The zipper implicitly calls this function if it finds modified nodes. The functions &lt;code&gt;zip/edit&lt;/code&gt;,  &lt;code&gt;zip/replace&lt;/code&gt;, and others are used to modify. Before looking at them, let’s discuss exactly how the modification occurs inside zippers.&lt;/p&gt;
    &lt;p&gt;The changes are specific because they affect locations, not the source data. After you have worked with a location, it is marked with the &lt;code&gt;:changed?&lt;/code&gt; flag. It is a signal to data re-building using the &lt;code&gt;zip/root&lt;/code&gt; function, which we will discuss later.&lt;/p&gt;
    &lt;p&gt;Let’s look at an example with the vector &lt;code&gt;[1 2 3]&lt;/code&gt;. Move to 2 and double it using the &lt;code&gt;zip/edit&lt;/code&gt; function. It takes a location, a function, and residual arguments.
You are familiar with this approach from topics about atoms (&lt;code&gt;swap!&lt;/code&gt;) and collections (&lt;code&gt;update&lt;/code&gt;). By analogy with them, a location will receive a new value, which the function calculated based on the previous one.&lt;/p&gt;
    &lt;p&gt;Here’s the location before changes:&lt;/p&gt;
    &lt;code&gt;(-&amp;gt; [1 2 3]
    zip/vector-zip
    zip/down
    zip/right)

[2 {:l [1] :pnodes [[1 2 3]] :ppath nil :r (3)}]
&lt;/code&gt;
    &lt;p&gt;Now, it’s the location after the changes: Pay attention to the &lt;code&gt;:changed?&lt;/code&gt; key:&lt;/p&gt;
    &lt;code&gt;(def loc-2
  (-&amp;gt; [1 2 3]
      zip/vector-zip
      zip/down
      zip/right
      (zip/edit * 2)))

[4 {:l [1] :pnodes [[1 2 3]] :ppath nil :r (3)
    :changed? true}]
&lt;/code&gt;
    &lt;p&gt;Next, we would like to get the modified vector &lt;code&gt;[1 4 3]&lt;/code&gt;. Let’s do it manually:&lt;/p&gt;
    &lt;code&gt;(-&amp;gt; loc-2
    zip/up
    zip/node)

;; [1 4 3]
&lt;/code&gt;
    &lt;p&gt;The &lt;code&gt;zip/root&lt;/code&gt; function accepts the location with changes and does the same. Its algorithm looks like this:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;ascend to the root location;&lt;/item&gt;
      &lt;item&gt;return a node.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;To get the result in one pass, add &lt;code&gt;zip/root&lt;/code&gt; to the end of the threading macro:&lt;/p&gt;
    &lt;code&gt;(-&amp;gt; [1 2 3]
    zip/vector-zip
    zip/down
    zip/right
    (zip/edit * 2)
    zip/root)

;; [1 4 3]
&lt;/code&gt;
    &lt;p&gt;The &lt;code&gt;zip/up&lt;/code&gt; function, which we called either manually or implicitly in &lt;code&gt;zip/root&lt;/code&gt;, does the bulk of the work. When going up, it checks if the location has been changed, and if so, rebuilds it with &lt;code&gt;make-node&lt;/code&gt;. Here’s a snippet of its code:&lt;/p&gt;
    &lt;code&gt;(defn up
  [loc]
  (let [[node {... changed? :changed? :as path}] loc]
    (when pnodes
      (let [pnode (peek pnodes)]
        (with-meta (if changed?
                     [(make-node loc pnode (concat l ...))
                      (and ppath (assoc ...))]
                     [pnode ppath])
                   (meta loc))))))
&lt;/code&gt;
    &lt;head rend="h3"&gt;Multiple change&lt;/head&gt;
    &lt;p&gt;When changing one location, problems usually don’t arise. However, we rarely modify a single location. In practice, we do it in a batch depending on some conditions.&lt;/p&gt;
    &lt;p&gt;Previously, we decomposed the zipper into a sequence of locations using &lt;code&gt;iter-zip&lt;/code&gt;, and then passed it through a series of &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;filter&lt;/code&gt;, and other functions. This method isn’t suitable when editing. For example, we selected the second item from the &lt;code&gt;zip-iter&lt;/code&gt; result and modified it:&lt;/p&gt;
    &lt;code&gt;(def loc-seq
  (-&amp;gt; [1 2 3]
      zip/vector-zip
      iter-zip))

(-&amp;gt; loc-seq (nth 2) (zip/edit * 2))

;; [4 {:l [1] :pnodes [[1 2 3]] :ppath nil :r (3)
;;    :changed? true}]
&lt;/code&gt;
    &lt;p&gt;Zippers themselves are immutable, and any action will return a new location. At the same time, the &lt;code&gt;zip-iter&lt;/code&gt; function is designed so that each next location is obtained from the previous one. Calling &lt;code&gt;zip/edit&lt;/code&gt; on one of the elements will not affect subsequent ones. If we go up from the last location, we get the vector unchanged, even if we have edited some locations in the middle before.&lt;/p&gt;
    &lt;code&gt;(-&amp;gt; loc-seq last zip/up zip/node)
;; [1 2 3]
&lt;/code&gt;
    &lt;p&gt;The following patterns are used when editing zippers.&lt;/p&gt;
    &lt;p&gt;One element changes. In this case, we iterate through the zipper until we meet the required location in the chain. Then we change it and call &lt;code&gt;zip/root&lt;/code&gt;.&lt;/p&gt;
    &lt;p&gt;Many elements change. With &lt;code&gt;loop&lt;/code&gt; and &lt;code&gt;zip/next&lt;/code&gt; we manually iterate through the zipper. In this case, the specified function either changes the location or leaves it intact. The &lt;code&gt;recur&lt;/code&gt; form gets &lt;code&gt;zip/next&lt;/code&gt; from the function result. So if there were changes, &lt;code&gt;zip/next&lt;/code&gt; will work with the new location, not the previous one.&lt;/p&gt;
    &lt;p&gt;The following functions can change locations:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;zip/replace&lt;/code&gt;is a literal replacement of the current node with another;&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;zip/edit&lt;/code&gt;is a more flexible node replacement. Similar to&lt;code&gt;update&lt;/code&gt;and&lt;code&gt;swap!&lt;/code&gt;it takes a function and additional arguments. The current node is the first argument of the function. The result will replace the location content;&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;zip/remove&lt;/code&gt;deletes a location and moves the pointer to the parent.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Functions for inserting neighbors or children:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;zip/insert-left&lt;/code&gt;adds a neighbor to the left of the current location;&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;zip/insert-right&lt;/code&gt;adds a neighbor to the right;&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;zip/insert-child&lt;/code&gt;adds a child to the beginning of the current location;&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;zip/append-child&lt;/code&gt;adds a child to the end.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Neighbors and children differ in hierarchy. The neighbor appears on the same level as the location, and the child appears below. In the center of the diagram is the location with the vector &lt;code&gt;[2 3]&lt;/code&gt;. Its neighbors are numbers 1 and 4, and its children are 2 and 3.&lt;/p&gt;
    &lt;code&gt;

                ┌─────────────┐
                │ [1 [2 3] 4] │
                └─────────────┘
                       ▲
                       │
    ┌───────┐    ┏━━━━━━━━━━━┓    ┌───────┐
    │   1   │◀───┃   [2 3]   ┃───▶│   4   │
    └───────┘    ┗━━━━━━━━━━━┛    └───────┘
                       │
                 ┌─────┴─────┐
                 ▼           ▼
             ┌───────┐   ┌───────┐
             │   2   │   │   3   │
             └───────┘   └───────┘

&lt;/code&gt;
    &lt;p&gt;Let’s look at these functions with simple examples. Suppose there is the key &lt;code&gt;:error&lt;/code&gt; deep in the nested vectors. You need to change this to &lt;code&gt;:ok&lt;/code&gt;. First, let’s add a predicate for the search:&lt;/p&gt;
    &lt;code&gt;(defn loc-error? [loc]
  (some-&amp;gt; loc zip/node (= :error)))
&lt;/code&gt;
    &lt;p&gt;Now, we’ll find the location, fix it and go up to the root:&lt;/p&gt;
    &lt;code&gt;(def data [1 2 [3 4 [5 :error]]])

(def loc-error
  (-&amp;gt;&amp;gt; data
       zip/vector-zip
       iter-zip
       (find-first loc-error?)))

(-&amp;gt; loc-error
    (zip/replace :ok)
    zip/root)

;; [1 2 [3 4 [5 :ok]]]
&lt;/code&gt;
    &lt;p&gt;Another example: change all &lt;code&gt;nil&lt;/code&gt; items to &lt;code&gt;0&lt;/code&gt; in the nested vector to make the math safe. This time there may be more than one location, so a traversal through the &lt;code&gt;loop&lt;/code&gt; is required. At each step, we check if the location matches the condition, and if so, we pass the &lt;code&gt;zip/next&lt;/code&gt; call from the modified version to &lt;code&gt;recur&lt;/code&gt;:&lt;/p&gt;
    &lt;code&gt;(def data [1 2 [5 nil 2 [3 nil]] nil 1])

(loop [loc (zip/vector-zip data)]
  (if (zip/end? loc)
    (zip/node loc)
    (if (-&amp;gt; loc zip/node nil?)
      (recur (zip/next (zip/replace loc 0)))
      (recur (zip/next loc)))))

;; [1 2 [5 0 2 [3 0]] 0 1]
&lt;/code&gt;
    &lt;p&gt;Do the same, but replace all negative numbers modulo. First, let’s declare the &lt;code&gt;abs&lt;/code&gt; function:&lt;/p&gt;
    &lt;code&gt;(defn abs [num]
  (if (neg? num)
    (- num)
    num))
&lt;/code&gt;
    &lt;p&gt;The traversal is similar to the previous one, but now instead of &lt;code&gt;zip/replace&lt;/code&gt;, we call
&lt;code&gt;zip/edit&lt;/code&gt;. It updates the content of the location, based on the previous value:&lt;/p&gt;
    &lt;code&gt;(def data [-1 2 [5 -2 2 [-3 2]] -1 5])

(loop [loc (zip/vector-zip data)]
  (if (zip/end? loc)
    (zip/node loc)
    (if (and (-&amp;gt; loc zip/node number?)
             (-&amp;gt; loc zip/node neg?))
      (recur (zip/next (zip/edit loc abs)))
      (recur (zip/next loc)))))
&lt;/code&gt;
    &lt;p&gt;In both cases, the loop logic is simple. If this is the final location, return its node. Recall that the final location is the initial location when you’ve returned to it after a series of &lt;code&gt;zip/next&lt;/code&gt; calls. Otherwise, if the location contains a negative number, we change the content with &lt;code&gt;zip/edit&lt;/code&gt;. From the changed location, we traverse to the next one. The key point: on the penultimate line, the call
&lt;code&gt;zip/next&lt;/code&gt; takes the result of &lt;code&gt;zip/edit&lt;/code&gt;, not the initial location. That is, changes in it will be passed on to the next step.&lt;/p&gt;
    &lt;p&gt;The examples above allow you to see patterns — repetitive techniques. Let’s put them in separate functions so as not to waste attention on them in the future.&lt;/p&gt;
    &lt;p&gt;Search for a location by predicate. It takes an initial location and predicate, and starts iteration. It returns the first location that matches the predicate:&lt;/p&gt;
    &lt;code&gt;(defn find-loc [loc loc-pred]
  (-&amp;gt;&amp;gt; loc
       iter-zip
       (find-first loc-pred)))
&lt;/code&gt;
    &lt;p&gt;Run locations with changes. It iterates locations using &lt;code&gt;zip/next&lt;/code&gt; and &lt;code&gt;loop/recur&lt;/code&gt;. When moving to the next step, it wraps the location into a function. The function should either change the location or return it unchanged. This is a generic version of &lt;code&gt;loop&lt;/code&gt; we wrote above.&lt;/p&gt;
    &lt;code&gt;(defn alter-loc [loc loc-fn]
  (loop [loc loc]
    (if (zip/end? loc)
      loc
      (-&amp;gt; loc loc-fn zip/next recur))))
&lt;/code&gt;
    &lt;p&gt;Let’s rewrite the example with the new functions. Find in the vector a location which node is 2.&lt;/p&gt;
    &lt;code&gt;(defn loc-2? [loc]
  (-&amp;gt; loc zip/node (= 2)))

(def loc-2
  (-&amp;gt; [1 2 3]
      zip/vector-zip
      (find-loc loc-2?)))
&lt;/code&gt;
    &lt;p&gt;Let’s double it and go to the final vector:&lt;/p&gt;
    &lt;code&gt;(-&amp;gt; loc-2 (zip/edit * 2) zip/root)
;; [1 4 2]
&lt;/code&gt;
    &lt;p&gt;Let’s change the negative numbers modulo. To do this, we’ll create the &lt;code&gt;loc-abs&lt;/code&gt; function. If the node has a negative number, we’ll return the corrected location, otherwise, the original one:&lt;/p&gt;
    &lt;code&gt;(defn loc-abs [loc]
  (if (and (-&amp;gt; loc zip/node number?)
           (-&amp;gt; loc zip/node neg?))
    (zip/edit loc abs)
    loc))
&lt;/code&gt;
    &lt;p&gt;Pass it to &lt;code&gt;alter-loc&lt;/code&gt;:&lt;/p&gt;
    &lt;code&gt;(-&amp;gt; [-1 2 [5 -2 2 [-3 2]] -1 5]
    zip/vector-zip
    (alter-loc loc-abs)
    zip/node)

;; [1 2 [5 2 2 [3 2]] 1 5]
&lt;/code&gt;
    &lt;head rend="h3"&gt;Prices in XML&lt;/head&gt;
    &lt;p&gt;Let’s move on to more realistic examples with XML and products. Prepare the next file: &lt;code&gt;products-price.xml&lt;/code&gt;:&lt;/p&gt;
    &lt;code&gt;&amp;lt;?xml version="1.0" encoding="UTF-8"?&amp;gt;
&amp;lt;catalog&amp;gt;
  &amp;lt;organization name="re-Store"&amp;gt;
    &amp;lt;product type="fiber" price="8.99"&amp;gt;VIP Fiber Plus&amp;lt;/product&amp;gt;
    &amp;lt;product type="iphone" price="899.99"&amp;gt;iPhone 11 Pro&amp;lt;/product&amp;gt;
  &amp;lt;/organization&amp;gt;
  &amp;lt;organization name="DNS"&amp;gt;
    &amp;lt;branch name="Office 2"&amp;gt;
      &amp;lt;bundle&amp;gt;
        &amp;lt;product type="fiber" price="9.99"&amp;gt;Premium iFiber&amp;lt;/product&amp;gt;
        &amp;lt;product type="iphone" price="999.99"&amp;gt;iPhone 11 Pro&amp;lt;/product&amp;gt;
      &amp;lt;/bundle&amp;gt;
    &amp;lt;/branch&amp;gt;
  &amp;lt;/organization&amp;gt;
&amp;lt;/catalog&amp;gt;
&lt;/code&gt;
    &lt;p&gt;Note that products now have prices — a characteristic that changes frequently.&lt;/p&gt;
    &lt;p&gt;As you might remember, in terms of Clojure, XML is nested dictionaries with keys. &lt;code&gt;:tag&lt;/code&gt;, &lt;code&gt;:attrs&lt;/code&gt; и &lt;code&gt;:content&lt;/code&gt;. But after the changes, we would like to see it in its usual, textual form. We need the opposite action: converting XML from the data structure to text. To do this, import the built-in &lt;code&gt;clojure.xml&lt;/code&gt; module. Its &lt;code&gt;emit&lt;/code&gt; function prints XML.&lt;/p&gt;
    &lt;p&gt;Often, &lt;code&gt;emit&lt;/code&gt; is wrapped in &lt;code&gt;with-out-str&lt;/code&gt; (a macro to intercept printing to a string). In the examples below, we’ll output the XML in the console. Since &lt;code&gt;emit&lt;/code&gt; doesn’t support indentation, we will add it manually for clarity.&lt;/p&gt;
    &lt;p&gt;The first task is to make a 10 percent discount on all iPhones. We have almost all abstractions ready, so let’s write the solution from top to bottom:&lt;/p&gt;
    &lt;code&gt;(require '[clojure.xml :as xml])

(-&amp;gt; "products-price.xml"
    -&amp;gt;xml-zipper
    (alter-loc alter-iphone-price)
    zip/node
    xml/emit)
&lt;/code&gt;
    &lt;p&gt;These five lines are enough for our task. It remains to write the &lt;code&gt;alter-iphone-price&lt;/code&gt; function. We need the function to take an iPhone location and return it, but with a different &lt;code&gt;price&lt;/code&gt; attribute. A location of a different type will remain unchanged. Let’s describe the function:&lt;/p&gt;
    &lt;code&gt;(defn alter-iphone-price [loc]
  (if (loc-iphone? loc)
    (zip/edit loc alter-attr-price 0.9)
    loc))
&lt;/code&gt;
    &lt;p&gt;The &lt;code&gt;loc-iphone?&lt;/code&gt; predicate checks if the location holds an iPhone. We’ve already written it in our
previous lessons:&lt;/p&gt;
    &lt;code&gt;(defn loc-iphone? [loc]
  (let [node (zip/node loc)]
    (and (-&amp;gt; node :tag (= :product))
         (-&amp;gt; node :attrs :type (= "iphone")))))
&lt;/code&gt;
    &lt;p&gt;The &lt;code&gt;alter-attr-price&lt;/code&gt; function takes a node (i.e., location content) and must change its attribute. The second function argument is the factor by which the current price should be multiplied. The slight difficulty is that attributes in XML are strings. To perform multiplication, you need to convert a string to a number, multiply it by a factor, and then convert the result, rounded to two digits, back to a string. All together gives us this function:&lt;/p&gt;
    &lt;code&gt;(defn alter-attr-price [node ratio]
  (update-in node [:attrs :price]
             (fn [price]
               (-&amp;gt;&amp;gt; price
                    read-string
                    (* ratio)
                    (format "%.2f")))))
&lt;/code&gt;
    &lt;p&gt;Quick check of the function:&lt;/p&gt;
    &lt;code&gt;(alter-attr-price {:attrs {:price "10"}} 1.1)
;; {:attrs {:price "11.00"}}
&lt;/code&gt;
    &lt;p&gt;After running the whole chain, we should get XML:&lt;/p&gt;
    &lt;code&gt;&amp;lt;?xml version="1.0" encoding="UTF-8"?&amp;gt;
&amp;lt;catalog&amp;gt;
  &amp;lt;organization name="re-Store"&amp;gt;
    &amp;lt;product price="8.99" type="fiber"&amp;gt;VIP Fiber Plus&amp;lt;/product&amp;gt;
    &amp;lt;product price="809.99" type="iphone"&amp;gt;iPhone 11 Pro&amp;lt;/product&amp;gt;
  &amp;lt;/organization&amp;gt;
  &amp;lt;organization name="DNS"&amp;gt;
    &amp;lt;branch name="Office 2"&amp;gt;
      &amp;lt;bundle&amp;gt;
        &amp;lt;product price="9.99" type="fiber"&amp;gt;Premium iFiber&amp;lt;/product&amp;gt;
        &amp;lt;product price="899.99" type="iphone"&amp;gt;iPhone 11 Pro&amp;lt;/product&amp;gt;
      &amp;lt;/bundle&amp;gt;
    &amp;lt;/branch&amp;gt;
  &amp;lt;/organization&amp;gt;
&amp;lt;/catalog&amp;gt;
&lt;/code&gt;
    &lt;p&gt;As a result, the price of iPhones changed by 10 percent, while the rest of the products remained the same.&lt;/p&gt;
    &lt;p&gt;More difficult task: add a new product — a headset — to all bundles. Again, let’s describe the solution from top to bottom:&lt;/p&gt;
    &lt;code&gt;(-&amp;gt; "products-price.xml"
    -&amp;gt;xml-zipper
    (alter-loc add-to-bundle)
    zip/node
    xml/emit)
&lt;/code&gt;
    &lt;p&gt;The solution differs from the previous one only in the &lt;code&gt;add-to-bundle&lt;/code&gt; functions. Its logic is as follows: if the current location is a bundle, add a child to it, and if not, just return the location.&lt;/p&gt;
    &lt;code&gt;(defn add-to-bundle [loc]
  (if (loc-bundle? loc)
    (zip/append-child loc node-headset)
    loc))
&lt;/code&gt;
    &lt;p&gt;Checking whether it’s a bundle or not:&lt;/p&gt;
    &lt;code&gt;(defn loc-bundle? [loc]
  (some-&amp;gt; loc zip/node :tag (= :bundle)))
&lt;/code&gt;
    &lt;p&gt;The &lt;code&gt;zip/append-child&lt;/code&gt; function appends the value to the end of the location’s children. In our case, it’s the &lt;code&gt;node-headset&lt;/code&gt; node, which we put into a constant:&lt;/p&gt;
    &lt;code&gt;(def node-headset
  {:tag :product
   :attrs {:type "headset"
           :price "199.99"}
   :content ["AirPods Pro"]})
&lt;/code&gt;
    &lt;p&gt;Here’s the final XML where a new product has been added into the bundles:&lt;/p&gt;
    &lt;code&gt;&amp;lt;?xml version="1.0" encoding="UTF-8"?&amp;gt;
&amp;lt;catalog&amp;gt;
  &amp;lt;organization name="re-Store"&amp;gt;
    &amp;lt;product price="8.99" type="fiber"&amp;gt;VIP Fiber Plus&amp;lt;/product&amp;gt;
    &amp;lt;product price="899.99" type="iphone"&amp;gt;iPhone 11 Pro&amp;lt;/product&amp;gt;
  &amp;lt;/organization&amp;gt;
  &amp;lt;organization name="DNS"&amp;gt;
    &amp;lt;branch name="Office 2"&amp;gt;
      &amp;lt;bundle&amp;gt;
        &amp;lt;product price="9.99" type="fiber"&amp;gt;Premium iFiber&amp;lt;/product&amp;gt;
        &amp;lt;product price="999.99" type="iphone"&amp;gt;iPhone 11 Pro&amp;lt;/product&amp;gt;
        &amp;lt;product price="199.99" type="headset"&amp;gt;AirPods Pro&amp;lt;/product&amp;gt;
      &amp;lt;/bundle&amp;gt;
    &amp;lt;/branch&amp;gt;
  &amp;lt;/organization&amp;gt;
&amp;lt;/catalog&amp;gt;
&lt;/code&gt;
    &lt;p&gt;The third task is to do away with all bundles. We decided that it was not profitable to sell items in bundles. All &lt;code&gt;&amp;lt;bundle&amp;gt;&lt;/code&gt; tags are removed from XML, but their products must go to organizations.&lt;/p&gt;
    &lt;p&gt;And for the third time, the solution differs only in the function:&lt;/p&gt;
    &lt;code&gt;(-&amp;gt; "products-price.xml"
    -&amp;gt;xml-zipper
    (alter-loc disband-bundle)
    zip/node
    xml/emit)
&lt;/code&gt;
    &lt;p&gt;Let’s describe the &lt;code&gt;disband-bundle&lt;/code&gt; algorithm. If the current node is a bundle, we save its children (products) to a variable to not lose them. Then we delete the bundle, which will return the parent of the deleted location. In our case, it’s an organization. We return it with the products attached.&lt;/p&gt;
    &lt;code&gt;(defn disband-bundle [loc]
  (if (loc-bundle? loc)
    (let [products (zip/children loc)
          loc-org (zip/remove loc)]
      (append-childs loc-org products))
    loc))
&lt;/code&gt;
    &lt;p&gt;The &lt;code&gt;append-childs&lt;/code&gt; function is our wrapper over the built-in &lt;code&gt;zip/append-child&lt;/code&gt;. The latter attaches only one element, which is inconvenient. To join a list, let’s write a helper function:&lt;/p&gt;
    &lt;code&gt;(defn append-childs [loc items]
  (reduce (fn [loc item]
            (zip/append-child loc item))
          loc
          items))
&lt;/code&gt;
    &lt;p&gt;Here’s the final XML with no bundles, but with the same products:&lt;/p&gt;
    &lt;code&gt;&amp;lt;?xml version="1.0" encoding="UTF-8"?&amp;gt;
&amp;lt;catalog&amp;gt;
  &amp;lt;organization name="re-Store"&amp;gt;
    &amp;lt;product price="8.99" type="fiber"&amp;gt;VIP Fiber Plus&amp;lt;/product&amp;gt;
    &amp;lt;product price="899.99" type="iphone"&amp;gt;iPhone 11 Pro&amp;lt;/product&amp;gt;
  &amp;lt;/organization&amp;gt;
  &amp;lt;organization name="DNS"&amp;gt;
    &amp;lt;branch name="Office 2"&amp;gt;
      &amp;lt;product price="9.99" type="fiber"&amp;gt;Premium iFiber&amp;lt;/product&amp;gt;
      &amp;lt;product price="999.99" type="iphone"&amp;gt;iPhone 11 Pro&amp;lt;/product&amp;gt;
    &amp;lt;/branch&amp;gt;
  &amp;lt;/organization&amp;gt;
&amp;lt;/catalog&amp;gt;
&lt;/code&gt;
    &lt;p&gt;We hope these examples are enough for you to understand how to edit zippers. Note that it took a little code: for each task, we wrote, on average, three functions. Another advantage is that the code is stateless. All functions are pure, and their call doesn’t affect the data. Should an exception pop up somewhere in the middle of editing, the XML tree won’t be half-changed.&lt;/p&gt;
    &lt;head rend="h2"&gt;Part 6. Virtual Trees. Currency Exchange&lt;/head&gt;
    &lt;p&gt;We hope that the theory and examples were enough to start experimenting with zippers. We bring to your attention an unusual example.&lt;/p&gt;
    &lt;p&gt;So far, the second function we passed to a zipper returned children from a branch. For a vector we used &lt;code&gt;seq&lt;/code&gt;, for XML — a more complex combination &lt;code&gt;(comp seq :content)&lt;/code&gt;. Both options depend on the parent node, and if there are no children, the functions return &lt;code&gt;nil&lt;/code&gt;.&lt;/p&gt;
    &lt;p&gt;But what happens if the function returns a constant set of children:&lt;/p&gt;
    &lt;code&gt;(fn [_]
  (seq [1 2 3]))
&lt;/code&gt;
    &lt;p&gt;How will such a zipper behave? Let’s write it:&lt;/p&gt;
    &lt;code&gt;(def zip-123
  (zip/zipper any?
              (constantly (seq [1 2 3]))
              nil
              1))
&lt;/code&gt;
    &lt;p&gt;Due to the fact that each element has three children, the zipper will become infinite. Traversing it with &lt;code&gt;iter-zip&lt;/code&gt; doesn’t work. &lt;code&gt;Zip/next&lt;/code&gt; will plunge deeper and deeper into the zipper but never reach its end.&lt;/p&gt;
    &lt;p&gt;For fun, let’s take a few steps on the new zipper. Let’s go down and to the right. We will find ourselves on 2 in the middle of the vector &lt;code&gt;[1 2 3]&lt;/code&gt;:&lt;/p&gt;
    &lt;code&gt;(def loc-2
  (-&amp;gt; zip-123
      zip/down
      zip/right))

(zip/node loc-2)
;; 2
&lt;/code&gt;
    &lt;p&gt;Let’s see our position on the diagram. A step to the left will move us on 1, a step to the right — on 3:&lt;/p&gt;
    &lt;code&gt;              ┌───────────┐
              │     1     │
              └───────────┘
                    ▲
                    │
 ┌───────┐    ┏━━━━━━━━━━━┓    ┌───────┐
 │   1   │◀───┃     2     ┃───▶│   3   │
 └───────┘    ┗━━━━━━━━━━━┛    └───────┘
                    │
                    ▼
                ┌───────┐
                │[1 2 3]│
                └───────┘
&lt;/code&gt;
    &lt;p&gt;Stepping down we fall into the next vector &lt;code&gt;[1 2 3]&lt;/code&gt; and so on. Let’s go down and to the right five more times, and still end up in 2:&lt;/p&gt;
    &lt;code&gt;(def down-right (comp zip/right zip/down))

(-&amp;gt; loc-2
    down-right
    down-right
    down-right
    down-right
    down-right
    zip/node)
;; 2
&lt;/code&gt;
    &lt;p&gt;The zipper can be called virtual because the data we travel through doesn’t really exist — they appear on the fly.&lt;/p&gt;
    &lt;p&gt;What the use of this zipper is yet to be seen. However, it confirms the important thesis that you can get child nodes in the process of traversing the tree. This does not violate the zipper rules and provides new opportunities.&lt;/p&gt;
    &lt;p&gt;However, the explicitly specified vector &lt;code&gt;[1 2 3]&lt;/code&gt; doesn’t expose them. If the children are known in advance, there is no need for a zipper, since the collection can be traversed in an easier way. A suitable case is when children depend on some external factors. For example, both functions &lt;code&gt;branch?&lt;/code&gt; and &lt;code&gt;children&lt;/code&gt; rely on other collections and data. This is also a traversal, but according to different rules.&lt;/p&gt;
    &lt;p&gt;Let’s look at the following problem. A bank exchanges currencies, for example, dollars for euros, rubles for lira, and so on. For brevity, let’s designate them in pairs: &lt;code&gt;(usd, eur)&lt;/code&gt; and &lt;code&gt;(rub, lir)&lt;/code&gt;. The exchange works in one direction. To exchange euros for dollars or lira for rubles, the bank must have separate rules &lt;code&gt;(eur, usd)&lt;/code&gt; and &lt;code&gt;(lir, rub)&lt;/code&gt;.&lt;/p&gt;
    &lt;p&gt;The client contacts the bank to exchange the currency &lt;code&gt;X&lt;/code&gt; for &lt;code&gt;Y&lt;/code&gt;. If there is a pair &lt;code&gt;(X, Y)&lt;/code&gt; in the exchange rules, there’s no problem. But if there is no such pair, the bank must build a chain of exchanges. For example, a client wants to exchange dollars for lira, but the bank doesn’t have the direct pair &lt;code&gt;(usd, lir)&lt;/code&gt;. However, there are pairs &lt;code&gt;(usd, eur)&lt;/code&gt; and &lt;code&gt;(eur, lir)&lt;/code&gt;. In this case, the client will be offered the exchange &lt;code&gt;usd -&amp;gt; eur -&amp;gt; lir&lt;/code&gt;.&lt;/p&gt;
    &lt;p&gt;Write a program that accepts exchange rules, as well as input and output currencies. You have to find the exchange chains. The shorter the chain, the better. If multiple chains of the same length are possible, return all of them so the client can choose. Consider the option when there are no solutions and provide an adequate response to this case, so as not to go into an eternal loop and not take up all the computer’s resources.&lt;/p&gt;
    &lt;p&gt;Let’s describe the input data in terms of Clojure. Each rule will be a vector of two keywords — which currency is exchanged for which one. The vector of rules will be called &lt;code&gt;rules&lt;/code&gt;. In addition to the rules, we takes the parameters &lt;code&gt;from&lt;/code&gt; and &lt;code&gt;to&lt;/code&gt; — these indicate which currency to change from and to which one.&lt;/p&gt;
    &lt;code&gt;;; rules
[[:usd :rub] [:rub :eur] [:eur :lir]]

:usd ;; from
:rub ;; to
&lt;/code&gt;
    &lt;p&gt;The output should be a set of chains from &lt;code&gt;from&lt;/code&gt; to &lt;code&gt;to&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt;. For the case above, the chain from dollar to euro looks like this:&lt;/p&gt;
    &lt;code&gt;[:usd :rub :eur]
&lt;/code&gt;
    &lt;p&gt;All together gives the function &lt;code&gt;exchanges&lt;/code&gt;, which body we have to fill:&lt;/p&gt;
    &lt;code&gt;(defn exchanges [rules from to]
  ...)
&lt;/code&gt;
    &lt;p&gt;First, let’s write some tests. They will help us warm up, and at the same time we’ll understand the problem better. The first test is a simple exchange, there is a rule for it:&lt;/p&gt;
    &lt;code&gt;(deftest test-simple
  (is (= [[:usd :rub]]
         (exchanges [[:usd :rub]] :usd :rub))))
&lt;/code&gt;
    &lt;p&gt;A reverse exchange is impossible unless there is a reverse rule:&lt;/p&gt;
    &lt;code&gt;(deftest test-reverse-err
  (is (nil? (exchanges [[:rub :usd]] :usd :rub))))
&lt;/code&gt;
    &lt;p&gt;Here’s a case where the exchange chain doesn’t exist:&lt;/p&gt;
    &lt;code&gt;(deftest test-no-solution
  (is (nil? (exchanges [[:rub :usd] [:lir :eur]] :usd :eur))))
&lt;/code&gt;
    &lt;p&gt;The most important scenario is multiple exchange. You can get from dollars to rubles in two ways – with euros or lira in the middle:&lt;/p&gt;
    &lt;code&gt; (deftest test-two-ways
  (is (= [[:usd :eur :rub]
          [:usd :lir :rub]]
         (exchanges [[:usd :eur]
                     [:eur :rub]
                     [:usd :lir]
                     [:lir :rub]] :usd :rub))))
&lt;/code&gt;
    &lt;p&gt;Another test checks if we only return the shortest chains. An exchange with four currencies (in this case, &lt;code&gt;[: usd: yen: eur: rub]&lt;/code&gt;) is not included in the result:&lt;/p&gt;
    &lt;code&gt;(deftest test-short-ways-only
  (is (= [[:usd :eur :rub]
          [:usd :lir :rub]]
         (exchanges [[:usd :eur]
                     [:eur :rub]
                     [:usd :lir]
                     [:lir :rub]
                     [:usd :yen]
                     [:yen :eur]] :usd :rub))))
&lt;/code&gt;
    &lt;p&gt;In terms of competitive programming, we can say that the problem offers separate edges of the graph. It’s required to check whether it’s possible to construct a continuous route from the vertex A to B from the edges. But since we’re solving the problem with zippers, we won’t use the terms “graph” and “edges”. We don’t guarantee that the solution will be optimal — perhaps the graph algorithm will do better. However, we hope that the example will further reveal the power of zippers.&lt;/p&gt;
    &lt;p&gt;As you remember, zippers are used to traverse trees, which is included in the problem statement. Let’s say the &lt;code&gt;from&lt;/code&gt; currency, which we want to exchange, is at the root node of the tree. Let it be a dollar. Obviously, children of this currency are all those that can be exchanged for the dollar. To do this, select the second element from each pair, where the first element is &lt;code&gt;:usd&lt;/code&gt;:&lt;/p&gt;
    &lt;code&gt;(def rules
  [[:usd :rub]
   [:usd :lir]
   [:rub :eur]
   [:rub :yen]
   [:eur :lir]
   [:lir :tug]])

(def from :usd)

(def usd-children
  (for [[v1 v2] rules
        :when (= v1 from)]
    v2))

;; (:rub :lir)
&lt;/code&gt;
    &lt;p&gt;In our case, the dollar children are the ruble and the lira. Let’s draw an imaginary tree and mark the levels:&lt;/p&gt;
    &lt;code&gt;                  ┌───────┐
     1            │  usd  │
                  └───────┘
                      │
          ┌───────┐   │   ┌───────┐
     2    │  rub  │◀──┴──▶│  lir  │
          └───────┘       └───────┘
&lt;/code&gt;
    &lt;p&gt;For each currency of the second level, we’ll find child nodes according to the same rule. For convenience, let’s write the &lt;code&gt;get-children&lt;/code&gt; function:&lt;/p&gt;
    &lt;code&gt;(defn get-children [value]
  (for [[v1 v2] rules
        :when (= v1 value)]
    v2))

(get-children :rub)
;; (:eur :yen)
&lt;/code&gt;
    &lt;p&gt;The new tree:&lt;/p&gt;
    &lt;code&gt;                      ┌───────┐
    1                 │  usd  │
                      └───────┘
                          │
              ┌───────┐   │   ┌───────┐
    2         │  rub  │◀──┴──▶│  lir  │
              └───────┘       └───────┘
                  │               │
       ┌───────┐  │  ┌───────┐    │  ┌───────┐
    3  │  eur  │◀─┴─▶│  yen  │    └─▶│  tug  │
       └───────┘     └───────┘       └───────┘
&lt;/code&gt;
    &lt;p&gt;Note: it’s exactly the virtual tree that we talked about recently. We don’t have this tree in advance, it appears in the process. The &lt;code&gt;make-children&lt;/code&gt; function is closed on the original exchange pairs. This is an example of traversing a data structure that we get on the fly from other data.&lt;/p&gt;
    &lt;p&gt;The structure of the currency tree is known and can be traversed. The question is, how deep should we traverse it? Apparently, we should stop as soon as we meet a location which node is equal to the &lt;code&gt;to&lt;/code&gt; currency. Let it be yen. That is, we’ve connected &lt;code&gt;from&lt;/code&gt; and &lt;code&gt;to&lt;/code&gt; using other currencies. Let’s show the solution on the diagram:&lt;/p&gt;
    &lt;code&gt;                      ┌───────┐
    1                 │  usd  │
                      └───────┘
                          │
              ┌───────┐   │   ┌ ─ ─ ─ ┐
    2         │  rub  │◀──┘
              └───────┘       └ ─ ─ ─ ┘
                  │
       ┌ ─ ─ ─ ┐  │  ┌───────┐       ┌ ─ ─ ─ ┐
    3             └─▶│  yen  │
       └ ─ ─ ─ ┘     └───────┘       └ ─ ─ ─ ┘

&lt;/code&gt;
    &lt;p&gt;To get the exchange chain, we pass the &lt;code&gt;to&lt;/code&gt; location to the &lt;code&gt;zip/path&lt;/code&gt; function. It should return the vector of all the location’s parents, excluding itself. So, the path to the location and its node form an exchange chain.&lt;/p&gt;
    &lt;p&gt;We’ll write the code based on this reasoning. Let’s prepare a zipper:&lt;/p&gt;
    &lt;code&gt;(def zip-val
  (zip/zipper keyword?      ;; is it currency?
              get-children  ;; what can it be exchanged for?
              nil
              from))        ;; original currency
&lt;/code&gt;
    &lt;p&gt;Look for a location with the target currency in the zipper:&lt;/p&gt;
    &lt;code&gt;(defn loc-to? [loc]
  (-&amp;gt; loc zip/node (= to)))

(def loc-to
  (-&amp;gt;&amp;gt; zip-val
       iter-zip
       (find-first loc-to?)))
&lt;/code&gt;
    &lt;p&gt;If it’s found, we get an exchange chain from it. To do this, add the &lt;code&gt;to&lt;/code&gt; value to the path:&lt;/p&gt;
    &lt;code&gt;(conj (zip/path loc-to) (zip/node loc-to))

;; [:usd :rub :yen]
&lt;/code&gt;
    &lt;p&gt;We have solved the main problem. But there’re drawbacks: for any data, we receive only one chain, even if there are several of them. To fix this, let’s search not only for the first location with the &lt;code&gt;to&lt;/code&gt; currency, but all of them using &lt;code&gt;filter&lt;/code&gt;.&lt;/p&gt;
    &lt;p&gt;Let’s expand the initial data:&lt;/p&gt;
    &lt;code&gt;(def rules
  [[:usd :rub]
   [:usd :lir]
   [:rub :eur]
   [:lir :yen]
   [:rub :yen]
   [:eur :lir]
   [:lir :tug]])

(def from :usd)
(def to :yen)
&lt;/code&gt;
    &lt;p&gt;and find chains. To do this, replace &lt;code&gt;find-first&lt;/code&gt; with &lt;code&gt;filter&lt;/code&gt;, which should return all elements matching the predicate.&lt;/p&gt;
    &lt;code&gt;(def locs-to
  (-&amp;gt;&amp;gt; zip-val
       iter-zip
       (filter loc-to?)))
&lt;/code&gt;
    &lt;p&gt;For each location found, let’s build a path:&lt;/p&gt;
    &lt;code&gt;(for [loc locs-to]
  (conj (zip/path loc) (zip/node loc)))

([:usd :rub :eur :lir :yen]
 [:usd :rub :yen]
 [:usd :lir :yen])
&lt;/code&gt;
    &lt;p&gt;Now we’ve found chains of any length, which may be redundant. According to the problem statement, we reject an exchange of four operations if we find it with two. Let’s write a function that returns the shortest lists from the result above. It groups exchanges by length, finds the shortest one, and selects it from a map.&lt;/p&gt;
    &lt;code&gt;(defn get-shortest-chains
  [chains]
  (when (seq chains)
    (let [count-&amp;gt;chains (group-by count chains)
          min-count (apply min (keys count-&amp;gt;chains))]
      (get count-&amp;gt;chains min-count))))
&lt;/code&gt;
    &lt;p&gt;For the last result, we get two vectors with three currencies in each. The last test &lt;code&gt;test-short-ways-only&lt;/code&gt;, where long chains are discarded, covers this case:&lt;/p&gt;
    &lt;code&gt;[[:usd :rub :yen] [:usd :lir :yen]]
&lt;/code&gt;
    &lt;p&gt;Build the &lt;code&gt;exchanges&lt;/code&gt; function from the code snippets. Make sure all tests pass. Add more cases to them.&lt;/p&gt;
    &lt;p&gt;It seems that the problem has been solved, but you can improve the solution. The fact is that with certain input data, the tree might become infinite. The program will either go into an infinite loop or, with a limited number of steps, won’t find a solution. Try to guess what might be causing this and how to fix it. In the next section, you will find the answer to these questions.&lt;/p&gt;
    &lt;head rend="h2"&gt;Part 7. Breadth-First Traversal. Improved Currency Exchange&lt;/head&gt;
    &lt;p&gt;Previously, we worked with the currency tree to find the exchange chain. We solved the problem, but mentioned that in special cases the tree can turn out to be infinite. How is this possible? Let’s remember how &lt;code&gt;zip/next&lt;/code&gt; traverses the tree.&lt;/p&gt;
    &lt;p&gt;The algorithm is called &lt;code&gt;depth-first&lt;/code&gt;. With this traversal, the code first walks down and only then to the side (in our case, to the right). This is easy to see if you decompose the data into parts using
a zipper:&lt;/p&gt;
    &lt;code&gt;(-&amp;gt;&amp;gt; [1 [2 [3] 4] 5]
     zip/vector-zip
     iter-zip
     (map zip/node)
     (map println))

;; 1
;; [2 [3] 4]
;; 2
;; [3]
;; 3
;; 4
;; 5
&lt;/code&gt;
    &lt;p&gt;The number &lt;code&gt;3&lt;/code&gt; preceding &lt;code&gt;4&lt;/code&gt; means the zipper goes deep first (inside the vector &lt;code&gt;[3]&lt;/code&gt;) and only then to the right.&lt;/p&gt;
    &lt;p&gt;Even more interesting is the case with a naive virtual tree, where each node has children &lt;code&gt;[1 2 3]&lt;/code&gt;. When traversing such a tree, the zipper will tend downward, each time descending into the next vector &lt;code&gt;[1 2 3]&lt;/code&gt; and stopping at 1. Let’s show this in the diagram:&lt;/p&gt;
    &lt;code&gt;(def zip-123
  (zip/zipper any?
              (constantly (seq [1 2 3]))
              nil
              1))
&lt;/code&gt;
    &lt;code&gt;                       ┌───────┐
                       │[1 2 3]│
                       └───────┘
                           │
               ┌───────┐   │
               │[1 2 3]│◀──┘
               └───────┘
                   │
        ┌───────┐  │
        │[1 2 3]│◀─┘
        └───────┘
            │
            │
    ...   ◀─┘

&lt;/code&gt;
    &lt;p&gt;Since there is no condition in our zipper to stop the production of child nodes, their nesting is unlimited. The &lt;code&gt;iter-zip&lt;/code&gt; function returns an infinite chain of locations, each containing 1. It doesn’t matter how much “1” we take from it — a hundred or a thousand — we get the same number of “1”.&lt;/p&gt;
    &lt;code&gt;(-&amp;gt;&amp;gt; zip-123
     iter-zip
     (take 10)
     (map zip/node))

;; (1 1 1 1 1 1 1 1 1 1)
&lt;/code&gt;
    &lt;p&gt;Now let’s get back to currency exchange. Suppose a bank changes rubles for dollars, dollars for euros, and euros for rubles. Let’s express it in code:&lt;/p&gt;
    &lt;code&gt;(def rules
  [[:rub :usd]
   [:usd :eur]
   [:eur :rub]])
&lt;/code&gt;
    &lt;p&gt;As you can see, we have a vicious circle:&lt;/p&gt;
    &lt;code&gt;             ┌───────┐
        ┌───▶│  rub  │────┐
        │    └───────┘    │
        │                 ▼
    ┌───────┐         ┌───────┐
    │  eur  │◀────────│  usd  │
    └───────┘         └───────┘
&lt;/code&gt;
    &lt;p&gt;The previous solution ignores the cyclical nature of the rules, this is its drawback. Suppose a client wants to exchange rubles for lira. Let’s start building a tree from the ruble. Here’s the beginning of the chain:&lt;/p&gt;
    &lt;code&gt;                       ┌───────┐
                       │  rub  │
                       └───────┘
                           │
               ┌───────┐   │
               │  usd  │◀──┘
               └───────┘
                   │
        ┌───────┐  │
        │  eur  │◀─┘
        └───────┘
            │
 ┌───────┐  │
 │  rub  │◀─┘
 └───────┘
&lt;/code&gt;
    &lt;p&gt;So we came to the ruble again. For it, we get the dollar again, for the dollar the euro, then the ruble. If we continue to iterate, we’ll dive into this chain endlessly.&lt;/p&gt;
    &lt;p&gt;Logic dictates that you need to stop going deep if the next currency is equal to the initial one. Simply put, a &lt;code&gt;:rub&lt;/code&gt; element that is not at the root node can’t have children. However, in the &lt;code&gt;branch?&lt;/code&gt; and &lt;code&gt;make-children&lt;/code&gt; functions, we don’t know where the element is located in the tree. They get values, not locations. We could fix this with a state, such as an atom, that would hold the list of the currencies that we traversed.&lt;/p&gt;
    &lt;p&gt;Another option is to check how many times we are referring to the &lt;code&gt;from&lt;/code&gt; currency to find children. If this is the first call, then we’re at the top of the tree (i.e., at the root node) Let’s find the children
and change the atom on which the &lt;code&gt;children&lt;/code&gt; function is closed. If not for the first time (atom
changed), we came across a cyclical case, and there are no children for it.&lt;/p&gt;
    &lt;p&gt;Both options have the right to exist, but for now, we want to do without state and mutable means.&lt;/p&gt;
    &lt;p&gt;If you examine the tree again, it becomes clear that the problem lies in the traversal order. Since we strive in depth, there is a high probability of falling into a wormhole from which we cannot get out. We might be lucky if we successfully stepped into the branch with the solution (on the left), and the infinite branch (on the right) remained untouched:&lt;/p&gt;
    &lt;code&gt;                 ┌───────┐
                 │  rub  │
                 └───────┘
                     │
         ┌───────┐   │   ┌───────┐
         │  yen  │◀──┴──▶│  usd  │
         └───────┘       └───────┘
             │               │
 ┏━━━━━━━┓   │               │   ┌───────┐
 ┃  lir  ┃◀──┘               └──▶│  eur  │
 ┗━━━━━━━┛                       └───────┘
                                     │
                                     │   ┌───────┐
                                     └──▶│  rub  │
                                         └───────┘
                                             │
                                             │
                                             └──▶  ...

&lt;/code&gt;
    &lt;p&gt;However, you cannot rely on luck when solving problems.&lt;/p&gt;
    &lt;p&gt;Now, let the zipper traverse the location not in depth, but in breadth and to the right. With this order, we are not threatened by infinite branch. We won’t try to exhaustively traverse an infinite branch if it occurs in the tree. Instead, we go down the levels of the tree and read all the elements of each level. Even if one of them originated from an endless branch, this doesn’t prevent you from exploring the rest of the elements. The figure below shows that horizontal traversal helps you get to the solution. In this case, the vertical traversal would go to infinity because both branches are cyclical.&lt;/p&gt;
    &lt;code&gt;

                               ┌───────┐
                           ┌───│  rub  │
                           │   └───────┘
                           ▼
                       ┌───────┐       ┌───────┐
                       │  yen  │──────▶│  usd  │
                       └───────┘       └───────┘
                                           │
                  ┌────────────────────────┘
                  ▼
              ┏━━━━━━━┓                         ┌───────┐
              ┃  lir  ┃────────────────────────▶│  eur  │
              ┗━━━━━━━┛                         └───────┘
                                                    │
           ┌────────────────────────────────────────┘
           ▼
       ┌───────┐     ┌───────┐           ┌───────┐     ┌───────┐
       │  rub  │────▶│  tug  │──────────▶│  yen  │────▶│  rub  │
       └───────┘     └───────┘           └───────┘     └───────┘
           │                                               │
           │                                               │
    ...  ◀─┘                                               └──▶  ...


&lt;/code&gt;
    &lt;p&gt;The problem is that the &lt;code&gt;clojure.zip&lt;/code&gt; module offers only depth-first order of traversal with &lt;code&gt;zip/next&lt;/code&gt;. There’s no other algorithm. We’ll write our own function to traverse the zipper “in layers”, as shown in the figure:&lt;/p&gt;
    &lt;code&gt;                            ┌───────┐
  1                         │   1   │
                            └───────┘
                                │
              ┌───────┐         │         ┌───────┐
  2           │   2   │◀────────┴────────▶│   3   │
              └───────┘                   └───────┘
                  │                           │
      ┌───────┐   │   ┌───────┐   ┌───────┐   │   ┌───────┐
  3   │   4   │◀──┴──▶│   5   │   │   6   │◀──┴──▶│   7   │
      └───────┘       └───────┘   └───────┘       └───────┘
&lt;/code&gt;
    &lt;p&gt;We’ll get the following layers:&lt;/p&gt;
    &lt;code&gt;[1]
[2 3]
[4 5 6 7]
&lt;/code&gt;
    &lt;p&gt;In this case, each element is not a primitive, but a location. This means that the element remembers its position in the tree, you can move from it to other elements, get its path, and so on.&lt;/p&gt;
    &lt;p&gt;First, we need a function that will return the child locations of the original one. Its logic is simple: if it’s possible to go down from the location, we move to the right until we reach emptiness.&lt;/p&gt;
    &lt;code&gt;(defn loc-children [loc]
  (when-let [loc-child (zip/down loc)]
    (-&amp;gt;&amp;gt; loc-child
         (iterate zip/right)
         (take-while some?))))
&lt;/code&gt;
    &lt;p&gt;Note that this function isn’t the same as &lt;code&gt;zip/children&lt;/code&gt;. The latter returns values, not locations, and we need locations exactly. Compare expressions:&lt;/p&gt;
    &lt;code&gt;(-&amp;gt; [1 2 3]
    zip/vector-zip
    zip/children)

(1 2 3)
&lt;/code&gt;
    &lt;p&gt;and&lt;/p&gt;
    &lt;code&gt;(-&amp;gt; [1 2 3]
    zip/vector-zip
    loc-children)

([1 {:l [] :pnodes [[1 2 3]] :ppath nil :r (2 3)}]
 [2 {:l [1] :pnodes [[1 2 3]] :ppath nil :r (3)}]
 [3 {:l [1 2] :pnodes [[1 2 3]] :ppath nil :r nil}])
&lt;/code&gt;
    &lt;p&gt;In the second case, we got the locations, while &lt;code&gt;zip/children&lt;/code&gt; simply accessed the find children function passing to the zipper.&lt;/p&gt;
    &lt;p&gt;Suppose, for some location, &lt;code&gt;loc-children&lt;/code&gt; returned a list of its children. To go down one level, you need to find their children and combine the result. The easiest way to do this is to use the following expression:&lt;/p&gt;
    &lt;code&gt;(mapcat loc-children locs)
&lt;/code&gt;
    &lt;p&gt;where &lt;code&gt;locs&lt;/code&gt; is a list of locations of the current level. If we pass the result of &lt;code&gt;mapcat&lt;/code&gt; to&lt;code&gt; locs&lt;/code&gt; parameter, we’ll move on even further. We’ll do this until we get an empty sequence. All together gives us the &lt;code&gt;loc-layers&lt;/code&gt; function:&lt;/p&gt;
    &lt;code&gt;(defn loc-layers [loc]
  (-&amp;gt;&amp;gt; [loc]
       (iterate (fn [locs]
                  (mapcat loc-children locs)))
       (take-while seq)))
&lt;/code&gt;
    &lt;p&gt;It takes the root location from where to start iterating over the layers. We set the first layer explicitly as a vector of one location. Then its children follow, then children of the children and so on. We’ll only stop when getting an empty layer. Quick check:&lt;/p&gt;
    &lt;code&gt;(def data [[[[1]]] 2 [[[3]]] 3])

(let [layers (-&amp;gt; data
                 zip/vector-zip
                 loc-layers)]
  (for [layer layers]
    (-&amp;gt;&amp;gt; layer
         (map zip/node)
         println)))

;; ([[[[1]]] 2 [[[3]]] 3])
;; ([[[1]]] 2 [[[3]]] 3)
;; ([[1]] [[3]])
;; ([1] [3])
;; (1 3)
&lt;/code&gt;
    &lt;p&gt;To get a chain where the elements go from left to right, we concatenate the layers using &lt;code&gt;concat&lt;/code&gt;. This function is not needed for solving the problem, but it can be useful:&lt;/p&gt;
    &lt;code&gt;(defn loc-seq-layers [loc]
  (apply concat (loc-layers loc)))
&lt;/code&gt;
    &lt;p&gt;Let’s go back to currency exchange. Let’s select the exchange rules so that they contain cyclical dependencies. The zipper remains the same: it builds the exchange tree using the local &lt;code&gt;get-children&lt;/code&gt; function, which is closed on the rules.&lt;/p&gt;
    &lt;code&gt;(def rules2
  [[:rub :usd]
   [:usd :eur]
   [:eur :rub]

   [:rub :lir]
   [:lir :eur]
   [:eur :din]
   [:din :tug]])
&lt;/code&gt;
    &lt;p&gt;The style of working with this zipper will change. Now we iterate through it using not &lt;code&gt;zip/next&lt;/code&gt; but our &lt;code&gt;loc-layers&lt;/code&gt;. At each step, we should get exchange layers. We have to find the locations, which node is equal to the final currency, in the next layer. As soon as we have found at least one, the problem is solved. It remains only to calculate the path to them.&lt;/p&gt;
    &lt;code&gt;(defn exchange2 [rules from to]

  (letfn [(get-children [value]
            (seq (for [[v1 v2] rules
                       :when (= v1 value)]
                   v2)))

          (loc-to? [loc]
            (-&amp;gt; loc zip/node (= to)))

          (find-locs-to [layer]
            (seq (filter loc-to? layer)))

          (-&amp;gt;exchange [loc]
            (conj (zip/path loc) (zip/node loc)))]

    (let [zipper (zip/zipper keyword?
                             get-children
                             nil
                             from)]

      (-&amp;gt;&amp;gt; zipper
           loc-layers
           (some find-locs-to)
           (map -&amp;gt;exchange)))))
&lt;/code&gt;
    &lt;p&gt;As you may have noticed, now there is no need to compare the lengths of the chains: if the locations belong to the same level, the number of steps to them is the same. According to the problem statement, we are interested in the shortest exchange options. For example, if one chain was found on the third level, and there are three chains on the fourth, the latter are not interesting to us – we complete the traversal on the third layer.&lt;/p&gt;
    &lt;p&gt;Here are examples of exchanges regarding the rules specified in &lt;code&gt;rules2&lt;/code&gt;:&lt;/p&gt;
    &lt;code&gt;(exchange2 rules2 :rub :eur)
([:rub :usd :eur] [:rub :lir :eur])

(exchange2 rules2 :rub :tug)
([:rub :usd :eur :din :tug] [:rub :lir :eur :din :tug])

(exchange2 rules2 :lir :din)
([:lir :eur :din])
&lt;/code&gt;
    &lt;p&gt;The solution is still not perfect. If we specify a pair of currencies for which there is no chain, we’ll get an infinite loop. To stop it, limit the number of layers to some reasonable number, such as five. From a financial point of view, currency exchange with no restrictions is likely to be detrimental, and therefore meaningless. Technically, we need to add the form &lt;code&gt;(take N)&lt;/code&gt; right after &lt;code&gt;loc-layers&lt;/code&gt;:&lt;/p&gt;
    &lt;code&gt;(-&amp;gt;&amp;gt; zipper
     loc-layers
     (take 5)
     (some find-locs-to)
     (map -&amp;gt;exchange))
&lt;/code&gt;
    &lt;p&gt;Now, we get an empty result for an invalid pair:&lt;/p&gt;
    &lt;code&gt;(exchange2 rules2 :tug :yen)
()
&lt;/code&gt;
    &lt;p&gt;The task can be improved further. For example, you can calculate costs and transaction fees for each chain. To do this, add the exchange rate and fee to the &lt;code&gt;[:from: to]&lt;/code&gt; vector. Depending on whether we represent a client or a bank, we’ll look for the most optimal or the most expensive exchanges. Please, come up with your own variations for this problem. At this point we’ll finish with currencies and move on.&lt;/p&gt;
    &lt;p&gt;In this chapter, we’ve discussed how the traversal order affects the solution to the problem. Breadth-first and depth-first traversal ordering applies to different cases. This is important for infinite trees, when the algorithm can loop while traversing. There is no breadth-width traversal in the &lt;code&gt;clojure.zip&lt;/code&gt; package, but you can easily write a function to divide the zipper into layers. You may find &lt;code&gt;loc-layers&lt;/code&gt; useful in other cases involving graphs and vertices.&lt;/p&gt;
    &lt;head rend="h2"&gt;Part 8. Summary&lt;/head&gt;
    &lt;p&gt;Finally, let’s take a look at other zipper features that you might find useful.&lt;/p&gt;
    &lt;head rend="h3"&gt;HTML&lt;/head&gt;
    &lt;p&gt;The previous examples show that zippers work fine with XML. By the way, you can apply them to HTML as well. Strictly speaking, the syntax of the formats is different: some HTML elements like &lt;code&gt;&amp;lt;br&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; don’t have closing tags. Parsers that take these features into account can solve the problem. As a result, we get an HTML tree that can be traversed as in the examples above.&lt;/p&gt;
    &lt;p&gt;The Hickory library offers an HTML markup parser. The parsing is based on the Java library JSoup, which builds a tree of elements. Hickory contains a function to rebuild a Java tree into Clojure-like one and get a zipper. Add a dependency to the project:&lt;/p&gt;
    &lt;code&gt;[hickory "0.7.1"]
&lt;/code&gt;
    &lt;p&gt;and run the example:&lt;/p&gt;
    &lt;code&gt;(ns zipper-manual.core
  (:require
   [hickory.core :as h]
   [hickory.zip :as hz]
   [clojure.zip :as zip]))

(def html (-&amp;gt; "https://grishaev.me/"
              java.net.URL.
              slurp))

(def doc-src (h/parse html))
(def doc-clj (h/as-hiccup doc-src))
(def doc-zip (hz/hiccup-zip doc-clj))
&lt;/code&gt;
    &lt;p&gt;How are these conversions performed? A website layout is loaded into the &lt;code&gt;html&lt;/code&gt; variable as a string. The &lt;code&gt;doc-src&lt;/code&gt; variable contains a tree obtained from HTML. It’s an object of the &lt;code&gt;Document&lt;/code&gt; class from the &lt;code&gt;org.jsoup.nodes&lt;/code&gt; package. For Clojure, it’s a black box: to work with it, it needs to read the documentation for the &lt;code&gt;Document&lt;/code&gt; class.&lt;/p&gt;
    &lt;p&gt;The &lt;code&gt;as-hiccup&lt;/code&gt; function converts the document into a set of nested vectors which look like this:&lt;/p&gt;
    &lt;code&gt;[:tag {:attr "value"} &amp;amp; [...]],
&lt;/code&gt;
    &lt;p&gt;The tag comes first, then the attribute dictionary, followed by any number of the same vectors or strings. This is the standard HTML representation in Clojure, and many libraries use the same format.&lt;/p&gt;
    &lt;p&gt;The &lt;code&gt;hiccup-zip&lt;/code&gt; function returns the zipper for that structure. It can do everything that we’ve practiced earlier, for example:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;remove unwanted tags like &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;,&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;;&lt;/item&gt;
      &lt;item&gt;leave these tags, but secure their attributes;&lt;/item&gt;
      &lt;item&gt;leave dangerous tags only if their source points to trusted sites;&lt;/item&gt;
      &lt;item&gt;look for items of interest to us.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Here’s how to find all the images on a webpage:&lt;/p&gt;
    &lt;code&gt;(defn loc-img? [loc]
  (some-&amp;gt; loc zip/node first (= :img)))

(defn loc-&amp;gt;src [loc]
  (some-&amp;gt; loc zip/node second :src))

(-&amp;gt;&amp;gt; doc-zip
     iter-zip
     (filter loc-img?)
     (map loc-&amp;gt;src))

("/assets/static/photo-round-small.png" ...)
&lt;/code&gt;
    &lt;p&gt;The first function checks if the location points to a node with the &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; tag, the second
extracts the &lt;code&gt;src&lt;/code&gt; attribute from it. The third form returns a list of links to images.&lt;/p&gt;
    &lt;p&gt;Based on these actions, you can build HTML filtering, especially if an HTML markup comes from a source you don’t trust. Another scenario is to find a suitable image for a social media cover in HTML. To do this, you need to select all images, estimate their width and height, and select the largest in area (if the &lt;code&gt;width&lt;/code&gt; and &lt;code&gt;height&lt;/code&gt; attributes are filled in).&lt;/p&gt;
    &lt;p&gt;Hickory considers typical cases and offers selectors for searching by tag and attribute. It isn’t even necessary to cast the JSoup tree to a zipper to do this. However, in rare cases, you need to find tags with complex relationships, as in the product and bundle example (either only in the bundle or strictly outside it). These problems fit zippers very well.&lt;/p&gt;
    &lt;head rend="h3"&gt;Data and Serialization&lt;/head&gt;
    &lt;p&gt;Another plus of zippers is that they are represented by data — a combination of lists and maps. This means that you can write the current zipper in EDN or JSON. When reading, we get the old data structure and continue traversing from where we left off. This is the difference between Clojure and object languages, where, in the general case, you cannot write an object to a file without some effort.&lt;/p&gt;
    &lt;p&gt;When restoring a zipper, remember about its metadata. The functions &lt;code&gt;branch?&lt;/code&gt;, &lt;code&gt;children&lt;/code&gt;, and &lt;code&gt;make-node&lt;/code&gt; that we passed to the constructor are stored in the zipper metadata. This is done to separate data from actions on it. Let’s check the zipper metadata we got from HTML:&lt;/p&gt;
    &lt;code&gt;(meta doc-zip)

#:zip{:branch? #function[clojure.core/sequential?]
      :children #function[hickory.zip/children]
      :make-node #function[hickory.zip/make]}
&lt;/code&gt;
    &lt;p&gt;Let’s write functions for resetting and reading EDN:&lt;/p&gt;
    &lt;code&gt;(defn edn-save [data path]
  (spit path (pr-str data)))

(defn edn-load [path]
  (-&amp;gt; path slurp edn/read-string))
&lt;/code&gt;
    &lt;p&gt;Let’s say we’ve made some iterations on a zipper and saved it:&lt;/p&gt;
    &lt;code&gt;(-&amp;gt; doc-zip
    zip/next
    zip/next
    zip/next
    (edn-save "zipper.edn"))
&lt;/code&gt;
    &lt;p&gt;If we read the EDN and pass the result to &lt;code&gt;zip/next&lt;/code&gt;, we’ll get an error. The function will call &lt;code&gt;branch?&lt;/code&gt; and &lt;code&gt;children&lt;/code&gt; from the metadata that has not been saved, resulting in an exception. To make a zipper from a file work, add metadata to it. You can either move it into a variable in advance or declare it manually.&lt;/p&gt;
    &lt;code&gt;(def zip-meta (meta doc-zip))

;; or

(def zip-meta
  #:zip{:branch? sequential?
        :children #'hickory.zip/children
        :make-node #'hickory.zip/make})
&lt;/code&gt;
    &lt;p&gt;In the second case, we had to specify the &lt;code&gt;children&lt;/code&gt; and &lt;code&gt;make-node&lt;/code&gt; functions as variables (instances of the &lt;code&gt;Var&lt;/code&gt; class) because they are private. The read zipper will be in the same state as at the time of saving.&lt;/p&gt;
    &lt;code&gt;(def doc-zip-new
  (-&amp;gt; "zipper.edn"
      edn-load
      (with-meta zip-meta)))

(-&amp;gt; doc-zip-new zip/node first)
:head
&lt;/code&gt;
    &lt;p&gt;Storing the zipper in long-term memory brings new possibilities. For example, traversal of certain data takes time, and the program can perform the task in chunks, keeping the intermediate result. This is how complex business scenarios work. If a customer refuses the services of the company, you must delete their records in the database, files, links to them in documents and much more. This process can be thought of as a set of steps. At each step, the code reads a zipper as EDN from the database and adds metadata. Then it shifts the zipper one &lt;code&gt;zip/next&lt;/code&gt;, performs the task, and updates the record in the database with the new version of the zipper. Once you’ve reached the initial node (&lt;code&gt;zip/end?&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;), you mark the record in the database as resolved.&lt;/p&gt;
    &lt;head rend="h3"&gt;Other Uses&lt;/head&gt;
    &lt;p&gt;The example with the currency exchange shows how to find a solution to the problem by brute force search. Whether you’re looking for the optimal chain of steps, maximum cost, or a traversal route, zippers might help you. It is easy to check if they are suitable for solving your problem. The zipper implies that you have a value and several others based on it, they in turn have their values and so on. If the condition works, you are one step away from building the tree and traversing it.&lt;/p&gt;
    &lt;p&gt;Let’s say, according to the exchange table, the dollar (current value) can be exchanged for the euro and the ruble (child values). From point A (current) you can drive to points B and C (children). In HTML, one tag can include other tags. In all three cases, you can use a zipper. You only need to define the functions &lt;code&gt;branch?&lt;/code&gt; (if an element can have children) and &lt;code&gt;children&lt;/code&gt; (how to find them specifically).&lt;/p&gt;
    &lt;head rend="h3"&gt;Third-party Libraries&lt;/head&gt;
    &lt;p&gt;The &lt;code&gt;clojure.zip&lt;/code&gt; module offers enough navigation functions. Nevertheless, throughout this chapter, we had to write a few functions ourselves. The library data.zip contains various add-ons for zippers, including the same ones as we wrote. Perhaps the library will shorten your utility code.&lt;/p&gt;
    &lt;head rend="h3"&gt;Summary&lt;/head&gt;
    &lt;p&gt;Zippers are means for navigating the data structure. A zipper offers movement in four directions: down, up, left, and right. An element in the center is called a node.&lt;/p&gt;
    &lt;p&gt;A zipper can navigate a wide variety of structures. It needs to know only two things: whether the current element is a branch of a tree, and if so, how to find the children. To do this, the zipper takes the &lt;code&gt;branch?&lt;/code&gt; and &lt;code&gt;children&lt;/code&gt; functions, which are later stored in metadata.&lt;/p&gt;
    &lt;p&gt;Usually, children are found from the parent node, but in some cases we get them dynamically. For example, to find out which currencies can be exchanged for the current one, you can refer to the exchange map. To do this, the &lt;code&gt;children&lt;/code&gt; function has to see the map as a global variable or a closure.&lt;/p&gt;
    &lt;p&gt;The current zipper element is called a location. It stores not only the value, but also the data for going in all directions, as well as the path. These qualities set zippers apart from &lt;code&gt;tree-seq&lt;/code&gt; and analogs that decompose a tree into a chain not including a path to an element. Some tasks consist precisely of finding the right path.&lt;/p&gt;
    &lt;p&gt;The zipper offers functions for editing and deleting the current node. Editing can be based on the current value (&lt;code&gt;zip/edit&lt;/code&gt;) or the new one (&lt;code&gt;zip/replace&lt;/code&gt;).&lt;/p&gt;
    &lt;p&gt;By default, zipper traversal is depth-first. When moving to the end, the location will receive a mark that the cycle has been completed. Use the &lt;code&gt;zip/end?&lt;/code&gt; function as a sign of ending an iteration. In our examples, we wrote the &lt;code&gt;zip-iter&lt;/code&gt; function that does exactly one traversal.&lt;/p&gt;
    &lt;p&gt;Breadth-first traversal is required for some tasks. This can happen when one of the tree branches is potentially infinite. For breadth-first traversal, we wrote our own functions that don’t come with the Clojure.zip.&lt;/p&gt;
    &lt;p&gt;Zippers are useful for working with XML, finding solutions, and filtering HTML. Try to figure them out to solve such problems in a short and elegant way.&lt;/p&gt;
    &lt;p&gt;Нашли ошибку? Выделите мышкой и нажмите Ctrl/⌘+Enter&lt;/p&gt;
    &lt;p&gt;VK, 7th Sep 2022, link&lt;/p&gt;
    &lt;p&gt;отлично. Thanks for sharing your wonderful perspective.&lt;/p&gt;
    &lt;p&gt;temco, 18th Oct 2022, link&lt;/p&gt;
    &lt;p&gt;thanks for your introduction to zipper, which I didn’t use before in the past years on clojure programming&lt;/p&gt;
    &lt;p&gt;Luke, 2nd Aug 2023, link&lt;/p&gt;
    &lt;p&gt;i really appreciate the effort you put into explaining zippers. i can see now how they are such a versatile and powerful construct- but i always avoided them due to a lack of documentation. i wonder if this could find its way onto the official clojure.core site as a guest post?&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://grishaev.me/en/clojure-zippers/"/><published>2025-10-23T03:51:40+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45684134</id><title>Claude Memory</title><updated>2025-10-24T16:44:10.889189+00:00</updated><content>&lt;doc fingerprint="777befbbffb2c0ea"&gt;
  &lt;main&gt;
    &lt;head rend="h1"&gt;Bringing memory to Claude&lt;/head&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Update&lt;p&gt;Expanding to Pro and Max plans&lt;/p&gt;&lt;p&gt;Oct 23, 2025&lt;/p&gt;&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Whether you’re iterating on a strategy proposal, debugging an issue, or managing multiple projects, Claude picks up right where you left off. Like Team and Enterprise users, you get project-scoped memory (each project has its own separate memory), full control to view and edit what Claude remembers, and incognito chat for conversations that don’t save to memory.&lt;/p&gt;
    &lt;p&gt;Before this rollout, we ran extensive safety testing across sensitive wellbeing-related topics and edge cases—including whether memory could reinforce harmful patterns in conversations, lead to over-accommodation, and enable attempts to bypass our safeguards. Through this testing, we identified areas where Claude's responses needed refinement and made targeted adjustments to how memory functions. These iterations helped us build and improve the memory feature in a way that allows Claude to provide helpful and safe responses to users.&lt;/p&gt;
    &lt;p&gt;To get started, enable memory in Settings.&lt;/p&gt;
    &lt;p&gt;Today, we’re introducing memory to the Claude app, where Claude remembers you and your team’s projects and preferences, eliminating the need to re-explain context and keeping complex work moving forward.&lt;/p&gt;
    &lt;p&gt;Memory is fully optional, with granular user controls that help you manage what Claude remembers. We’re also introducing Incognito chats that don’t appear in your conversation history or save to memory.&lt;/p&gt;
    &lt;p&gt;Memory is rolling out to Team and Enterprise plan users starting today. Enterprise admins can choose whether to disable memory for their organization at any time. Incognito chat is available to all Claude users.&lt;/p&gt;
    &lt;head rend="h2"&gt;Memory built for work&lt;/head&gt;
    &lt;p&gt;With memory, Claude focuses on learning your professional context and work patterns to maximize productivity. It remembers your team’s processes, client needs, project details, and priorities. Sales teams keep client context across deals, product teams maintain specifications across sprints, and executives track initiatives without constantly rebuilding context.&lt;/p&gt;
    &lt;p&gt;If you use projects, Claude creates a separate memory for each project. This ensures that your product launch planning stays separate from client work, and confidential discussions remain separate from general operations. These project boundaries help you and your teams manage complex, concurrent initiatives without mixing unrelated details, serving as a safety guardrail that keeps sensitive conversations contained.&lt;/p&gt;
    &lt;p&gt;Claude uses a memory summary to capture all its memories in one place for you to view and edit. In your settings, you can see exactly what Claude remembers from your conversations, and update the summary at any time by chatting with Claude. Based on what you tell Claude to focus on or to ignore, Claude will adjust the memories it references.&lt;/p&gt;
    &lt;head rend="h2"&gt;Incognito chat&lt;/head&gt;
    &lt;p&gt;Sometimes you need Claude’s help without using or adding to memory. Incognito chat gives you a clean slate for conversations that you don’t want to preserve in memory. It is perfect for sensitive brainstorming, confidential strategy discussions, or when you simply want a fresh conversation without context from previous chats. Your regular memory and conversation history remain untouched. If you’re using memory on a Team or Enterprise plan, your standard data retention settings apply.&lt;/p&gt;
    &lt;head rend="h2"&gt;Starting with teams at work&lt;/head&gt;
    &lt;p&gt;Memory introduces new safety considerations and we've designed the feature to be useful in work settings, while avoiding sensitive conversations and topics. We're also taking a thoughtful phased approach to ensure these powerful capabilities are deployed responsibly, and will continue to evaluate and test how memory works across the different ways people use Claude before expanding availability.&lt;/p&gt;
    &lt;head rend="h2"&gt;Getting started&lt;/head&gt;
    &lt;p&gt;To see memory in action, enable the feature in Settings, and let Claude generate memory with your past chats at initial set-up. Ask Claude questions like “what were we working on last week?” to see what Claude remembers across your existing chats and connected tools. If you would like to bring your memory details over from a different AI tool or export your memory from Claude for backup or migration, you can follow these instructions.&lt;/p&gt;
    &lt;p&gt;Great work builds over time. With memory, each conversation with Claude improves the next.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://www.anthropic.com/news/memory"/><published>2025-10-23T16:56:07+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45687458</id><title>/dev/null is an ACID compliant database</title><updated>2025-10-24T16:44:10.634347+00:00</updated><content>&lt;doc fingerprint="8812dd1940f64a11"&gt;
  &lt;main&gt;
    &lt;head rend="h2"&gt;Atomicity&lt;/head&gt;
    &lt;p&gt;Operations are "all or nothing."&lt;/p&gt;
    &lt;p&gt;Anything you write to &lt;code&gt;/dev/null&lt;/code&gt; disappears entirely. There's no partial write problem: it’s either written (and discarded) or not written at all. ✅&lt;/p&gt;
    &lt;head rend="h2"&gt;Consistency&lt;/head&gt;
    &lt;p&gt;The system transitions from one valid state to another.&lt;/p&gt;
    &lt;p&gt;&lt;code&gt;/dev/null&lt;/code&gt; always stays in a consistent state (empty). No matter what you write, the invariant "file contains nothing" always holds. ✅&lt;/p&gt;
    &lt;head rend="h2"&gt;Isolation&lt;/head&gt;
    &lt;p&gt;Concurrent transactions don’t interfere with each other.&lt;/p&gt;
    &lt;p&gt;Multiple processes can write to &lt;code&gt;/dev/null&lt;/code&gt; at the same time, and their outputs never conflict, because nothing is ever stored. ✅&lt;/p&gt;
    &lt;head rend="h2"&gt;Durability&lt;/head&gt;
    &lt;p&gt;Once a transaction is committed, it remains so, even after crashes.&lt;/p&gt;
    &lt;p&gt;&lt;code&gt;/dev/null&lt;/code&gt; "durably" commits your data into nothingness. After a crash or reboot, it still contains exactly what it always has: nothing. ✅&lt;/p&gt;
    &lt;p&gt;There is only 1 small problem though, it only comes with 0b of free storage. For more space, you will have to contact entreprise sales, which is actually just me!&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://jyu.dev/blog/why-dev-null-is-an-acid-compliant-database/"/><published>2025-10-23T21:28:02+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45689241</id><title>Counter-Strike's player economy is in a multi-billion dollar freefall</title><updated>2025-10-24T16:44:10.142265+00:00</updated><content>&lt;doc fingerprint="b660f151878bcf98"&gt;
  &lt;main&gt;
    &lt;p&gt;Counter-Strike has long been known for two things: tight tactical FPS gameplay and a thriving player marketplace effectively valued at literal billions of dollars. Now, thanks to a recent update from Valve, the latter is in a downward spiral, having lost 25% of its value — or $1.75 billion — overnight.&lt;/p&gt;
    &lt;p&gt;First, some context. Counter-Strike is a free-to-play multiplayer shooter. As with most other F2P games, it generates revenue from selling cosmetics. They arrive in lootbox-like Cases, which are opened by Keys purchased with real-world currency. They can also be obtained through trading with other players and purchasing from Steam Community Market. Beyond Steam, unofficial third-party marketplaces for CS cosmetics have also popped up as channels for buying and selling items.&lt;/p&gt;
    &lt;p&gt;Because items are obtained at random through opening Cases, rarer items fetch the highest value on the open marketplaces. Items of lower-rarity tiers can also be traded in at volume for an item of a higher tier via trade up contracts. Previously, Knives and Gloves could not be obtained through trade up contracts, exponentially increasing their value as highly sought-after items. Prior to the most recent update, some Knives, like a Doppler Ruby Butterfly Knife, could fetch around $20,000 on third-party storefronts like CSFloat.&lt;/p&gt;
    &lt;p&gt;Following Valve's Oct. 22 update to Counter-Strike, the second-highest-tier, Covert (Red), can now be traded up and turned into Knives and Gloves. Essentially, this means that a previously extremely rare and highly sought-after cosmetic is going to be much more obtainable for those who increasingly want it, reducing the value of Knives and Gloves on the open marketplace.&lt;/p&gt;
    &lt;p&gt;And this is where the market descends into a freefall. Now, that Butterfly Knife mentioned above? It's going for around $12,000, as people are essentially dumping their stock, with 15 sold over the past 16 hours at the time of this writing.&lt;/p&gt;
    &lt;p&gt;Bloomberg reported the market for Counter-Strike cosmetic items dropped 25% overnight from Wednesday evening into Thursday morning. It's lost about $1.84 billion in value, according to Pricempire, which tracks and analyses the market for CS items. "This completely changes the supply of Counter-Strike’s most sought-after and expensive tier of items," Pricempire marketing manager Ethan MacDonald told Bloomberg.&lt;/p&gt;
    &lt;p&gt;As sellers attempt to recoup their investments, similar fire sales like the one happening at CSFloat are occurring at other sites. One such site, Skin Port, even put us in a waiting room to access it; traffic was overwhelming its servers.&lt;/p&gt;
    &lt;p&gt;Just like how NFT or cryptocurrency values can drastically shift, Counter-Strike item traders are seeing their stock rapidly change in value, and not for the best. While some items of lower-rarity tiers have gone up in value, and Reds might see a bump now that they can be traded up into Knives and Gloves, that can't make up for the sudden drop at the top of the cosmetics market.&lt;/p&gt;
    &lt;p&gt;We'll have to wait and see if the market levels out or if it continues to crash. Plenty of players and CS traders must be eagerly awaiting more news: As of this writing, Pricempire's servers had crashed.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://www.polygon.com/counter-strike-cs-player-economy-multi-billion-dollar-freefall/"/><published>2025-10-24T00:24:11+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45690251</id><title>Roc Camera</title><updated>2025-10-24T16:44:09.511763+00:00</updated><content>&lt;doc fingerprint="d8c40a7031a4502f"&gt;
  &lt;main&gt;
    &lt;head rend="h2"&gt;Photos used to be magic&lt;/head&gt;
    &lt;head rend="h2"&gt;Photosusedtobemagic&lt;/head&gt;
    &lt;p&gt;There was a time when cameras captured magic. Photos told stories of a certain moment in time, a reflection of reality, a physical artifact of lives.&lt;/p&gt;
    &lt;head rend="h2"&gt;AI has blurred the line&lt;/head&gt;
    &lt;head rend="h2"&gt;AIhasblurredtheline&lt;/head&gt;
    &lt;p&gt;Now, how we take, share, and create images has changed. Social media has made sharing images easy. Generative AI now creates any image we can imagine.&lt;/p&gt;
    &lt;head rend="h2"&gt;Lost sight of what is real&lt;/head&gt;
    &lt;head rend="h2"&gt;Lostsightofwhatisreal&lt;/head&gt;
    &lt;p&gt;We've started to lose sight of what is real. We've lost our ability to find our bearings in an endless sea of copies and AI-generated noise.&lt;/p&gt;
    &lt;head rend="h2"&gt;It's time for Roc Camera&lt;/head&gt;
    &lt;head rend="h2"&gt;It'stimeforRocCamera&lt;/head&gt;
    &lt;p&gt;By combining attested sensor data, zero-knowledge proofs, and a tamper-proof environment, we've built Roc Camera to capture verifiably real photos.&lt;/p&gt;
    &lt;head rend="h3"&gt;Camera Components:&lt;/head&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;â¢ 4-inch IPS LCD Screen 720x720 with Capacitive Touch&lt;/item&gt;
      &lt;item&gt;â¢ 16MP Sony IMX519 CMOS with 122Â° FOV lens&lt;/item&gt;
      &lt;item&gt;â¢ Raspberry Pi 4 4GB RAM ARM Cortex-A72 1.5 Ghz&lt;/item&gt;
      &lt;item&gt;â¢ LiPo 4000mAh Battery&lt;/item&gt;
      &lt;item&gt;â¢ Uninterruptible Power Supply Board&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h3"&gt;Capture&lt;/head&gt;
    &lt;p&gt;Capture a photo that only this Camera can uniquely take&lt;/p&gt;
    &lt;head rend="h3"&gt;Prove&lt;/head&gt;
    &lt;p&gt;Creates a Zero Knowledge (ZK) Proof of the camera sensor data and other metadatas&lt;/p&gt;
    &lt;head rend="h3"&gt;Verify&lt;/head&gt;
    &lt;p&gt;Verify that the photo is real by checking the ZK proof via the Roc Photo SDK&lt;/p&gt;
    &lt;head rend="h2"&gt;Capture verifiably real moments&lt;/head&gt;
    &lt;p&gt;Accepting orders now â (Batch 2)&lt;/p&gt;
    &lt;p&gt;Ships in 2~3 weeks&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://roc.camera/"/><published>2025-10-24T02:54:29+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45690679</id><title>JupyterGIS breaks through to the next level</title><updated>2025-10-24T16:44:08.479028+00:00</updated><content>&lt;doc fingerprint="1e3f8f51d82fedc0"&gt;
  &lt;main&gt;
    &lt;p&gt;Launched in June 2024, JupyterGIS was introduced as a collaborative, web-based GIS environment built on the JupyterLab framework. Its objective is to bring QGIS-inspired workflows into the browser, enabling real-time collaborative editing, seamless integration with notebooks, and support for core geospatial data formats.&lt;/p&gt;
    &lt;p&gt;When it was first announced earlier this year, JupyterGIS already delivered:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Real-time collaborative editing (Google Docs-style)&lt;/item&gt;
      &lt;item&gt;Visualisation of raster &amp;amp; vector data&lt;/item&gt;
      &lt;item&gt;Symbology editing and spatio-temporal animations&lt;/item&gt;
      &lt;item&gt;Programmatic map control via a Python API.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Thanks to contributions from the community and support from partner organizations, JupyterGIS has advanced significantly and now offers an expanded range of features for analysis, visualization, and collaboration.&lt;/p&gt;
    &lt;p&gt;Enhanced vector tile capabilities&lt;/p&gt;
    &lt;p&gt;Support for vector tiles has been strengthened, including full compatibility with the pmtiles format.&lt;/p&gt;
    &lt;p&gt;Other key updates include:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;An identify tool that inspects vector tiles to display features and associated properties.&lt;/item&gt;
      &lt;item&gt;A symbology panel that applies graduated, categorized, and canonical symbology to vector tile layers.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;These improvements enhance the interpretability and styling of geospatial datasets directly in the browser.&lt;/p&gt;
    &lt;p&gt;A new processing toolbox&lt;/p&gt;
    &lt;p&gt;One of the most significant updates is a new browser-based processing toolbox powered by a WebAssembly (WASM) build of the Geospatial Data Abstraction Library (GDAL).&lt;/p&gt;
    &lt;p&gt;Available tools include:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Buffer: computes a buffer around geometries of a vector dataset.&lt;/item&gt;
      &lt;item&gt;Convex Hull: calculates the convex hull for each feature of an input layer.&lt;/item&gt;
      &lt;item&gt;Dissolve: combines features of vector layers into new features&lt;/item&gt;
      &lt;item&gt;Bounding Boxes: calculates the bounding box for each feature in an input layer.&lt;/item&gt;
      &lt;item&gt;Centroid: creates a new layer with the centroids of the geometries of an input layer.&lt;/item&gt;
      &lt;item&gt;Concave Hull: computes the concave hull for each feature of an input point layer.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;This toolbox has been designed for extensibility, with a JSON schema that allows additional GDAL operations to be integrated in a straightforward manner.&lt;/p&gt;
    &lt;p&gt;Symbology enhancements&lt;/p&gt;
    &lt;p&gt;Visualization of geospatial data has become more flexible and expressive through several enhancements:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Viridis is now the default colormap, providing perceptually uniform visualization.&lt;/item&gt;
      &lt;item&gt;Multiband symbology is now available for GeoTIFFs.&lt;/item&gt;
      &lt;item&gt;Canonical symbology defined in GeoJSON files can be applied automatically.&lt;/item&gt;
      &lt;item&gt;Colormaps can now be reversed, allowing greater flexibility for data interpretation and visualization.&lt;/item&gt;
      &lt;item&gt;In the case of point layers, color and marker size can be styled independently, and bound to different data.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Integration with SpatioTemporal Asset Catalogs (STAC)&lt;/p&gt;
    &lt;p&gt;A SpatioTemporal Asset Catalog (STAC) browser is now embedded into JupyterGIS, streamlining access to different data collections. Users can select specific platforms and sensors, choose data products and processing levels, and set temporal and spatial constraints.&lt;/p&gt;
    &lt;p&gt;It is now possible to search across multiple datasets simultaneously. Users can click on any result to add it directly as a layer to their JupyterGIS project. This creates a seamless workflow from data discovery to visualization, making it easier for researchers and analysts to find and integrate relevant satellite imagery and geospatial datasets into their Jupyter notebooks.&lt;/p&gt;
    &lt;p&gt;Currently, the STAC Browser only supports the Geodes STAC API but support for all STAC catalogs is under way.&lt;/p&gt;
    &lt;p&gt;Support for more data types&lt;/p&gt;
    &lt;p&gt;The range of supported geospatial data formats is now broadened with GeoParquet and PMTiles, enabling efficient columnar storage and fast analytical queries for GeoParquet, and highly compact, streaming-friendly vector tile delivery for PMTiles.&lt;/p&gt;
    &lt;p&gt;User experience and interface improvements&lt;/p&gt;
    &lt;p&gt;The interface has been refined for a smoother workflow:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Integrated control panels (layer list, filters, layer properties, etc.), reducing back and forth between the JupyterLab side-panels and the JupyterGIS UI. It also improves the “single document” scenario, allowing it to interact with JupyterGIS controls when opening a GIS document from the classic Jupyter Notebook UI.&lt;/item&gt;
      &lt;item&gt;An improved toolbar design, with cleaner icons and better usability.&lt;/item&gt;
      &lt;item&gt;A new feature to center the map on your current location.&lt;/item&gt;
      &lt;item&gt;Map annotations now link to the map: clicking an annotation automatically re-centers and zooms to the location.&lt;/item&gt;
      &lt;item&gt;Full-screen mode support.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Legends for vector layers&lt;/p&gt;
    &lt;p&gt;JupyterGIS now automatically generates legends for vector layers, ensuring consistent interpretation:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Legends are dynamically updated to reflect current symbology.&lt;/item&gt;
      &lt;item&gt;Customizations such as reversed colormaps are preserved.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;JupyterGIS tiler extension&lt;/p&gt;
    &lt;p&gt;An extension for JupyterGIS enables the creation of JupyterGIS layers from xarray variables in Jupyter kernels, with support for lazy evaluation, bridging geospatial workflows with powerful array-based computation.&lt;/p&gt;
    &lt;p&gt;The package, called JupyterGIS-tiler, is available in GitHub here and can be installed from PyPI with pip install jupytergis-tiler.&lt;/p&gt;
    &lt;p&gt;Looking ahead&lt;/p&gt;
    &lt;p&gt;Development will continue to expand JupyterGIS in several directions:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Extension of the GDAL-based processing toolbox.&lt;/item&gt;
      &lt;item&gt;Deeper integration with QGIS and a richer Python API for automation.&lt;/item&gt;
      &lt;item&gt;A Story Maps Editor and Viewer to enable interactive communication of geospatial information through text, imagery, and maps.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;In the meantime, feel free to try JupyterGIS directly in your browser with JupyterLite, no installation required.&lt;/p&gt;
    &lt;p&gt;Opportunities for engagement also include:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Checking out documentation for tutorials and the Python API.&lt;/item&gt;
      &lt;item&gt;Discussions via the GeoJupyter Zulip channel or the bi-weekly GeoJupyter hackathon.&lt;/item&gt;
      &lt;item&gt;Contributions to the development repository.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The JupyterGIS community continues to grow, and active participation from researchers, developers, and educators worldwide is encouraged.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://eo4society.esa.int/2025/10/16/jupytergis-breaks-through-to-the-next-level/"/><published>2025-10-24T04:13:01+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45692984</id><title>Twake Drive – An open-source alternative to Google Drive</title><updated>2025-10-24T16:44:06.600513+00:00</updated><content>&lt;doc fingerprint="cb16d4485c6376c3"&gt;
  &lt;main&gt;
    &lt;p&gt; The open-source alternative to Google Drive. &lt;lb/&gt; Learn more » &lt;lb/&gt; Telegram | Website | Issues | Roadmap &lt;/p&gt;
    &lt;p&gt;To get a local copy up and running, please follow these simple steps.&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Clone the repo &lt;quote&gt;git clone https://github.com/linagora/twake-drive&lt;/quote&gt;&lt;/item&gt;
      &lt;item&gt;Run it with Docker &lt;code&gt;cd tdrive docker compose -f docker-compose.minimal.yml up&lt;/code&gt;&lt;/item&gt;
      &lt;item&gt;Open http://localhost/ in a browser&lt;/item&gt;
    &lt;/list&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Node.js (Version: &amp;gt;=18.x)&lt;/item&gt;
      &lt;item&gt;MongoDB&lt;/item&gt;
      &lt;item&gt;Yarn (recommended)&lt;/item&gt;
    &lt;/list&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;
        &lt;p&gt;Launch MongoDB using&lt;/p&gt;
        &lt;quote&gt;docker run -p 27017:27017 -d mongo&lt;/quote&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Launch frontend with&lt;/p&gt;
        &lt;quote&gt;cd tdrive/frontend/; yarn dev:start&lt;/quote&gt;
      &lt;/item&gt;
      &lt;item&gt;&lt;p&gt;Launch backend with&lt;/p&gt;&lt;quote&gt;cd tdrive/backend/node/; SEARCH_DRIVER=mongodb DB_DRIVER=mongodb PUBSUB_TYPE=local \ DB_MONGO_URI=mongodb://localhost:27017 STORAGE_LOCAL_PATH=/[full-path-to-store-documents]/documents \ NODE_ENV=development yarn dev&lt;/quote&gt;&lt;p&gt;If you need more parameters, create/edit&lt;/p&gt;&lt;code&gt;tdrive/backend/node/config/development.json&lt;/code&gt;file&lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;The app will be running on port 3000&lt;/p&gt;
      &lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Twake Drive is licensed under Affero GPL v3&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://github.com/linagora/twake-drive"/><published>2025-10-24T10:16:25+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45693325</id><title>Mesh2Motion – Open-source web application to animate 3D models</title><updated>2025-10-24T16:44:06.349924+00:00</updated><content>&lt;doc fingerprint="a9753601cfb2d489"&gt;
  &lt;main&gt;
    &lt;head rend="h3"&gt;ð¥³ Human &amp;amp; Animal rigs&lt;/head&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Supports importing GLB, GLTF, and FBX models&lt;/item&gt;
      &lt;item&gt;Human and animal skeleton options&lt;/item&gt;
      &lt;item&gt;Intuitive skeleton positioning&lt;/item&gt;
      &lt;item&gt;Undo/Redo system when you make mistakes&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h3"&gt;âï¸ Export Animations&lt;/head&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Export multiple animations at once&lt;/item&gt;
      &lt;item&gt;Uses widely-supported GLB format&lt;/item&gt;
      &lt;item&gt;Human animation library from Quaternius&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h2"&gt;Video Walkthrough&lt;/head&gt;
    &lt;head rend="h2"&gt;FREE &amp;amp; Open-Source&lt;/head&gt;
    &lt;p&gt;Mesh2Motion is an open-source project. With the way 3d animations and modeling tools are progressing, there just needs to be some tool like this that is open-source that can evolve. The goal of this project is to provide a free and easy way to animate 3D models for web and game engines. Everything should be freely available for both personal and commercial projects. Check out the GitHub repository for all the code.&lt;/p&gt;
    &lt;head rend="h2"&gt;Contact&lt;/head&gt;
    &lt;p&gt;The best place for bug reports and feedback is on the GitHub page. If you don't have GitHub, you could also try my socials:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;github.com/scottpetrovic/mesh2motion-app&lt;/item&gt;
      &lt;item&gt;@scottpetrovic&lt;/item&gt;
      &lt;item&gt;@scottpetrovic.bsky.social&lt;/item&gt;
    &lt;/list&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://mesh2motion.org/"/><published>2025-10-24T11:01:23+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45693591</id><title>ChunkLLM: A Lightweight Pluggable Framework for Accelerating LLMs Inference</title><updated>2025-10-24T16:44:06.230111+00:00</updated><content>&lt;doc fingerprint="8d9c1c23d1f186ae"&gt;
  &lt;main&gt;&lt;head rend="h1"&gt;Computer Science &amp;gt; Computation and Language&lt;/head&gt;&lt;p&gt; [Submitted on 28 Sep 2025]&lt;/p&gt;&lt;head rend="h1"&gt;Title:ChunkLLM: A Lightweight Pluggable Framework for Accelerating LLMs Inference&lt;/head&gt;View PDF HTML (experimental)&lt;quote&gt;Abstract:Transformer-based large models excel in natural language processing and computer vision, but face severe computational inefficiencies due to the self-attention's quadratic complexity with input tokens. Recently, researchers have proposed a series of methods based on block selection and compression to alleviate this problem, but they either have issues with semantic incompleteness or poor training-inference efficiency. To comprehensively address these challenges, we propose ChunkLLM, a lightweight and pluggable training framework. Specifically, we introduce two components: QK Adapter (Q-Adapter and K-Adapter) and Chunk Adapter. The former is attached to each Transformer layer, serving dual purposes of feature compression and chunk attention acquisition. The latter operates at the bottommost layer of the model, functioning to detect chunk boundaries by leveraging contextual semantic information. During the training phase, the parameters of the backbone remain frozen, with only the QK Adapter and Chunk Adapter undergoing training. Notably, we design an attention distillation method for training the QK Adapter, which enhances the recall rate of key chunks. During the inference phase, chunk selection is triggered exclusively when the current token is detected as a chunk boundary, thereby accelerating model inference. Experimental evaluations are conducted on a diverse set of long-text and short-text benchmark datasets spanning multiple tasks. ChunkLLM not only attains comparable performance on short-text benchmarks but also maintains 98.64% of the performance on long-context benchmarks while preserving a 48.58% key-value cache retention rate. Particularly, ChunkLLM attains a maximum speedup of 4.48x in comparison to the vanilla Transformer in the processing of 120K long texts.&lt;/quote&gt;&lt;head rend="h3"&gt;References &amp;amp; Citations&lt;/head&gt;&lt;p&gt; export BibTeX citation Loading... &lt;/p&gt;&lt;head rend="h1"&gt;Bibliographic and Citation Tools&lt;/head&gt;&lt;p&gt; Bibliographic Explorer (What is the Explorer?) &lt;/p&gt;&lt;p&gt; Connected Papers (What is Connected Papers?) &lt;/p&gt;&lt;p&gt; Litmaps (What is Litmaps?) &lt;/p&gt;&lt;p&gt; scite Smart Citations (What are Smart Citations?) &lt;/p&gt;&lt;head rend="h1"&gt;Code, Data and Media Associated with this Article&lt;/head&gt;&lt;p&gt; alphaXiv (What is alphaXiv?) &lt;/p&gt;&lt;p&gt; CatalyzeX Code Finder for Papers (What is CatalyzeX?) &lt;/p&gt;&lt;p&gt; DagsHub (What is DagsHub?) &lt;/p&gt;&lt;p&gt; Gotit.pub (What is GotitPub?) &lt;/p&gt;&lt;p&gt; Hugging Face (What is Huggingface?) &lt;/p&gt;&lt;p&gt; Papers with Code (What is Papers with Code?) &lt;/p&gt;&lt;p&gt; ScienceCast (What is ScienceCast?) &lt;/p&gt;&lt;head rend="h1"&gt;Demos&lt;/head&gt;&lt;head rend="h1"&gt;Recommenders and Search Tools&lt;/head&gt;&lt;p&gt; Influence Flower (What are Influence Flowers?) &lt;/p&gt;&lt;p&gt; CORE Recommender (What is CORE?) &lt;/p&gt;&lt;head rend="h1"&gt;arXivLabs: experimental projects with community collaborators&lt;/head&gt;&lt;p&gt;arXivLabs is a framework that allows collaborators to develop and share new arXiv features directly on our website.&lt;/p&gt;&lt;p&gt;Both individuals and organizations that work with arXivLabs have embraced and accepted our values of openness, community, excellence, and user data privacy. arXiv is committed to these values and only works with partners that adhere to them.&lt;/p&gt;&lt;p&gt;Have an idea for a project that will add value for arXiv's community? Learn more about arXivLabs.&lt;/p&gt;&lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://arxiv.org/abs/2510.02361"/><published>2025-10-24T11:41:26+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45693599</id><title>Poker fraud used X-ray tables, high-tech glasses and NBA players</title><updated>2025-10-24T16:44:05.829433+00:00</updated><content>&lt;doc fingerprint="7cc1817ecd478309"&gt;
  &lt;main&gt;
    &lt;head rend="h1"&gt;'Mind-boggling' poker fraud used X-ray tables, high-tech glasses and NBA players&lt;/head&gt;
    &lt;p&gt;Celebrities, professional sports stars and wealthy gamblers sat at a table hoping to win big in a game of Texas Hold 'Em.&lt;/p&gt;
    &lt;p&gt;But they didn't know it was nearly impossible. They were "fishes" allegedly being targeted by the mafia in an elaborate poker gambling scheme that included X-ray card tables, secret cameras, analysers in chip trays and sunglasses and contact lenses that could read their hand.&lt;/p&gt;
    &lt;p&gt;In what sounds like an Ocean's Eleven film plot, prosecutors say these "unwitting" victims were cheated out of at least $7m (£5.25m) in poker games - with one person losing at least $1.8m.&lt;/p&gt;
    &lt;p&gt;The scheme, which US prosecutors described as "reminiscent of a Hollywood movie", was dismantled in a sprawling federal investigation that led to more than 30 arrests, including members of La Cosa Nostra crime families, Portland Trail Blazers basketball coach Chauncey Billups and former National Basketball Association (NBA) player Damon Jones.&lt;/p&gt;
    &lt;p&gt;FBI director Kash Patel called it a "mind-boggling" fraud scheme that cheated victims in New York, Miami, Las Vegas and other US cities.&lt;/p&gt;
    &lt;p&gt;Arrests in the scheme were announced on Thursday along with those in an alleged basketball betting plot, in which professional NBA players are accused of faking injuries to influence betting odds.&lt;/p&gt;
    &lt;p&gt;The underground poker scheme started as early as 2019, prosecutors say, and was allegedly operated by the mafia - specifically by members of notorious crime families, including Bonnano, Gambino, Lucchese and Genovese. A cut of the profits, prosecutors say, helped fund their criminal enterprise.&lt;/p&gt;
    &lt;p&gt;Former professional athletes, described by prosecutors as "face cards", were enlisted to help in the scheme and entice victims into playing.&lt;/p&gt;
    &lt;p&gt;Lured in by the opportunity to play with a high-profile celebrity - such as Billups or Jones - a wealthy, "unwitting victim" would be recruited for illegal, underground poker games where tens of thousands of dollars were on the line, prosecutors allege.&lt;/p&gt;
    &lt;p&gt;Unbeknownst to the lured-in players - referred to in the scheme as a "fish" - everyone surrounding them was in on the elaborate scam - from the players to the dealers, even the technology used to shuffle the deck and count the chips, according to a lengthy federal indictment.&lt;/p&gt;
    &lt;p&gt;Sophisticated wireless technology was also used to deceive the players during the games, most commonly in Texas Hold 'Em.&lt;/p&gt;
    &lt;p&gt;The technology was everywhere - an X-ray table that read any face-down card, analysers inside chip trays, a rigged shuffling machine that read cards and predicted who would have the best hand, and pre-marked cards that allowed those wearing special sunglasses and contact lenses to read what was in everyone's hands.&lt;/p&gt;
    &lt;p&gt;Secretive cameras - built into tables and light fixtures - also helped convey information to those helping in the plot, authorities say.&lt;/p&gt;
    &lt;p&gt;Then there was also a sophisticated method of communicating and rigging the game, prosecutors allege.&lt;/p&gt;
    &lt;p&gt;Information from the game would be sent to an off-site conspirator - called an "operator" by prosecutors - who then would send information to another player sitting at the table who was in on the scheme - who prosecutors call a "quarterback" or "driver".&lt;/p&gt;
    &lt;p&gt;That person would then secretly signal to others, prosecutors allege, effectively stealing money and making it impossible for victims to win.&lt;/p&gt;
    &lt;p&gt;Texts from the US justice department's evidence suggest the "quarterback" would either touch the $1,000 poker chip, tap his chin, wrist or arm to signal which conspirator had the best hand.&lt;/p&gt;
    &lt;p&gt;If the victim had the best hand, the "quarterback" would touch his black chips.&lt;/p&gt;
    &lt;p&gt;The texts also appear to show that at times conspirators agreed to lose some hands in order to keep victims at the gambling table for longer.&lt;/p&gt;
    &lt;p&gt;Another series of texts suggests participants in the scheme avoided suspicion of cheating by swapping in players and losing money to co-conspirators.&lt;/p&gt;
    &lt;p&gt;Authorities estimate that each game would leave a victim out of tens or hundreds of thousands of dollars.&lt;/p&gt;
    &lt;p&gt;Prosecutors say the defendants allegedly laundered the funds from the scheme through cryptocurrency, cash exchanges and shell companies.&lt;/p&gt;
    &lt;p&gt;A cut of the profits went to those who helped in the plot, prosecutors say, and some allegedly went to fund the mafia's criminal enterprise.&lt;/p&gt;
    &lt;p&gt;"This alleged scheme wreaked havoc across the nation, exploiting the notoriety of some and the wallets of others to finance the Italian crime families," said FBI Assistant Director in Charge Christopher Raia.&lt;/p&gt;
    &lt;p&gt;Billups, who was accused of being a face card in the fixed card games, was arrested in Portland and was placed on leave by the NBA. The Portland Trail Blazers said in a statement that they were aware of the allegations involving their head coach and were "fully co-operating with the investigation".&lt;/p&gt;
    &lt;p&gt;Jones was arrested in relation to both the poker and NBA injuries scheme. He is charged with two counts each of wire fraud conspiracy and money laundering conspiracy.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://www.bbc.com/news/articles/cz6nd9wnzn6o"/><published>2025-10-24T11:42:29+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45693743</id><title>Padlet (YC W13) Is Hiring in San Francisco and Singapore</title><updated>2025-10-24T16:44:05.606089+00:00</updated><content>&lt;doc fingerprint="28684c070fcc5eec"&gt;
  &lt;main&gt;
    &lt;head rend="h1"&gt;LET'S GET TO WORK&lt;/head&gt;
    &lt;p&gt;Your morning cup of coffee.&lt;lb/&gt;The song you'll play at your wedding.&lt;lb/&gt;Football, either one.&lt;lb/&gt;The camera that recorded your first steps.&lt;lb/&gt;Air conditioning in the living room, hot water in the bathroom.&lt;lb/&gt;Your every comfort, every joy, every memory.&lt;lb/&gt;You have them because of someone's work,&lt;lb/&gt;because of a world at work,&lt;lb/&gt;because of generations that worked before us.&lt;lb/&gt;Making.&lt;lb/&gt;Saving.&lt;lb/&gt;Breaking.&lt;lb/&gt;Moving.&lt;lb/&gt;Wrestling inboxes that never tap out.&lt;lb/&gt;Five minutes to finish a ziplocked ham sandwich.&lt;lb/&gt;Trying to find parking. Always trying to find parking.&lt;lb/&gt;Knots in the gut before the lights turn on.&lt;lb/&gt;Blisters on fingers where the pencil meets the skin.&lt;lb/&gt;Snowfall or heatwave.&lt;lb/&gt;Stardust to sunrise.&lt;lb/&gt;They showed up for us.&lt;lb/&gt;Let's show up for them.&lt;lb/&gt;Let's move.&lt;lb/&gt;Let's break.&lt;lb/&gt;Let's save.&lt;lb/&gt;Let's make.&lt;lb/&gt;Let's get to work.&lt;/p&gt;
    &lt;p&gt;The song you'll play at your wedding.&lt;/p&gt;
    &lt;p&gt;Football, either one.&lt;/p&gt;
    &lt;p&gt;The camera that recorded your first steps.&lt;/p&gt;
    &lt;p&gt;Air conditioning in the living room, hot water in the bathroom.&lt;/p&gt;
    &lt;p&gt;Your every comfort, every joy, every memory.&lt;/p&gt;
    &lt;p&gt;You have them because of someone's work,&lt;/p&gt;
    &lt;p&gt;because of a world at work,&lt;/p&gt;
    &lt;p&gt;because of generations that worked before us.&lt;/p&gt;
    &lt;p&gt;Making.&lt;/p&gt;
    &lt;p&gt;Saving.&lt;/p&gt;
    &lt;p&gt;Breaking.&lt;/p&gt;
    &lt;p&gt;Moving.&lt;/p&gt;
    &lt;p&gt;Wrestling inboxes that never tap out.&lt;/p&gt;
    &lt;p&gt;Five minutes to finish a ziplocked ham sandwich.&lt;/p&gt;
    &lt;p&gt;Trying to find parking. Always trying to find parking.&lt;/p&gt;
    &lt;p&gt;Knots in the gut before the lights turn on.&lt;/p&gt;
    &lt;p&gt;Blisters on fingers where the pencil meets the skin.&lt;/p&gt;
    &lt;p&gt;Snowfall or heatwave.&lt;/p&gt;
    &lt;p&gt;Stardust to sunrise.&lt;/p&gt;
    &lt;p&gt;They showed up for us.&lt;/p&gt;
    &lt;p&gt;Let's show up for them.&lt;/p&gt;
    &lt;p&gt;Let's move.&lt;/p&gt;
    &lt;p&gt;Let's break.&lt;/p&gt;
    &lt;p&gt;Let's save.&lt;/p&gt;
    &lt;p&gt;Let's make.&lt;/p&gt;
    &lt;p&gt;Let's get to work.&lt;/p&gt;
    &lt;p&gt;Nitesh&lt;/p&gt;
    &lt;p&gt;Founder and CEO&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://padlet.jobs"/><published>2025-10-24T12:01:08+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45693814</id><title>Rust Contagious Borrow Issue</title><updated>2025-10-24T16:44:04.089882+00:00</updated><content>&lt;doc fingerprint="ee25ecb3bce0ab19"&gt;
  &lt;main&gt;
    &lt;head rend="h1"&gt;How to Avoid Fighting Rust Borrow Checker&lt;/head&gt;
    &lt;p&gt;The 3 important facts in Rust:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Tree-shaped ownership. In Rust's ownership system, one object can own many children or no chlld, but must be owned by exactly one parent. Ownership relations form a tree. 1&lt;/item&gt;
      &lt;item&gt;Mutable borrow exclusiveness. If there exists one mutable borrow for an object, then no other borrow to that object can exist. Mutable borrow is exclusive.&lt;/item&gt;
      &lt;item&gt;Borrow is contagious. If you borrow a child, you indirectly borrow the parent (and parent's parent, and so on). Mutably borrowing one wheel of a car makes you borrow the whole car, preventing another wheel from being borrowed. It can be avoided by split borrow which only works within one scope.&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h2"&gt;Considering reference shape&lt;/head&gt;
    &lt;p&gt;Firstly consider the reference 2 shape of your in-memory data.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;If the reference is tree-shaped, then it's simple and natural in Rust.&lt;/item&gt;
      &lt;item&gt;If the reference shape has sharing, things become a little complicated. &lt;list rend="ul"&gt;&lt;item&gt;Sharing means there are two or more references to the same object.&lt;/item&gt;&lt;item&gt;If shared object is immutable: &lt;list rend="ul"&gt;&lt;item&gt;If the sharing is scoped (only temporarily shared), then you can use immutable borrow. You may need lifetime annotation.&lt;/item&gt;&lt;item&gt;If the sharing is not scoped (may share for a long time, not bounded within a scope), you need to use reference counting (&lt;code&gt;Rc&lt;/code&gt;in singlethreaded case,&lt;code&gt;Arc&lt;/code&gt;in possibly-multithreaded case)&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;&lt;item&gt;If shared object is mutable, then it's in borrow-check-unfriendly case. Solutions elaborated below.&lt;/item&gt;&lt;item&gt;Contagious borrow can cause unwanted sharing (elaborated below).&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;If the reference shape has cycle, then it's also in borrow-check-unfriendly case. Solutions elaborated below.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The most fighting with borrow checker happens in the borrow-check-unfriendly cases.&lt;/p&gt;
    &lt;head rend="h2"&gt;Summarize solutions&lt;/head&gt;
    &lt;p&gt;The solutions in borrow-checker-unfriendly cases (will elaborate below):&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Data-oriented design. Avoid unnecessary getter and setter.&lt;/item&gt;
      &lt;item&gt;Do split borrow in outer scope and pass borrowing of each component separately.&lt;/item&gt;
      &lt;item&gt;Use ID/handle to replace borrow. Use arena to hold data.&lt;/item&gt;
      &lt;item&gt;Defer mutation. Turn mutation as commands and execute later.&lt;/item&gt;
      &lt;item&gt;Avoid in-place mutation. Mutate-by-recreate. Use &lt;code&gt;Arc&lt;/code&gt;to share immutable data. Use persistent data structure.&lt;/item&gt;
      &lt;item&gt;For circular reference: &lt;list rend="ul"&gt;&lt;item&gt;For graph data structure, use ID/handle and arena.&lt;/item&gt;&lt;item&gt;For callback, use event bus or &lt;code&gt;Arc&amp;lt;QCell&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;(use&lt;code&gt;Weak&lt;/code&gt;to cut cycle)&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;Borrow as temporary as possible. For example, replace container for-loop &lt;code&gt;for x in &amp;amp;vec {}&lt;/code&gt;with raw index loop.&lt;/item&gt;
      &lt;item&gt;
        &lt;code&gt;Arc&amp;lt;QCell&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;
      &lt;/item&gt;
      &lt;item&gt;&lt;code&gt;Arc&amp;lt;RwLock&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;(only use when really necessary)&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;unsafe&lt;/code&gt;and raw pointer (only use when really necessary)&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h2"&gt;Contagious borrow issue&lt;/head&gt;
    &lt;p&gt;Contagious borrow issue is a very common and important source of frustrations in Rust, especially for beginners.&lt;/p&gt;
    &lt;p&gt;The previously mentioned two important facts:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Mutable borrow exclusiveness. If you mutably borrow one object, others cannot borrow it.&lt;/item&gt;
      &lt;item&gt;Borrow is contagious. If you borrow a child, you indirectly borrow the parent (and parent's parent, and so on), which contagiously borrow other childs of the same parent. Mutably borrowing one wheel of a car makes you borrow the whole car, including all 4 wheels, then the wheel that you don't use cannot be borrowed. This don't happen under split borrow.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;A simple example:&lt;/p&gt;
    &lt;code&gt;pub struct Parent {  &lt;/code&gt;
    &lt;p&gt;Compile error:&lt;/p&gt;
    &lt;code&gt;25 |     for child in parent.get_children() {&lt;/code&gt;
    &lt;p&gt;(That example is just for illustrating contagious borrow issue. The &lt;code&gt;total_score&lt;/code&gt; is analogous to a complex state that exists in real applications. Same for subsequent examples. Just summing integer don't necessarily need to use mutable field. Simple integer mutable state can be workarounded using &lt;code&gt;Cell&lt;/code&gt;.)&lt;/p&gt;
    &lt;p&gt;This code is totally memory-safe: the &lt;code&gt;.add_score()&lt;/code&gt; only touch the &lt;code&gt;total_score&lt;/code&gt; field, and &lt;code&gt;.get_children()&lt;/code&gt; only touch the &lt;code&gt;children&lt;/code&gt; field. They work on separate data, but borrow checker thinks they overlap, because of contagious borrow:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;In &lt;code&gt;fn get_children(&amp;amp;self) -&amp;gt; &amp;amp;Vec&amp;lt;Child&amp;gt; { &amp;amp;self.children }&lt;/code&gt;, although the method body just borrows&lt;code&gt;children&lt;/code&gt;field, the return value indirectly borrows the whole&lt;code&gt;self&lt;/code&gt;, not just one field.&lt;/item&gt;
      &lt;item&gt;In &lt;code&gt;fn add_score(&amp;amp;mut self, score: u32) { self.total_score += score; }&lt;/code&gt;, the function body only mutably borrowed&lt;code&gt;total_score&lt;/code&gt;field, but the argument&lt;code&gt;&amp;amp;mut self&lt;/code&gt;borrows the whole&lt;code&gt;Parent&lt;/code&gt;, not just one field.&lt;/item&gt;
      &lt;item&gt;Inside the loop, one immutable borrow to the whole &lt;code&gt;Parent&lt;/code&gt;and one mutable borrow to the whole&lt;code&gt;Parent&lt;/code&gt;overlaps in lifetime.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;You just want to borrow one field, but forced to borrow the whole object.&lt;/p&gt;
    &lt;p&gt;What if I just inline &lt;code&gt;get_children&lt;/code&gt; and &lt;code&gt;add_score&lt;/code&gt;? Then it compiles fine:&lt;/p&gt;
    &lt;code&gt;pub struct Parent {  &lt;/code&gt;
    &lt;p&gt;Why that compiles? Because it does a split borrow: the compiler sees borrowing of individual fields in one function (&lt;code&gt;main()&lt;/code&gt;), and don't do contagious borrow.&lt;/p&gt;
    &lt;p&gt;The deeper cause is that:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Borrow checker works locally: when seeing a function call, it only checks function signature, instead of checking code inside the function. (Its benefit is to make borrow checking faster and simpler. Doing whole-program analysis is hard and slow, and doesn't work with things like dynamic linking.)&lt;/item&gt;
      &lt;item&gt;Information is lost in function signature: the borrowing information becomes coarse-grained and is simplified in function signature. The type system does not allow expressing borrowing only one field, and can only express borrowing the whole object. There are propsed solutions: view type.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Summarize solutions (workarounds) of contagious borrow issue (elaborated below):&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Remove unnecessary getters and setters. &lt;list rend="ul"&gt;&lt;item&gt;Just simply make fields public. This makes split borrow possible. If you want encapsulation, it's recommended to use ID/handle to replace borrow of mutable data (elaborated below).&lt;/item&gt;&lt;item&gt;The getter that returns cloned/copied value is fine.&lt;/item&gt;&lt;item&gt;If data is immutable, getter is also fine.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;Defer mutation&lt;/item&gt;
      &lt;item&gt;Avoid in-place mutation&lt;/item&gt;
      &lt;item&gt;Do a split borrow on the outer scope. Or just get rid of struct, pass fields as separate arguments. (This is inconvenient.)&lt;/item&gt;
      &lt;item&gt;Manually manage index (or key) in container for-loop. Borrow as temporary as possible.&lt;/item&gt;
      &lt;item&gt;Just clone the data (can be shallow-clone).&lt;/item&gt;
      &lt;item&gt;Use interior mutability (cells and locks).&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h2"&gt;Defer mutation. Mutation-as-data&lt;/head&gt;
    &lt;p&gt;Another solution is to treat mutation as data. To mutate something, append a mutation command into command queue. Then execute the mutation commands at once. (Note that command should not indirectly borrow base data.)&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;In the process of creating new commands, it only do immutable borrow to base data, and only one mutable borrow to the command queue at a time.&lt;/item&gt;
      &lt;item&gt;When executing the commands, it only do one mutable borrow to base data, and one borrow to command queue at a time.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;What if I need the latest state before executing the commands in queue? Then inspect both the command queue and base data to get latest state (LSM tree does similar things). You can often avoid needing to getting latest state during processing, by separating it into multiple stages.&lt;/p&gt;
    &lt;p&gt;The previous code rewritten using deferred mutation:&lt;/p&gt;
    &lt;code&gt;pub struct Parent {  &lt;/code&gt;
    &lt;p&gt;Deferred mutation is not "just a workaround for borrow checker". Treating mutation as data also has other benefits:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;The mutation can be serialized, and sent via network or saved to disk.&lt;/item&gt;
      &lt;item&gt;The mutation can be inspected for debugging and logging.&lt;/item&gt;
      &lt;item&gt;You can post-process the command list, such as sorting, filtering.&lt;/item&gt;
      &lt;item&gt;Easier parallelism. The process of generating mutation command does not mutate the base data, so it can be parallelized. If data is sharded, the execution of mutation commands can be dispatched to shards executing in parallel.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Other applications of the idea of mutation-as-data:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Transactional databases often use write-ahead log (WAL) to help atomicity of transactions. Database writs all mutations into WAL. Then after some time the mutations in WAL will be merged to base data in disk.&lt;/item&gt;
      &lt;item&gt;Event sourcing. Derive the latest state from events and previous checkpoint. Distributes systems often use consensus protocol (like Raft) to replicate log (events, mutations). The mutable data is derived from logs and previous checkpoint.&lt;/item&gt;
      &lt;item&gt;The idea of turning operations into data is also adopted by io_uring and modern graphics APIs (Vulkan, Metal, WebGPU).&lt;/item&gt;
      &lt;item&gt;The idea of turning mutation into insertion is also adopted by ClickHouse. In ClickHouse, direct mutaiton is not performant. Mutate-by-insert is faster, but querying require aggregate both the old data and new mutations.&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h2"&gt;Avoid in-place mutation&lt;/head&gt;
    &lt;p&gt;The previous problem occurs partially due to mutable borrow exclusiveness. If all borrows are immutable, then contagious borrow is usually not a problem.&lt;/p&gt;
    &lt;p&gt;The common way of avoiding mutation is mutate-by-recreate: All data is immutable. When you want to mutate something, you create a new version of it. Just like in pure functional language (e.g. Haskell).&lt;/p&gt;
    &lt;p&gt;Unfortunately, mutate-by-recreate is also contagious: if you recreated a new version of a child, you need to also recreate a new version of parent that holds the new child, and parent's parent, and so on. There are abstractions like lens to make this kind of cascade-recreate more convenient.&lt;/p&gt;
    &lt;p&gt;Mutate-by-recreate can be useful for cases like:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Safely sharing data in multithreading (read-copy-update (RCU), copy-on-write (COW))&lt;/item&gt;
      &lt;item&gt;Take snapshot and rollback efficiently&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Persistent data structure: they share unchanged sub-structure (structural sharing) to make mutate-by-recreate faster. Some crates of persistent data structures: rpds, im, pvec.&lt;/p&gt;
    &lt;p&gt;Example of mutating hash map while looping on a clone of it, using rpds:&lt;/p&gt;
    &lt;code&gt;let mut map: HashTrieMap&amp;lt;i32, i32&amp;gt; = HashTrieMap::new();  &lt;/code&gt;
    &lt;head rend="h2"&gt;Split borrow&lt;/head&gt;
    &lt;p&gt;Split borrow of fields in struct: As previously mentioned, if you separately borrow two fields of a struct within one scope (e.g. a function), Rust will do a split borrow. This can solve contagious borrow issue. Getter and setter functions break split borrow, because borrowing information become coarse-grained in function signature.&lt;/p&gt;
    &lt;p&gt;Contagious borrow can also happen in containers. If you borrow one element of a container, then another element cannot be mutably borrowed. How to split borrow a container:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;For &lt;code&gt;Vec&lt;/code&gt;and slice, use&lt;code&gt;split_at_mut&lt;/code&gt;&lt;/item&gt;
      &lt;item&gt;For &lt;code&gt;HashMap&lt;/code&gt;, use&lt;code&gt;get_disjoint_mut&lt;/code&gt;&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h2"&gt;Avoid iterator. Manually manage index (key) in loop&lt;/head&gt;
    &lt;p&gt;For looping on container is very common. Rust provides concise container for-loop syntax &lt;code&gt;for x in &amp;amp;container {...}&lt;/code&gt;. However, it has an implicit iterator that keeps borrowing the whole container.&lt;/p&gt;
    &lt;p&gt;One solution is to manually manage index (key) in loop, without using iterator. For &lt;code&gt;Vec&lt;/code&gt; or slice, you can make index a mutable local variable, then use while loop to traverse the array.&lt;/p&gt;
    &lt;p&gt;The previous example rewritten using manual loop:&lt;/p&gt;
    &lt;code&gt;pub struct Parent {  &lt;/code&gt;
    &lt;p&gt;It calls &lt;code&gt;.get_children()&lt;/code&gt; many times. Each time, the result borrow is kept for only a short time. After copying the &lt;code&gt;score&lt;/code&gt; field of element, it stops borrowing the element, which then indirectly stops borrowing the parent.&lt;/p&gt;
    &lt;p&gt;Note that it requires stop borrowing the element before doing mutation. That example copies &lt;code&gt;score&lt;/code&gt; integer so it can stop borrowing the child. For other large data structures, you also need copying/cloning to stop borrowing element (reference counting and persistent data structure can reduce cost of cloning).&lt;/p&gt;
    &lt;p&gt;(Rust doesn't have C-style for loop &lt;code&gt;for (int i = 0; i &amp;lt; len; i++)&lt;/code&gt;.)&lt;/p&gt;
    &lt;p&gt;The similar thing can be done in &lt;code&gt;BTreeMap&lt;/code&gt;. We can get the minimum key, then iteratively get next key. This allows looping on &lt;code&gt;BTreeMap&lt;/code&gt; without keep borrowing it.&lt;/p&gt;
    &lt;p&gt;Example of mutating a &lt;code&gt;BTreeMap&lt;/code&gt; when looping on it.&lt;/p&gt;
    &lt;code&gt;let mut map: BTreeMap&amp;lt;i32, i32&amp;gt; = BTreeMap::new();&lt;/code&gt;
    &lt;p&gt;Note that it requires copying/cloning the key, and stop borrowing element before mutating.&lt;/p&gt;
    &lt;p&gt;That way doesn't work for &lt;code&gt;HashMap&lt;/code&gt;. &lt;code&gt;HashMap&lt;/code&gt; doesn't preserver order and doesn't allow getting the next key. But that way can work on indexmap's &lt;code&gt;IndexMap&lt;/code&gt;, which allows getting key by integer index (it internally uses array, so removing or adding in the middle is not fast).&lt;/p&gt;
    &lt;head rend="h2"&gt;Just (shallow) clone the data&lt;/head&gt;
    &lt;p&gt;Cloning data can avoid keeping borrowing the data. For immutable data, wrapping in &lt;code&gt;Rc&lt;/code&gt; (&lt;code&gt;Arc&lt;/code&gt;) then clone can work:&lt;/p&gt;
    &lt;p&gt;The previous example rewritten by wrapping container in &lt;code&gt;Rc&lt;/code&gt; then for-loop:&lt;/p&gt;
    &lt;code&gt;pub struct Parent {  &lt;/code&gt;
    &lt;p&gt;For mutable data, to make cloning and mutation more efficient, the previously mentioned persistent data structure can be used.&lt;/p&gt;
    &lt;p&gt;If the data is small, deep cloning is usually fine. If it's not in hot code, deep cloning is also usually fine.&lt;/p&gt;
    &lt;head rend="h2"&gt;About circular reference&lt;/head&gt;
    &lt;head rend="h3"&gt;Circular reference in mathematics&lt;/head&gt;
    &lt;p&gt;Some may argue that "Circular reference is a bad thing. Look how much trouble do circular references create in mathematics":&lt;/p&gt;
    &lt;head&gt;Details&lt;/head&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;
        &lt;p&gt;Circular proof: if A then B, if B then A. Circular proof is wrong. It can prove neither A nor B.&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;The set that indirectly includes itself cause Russel's paradox: Let R be the set of all sets that are not members of themselves. R contains R deduces R should not contain R, and vice versa. Set theory carefully avoids cirular reference.&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;&lt;p&gt;Halting problem is proved impossible to solve, by using circular reference:&lt;/p&gt;&lt;p&gt;Assume there exists a function&lt;/p&gt;&lt;code&gt;halts(program, input)&lt;/code&gt;, which takes in a&lt;code&gt;program&lt;/code&gt;and&lt;code&gt;input&lt;/code&gt;data, and outputs a boolean telling whether&lt;code&gt;program(input)&lt;/code&gt;will eventually halt.&lt;p&gt;Then construct a paradox program&lt;/p&gt;&lt;code&gt;paradox&lt;/code&gt;:&lt;/item&gt;
    &lt;/list&gt;
    &lt;code&gt;fn paradox(program: Program) {&lt;/code&gt;
    &lt;p&gt;Then &lt;code&gt;halts(paradox, paradox)&lt;/code&gt; will cause a paradox. If it returns true, then &lt;code&gt;paradox(paradox)&lt;/code&gt; halts, but in &lt;code&gt;paradox&lt;/code&gt;'s definition it should deadloop.&lt;/p&gt;
    &lt;p&gt;Rice's theorem is an extension to Halting problem: All non-trivial semantic properties of programs are undecidable (includes whether it eventually halts).&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Gödel's incomplete theorem. &lt;list rend="ul"&gt;&lt;item&gt;Firstly encode symbols, statements and proofs into data 3. The statements that contain free variables (e.g. x is a free variable in "x is an even number") can also be encoded (it can represent "functions" and even "higher-order functions").&lt;/item&gt;&lt;item&gt;&lt;code&gt;is_proof(theory, proof)&lt;/code&gt;allows determining whether a proof successfully proves a theory.&lt;/item&gt;&lt;item&gt;Then &lt;code&gt;provable(theory)&lt;/code&gt;is defined as whether there exists a&lt;code&gt;proof&lt;/code&gt;that satisfies&lt;code&gt;is_proof(theory, proof)&lt;/code&gt;.&lt;/item&gt;&lt;item&gt;Unprovable is inverse of provable: &lt;code&gt;unprovable(theory) = !provable(theory)&lt;/code&gt;&lt;/item&gt;&lt;item&gt;Let &lt;code&gt;H(x) = unprovable(x(x))&lt;/code&gt;. Then let&lt;code&gt;G = H(H) = unprovable(H(H)) = unprovable(G)&lt;/code&gt;4, which creates a self-referencial statement:&lt;code&gt;G&lt;/code&gt;means&lt;code&gt;G&lt;/code&gt;is not provable. If&lt;code&gt;G&lt;/code&gt;is true, then&lt;code&gt;G&lt;/code&gt;is not provable, then&lt;code&gt;G&lt;/code&gt;is false, which is a paradox.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;There is something in common between Halting problem, Russel's paradox and Gödel's incomplete theorem: they all self-reference and "negate" itself, causing paradox.&lt;/p&gt;
    &lt;head rend="h3"&gt;Circular reference in programming&lt;/head&gt;
    &lt;p&gt;Circular reference being bad in mathematics does NOT mean they are also bad in programming. The circular reference in math theories are different to circular reference in data. There are many valid cases of circular references in programming (e.g. there are doublely-linked list running in Linux kernel that works fine).&lt;/p&gt;
    &lt;p&gt;But circular reference do add risks to memory management:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;In C/C++, if two objects point to each other, when one object destructs, the another object's reference should be cleared, or there will be risk of use-after-free.&lt;/item&gt;
      &lt;item&gt;When using reference counting, loop should be cut by weak reference, or it will memory leak.&lt;/item&gt;
      &lt;item&gt;In GC languages, circular reference has memory leak risk. If all children references parents, and parents references children, then referencing any child will keep the whole structure alive.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Here are some common use cases of circular reference:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Case 1: The parent references a child. The child references its parent, just for convenience. (Referencing to parent is not necessary, parent can be passed by argument)&lt;/item&gt;
      &lt;item&gt;Case 2: The parent registers a callback to child. When something happened on child, the callback is called, and parent do something. It that case, parent references child, child references callback, callback references parent.&lt;/item&gt;
      &lt;item&gt;Case 3: In a tree structure, the child references parent allows getting the path from one node to root node. Without it, you cannot get the path from just one node reference, and need to store variable-length path information.&lt;/item&gt;
      &lt;item&gt;Case 4: The data is inherently a graph structure that can contain cycles.&lt;/item&gt;
      &lt;item&gt;Case 5: The data requires self-reference.&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h3"&gt;Avoid "just-for-convenience" circular reference in Rust&lt;/head&gt;
    &lt;p&gt;In the case 1 above: The child references parent, just for convenience. In OOP code. If you just have a reference to a child object, and you want to use some data in parent, child referencing parent would be convenient. Without it, the parent also need to be passed as argument.&lt;/p&gt;
    &lt;p&gt;That convenience in OOP languages will lead to troubles in Rust. It's recommended to pass extra arguments instead of having circular reference.&lt;/p&gt;
    &lt;p&gt;Note that due to previously mentioned contagious borrow issue, you cannot mutably borrow child and parent at the same time (except using interior mutability). The workaround is to 1. do a split borrow on parent and pass the individual components of parent (pass more arguments and be more verbose than in other languages) 2. use interior mutability (e.g. &lt;code&gt;RefCell&lt;/code&gt;, &lt;code&gt;Mutex&lt;/code&gt;, &lt;code&gt;QCell&lt;/code&gt;).&lt;/p&gt;
    &lt;head rend="h3"&gt;The callback circular reference&lt;/head&gt;
    &lt;p&gt;Observer pattern is commonly used in GUI and other dynamic reactive systems. If parent want to be notified when some event happens on child, the parent register callback to child, and child calls callback when event happens.&lt;/p&gt;
    &lt;p&gt;However, the callback function object often have to reference the parent (because it need to use parent's data). Then it creates circular reference: parent references child, child references callback, callback references parent, as mentioned previously in case 2.&lt;/p&gt;
    &lt;p&gt;Solutions:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;p&gt;Use reference counting and interior mutability. The classical ones:&lt;/p&gt;&lt;code&gt;Rc&amp;lt;RefCell&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;(singlethreaded),&lt;code&gt;Arc&amp;lt;RwLock&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;(multithreaded). I also recommend using&lt;code&gt;QCell&lt;/code&gt;(elaborated below):&lt;code&gt;Rc&amp;lt;QCell&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;,&lt;code&gt;Arc&amp;lt;QCell&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;.&lt;p&gt;The back-reference (callback to parent, child to parent) should use&lt;/p&gt;&lt;code&gt;Weak&lt;/code&gt;to avoid memory leak.&lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Use event bus to replace callbacks. Similar to the previous deferred mutation, we turn event into data. Each component listen to specific "event channel" or "event topic". When something happens, put the event into event bus, then event bus notifies components.&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Use ID/handle to replace borrow (elaborated later).&lt;/p&gt;
      &lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h3"&gt;The circular reference that's inherent in data structure&lt;/head&gt;
    &lt;p&gt;In the previously mentioned case 3 and case 4, circular reference is needed in data structure.&lt;/p&gt;
    &lt;p&gt;Solutions:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Use reference counting and interior mutability (previously mentioned). This is recommended when there are many different types of components and you want to add new types easily (like in GUI).&lt;/item&gt;
      &lt;item&gt;Use ID/handle to replace borrow (elaborated later). This is recommended when you want more compact memory layout, and you rarely need to add new types into data (suitable for data-intensive cases, can obtain better performance due to cache-friendliness).&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h3"&gt;Self-reference&lt;/head&gt;
    &lt;p&gt;Self-reference means a struct contains an interior pointer to another part of data that it owns.&lt;/p&gt;
    &lt;p&gt;Zero-cost self reference requires &lt;code&gt;Pin&lt;/code&gt; and &lt;code&gt;unsafe&lt;/code&gt;. Normal Rust mutable borrow allow moving the value out (by &lt;code&gt;mem::replace&lt;/code&gt;, or &lt;code&gt;mem::swap&lt;/code&gt;, etc.). &lt;code&gt;Pin&lt;/code&gt; disallows that, as self-reference pointer can be invalidated by moving. They are complex and hard to use. Workarounds includes separating child and use reference counting so it's no longer self-reference.&lt;/p&gt;
    &lt;head rend="h2"&gt;Use handle/ID to replace borrow&lt;/head&gt;
    &lt;p&gt;Data-oriented design:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Try to pack data into contagious array, (instead of objects laid out sparsely managed by allocator).&lt;/item&gt;
      &lt;item&gt;Use handle (e.g. array index) or ID to replace reference.&lt;/item&gt;
      &lt;item&gt;Decouple object ID with memory address. An ID can be saved to disk and sent via network, but a pointer cannot (the same address cannot be used in another process or after process restart, because there may be other data in the same address).&lt;/item&gt;
      &lt;item&gt;The different fields of the same object doesn't necessarily need to be together in memory. The one field of many objects can be put together (parallel array).&lt;/item&gt;
      &lt;item&gt;Manage memory based on arenas.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Some may think that using handle/ID is "just a nasty workaround caused by borow checker". However, in GC languages, using ID to refer to object is also common, as reference cannot be saved to database or sent via network. 5&lt;/p&gt;
    &lt;p&gt;One kind of arena is slotmap:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Slotmap is basically an array of elements, but each element has a version integer.&lt;/item&gt;
      &lt;item&gt;Each handle (key) has an index and a version. It's &lt;code&gt;Copy&lt;/code&gt;-able data that's not restricted by borrow checker.&lt;/item&gt;
      &lt;item&gt;When accessing the slotmap, it firstly does a bound check, then checks version.&lt;/item&gt;
      &lt;item&gt;After removing element, the version increments. The previous handle cannot get the new element at the same index, because of version mismatch.&lt;/item&gt;
      &lt;item&gt;Although memory safe, it still has the equivalent of "use-after-free": using a handle of an already-removed object cannot get element from the slotmap 6. Each get element operation may fail.&lt;/item&gt;
      &lt;item&gt;Note that slotmap is not efficient when there are many unused empty space between elements. Slotmap offers two other variants for sparce case.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Other map structure, like &lt;code&gt;HashMap&lt;/code&gt; or &lt;code&gt;TreeMap&lt;/code&gt; can also be arenas.&lt;/p&gt;
    &lt;p&gt;If no element can be removed from arena, then a &lt;code&gt;Vec&lt;/code&gt; can also be an areana.&lt;/p&gt;
    &lt;p&gt;The important things about arena:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;The borrow checker no longer ensure the ID/handle points to a living object. Each data access to arena may fail. There is equivalent of "use after free".&lt;/item&gt;
      &lt;item&gt;Arenas still suffer from contagious borrow issue. We need to borrow things as temporary as possible. But when arena contains a container and we want to for-loop on it, to avoid cost of copying the container, borrowing for long time is still necessary. If we want to change the arena when for looping in that container, contagious borrow issue appears. The previously mentioned deferred mutation can help.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Some may think "using arena cannot protect you from equivalent of 'use after free' so it doesn't solve problem". But arena can greatly improve determinism of bugs, making debugging much easier. A randomly-occuring memory safety Heisenbug may no longer trigger when you enable sanitizer, as sanitizer can change memory layout.&lt;/p&gt;
    &lt;head rend="h3"&gt;Entity component system&lt;/head&gt;
    &lt;p&gt;Entity component system (ECS) is a way of organizing data that's different to OOP. In OOP, an object's fields are laid together in memory. But in ECS, each object is separated into components. The same kind of components for different entities are managed together (often laid together in memory). It can improve cache-friendliness. (Note that performance is affected by many factors and depends on exact case.)&lt;/p&gt;
    &lt;p&gt;ECS also favors composition over inheritance. Inheritance tend to bind code with specific types that cannot easily compose.&lt;/p&gt;
    &lt;p&gt;(For example, in an OOP game, &lt;code&gt;Player&lt;/code&gt; extends &lt;code&gt;Entity&lt;/code&gt;, &lt;code&gt;Enemy&lt;/code&gt; extends &lt;code&gt;Entity&lt;/code&gt;. There is a special enemy &lt;code&gt;Ghost&lt;/code&gt; that ignores collision and also extends &lt;code&gt;Enemy&lt;/code&gt;. But one day if you want to add a new player skill that temporarily ignores collision like &lt;code&gt;Ghost&lt;/code&gt;, you cannot make &lt;code&gt;Player&lt;/code&gt; extend &lt;code&gt;Ghost&lt;/code&gt; and have to duplicate code. In ECS that can be solved by just combining special collision component.)&lt;/p&gt;
    &lt;head rend="h3"&gt;Generalized reference and two reference semantics&lt;/head&gt;
    &lt;p&gt;The concept of generalized reference:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;The reference in GC languages is generalized reference.&lt;/item&gt;
      &lt;item&gt;Pointer is generalized reference.&lt;/item&gt;
      &lt;item&gt;Borrowing in Rust is generalized reference.&lt;/item&gt;
      &lt;item&gt;Ownership in Rust is also considered as generalized reference.&lt;/item&gt;
      &lt;item&gt;Smart pointer (&lt;code&gt;Rc&lt;/code&gt;,&lt;code&gt;Arc&lt;/code&gt;,&lt;code&gt;Weak&lt;/code&gt;,&lt;code&gt;Box&lt;/code&gt;in Rust,&lt;code&gt;shared_ptr&lt;/code&gt;,&lt;code&gt;weak_ptr&lt;/code&gt;,&lt;code&gt;unique_ptr&lt;/code&gt;in C++, etc.) are generalized reference.&lt;/item&gt;
      &lt;item&gt;IDs are generalized reference. (It includes all kinds of IDs, including handles, UUID, string id (URL, file path, username, etc.), integer id, primary key, and all kinds of identification information).&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The generalized reference is separated into two kinds: strong and weak:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;p&gt;Strong generalized reference: The system ensures it always points to a living object.&lt;/p&gt;&lt;p&gt;It contains: normal references in GC languages (when not null), Rust borrow and ownership, strong reference counting (&lt;/p&gt;&lt;code&gt;Rc&lt;/code&gt;,&lt;code&gt;Arc&lt;/code&gt;,&lt;code&gt;shared_ptr&lt;/code&gt;when not null), and ID in database with foreign key constraint.&lt;/item&gt;
      &lt;item&gt;&lt;p&gt;Weak generalized reference: The system does NOT ensure it points to a living object.&lt;/p&gt;&lt;p&gt;It contains: ID (no foreign key constraint), handles, weak reference in GC languages, weak reference counting (&lt;/p&gt;&lt;code&gt;Weak&lt;/code&gt;,&lt;code&gt;weak_ptr&lt;/code&gt;).&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The major differences:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;For weak generalized references, every data access may fail, and requires error handling. (just panic is also a kind of error handling)&lt;/item&gt;
      &lt;item&gt;For strong generalized reference, the lifetime of referenced object is tightly coupled with the existence of reference: &lt;list rend="ul"&gt;&lt;item&gt;In Rust, the coupling comes from borrow checker. The borrow is limited by lifetime and other constraints.&lt;/item&gt;&lt;item&gt;In GC langauges, the coupling comes from GC. The existence of a strong reference keeps the object alive. Note that in GC languages there are live-but-unusable objects (e.g. Java &lt;code&gt;FileInputStream&lt;/code&gt;is unusable after closing).&lt;/item&gt;&lt;item&gt;In reference counting, the coupling of course comes from runtime reference counting.&lt;/item&gt;&lt;item&gt;The foreign key constraint of ID is enforced by database.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;For weak generalized reference, the lifetime of object is decoupled from referces to it.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;If you want to design an abstraction that decouples object lifetime and how these objects are referenced, it's recommended to either:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Use weak generalized reference, such as ID and handle. The object can be freed without having to consider how its IDs are held.&lt;/item&gt;
      &lt;item&gt;Use strong generalized reference, but add a new usability state that's decoupled with object lifetime. This is common in GC languages. Examples: &lt;list rend="ul"&gt;&lt;item&gt;In JS, if you send an &lt;code&gt;ArrayBuffer&lt;/code&gt;to another web worker, the&lt;code&gt;ArrayBuffer&lt;/code&gt;object can still be referenced and kept alive, but the binary content is no longer accessible from that&lt;code&gt;ArrayBuffer&lt;/code&gt;object.&lt;/item&gt;&lt;item&gt;In Java, the IO-related objects (e.g. &lt;code&gt;FileInputStream&lt;/code&gt;) can no longer be used after closing, even these objects are still referenced and still alive.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;In JS, if you send an &lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h2"&gt;Mutable borrow exclusiveness&lt;/head&gt;
    &lt;p&gt;As previously mentioned, Rust has mutable borrow exclusiveness:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;A mutable borrow to one object cannot co-exist with any other borrow to the same object. Two mutable borrows cannot co-exist. One mutable and one immutable also cannot co-exist.&lt;/item&gt;
      &lt;item&gt;Multiple immutable borrows for one object can co-exist.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;That is also called "mutation xor sharing", as mutation and sharing cannot co-exist.&lt;/p&gt;
    &lt;p&gt;In multi-threading case, this is natural: multiple threads read the same immutable data is fine. As long as one thread mutates the data, other thread cannot safely read or write it without other synchronization (atomics, locks, etc.).&lt;/p&gt;
    &lt;p&gt;But in single-threaded case, this restriction is not natural at all. No mainstream language (other than Rust) has this restriction.&lt;/p&gt;
    &lt;quote&gt;&lt;p&gt;Mutation xor sharing is, in some sense, neither necessary nor sufficient. It’s not necessary because there are many programs (like every program written in Java) that share data like crazy and yet still work fine. It’s also not sufficient in that there are many problems that demand some amount of sharing – which is why Rust has “backdoors” like&lt;/p&gt;&lt;code&gt;Arc&amp;lt;Mutex&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;,&lt;code&gt;AtomicU32&lt;/code&gt;, and—the ultimate backdoor of them all—&lt;code&gt;unsafe&lt;/code&gt;.&lt;/quote&gt;
    &lt;p&gt;Mutable borrow exclusiveness is still important for safety of interior pointer, even in single thread:&lt;/p&gt;
    &lt;head rend="h3"&gt;Interior pointer&lt;/head&gt;
    &lt;p&gt;Rust has interior pointer. Interior pointer are the pointers that point into some data inside another object. A mutation can invalidate the memory layout that interior pointer points to.&lt;/p&gt;
    &lt;p&gt;For example, you can take pointer of an element in &lt;code&gt;Vec&lt;/code&gt;. If the &lt;code&gt;Vec&lt;/code&gt; grows, it may allocate new memory and copy existing data to new memory, thus the interior pointer to it can become invalid (break the memory layout that interior pointer points to). Mutable borrow exclusiveness can prevent this issue from happening:&lt;/p&gt;
    &lt;code&gt;fn main() {  &lt;/code&gt;
    &lt;p&gt;Compile error:&lt;/p&gt;
    &lt;code&gt;3 |     let interior_pointer: &amp;amp;u32 = &amp;amp;vec[0];&lt;/code&gt;
    &lt;p&gt;Another example is about &lt;code&gt;enum&lt;/code&gt;: interior pointer pointing inside &lt;code&gt;enum&lt;/code&gt; can also be invalidated, because different enum variants has different memory layout. In one layout the first 8 bytes is integer, in another layout the first 8 bytes may be a pointer. Treating an arbitrary integer as a pointer is definitely not memory-safe.&lt;/p&gt;
    &lt;code&gt;enum DifferentMemoryLayout {  &lt;/code&gt;
    &lt;p&gt;Compile error:&lt;/p&gt;
    &lt;code&gt;9  |         DifferentMemoryLayout::A(ref a, ref b) =&amp;gt; {a}&lt;/code&gt;
    &lt;p&gt;Note that sometimes mutating can keep validity of interior pointer. For example, changing an element in &lt;code&gt;Vec&amp;lt;u32&amp;gt;&lt;/code&gt; doesn't invalidate interior pointer to elements, because there is no memory layout change. But Rust by default prevents all mutation when interior pointer exists (unless using interior mutability).&lt;/p&gt;
    &lt;head rend="h3"&gt;Interior pointer in other languages&lt;/head&gt;
    &lt;p&gt;Golang also supports interior pointer, but doesn't have such restriction. For example, interior pointer into slice:&lt;/p&gt;
    &lt;code&gt;package main&lt;/code&gt;
    &lt;p&gt;Output&lt;/p&gt;
    &lt;code&gt;1&lt;/code&gt;
    &lt;p&gt;Because after re-allocating the slice, the old slice still exists in memory (not immediately freed). If there is an interior pointer into the old slice, the old slice won't be freed by GC. The interior pointer will always be memory-safe (but may point to stale data).&lt;/p&gt;
    &lt;p&gt;Golang also doesn't have sum type, so there is no equivalent to enum memory layout change in the previous Rust example.&lt;/p&gt;
    &lt;p&gt;Also, Golang's doesn't allow taking interior pointer to map entry value, but Rust allows. Rust's interior pointer is more powerful than Golang's.&lt;/p&gt;
    &lt;p&gt;In Java, there is no interior pointer. So no memory safety issue caused by interior pointer.&lt;/p&gt;
    &lt;p&gt;But in Java there is one thing logically similar to interior pointer: &lt;code&gt;Iterator&lt;/code&gt;. Mutating a container can cause iterator invalidation:&lt;/p&gt;
    &lt;code&gt;public class Main {  &lt;/code&gt;
    &lt;p&gt;That will get &lt;code&gt;java.util.ConcurrentModificationException&lt;/code&gt;. Java's &lt;code&gt;ArrayList&lt;/code&gt; has an internal version counter that's incremented every time it changes. The iterator code checks concurrent modification using version counter.&lt;/p&gt;
    &lt;p&gt;Even without the version check, it will still be memory-safe because array access is range-checked.&lt;/p&gt;
    &lt;p&gt;Note that the container for loop in java internally use iterator (except for raw array). Inserting or removing to the container while for looping can also cause iterator invalidation.&lt;/p&gt;
    &lt;p&gt;Note that iteration invalidation is logic error, no matter whether it's memory-safe or not.&lt;/p&gt;
    &lt;p&gt;In Java, you can remove element via the iterator, then the iterator will update together with container, and no longer invalidate. Or use &lt;code&gt;removeIf&lt;/code&gt; that avoids managing iterator.&lt;/p&gt;
    &lt;p&gt;Mutable borrow exclusiveness is still important in single-threaded case, because of interior pointer. But if we don't use any interior pointer, then mutable borrow exclusiveness is not necessary for memory safety in single-thread case.&lt;/p&gt;
    &lt;p&gt;That's why mainstream languages has no mutable borrow exclusiveness, and still works fine in single-threaded case. Java, JS and Python has no interior pointer. Golang and C# have interior pointer, they have GC and restrict interior pointer, so memory safe is still kept without mutable borrow exclusiveness.&lt;/p&gt;
    &lt;head rend="h3"&gt;Benefits of mutable borrow exclusiveness&lt;/head&gt;
    &lt;p&gt;Rust's mutable borrow exclusiveness creates a lot of troubles in single-threaded cases. But it also has benefits (even in signle-threaded cases):&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Make the borrow more universal. In Rust, map key and value can be borrowed. But in Golang you cannot take interior pointer to map key or value. This makes abstractions that work with borrows more general.&lt;/item&gt;
      &lt;item&gt;Mutable borrow is exclusive, so Rust can emit &lt;code&gt;noalias&lt;/code&gt;attribute to LLVM.&lt;code&gt;noalias&lt;/code&gt;means the pointed data cannot be accessed by other code, which means:&lt;list rend="ul"&gt;&lt;item&gt;It allows aggressively merging reads. Before next write to it, it can be temporarily treated as constant.&lt;/item&gt;&lt;item&gt;It allows aggressively merging writes. If there are two memory writes to it, compiler can remove the first write, only keep the last write.&lt;/item&gt;&lt;item&gt;It allows removing reads after write, using the previous write as read result.&lt;/item&gt;&lt;item&gt;It allows aggressively reordering reads/writes to it between other computation and other memory accesses.&lt;/item&gt;&lt;item&gt;The above give compiler a lot of freedom of transforming code, which enables many other optimizations.&lt;/item&gt;&lt;item&gt;Without &lt;code&gt;noalias&lt;/code&gt;, the optimizer must consider all possible reads/writes to the same value to do above transformation. In many cases, compiler don't have enough information, so much fewer optimizations can be done.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h3"&gt;Interior mutability summary&lt;/head&gt;
    &lt;p&gt;Mutable borrow exclusiveness is overly restrictive. It is not necessary for memory safety in single-threaded code when not using interior pointer. There is interior mutability that allows getting rid of that constraint.&lt;/p&gt;
    &lt;p&gt;Interior mutability allows you to mutate something from an immutable reference to it. (Because of that, immutable borrow doesn't necessarily mean the pointed data is actually immutable. This can cause some confusion.)&lt;/p&gt;
    &lt;p&gt;Ways of interior mutability:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt;. It's suitable for simple copy-able types like integer. In the previous contagious borrow example, if the&lt;code&gt;total_score&lt;/code&gt;is replaced with&lt;code&gt;Cell&amp;lt;u32&amp;gt;&lt;/code&gt;then mutating it doesn't need mutable borrow of parent thus avoid the issue.&lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt;only supports replacing the whole&lt;code&gt;T&lt;/code&gt;at once, and doesn't support getting a mutable borrow.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;, suitable for data structure that does incremental mutation, in single-threaded cases. It has internal counters tracking how many immutable borrow and mutable borrow currently exist. If it detects violation of mutable borrow exclusiveness,&lt;code&gt;.borrow()&lt;/code&gt;or&lt;code&gt;.borrow_mut()&lt;/code&gt;will panic.It can cause crash if there is nested borrow that involves mutation.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt;&lt;code&gt;RwLock&amp;lt;T&amp;gt;&lt;/code&gt;, for locking in multi-threaded case. Its functionality is similar to&lt;code&gt;RefCell&lt;/code&gt;. Note that unnecessary locking can cost performance, and has risk of deadlock. It's not recommended to overuse&lt;code&gt;Arc&amp;lt;Mutex&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;just because it can satisfy the borrow checker.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;QCell&amp;lt;T&amp;gt;&lt;/code&gt;. Elaborated below.&lt;/item&gt;
      &lt;item&gt;Atomic types such as &lt;code&gt;AtomicU32&lt;/code&gt;&lt;/item&gt;
      &lt;item&gt;
        &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt;
      &lt;/item&gt;
      &lt;item&gt;Lazily-initialized &lt;code&gt;OnceCell&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/item&gt;
      &lt;item&gt;......&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;They are usually used inside reference counting (&lt;code&gt;Arc&amp;lt;...&amp;gt;&lt;/code&gt;, &lt;code&gt;Rc&amp;lt;...&amp;gt;&lt;/code&gt;).&lt;/p&gt;
    &lt;head rend="h3"&gt;&lt;code&gt;RefCell&lt;/code&gt; is not panacea&lt;/head&gt;
    &lt;p&gt;In the previous contagious borrow case, wrapping parent in &lt;code&gt;RefCell&amp;lt;&amp;gt;&lt;/code&gt; can make the code compile. However it doesn't fix the issue. It just turns compile error into runtime panic:&lt;/p&gt;
    &lt;code&gt;use std::cell::RefCell;  &lt;/code&gt;
    &lt;p&gt;It will panic with &lt;code&gt;RefCell already borrowed&lt;/code&gt; error.&lt;/p&gt;
    &lt;p&gt;&lt;code&gt;RefCell&lt;/code&gt; still follows mutable borrow exclusiveness rule, just checked at runtime, not compile time. Borrowing one fields inside &lt;code&gt;RefCell&lt;/code&gt; still borrows the whole &lt;code&gt;RefCell&lt;/code&gt;.&lt;/p&gt;
    &lt;p&gt;Wrapping parent in &lt;code&gt;RefCell&lt;/code&gt; cannot fix contagious borrow, but putting individual children into &lt;code&gt;RefCell&lt;/code&gt; can work, as it makes borrow more fine-grained.&lt;/p&gt;
    &lt;p&gt;See also: Dynamic borrow checking causes unexpected crashes after refactorings&lt;/p&gt;
    &lt;p&gt;Rust assumes that, if you have a mutable borrow &lt;code&gt;&amp;amp;mut T&lt;/code&gt;, you can use it at any time. But holding the reference is different to using reference. There are use cases that I have two mutable references to the same object, but I only use one at a time. This is the use case that &lt;code&gt;RefCell&lt;/code&gt; solves.&lt;/p&gt;
    &lt;p&gt;Another problem: The borrow taken from &lt;code&gt;RefCell&lt;/code&gt; cannot be directly returned.&lt;/p&gt;
    &lt;code&gt;pub struct Parent {  &lt;/code&gt;
    &lt;p&gt;Compile error:&lt;/p&gt;
    &lt;code&gt;error[E0308]: mismatched types&lt;/code&gt;
    &lt;p&gt;Because the borrow got from &lt;code&gt;RefCell&lt;/code&gt; is not normal borrow, it's actually &lt;code&gt;Ref&lt;/code&gt;. &lt;code&gt;Ref&lt;/code&gt; implements &lt;code&gt;Deref&lt;/code&gt; so it can be used similar to a normal borrow.&lt;/p&gt;
    &lt;p&gt;The "help: consider borrowing here" suggestion won't solve the compiler error. Don't blindly follow compiler's suggestions.&lt;/p&gt;
    &lt;p&gt;One solution is to return &lt;code&gt;&amp;amp;RefCell&amp;lt;HashMap&amp;lt;String, Entry&amp;gt;&amp;gt;&lt;/code&gt;, instead of returning &lt;code&gt;&amp;amp;HashMap&amp;lt;String, Entry&amp;gt;&lt;/code&gt;.&lt;/p&gt;
    &lt;p&gt;Returning &lt;code&gt;Ref&amp;lt;HashMap&amp;lt;String, Entry&amp;gt;&amp;gt;&lt;/code&gt; or returning &lt;code&gt;impl Deref&amp;lt;Target=HashMap&amp;lt;String, Entry&amp;gt;&amp;gt;&lt;/code&gt;) can also work, but they are not recommended.&lt;/p&gt;
    &lt;head rend="h3"&gt;&lt;code&gt;Rc&amp;lt;RefCell&amp;lt;...&amp;gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;Arc&amp;lt;Mutex&amp;lt;...&amp;gt;&amp;gt;&lt;/code&gt; are not panacea&lt;/head&gt;
    &lt;p&gt;&lt;code&gt;Rc&amp;lt;RefCell&amp;lt;...&amp;gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;Arc&amp;lt;Mutex&amp;lt;...&amp;gt;&amp;gt;&lt;/code&gt; allows freely copying reference and freely mutating things, just like in other languages. Finally "get rid of shackle of borrow checker". However, there are traps:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Contagious borrowing. As previously mentioned, &lt;code&gt;RefCell&lt;/code&gt;wrapping parent doesn't solve contagious borrowing.&lt;code&gt;Mutex&lt;/code&gt;also won't. Violating mutable borrow exclusiveness in the same thread is panic (or error) in&lt;code&gt;RefCell&lt;/code&gt;and deadlock in&lt;code&gt;Mutex&lt;/code&gt;. Rust lock is not re-entrant, explained below.&lt;/item&gt;
      &lt;item&gt;Need to cut cycle using &lt;code&gt;Weak&lt;/code&gt;, unless it will memory leak.&lt;/item&gt;
      &lt;item&gt;Performance. &lt;code&gt;Rc&lt;/code&gt;and&lt;code&gt;RefCell&lt;/code&gt;has relatively small performance cost. But for&lt;code&gt;Arc&amp;lt;Mutex&amp;lt;...&amp;gt;&amp;gt;&lt;/code&gt;, unnecessary locking can hurt performance.&lt;code&gt;Arc&lt;/code&gt;also can have performance issue, explained below. It's still ok to use them when not in performance bottleneck.&lt;/item&gt;
      &lt;item&gt;Their syntax ergonomic is not good. The code will have a lot of "noise" like &lt;code&gt;.borrow().borrow_mut()&lt;/code&gt;.&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h3"&gt;
      &lt;code&gt;QCell&lt;/code&gt;
    &lt;/head&gt;
    &lt;p&gt;&lt;code&gt;QCell&amp;lt;T&amp;gt;&lt;/code&gt; has an internal ID. &lt;code&gt;QCellOwner&lt;/code&gt; is also an ID. You can only use &lt;code&gt;QCell&lt;/code&gt; via an &lt;code&gt;QCellOwner&lt;/code&gt; that has matched ID.&lt;/p&gt;
    &lt;p&gt;The borrowing to &lt;code&gt;QCellOwner&lt;/code&gt; "centralizes" the borrowing of many &lt;code&gt;QCell&lt;/code&gt;s associated with it, ensuring mutable borrow exclusiveness. Using it require passing borrow of &lt;code&gt;QCellOwner&lt;/code&gt; in argument everywhere it's used.&lt;/p&gt;
    &lt;p&gt;&lt;code&gt;QCell&lt;/code&gt; will fail to borrow if the owner ID doesn't match. Different to &lt;code&gt;RefCell&lt;/code&gt;, if owner ID matches, it won't panic just because nested borrow.&lt;/p&gt;
    &lt;p&gt;Its runtime cost is low. When borrowing, it just checks whether cell's id matches owner's id. It has memory cost of owner ID per cell.&lt;/p&gt;
    &lt;p&gt;One advantage of &lt;code&gt;QCell&lt;/code&gt; is that the duplicated borrow will be compile-time error instead of runtime panic, which helps catch error earlier. If I change the previous &lt;code&gt;RefCell&lt;/code&gt; panic example into &lt;code&gt;QCell&lt;/code&gt;:&lt;/p&gt;
    &lt;code&gt;pub struct Parent { total_score: u32, children: Vec&amp;lt;Child&amp;gt; }&lt;/code&gt;
    &lt;p&gt;Compile error:&lt;/p&gt;
    &lt;code&gt;17 |     for child in parent.ro(&amp;amp;owner).get_children() {&lt;/code&gt;
    &lt;p&gt;It turns runtime panic into compile error, which make discovering problems eariler.&lt;/p&gt;
    &lt;p&gt;GPUI's &lt;code&gt;Model&amp;lt;T&amp;gt;&lt;/code&gt; is similar to &lt;code&gt;Rc&amp;lt;QCell&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;, where GPUI's &lt;code&gt;AppContext&lt;/code&gt; correspond to &lt;code&gt;QCellOwner&lt;/code&gt;.&lt;/p&gt;
    &lt;p&gt;It can also work in multithreading, by having &lt;code&gt;RwLock&amp;lt;QCellOwner&amp;gt;&lt;/code&gt;. This can allow one lock to protect many pieces of data in different places 7.&lt;/p&gt;
    &lt;p&gt;Ghost cell and LCell are similar to QCell, but use closure lifetime as owner id. They are zero-cost, but more restrictive (owner is tied to closure scope, cannot dynamically create, owner cannot outlive closure).&lt;/p&gt;
    &lt;head rend="h3"&gt;Rust lock is not re-entrant&lt;/head&gt;
    &lt;p&gt;Re-entrant lock means one thread can lock one lock, then lock it again, then unlock twice, without deadlocking. Rust lock is not re-entrant. (Rust lock is also responsible for keeping mutable borrow exclusiveness. Allowing re-entrant can produce two &lt;code&gt;&amp;amp;mut&lt;/code&gt; for same object.)&lt;/p&gt;
    &lt;p&gt;For example, in Java, the two-layer locking doesn't deadlock:&lt;/p&gt;
    &lt;code&gt;public class Main {  &lt;/code&gt;
    &lt;p&gt;But in Rust the equivalent will deadlock:&lt;/p&gt;
    &lt;code&gt;fn main() {  &lt;/code&gt;
    &lt;p&gt;It prints &lt;code&gt;going to do second-layer lock&lt;/code&gt; then deadlocks.&lt;/p&gt;
    &lt;p&gt;In Rust, it's important to be clear about which scope holds lock. Golang lock is also not re-entrant.&lt;/p&gt;
    &lt;p&gt;Another important thing is that Rust only unlocks at the end of scope by default. &lt;code&gt;mutex.lock().unwrap()&lt;/code&gt; gives a &lt;code&gt;MutexGuard&amp;lt;T&amp;gt;&lt;/code&gt;. &lt;code&gt;MutexGuard&lt;/code&gt; implements &lt;code&gt;Drop&lt;/code&gt;, so it will drop at the end of scope. It's different to the local variables whose type doesn't implement &lt;code&gt;Drop&lt;/code&gt;, they are dropped after their last use (unless borrowed). This is called NLL (non-lexical lifetime).&lt;/p&gt;
    &lt;head rend="h2"&gt;&lt;code&gt;Arc&lt;/code&gt; is not always fast&lt;/head&gt;
    &lt;p&gt;&lt;code&gt;Arc&lt;/code&gt; uses atomic operations to change its reference count. (Cloning and dropping &lt;code&gt;Arc&lt;/code&gt; changes reference count, but borrowing &lt;code&gt;Arc&lt;/code&gt; doesn't.)&lt;/p&gt;
    &lt;p&gt;However, when many threads frequently change the same atomic counter, performance can degrade. The more threads touching it, the slower it is.&lt;/p&gt;
    &lt;p&gt;Modern CPUs use cache coherency protocol (e.g. MOESI). Atomic operations often require the CPU core to hold "exclusive ownership" to cache line (this may vary between different hardware). Many threads frequently doing so cause cache contention, similar to locking, but on hardware.&lt;/p&gt;
    &lt;p&gt;Atomic reference counting is still fast if not contended (mostly only one thread change reference count). Atomic reference counting is faster on Apple silicon than Intel CPUs. 8&lt;/p&gt;
    &lt;p&gt;Solutions:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Avoid sharing the same reference count. Copying data is sometimes better.&lt;/item&gt;
      &lt;item&gt;trc and hybrid_rc. They use per-thread non-atomic counter, and another shared atomic counter for how many threads use it. This can make atomic operations be less frequent, getting higher performance.&lt;/item&gt;
      &lt;item&gt;For scenario of frequent short-term reads: &lt;list rend="ul"&gt;&lt;item&gt;arc_swap. It uses hazard pointer and other mechanics to improve performance.&lt;/item&gt;&lt;item&gt;aarc and crossbeam_epoch. Use epoch-based memory reclamation.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;These deferred memory reclamation techniques (hazard pointer, epoch-based) are also used in lock-free data structures. If one thread can read an element while another thread removes and frees the same element in parallel, it will not be memory-safe (this issue doesn't exist in GC languages).&lt;/p&gt;
    &lt;head rend="h2"&gt;Reference counting vs tracing GC&lt;/head&gt;
    &lt;p&gt;There are some ambiguity of the word "GC". Some say reference counting is GC, some say it isn't.&lt;/p&gt;
    &lt;p&gt;No matter what the definition of "GC" is, reference counting is different from tracing GC (in Java/JS/C#/Golang/etc.):&lt;/p&gt;
    &lt;table&gt;
      &lt;row span="2"&gt;
        &lt;cell role="head"&gt;Reference counting&lt;/cell&gt;
        &lt;cell role="head"&gt;Tracing GC&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;Frees memory immediately&lt;/cell&gt;
        &lt;cell&gt;Frees in deferred and batched way 9&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;Freeing a whole large structure may cause large lag 10&lt;/cell&gt;
        &lt;cell&gt;Require more memory to achieve high performance, otherwise GC lag will be large.&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;Finds greatest fixed point&lt;/cell&gt;
        &lt;cell&gt;Finds least fixed point&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;Propagates "death". (freeing one object may cause its children to be freed)&lt;/cell&gt;
        &lt;cell&gt;Propagates "live". (a living object cause its children to live, except for weak reference)&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;Cloning and dropping a reference involves atomic operation (except single-threaded &lt;code&gt;Rc&lt;/code&gt;)&lt;/cell&gt;
        &lt;cell&gt;Reading/writing an on-heap reference may involve read/write barrier (often a branch, no atomic memory access)&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;Cannot automatically handle cycles. Need to use weak reference to cut cycle&lt;/cell&gt;
        &lt;cell&gt;Can handle cycles automatically&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;cell&gt;Cost is roughly O(reference count changing frequency) 11&lt;/cell&gt;
        &lt;cell&gt;Cost is roughly O(count of living objects * GC frequency) 12&lt;/cell&gt;
      &lt;/row&gt;
    &lt;/table&gt;
    &lt;head rend="h2"&gt;Bump allocator&lt;/head&gt;
    &lt;p&gt;bumpalo provides bump allocator. In bump allocator, allocation is fast because it usually just increase an integer. It supports quickly freeing the whole arena, but doesn't support freeing individual objects.&lt;/p&gt;
    &lt;p&gt;It's usually faster than normal memory allocators. Normal memory allocator will do a lot of bookkeeping work for each allocation and free. Each individual memory region can free separately, these regions can be reused for later allocation, these information need to be recorded and updated.&lt;/p&gt;
    &lt;p&gt;Bump allocator frees memory in batched and deferred way. As it cannot free individual objects, it may temporarily consume more memory.&lt;/p&gt;
    &lt;p&gt;Bump allocator is suitable for temporary objects, where you are sure that none of these temporary objects will be needed after the work complets.&lt;/p&gt;
    &lt;p&gt;The function signature of allocation (changed for clarity):&lt;/p&gt;
    &lt;code&gt;impl Bump {&lt;/code&gt;
    &lt;p&gt;It takes immutable borrow of &lt;code&gt;Bump&lt;/code&gt; (it has interior mutability). It moves &lt;code&gt;val&lt;/code&gt; into the bump-allocated memory region. It outputs a mutable borrow, having the same lifetime as bump allocator. That lifetime ensures memory safety (cannot make the borrow of allocated value outlive bump allocator).&lt;/p&gt;
    &lt;p&gt;If you want to keep the borrow of allocated result for long time, then lifetime annotation is often required. In Rust, lifetime annotation is also contagious:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Every struct that holds bump-allocated borrow need to also have lifetime annotation of the bump allocator.&lt;/item&gt;
      &lt;item&gt;Every function that use it also needs lifetime annotation. Rust has lifetime elision, which allows you to omit lifetime in function signature in some cases. However it doesn't work in all cases.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Adding or removing lifetime for one thing may involve refactoring many code that use it, which can be huge work. Be careful in planning what lifetime parameters it needs.&lt;/p&gt;
    &lt;p&gt;&lt;code&gt;Bump&lt;/code&gt; doesn't implement &lt;code&gt;Sync&lt;/code&gt;, so &lt;code&gt;&amp;amp;Bump&lt;/code&gt; is not &lt;code&gt;Send&lt;/code&gt;. It cannot be shared across threads (even if it can share, there will be lifetime constraint that force you to use structured concurrency). It's recommended to have separated bump allocator in each thread, locally.&lt;/p&gt;
    &lt;head rend="h2"&gt;Using unsafe&lt;/head&gt;
    &lt;p&gt;By using unsafe you can freely manipulate pointers and are not restricted by borrow checker. But writing unsafe Rust is harder than just writing C, because you need to carefully avoid breaking the constraints that safe Rust code relies on. A bug in unsafe code can cause issue in safe code.&lt;/p&gt;
    &lt;p&gt;Writing unsafe Rust correctly is hard. Here are some traps in unsafe:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Don't violate mutable borrow exclusiveness. &lt;list rend="ul"&gt;&lt;item&gt;A &lt;code&gt;&amp;amp;mut&lt;/code&gt;cannot overlap with any other borrow that overlaps.&lt;/item&gt;&lt;item&gt;The overlap here also includes interior pointer. A &lt;code&gt;&amp;amp;mut&lt;/code&gt;to an object cannot co-exist with any other borrow into any part of that object.&lt;/item&gt;&lt;item&gt;Violating that rule cause undefined behavior and can cause wrong optimization. Rust adds &lt;code&gt;noalias&lt;/code&gt;attribute for mutable borrows into LLVM IR. LLVM will heavily optimize based on&lt;code&gt;noalias&lt;/code&gt;. See also&lt;/item&gt;&lt;item&gt;The above rule doesn't apply to raw pointer &lt;code&gt;*mut T&lt;/code&gt;.&lt;/item&gt;&lt;item&gt;Converting a &lt;code&gt;&amp;amp;T&lt;/code&gt;to&lt;code&gt;*mut T&lt;/code&gt;then mutate pointed data is undefined behavior. For that use case, wrap&lt;code&gt;T&lt;/code&gt;in&lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt;.&lt;/item&gt;&lt;item&gt;It's very easy to accidentally violate that rule when using borrows in unsafe. It's recommended to always use raw pointer and avoid using borrow (including slice borrow) in unsafe code. Related1, Related2&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;A &lt;/item&gt;
      &lt;item&gt;Pointer provenance. &lt;list rend="ul"&gt;&lt;item&gt;Two pointers created from two provenances is considered to never alias. If their address equals, it's undefined behavior.&lt;/item&gt;&lt;item&gt;Converting an integer to pointer gets a pointer with no provenance, using that pointer is undefined behavior, unless in these two cases: &lt;list rend="ul"&gt;&lt;item&gt;The integer was converted from a pointer using &lt;code&gt;.expose_provenance()&lt;/code&gt;and then integer converts to pointer using&lt;code&gt;with_exposed_provenance()&lt;/code&gt;&lt;/item&gt;&lt;item&gt;The integer &lt;code&gt;i&lt;/code&gt;is converted to pointer using&lt;code&gt;p.with_addr(i)&lt;/code&gt;(&lt;code&gt;p&lt;/code&gt;is another pointer). The result has same provenance of&lt;code&gt;p&lt;/code&gt;.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;&lt;item&gt;The integer was converted from a pointer using &lt;/item&gt;&lt;item&gt;Adding a pointer with an integer doesn't change provenance.&lt;/item&gt;&lt;item&gt;The provenance is tracked by compiler in compile time. In actual execution, pointer is still integer address that doesn't attach provenance information 13.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;Using uninitialized memory is undefined behavior. &lt;code&gt;MaybeUninit&lt;/code&gt;&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;a = b&lt;/code&gt;will drop the original object in place of&lt;code&gt;a&lt;/code&gt;. If&lt;code&gt;a&lt;/code&gt;is uninitialized, then it will drop an unitialized object, which is undefined behavior. Use&lt;code&gt;addr_of_mut!(...).write(...)&lt;/code&gt;Related&lt;/item&gt;
      &lt;item&gt;Handle panic unwinding.&lt;/item&gt;
      &lt;item&gt;Reading/writing to mutable data that's shared between threads need to use atomic, or volatile access (&lt;code&gt;read_volatile&lt;/code&gt;,&lt;code&gt;write_volatile&lt;/code&gt;), or use other synchronization (like locking). If not, optimizer may wrongly merge and reorder reads/writes. Note that volatile access themself doesn't establish memory order (unlike Java&lt;code&gt;volatile&lt;/code&gt;).&lt;/item&gt;
      &lt;item&gt;......&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Modern compilers tries to optimize as much as possible. To optimize as much as possible, the compiler makes assumptions as much as possible. Breaking any of these assumption can lead to wrong optimization. That's why it's so complex. See also&lt;/p&gt;
    &lt;p&gt;Unfortunately Rust's syntax ergonomics on raw pointer is currently not good:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;If &lt;code&gt;p&lt;/code&gt;is a raw pointer, you cannot write&lt;code&gt;p-&amp;gt;field&lt;/code&gt;(like in C/C++), and can only write&lt;code&gt;(*p).field&lt;/code&gt;&lt;/item&gt;
      &lt;item&gt;Raw pointer cannot be method receiver (self).&lt;/item&gt;
      &lt;item&gt;There is no "raw pointer to slice". You need to manually &lt;code&gt;.add()&lt;/code&gt;pointer and dereference. Bound checking is also manual.&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h2"&gt;Contagious borrowing between branches&lt;/head&gt;
    &lt;p&gt;Current borrow checker does coarse-grained analysis on branch. One branch's output's borrowing is contagious to another branch.&lt;/p&gt;
    &lt;p&gt;Currently, this won't compile (see also):&lt;/p&gt;
    &lt;code&gt;fn get_default&amp;lt;'r, K: Hash + Eq + Copy, V: Default&amp;gt;(&lt;/code&gt;
    &lt;p&gt;Becaue the first branch &lt;code&gt;Some(value) =&amp;gt; ...&lt;/code&gt;'s output value indirectly mutably borrows &lt;code&gt;map&lt;/code&gt;, the second branch has to also indirectly mutably borrow &lt;code&gt;map&lt;/code&gt;, which conflicts with another mutable borrow in scope.&lt;/p&gt;
    &lt;p&gt;This will be fixed by Polonius borrow checker. Currently (2025 Aug) it's available in nightly Rust and can be enabled by an option.&lt;/p&gt;
    &lt;head rend="h2"&gt;&lt;code&gt;Send&lt;/code&gt; and &lt;code&gt;Sync&lt;/code&gt;&lt;/head&gt;
    &lt;p&gt;Rust favors tree-shaped ownership. Each object is owned by exactly one place. If you send tree-shaped data to another thread, only one thread can access it, so it's thread-safe. No data race.&lt;/p&gt;
    &lt;p&gt;Sending an immutable borrow to another thread is also fine as long as the shared data is actually immutable.&lt;/p&gt;
    &lt;p&gt;But there are exceptions. One exception is interior mutability. Because of interior mutability, the data pointed by immutable borrow &lt;code&gt;&amp;amp;T&lt;/code&gt; may no longer actually be immutable. So Rust prevents sharing &lt;code&gt;&amp;amp;Cell&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;amp;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; by making &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; not &lt;code&gt;Sync&lt;/code&gt;. If &lt;code&gt;X&lt;/code&gt; is &lt;code&gt;Sync&lt;/code&gt; then &lt;code&gt;&amp;amp;X&lt;/code&gt; is &lt;code&gt;Send&lt;/code&gt;. If &lt;code&gt;X&lt;/code&gt; is not &lt;code&gt;Sync&lt;/code&gt; then &lt;code&gt;&amp;amp;X&lt;/code&gt; is not &lt;code&gt;Send&lt;/code&gt;. This prevents &lt;code&gt;Cell&lt;/code&gt; and &lt;code&gt;RefCell&lt;/code&gt; from being shared across threads.&lt;/p&gt;
    &lt;p&gt;&lt;code&gt;Rc&lt;/code&gt; also has internal shared mutable reference counter. It's not atomic, so &lt;code&gt;Rc&lt;/code&gt; cannot be passed between threads. It's neither &lt;code&gt;Send&lt;/code&gt; or &lt;code&gt;Sync&lt;/code&gt;.&lt;/p&gt;
    &lt;p&gt;But &lt;code&gt;&amp;amp;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; can be shared because lock protects them. Also immutable reference to atomic cells like &lt;code&gt;&amp;amp;AtomicU32&lt;/code&gt; can be shared because of atomicity. &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;AtomicU32&lt;/code&gt; are &lt;code&gt;Sync&lt;/code&gt; so &lt;code&gt;&amp;amp;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;amp;AtomicU32&lt;/code&gt; are &lt;code&gt;Send&lt;/code&gt;.&lt;/p&gt;
    &lt;p&gt;There are things that are &lt;code&gt;Sync&lt;/code&gt; but not &lt;code&gt;Send&lt;/code&gt;, like &lt;code&gt;MutexGuard&lt;/code&gt;. If something is already locked, sharing its reference to other threads temporarily is fine. But moving a &lt;code&gt;MutexGuard&lt;/code&gt; to another thread is not fine because locking is tied to thread.&lt;/p&gt;
    &lt;head rend="h2"&gt;
      &lt;code&gt;Send + 'static&lt;/code&gt;
    &lt;/head&gt;
    &lt;p&gt;Tokio is a popular async runtime. In Tokio, submitting a task require the future to be &lt;code&gt;Send&lt;/code&gt; and &lt;code&gt;'static&lt;/code&gt;.&lt;/p&gt;
    &lt;code&gt;pub fn spawn&amp;lt;F&amp;gt;(future: F) -&amp;gt; JoinHandle&amp;lt;F::Output&amp;gt;  &lt;/code&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;'static&lt;/code&gt;means it's standalone (self-owned). It doesn't borrow temporary things. It can borrow global values (global values will always live when program is running). It cannot borrow a value that only temporarily exists.&lt;p&gt;The spawned future may be kept for a long time. It's not determined whether future will only temporarily live within a scope. So the future need to be&lt;/p&gt;&lt;code&gt;'static&lt;/code&gt;. tokio_scoped allows submitting a future that's not&lt;code&gt;'static&lt;/code&gt;, but it must be finished within a scope.&lt;p&gt;If the future need to share data with outside, pass&lt;/p&gt;&lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt;into (not&lt;code&gt;&amp;amp;Arc&amp;lt;T&amp;gt;&lt;/code&gt;).&lt;p&gt;Note that the "static" in C/C++/Java/C# often mean global variable. But in Rust its meaning is different.&lt;/p&gt;&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;Send&lt;/code&gt;means that the future can be sent across threads. Tokio use work-stealing, which means that one thread's task can be stolen by other threads that currently have no work.&lt;code&gt;Send&lt;/code&gt;is not needed if the async runtime doesn't move future between threads.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Rust converts an async functions into a state machine, which is the future. In async function, the local variables that are used across &lt;code&gt;await&lt;/code&gt; points will become fields in future. If the future is required to be &lt;code&gt;Send&lt;/code&gt; then these local variables also need to be &lt;code&gt;Send&lt;/code&gt;.&lt;/p&gt;
    &lt;head rend="h2"&gt;Async traps&lt;/head&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;The normal sleep &lt;code&gt;std::thread::sleep&lt;/code&gt;and normal locking&lt;code&gt;std::sync::Mutex&lt;/code&gt;should not be used when using async runtime, because they block using OS functionality without telling async runtime, so they will block the async runtime's scheduling thread. In Tokio, use&lt;code&gt;tokio::sync::Mutex&lt;/code&gt;and&lt;code&gt;tokio::time::sleep&lt;/code&gt;.&lt;/item&gt;
      &lt;item&gt;Cancellation safety. See also&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h2"&gt;Side effect of extracting and inlining variable&lt;/head&gt;
    &lt;p&gt;In C and GC languages:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;If a variable is used only once, you can inline that variable. This will only change execution order (except in short-circuit 14).&lt;/item&gt;
      &lt;item&gt;Extracting a variable will only change execution order (except when variable is used twice or in short-circuit).&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;But in Rust it's different.&lt;/p&gt;
    &lt;head rend="h3"&gt;Lifetime of temporary value&lt;/head&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;A temporary value drops immediately after evaluating, except when there is a borrow to it, its lifetime extends by the borrow. It's called temporary lifetime extension. &lt;list rend="ul"&gt;&lt;item&gt;There are implicit ways of creating borrow. &lt;code&gt;DeRef&lt;/code&gt;can implicitly borrow,&lt;code&gt;a.b()&lt;/code&gt;can implicitly borrow&lt;code&gt;a&lt;/code&gt;&lt;/item&gt;&lt;item&gt;&lt;code&gt;match&lt;/code&gt;,&lt;code&gt;if let&lt;/code&gt;or&lt;code&gt;while let&lt;/code&gt;can also borrow which extend the lifetime&lt;/item&gt;&lt;item&gt;Sometimes temporary lifetime extension doesn't work, such as &lt;code&gt;let guard = Mutex::new(0).lock().unwrap();&lt;/code&gt;&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;There are implicit ways of creating borrow. &lt;/item&gt;
      &lt;item&gt;A value that's put into a local variable: &lt;list rend="ul"&gt;&lt;item&gt;If its type implements &lt;code&gt;Drop&lt;/code&gt;, then it will drop at the end of scope (one example is&lt;code&gt;MutexGuard&lt;/code&gt;).&lt;/item&gt;&lt;item&gt;If its type doesn't implement &lt;code&gt;Drop&lt;/code&gt;, then it will drop after its last use. This is called NLL (non-lexical lifetime).&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;If its type implements &lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Simplify:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Putting a temporary value to local variable usually make it live longer.&lt;/item&gt;
      &lt;item&gt;Inlining a local variable usually make it live shorter.&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h3"&gt;Reborrow&lt;/head&gt;
    &lt;p&gt;Normally mutable borrow &lt;code&gt;&amp;amp;mut T&lt;/code&gt; can only be moved and cannot be copied.&lt;/p&gt;
    &lt;p&gt;But reborrow is a feature that sometimes allow you to use a mutable borrow multiple times. Reborrow is very common in real-world Rust code. Reborrow is not explicitly documented. See also&lt;/p&gt;
    &lt;p&gt;Example:&lt;/p&gt;
    &lt;code&gt;fn mutate(i: &amp;amp;mut u32) -&amp;gt; &amp;amp;mut u32 {  &lt;/code&gt;
    &lt;p&gt;That works. Rust will implicitly treat the first &lt;code&gt;mutate(i)&lt;/code&gt; as &lt;code&gt;mutate(&amp;amp;mut *i)&lt;/code&gt; so that &lt;code&gt;i&lt;/code&gt; is not moved into and become usable again.&lt;/p&gt;
    &lt;p&gt;But extracting the second &lt;code&gt;i&lt;/code&gt; into a local variable early make it not compile:&lt;/p&gt;
    &lt;code&gt;fn mutate_twice(i: &amp;amp;mut u32) -&amp;gt; &amp;amp;mut u32 {  &lt;/code&gt;
    &lt;code&gt;7  | fn mutate_twice(i: &amp;amp;mut u32) -&amp;gt; &amp;amp;mut u32 {&lt;/code&gt;
    &lt;head rend="h3"&gt;Move cloned data into closure&lt;/head&gt;
    &lt;p&gt;&lt;code&gt;tokio::spawn&lt;/code&gt; require future to be standalone and doesn't borrow other things (&lt;code&gt;'static&lt;/code&gt;).&lt;/p&gt;
    &lt;p&gt;Passing passing an &lt;code&gt;Arc&lt;/code&gt; (that's used later) into moved closure makes closure borrow the &lt;code&gt;Arc&lt;/code&gt;. The data that contains borrow is not standalone (not &lt;code&gt;'static&lt;/code&gt;).&lt;/p&gt;
    &lt;code&gt;#[tokio::main]  &lt;/code&gt;
    &lt;p&gt;Compile error&lt;/p&gt;
    &lt;code&gt;6    |     let data: Arc&amp;lt;u64&amp;gt; = Arc::new(1);&lt;/code&gt;
    &lt;p&gt;Manually clone the &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; and put it into local variable works. It will make the cloned version to move into future:&lt;/p&gt;
    &lt;code&gt;#[tokio::main]  &lt;/code&gt;
    &lt;p&gt;Note that inlining &lt;code&gt;data2&lt;/code&gt; local variable make it not compile:&lt;/p&gt;
    &lt;code&gt;#[tokio::main]  &lt;/code&gt;
    &lt;code&gt;5    |     let data: Arc&amp;lt;u64&amp;gt; = Arc::new(1);&lt;/code&gt;
    &lt;p&gt;There is a proposal on improving syntax ergonomic of it.&lt;/p&gt;
    &lt;head rend="h2"&gt;Summarize the contagious things&lt;/head&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Borrowing that cross function boundary is contagious. Just borrowing a wheel of car can indirectly borrow the whole car.&lt;/item&gt;
      &lt;item&gt;Mutate-by-recreate is contagious. Recreating child require also recreating parent that holds the new child, and parent's parent, and so on.&lt;/item&gt;
      &lt;item&gt;Lifetime annotation is contagious. If some type has a lifetime parameter, then every type that holds it must also have lifetime parameter. Every function that use them also need lifetime parameter, except when lifetime elision works. Refactoring that adds/remove lifetime parameter can be huge work.&lt;/item&gt;
      &lt;item&gt;In current borrow checker, one branch's output's borrowing is contagious to the whole branching scope.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;async&lt;/code&gt;is contagious.&lt;code&gt;async&lt;/code&gt;function can call normal function. Normal function cannot easily call&lt;code&gt;async&lt;/code&gt;function (but it's possible to call by blocking).&lt;/item&gt;
      &lt;item&gt;Being not &lt;code&gt;Sync&lt;/code&gt;/&lt;code&gt;Send&lt;/code&gt;is contagious. A struct that indirectly owns a non-&lt;code&gt;Sync&lt;/code&gt;data is not&lt;code&gt;Sync&lt;/code&gt;. A struct that indirectly owns a non-&lt;code&gt;Send&lt;/code&gt;data is not&lt;code&gt;Send&lt;/code&gt;.&lt;/item&gt;
      &lt;item&gt;Error passing is contagious. If panic is not acceptable, then all functions that indirectly call a fallible function must return &lt;code&gt;Result&lt;/code&gt;. Related: NaN is contagious in floating point computation.&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h2"&gt;Some arguments&lt;/head&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;"Rust doesn't ensure safety of &lt;code&gt;unsafe&lt;/code&gt;code, so using&lt;code&gt;unsafe&lt;/code&gt;defeats the purpose of using Rust". No. If you keep the amount of&lt;code&gt;unsafe&lt;/code&gt;small, then when memory/thread safety issue happens, you can inspect these small amount of&lt;code&gt;unsafe&lt;/code&gt;code. In C/C++ you need to inspect all related code. It's still not recommended to use many&lt;code&gt;unsafe&lt;/code&gt;in Rust.&lt;/item&gt;
      &lt;item&gt;"Using arena still face the equivalent of 'use after free', so arena doesn't solve the problem". No. Arenas can make these bugs much more deterministic than the use-after-free in C/C++, prevent memory-safety Heisenbugs 15, making debugging much easier.&lt;/item&gt;
      &lt;item&gt;"Rust borrow checker rejects your code because your code is wrong." No. Rust can reject valid safe code.&lt;/item&gt;
      &lt;item&gt;"Doubly-linked list is useless." No. It can be useful in many cases. Linux kernel uses them. But often trees and hash maps can replace manually-implemented doubly-linked list.&lt;/item&gt;
      &lt;item&gt;"Circular reference is bad and should be avoided." No. Circular reference can be useful in many cases. Circular reference do come with risks.&lt;/item&gt;
      &lt;item&gt;"Rust guarantees high performance." No. If one evades borrow checker by using &lt;code&gt;Arc&amp;lt;Mutex&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt;everywhere, the program will be likely slower than using a normal GC language (and has more risk of deadlocking). But it's easier to achieve high performance in Rust. In many other languages, achieving high perfomance often require bypassing (hacking) a lot of language functionalities.&lt;/item&gt;
      &lt;item&gt;"Rust guarantees security." No. Not all security issues are memory/thread safety issues. According to Common Weakness Enumeration 2024, many real-world vulnerabilities are XSS, SQL injection, directory traversal, command injection, missing authentication, etc. that are not memory/thread safety.&lt;/item&gt;
      &lt;item&gt;"Rust doesn't help other than memory/thread safety." No. &lt;list rend="ul"&gt;&lt;item&gt;Algebraic data type (e.g. &lt;code&gt;Option&lt;/code&gt;,&lt;code&gt;Result&lt;/code&gt;) helps avoid creating illegal data from the source. Using ADT data require pattern match all cases, avoiding forgetting handling one case. (except when using escape hatch like&lt;code&gt;unwrap()&lt;/code&gt;).&lt;/item&gt;&lt;item&gt;Mutable borrow exclusiveness prevents iterator invalidation. And it reduces bugs caused by accidental mutation.&lt;/item&gt;&lt;item&gt;Explicit &lt;code&gt;.clone()&lt;/code&gt;avoids accidentally copying container like in C++.&lt;/item&gt;&lt;item&gt;Managing dependencies is much easier in Rust than in C/C++.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;Algebraic data type (e.g. &lt;/item&gt;
      &lt;item&gt;"Using immutable data structure is just a workaround forced by Rust." No. Immutable data structure can prevent many bugs caused by accidental mutation. If used correctly, they can reduce complexity. The persistent data structures are also efficient for things like rollback.&lt;/item&gt;
      &lt;item&gt;"Memory safety can only be achieved by Rust." No. Most GC languages are memory-safe. 16 Memory safety of existing C/C++ applications can be achieved via Fil-C.&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h2"&gt;Other&lt;/head&gt;
    &lt;p&gt;Rust prefers data-oriented design. Rust doesn't fit OOP. Rust dislikes sharing mutable data. Rust dislikes circular reference. Rust is unfriendly to observer pattern. Getter and setter can easily cause contagious borrow issue. Sharing and mutation has many limitations.&lt;/p&gt;
    &lt;p&gt;Rust is less flexible and does not suit quick iteration (unless you are a Rust expert).&lt;/p&gt;
    &lt;p&gt;Rust's constraints apply to both human and AI. In a large C/C++ codebase, both human and AI can accidentally break memory safety and thread safety in non-obvious way. Rust can protect against that. Popular open source projects are often flooded with AI-generated PR. Rust makes reviewing PR easier: as long as CI passes and it doesn't use &lt;code&gt;unsafe&lt;/code&gt;, it won't break memory and thread safety. Note that Rust doesn't protect against many kinds logical error.&lt;/p&gt;
    &lt;head rend="h2"&gt;Footnotes&lt;/head&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;&lt;p&gt;The native Rust ownership relation form a tree. Reference counting (&lt;/p&gt;&lt;code&gt;Rc&lt;/code&gt;,&lt;code&gt;Arc&lt;/code&gt;) allows shared ownership. ↩&lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Note that here "reference" here means reference in general OOP context (where there is no distinction between ownership and non-owning reference, think about reference in Java/C#/JS/Python). This is different to the Rust reference. I will use "borrow" for Rust reference in this article. ↩&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Specifically, Gödel encodes symbols, statements and proofs into integer, called Gödel number. There exists many ways of encoding symbols/statements/proofs as data, and which exact way is not important. For simplicity, I will treat them all as data, and ignore the conversion between data and symbol/statements/proofs. ↩&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;&lt;p&gt;Here&lt;/p&gt;&lt;code&gt;x(x)&lt;/code&gt;is symbol substitution. replacing the free variable&lt;code&gt;x&lt;/code&gt;with&lt;code&gt;x&lt;/code&gt;, while avoid making two different variables same name by renaming when necessary. It's also similar to Y combinator:&lt;code&gt;Y = f -&amp;gt; (x -&amp;gt; f(x(x))) (x -&amp;gt; f(x(x)))&lt;/code&gt;. In that case&lt;code&gt;f = unprovable&lt;/code&gt;,&lt;code&gt;H = x -&amp;gt; f(x(x))&lt;/code&gt;,&lt;code&gt;Y(f) = H(H)&lt;/code&gt;,&lt;code&gt;Y(f)&lt;/code&gt;is a fixed point of&lt;code&gt;f&lt;/code&gt;:&lt;code&gt;f(Y(f)) = Y(f)&lt;/code&gt;.&lt;code&gt;G = Y(f)&lt;/code&gt;,&lt;code&gt;f(G) = G&lt;/code&gt;↩&lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Having both ID and object reference introduces friction: translating between ID and object reference. Some ORM will malfunction if there exists two objects with the same primary key. ↩&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Each slotmap ensures key uniqueness, but if you mix keys of different slotmaps, the different keys of different slotmap may duplicate. Using the wrong key may successfully get an element but logically wrong. ↩&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Sometimes, having fine-grained lock is slower because of more lock/unlock operations. But sometimes having fine-grained lock is faster because it allows higher parallelism. Sometimes fine-grained lock can cause deadlock but coarse-grained lock won't deadlock. It depends on exact case. ↩&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;See also. That was in 2020. Unsure whether it changed now. One possible reason is that ARM allows weaker memory order than X86. Also, Swift and Objective-C use reference counting almost everywhere, so possibly Apple payed more efforts in optimizing atomic reference counting. ↩&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;&lt;p&gt;Tracing GC is faster for short-lived programs (such as some CLI programs and serverless functions), because there's no need to free memory for individual objects on exit. Example: My JavaScript is Faster than Your Rust. The same optimization is also achievable in Rust, but require extra work (e.g.&lt;/p&gt;&lt;code&gt;mem::forget&lt;/code&gt;, bump allocator). ↩&lt;/item&gt;
      &lt;item&gt;&lt;p&gt;It lags because it need to do many counter decrement and deallocation for each individual object. Can be workarounded by sending the&lt;/p&gt;&lt;code&gt;Arc&lt;/code&gt;to another thread and drop in that thread. Also, for deep structures, dropping may stack overflow. ↩&lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Contended atomic operations (many threads touch one atomic value at the same time) are much slower than when not contended. Its cost also include memory block allocation and freeing. ↩&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;GC frequency is roughly porpotional to allocation speed divide by free memory. In generational GC, a minor GC only scans young generation, whose cost is roughly count of living young generation objects. But it still need to occasionally do full GC. ↩&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;When running in tools like Miri, the pointer provenance will be tracked at runtime. ↩&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;&lt;code&gt;a() || b()&lt;/code&gt;will not execute&lt;code&gt;b()&lt;/code&gt;if&lt;code&gt;a()&lt;/code&gt;returns true.&lt;code&gt;a() &amp;amp;&amp;amp; b()&lt;/code&gt;will not execute&lt;code&gt;b()&lt;/code&gt;if&lt;code&gt;a()&lt;/code&gt;returns false. ↩&lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;The Heisenbugs may only trigger in relase build, not in debug build, not when sanitizers are on, not when logging is on, not when debugger is on. Because optimization, sanitizer, debugger and logging can change timing and memory layout, which can make memory safety or thread safety bug no longer trigger. Debugging a Heisenbug in large codebase may take weeks even months. Note that not all memory/thread safety bugs are Heisenbugs. Many are still easy to trigger. ↩&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Golang is not memory-safe under data race. ↩&lt;/p&gt;
      &lt;/item&gt;
    &lt;/list&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://qouteall.fun/qouteall-blog/2025/How%20to%20Avoid%20Fighting%20Rust%20Borrow%20Checker#contagious-borrow-issue"/><published>2025-10-24T12:10:25+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45693904</id><title>Show HN: A fast, privacy-first image converter that runs in browser</title><updated>2025-10-24T16:44:03.474677+00:00</updated><content>&lt;doc fingerprint="1d3445719171ada6"&gt;
  &lt;main&gt;
    &lt;p&gt;PNG -&amp;gt; JPG converter&lt;/p&gt;
    &lt;head rend="h1"&gt;Convert PNG to JPG in seconds&lt;/head&gt;
    &lt;p&gt;Upload a PNG image and instantly download a high-quality JPG. Everything stays in your browser — no uploads, no limits.&lt;/p&gt;
    &lt;p&gt;100% free image converter&lt;/p&gt;
    &lt;p&gt;Lightning-fast&lt;/p&gt;
    &lt;p&gt;Explore other image converters&lt;/p&gt;
    &lt;head rend="h2"&gt;How to convert PNG to JPG in your browser&lt;/head&gt;
    &lt;head rend="h3"&gt;1. Upload your image&lt;/head&gt;
    &lt;p&gt;Drop or select a PNG file from your device. The file never leaves your browser.&lt;/p&gt;
    &lt;head rend="h3"&gt;2. We convert it instantly&lt;/head&gt;
    &lt;p&gt;The converter renders your image as JPG locally, keeping quality and dimensions intact.&lt;/p&gt;
    &lt;head rend="h3"&gt;3. Download the JPG file&lt;/head&gt;
    &lt;p&gt;Save the converted JPG with one click or choose another format.&lt;/p&gt;
    &lt;head rend="h2"&gt;Image converter FAQ&lt;/head&gt;
    &lt;p&gt;Everything you need to know about switching image formats in your browser&lt;/p&gt;
    &lt;head class="flex cursor-pointer items-center justify-between px-6 py-4 text-left hover:bg-muted/50 transition-colors list-none"&gt;Is the image converter free to use?&lt;/head&gt;
    &lt;p&gt;Yes—every converter on imageconverter.dev is free, unlimited, and watermark-free. Convert as many files as you want without creating an account.&lt;/p&gt;
    &lt;head class="flex cursor-pointer items-center justify-between px-6 py-4 text-left hover:bg-muted/50 transition-colors list-none"&gt;Do my images ever upload to a server?&lt;/head&gt;
    &lt;p&gt;No. All conversions happen entirely in your browser using Web APIs. After the page loads you can even go offline and the converter will keep working.&lt;/p&gt;
    &lt;head class="flex cursor-pointer items-center justify-between px-6 py-4 text-left hover:bg-muted/50 transition-colors list-none"&gt;Will the converter reduce image quality?&lt;/head&gt;
    &lt;p&gt;We preserve the image resolution and apply gentle compression only when the target format requires it. Transparent backgrounds are automatically flattened to white when exporting to JPG.&lt;/p&gt;
    &lt;head class="flex cursor-pointer items-center justify-between px-6 py-4 text-left hover:bg-muted/50 transition-colors list-none"&gt;Can I convert multiple images at once?&lt;/head&gt;
    &lt;p&gt;Right now this tool handles one file at a time so you can review the output before downloading. Need bulk conversions? Try our bulk resize tool with format switching support.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://imageconverter.dev/"/><published>2025-10-24T12:21:55+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45693978</id><title>Typst 0.14</title><updated>2025-10-24T16:44:02.563198+00:00</updated><content>&lt;doc fingerprint="7e9e51106fe534cc"&gt;
  &lt;main&gt;
    &lt;p&gt;Typst 0.14 is out now. With accessibility by default, PDFs as images, character-level justification, and more, it has everything you need to move from draft to production.&lt;/p&gt;
    &lt;p&gt;Typst's origins lie in academia, but over the past year, we've seen it expand to so much more. It's increasingly being used in the industry: For manually written documents, partially automated reports, and in fully automated batch PDF generation pipelines. Across these use cases, it's being used in production for critical documents.&lt;/p&gt;
    &lt;p&gt;In August, we launched a new website to reflect Typst's expanding scope, and now, with Typst 0.14, we're shipping crucial features that make Typst even more widely applicable.&lt;/p&gt;
    &lt;p&gt;If you need to comply with accessibility-related regulations, Typst 0.14 has your back. Typst now generates accessible documents by default, with opt-in support for stricter checks. For those working with complex illustrations, PDFs are now supported as a native image format. In case you're typesetting a book, the new character-level justification will give your layout the final touch. And if you're building a website or blog, many improvements to Typst's HTML export are waiting for you.&lt;/p&gt;
    &lt;head rend="h2"&gt;Contents&lt;/head&gt;
    &lt;p&gt;In this blog post, we'll take a closer look at the highlights of this release:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Accessibility&lt;/item&gt;
      &lt;item&gt;PDF standards&lt;/item&gt;
      &lt;item&gt;PDFs as images&lt;/item&gt;
      &lt;item&gt;Character-level justification&lt;/item&gt;
      &lt;item&gt;Richer HTML export&lt;/item&gt;
      &lt;item&gt;Migrating to Typst 0.14&lt;/item&gt;
      &lt;item&gt;Community Call&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;To get started with Typst 0.14…&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;…in the web app: Just open any of your projects! You'll get a prompt offering you to upgrade to the latest version.&lt;/item&gt;
      &lt;item&gt;…on the command line: Run &lt;code&gt;typst update&lt;/code&gt;in your terminal or, if you haven't installed Typst previously, download the latest version of the CLI.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;For a comprehensive overview of all changes in the release, visit the changelog. If you're looking to upgrade your document to Typst 0.14, you can also skip ahead to the Migration section.&lt;/p&gt;
    &lt;head rend="h2"&gt;Accessibility&lt;/head&gt;
    &lt;p&gt;Not everyone reads PDF documents the same. Some people read on large screens or print; others use small phones or screen readers to have documents read aloud. To cater to all these uses, a file must contain tags that allow Assistive Technology (AT) like screen readers to learn about the reading order and semantic meaning of each piece of text. Tags allow AT users to learn which text is &lt;code&gt;*strongly emphasized*&lt;/code&gt;, enable navigation of the document by skipping between headings, and more.&lt;/p&gt;
    &lt;p&gt;Tagging requires no additional work from you: If you are using the built-in markup and elements, Typst will automatically select the right tags! Unlike many other tools, PDF files created with Typst 0.14 are tagged by default, raising the bar for accessibility.&lt;/p&gt;
    &lt;p&gt;But tags are not enough to make a file accessible: To reach everyone, you need to design for universal accessibility from the start. The new features in Typst 0.14 can help you with that. Consider diagrams created with shapes or packages like cetz—their visual meaning is invisible to assistive technology. The new &lt;code&gt;alt&lt;/code&gt; parameter on figures solves this:&lt;/p&gt;
    &lt;code&gt;#figure(
  stack(
    dir: ltr,
    spacing: 0.5em,
    rect[Tagged PDF],
    text(2em, sym.arrow.long),
    rect[Accessibility],
  ),
  alt: "Diagram with two rectangles. The first is labelled 'Tagged PDF'. An arrow points to the second, labelled 'Accessibility'",
  caption: [
    Tags enable PDF accessibility
  ],
)
&lt;/code&gt;
    &lt;p&gt;With this change, AT users hear the alternative description and can grasp the figure's purpose just like sighted users—no information is lost. We have put together a new Accessibility Guide that contains more tips on how to create accessible documents, including how to write good alternative descriptions, when to use the figure's vs. the image's &lt;code&gt;alt&lt;/code&gt; parameter, and more.&lt;/p&gt;
    &lt;p&gt;To make sure you got everything right, you can enable the new PDF/UA-1 export. PDF/UA is an international standard that helps to create universally accessible PDF files. When it is enabled, Typst will run additional checks against your document to find accessibility issues and optimize for accessibility rather than compatibility. It will find issues such as missing document titles, wrong heading hierarchies, and missing alternative descriptions.&lt;/p&gt;
    &lt;p&gt;PDF/UA-1 helps you comply with existing and upcoming international accessibility regulation like the European Accessibility Act (EAA) in the EU and the new Americans with Disabilities Act's (ADA) Title II guidance by the DOJ. The former applies to many businesses active in the European Union since 28 June 2025 while the deadline for the latter is set for April 24, 2026. If you are using Typst in your business for customer- or government-facing documents, you should adopt Typst 0.14 as soon as possible.&lt;/p&gt;
    &lt;head rend="h2"&gt;PDF standards&lt;/head&gt;
    &lt;p&gt;Alongside PDF/UA-1 support, we've also generally expanded Typst's support for PDF standards. Instead of just PDF 1.7, you can now choose between the PDF versions 1.4, 1.5, 1.6, 1.7, and 2.0. And for PDF/A, we've expanded support from just two specific substandards to all four parts with all their conformance levels. While Typst's defaults are perfectly fine for most use cases, choosing a standard can optimize your document specifically for your use case. Consult the expanded PDF documentation in the reference for guidance on which standards you should pick under which circumstances.&lt;/p&gt;
    &lt;head rend="h2"&gt;PDFs as images&lt;/head&gt;
    &lt;p&gt;Staying with the PDF theme, there are exciting news for authors that have a lot of complex illustrations. Typst now supports PDF as a native image format. What I personally find most exciting about it, is that PDF images are supported across all export targets, and for each export target in the most suitable format. In PDF export, PDFs are naturally directly embedded. Meanwhile, in HTML and SVG export, PDFs are converted to an embedded SVG on-the-fly. And, finally, in PNG export and the web app preview, PDFs are rasterized. All of this PDF processing functionality lives right in the Typst compiler, with no system dependencies. This is only possible thanks to the amazing work of community member @LaurenzV, who created a new PDF processing library called &lt;code&gt;hayro&lt;/code&gt; from scratch. The library is 100% written in the programming language Rust (which is also the language we use for the Typst compiler) and is thus highly portable.&lt;/p&gt;
    &lt;code&gt;#figure(
  image(
    "throwing-success.pdf",
    alt: "A diagram titled 'Throwing Success' that .."
  ),
  caption: [
    Effect of normalized thrust
    on X and Y position of
    thrown emojis
  ],
)
&lt;/code&gt;
    &lt;head rend="h2"&gt;Character-level justification&lt;/head&gt;
    &lt;p&gt;Producing a visually balanced paragraph was once a fine art, when professional typesetters still carefully set paragraphs with movable type. Nowadays, you could hope that optimal paragraph typesetting is a solved problem across all our software. But, alas, it is not!&lt;/p&gt;
    &lt;p&gt;There are different strategies we can employ to produce a well-justified paragraph. Of course, to justify the paragraph, we need to stretch each line to the width of the measure. There are different ways to do this: Most obviously, we can adjust the spacing between words. This is what most software does. But we can also adjust the spacing between characters. This is now implemented in Typst.&lt;/p&gt;
    &lt;p&gt;Other methods to do this (which we want to explore in the future) include stretching the width of characters (this is best done with variable fonts) or, for some scripts, inserting special textual elements. For example, in Arabic, there are Kashida, which allow spacing out glyphs in words by extending the connectors between individual glyphs.&lt;/p&gt;
    &lt;p&gt;But that's just part of the recipe. Arguably, the even more crucial part is how this interplays with which linebreaks we chose to insert. Naively, we can choose our break points based on how much text fits and then perform the stretching. But we can do much better by taking into account each line's potential for stretching with the various mechanisms discussed above! We can then choose the break points that minimize the amount of bad-looking stretching.&lt;/p&gt;
    &lt;p&gt;I was initially skeptical about supporting character-level justification because I've seen it done poorly in some books. But that's actually not the fault of character-level justification per se; it's just excessive use of it. Tastefully chosen maxima—together with an algorithm that minimizes displeasing typography—make it bring out the best in justification.&lt;/p&gt;
    &lt;p&gt;We hear a lot about microtypography when people compare Typst with LaTeX. And even though Typst uses the same fundamental algorithm as LaTeX does to optimize paragraphs, it's true that LaTeX has some extra tricks up its sleeve. Now we do too though, as character-level justification is a feature that LaTeX does not support.&lt;/p&gt;
    &lt;head rend="h2"&gt;Richer HTML Export&lt;/head&gt;
    &lt;p&gt;In Typst 0.13, we shipped a first, highly experimental version of HTML export. This very minimal version already introduced the primitives for flexible HTML generation. With these primitives, the mapping of Typst elements to HTML can be expressed through show rules, just like the mapping to visual elements is performed in paged export.&lt;/p&gt;
    &lt;p&gt;What was lacking though were show rules for many built-in elements, including elements like footnotes, outlines, and citations. Typst 0.14 makes good progress in this regard. Most semantic elements (those from the Model category) are now properly mapped to semantic HTML. We've also improved handling of textual content in HTML export. The more visualization- and styling-focused parts of Typst's standard library remain largely unsupported, but we plan to add support for those (to the extent possible) in the future.&lt;/p&gt;
    &lt;p&gt;Below, you can see an example of a small, but non-trivial Typst document exported to HTML with Typst 0.14.&lt;/p&gt;
    &lt;code&gt;#set heading(numbering: "1.")

= Introduction &amp;lt;intro&amp;gt;
In @intro, let's cite @netwok.

#bibliography("works.bib")
&lt;/code&gt;
    &lt;quote&gt;&amp;lt;!-- html, head, and body omitted for brevity --&amp;gt; &amp;lt;h2 id="intro"&amp;gt;1. Introduction&amp;lt;/h2&amp;gt; &amp;lt;p&amp;gt; In &amp;lt;a href="#intro"&amp;gt;Section 1&amp;lt;/a&amp;gt;, let’s cite &amp;lt;a id="loc-1" href="#loc-2" role="doc-biblioref"&amp;gt;[1]&amp;lt;/a&amp;gt;. &amp;lt;/p&amp;gt; &amp;lt;section role="doc-bibliography"&amp;gt; &amp;lt;h2&amp;gt;Bibliography&amp;lt;/h2&amp;gt; &amp;lt;ul style="list-style-type: none"&amp;gt; &amp;lt;li id="loc-2"&amp;gt; &amp;lt;span class="prefix"&amp;gt;&amp;lt;a href="#loc-1" role="doc-backlink"&amp;gt;[1]&amp;lt;/a&amp;gt;&amp;lt;/span&amp;gt; R. Astley and L. Morris, “At-scale impact of the Net Wok: A culinarically holistic investigation of distributed dumplings,” &amp;lt;em&amp;gt;Armenian Journal of Proceedings&amp;lt;/em&amp;gt;, vol. 61, pp. 192–219, 2020. &amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;/section&amp;gt;&lt;/quote&gt;
    &lt;p&gt;Another exciting addition to HTML export is the new typed HTML interface. Typst's &lt;code&gt;html&lt;/code&gt; module now includes functions for constructing HTML elements with strongly-typed attributes. This means you can now write&lt;/p&gt;
    &lt;code&gt;#html.video(
  autoplay: true,
  width: 1280,
  height: 720,
  src: "sunrise.mp4",
)
&lt;/code&gt;
    &lt;p&gt;instead of&lt;/p&gt;
    &lt;code&gt;#html.elem("video", attrs: (
  autoplay: "",
  width: "1280",
  height: "720",
  src: "sunrise.mp4",
))
&lt;/code&gt;
    &lt;p&gt;As you can see, attributes are mapped to idiomatic Typst-native types.&lt;/p&gt;
    &lt;p&gt;Last but not least, we're happy to announce that HTML export will soon come to the Typst web app. We're still polishing up the implementation, but plan to ship it in the coming weeks.&lt;/p&gt;
    &lt;p&gt;Please note that HTML export remains experimental. To enable it in the CLI, pass &lt;code&gt;--features html&lt;/code&gt; or set &lt;code&gt;TYPST_FEATURES=html&lt;/code&gt;. In the web app, support for HTML export will also need to be enabled on a per-project basis.&lt;/p&gt;
    &lt;head rend="h2"&gt;Migrating to Typst 0.14&lt;/head&gt;
    &lt;p&gt;As far as breaking changes and deprecations go, this is a pretty calm release. Most documents should continue to work as before. There are a few minor breaking changes that make certain validations more strict. For instance, labels, link URLs, and font lists may not be empty anymore. To learn about all breaking changes, consult the changelog and search for "breaking change".&lt;/p&gt;
    &lt;p&gt;The release also contains a few deprecations. In particular, you'll need to replace any use of &lt;code&gt;pdf.embed&lt;/code&gt; with &lt;code&gt;pdf.attach&lt;/code&gt;. Moreover, two bibliography styles were renamed and the &lt;code&gt;--make-deps&lt;/code&gt; CLI flag was deprecated in favor of the new, more flexible &lt;code&gt;--deps&lt;/code&gt; flag with &lt;code&gt;--deps-format make&lt;/code&gt;. There are also a few deprecated symbols. The compiler will warn you about all use of deprecated functionality.&lt;/p&gt;
    &lt;head rend="h3"&gt;In the web app&lt;/head&gt;
    &lt;p&gt;With this release, we're also bringing a better version upgrade experience to the web app. Previously, projects would always use the latest compiler version unless explicitly pinned to a specific version in the settings side panel.&lt;/p&gt;
    &lt;p&gt;We are now phasing out the "Latest" option. Instead, the web app detects when a new version is available since you've last edited a project, and offers you to upgrade. The upgrade assistant includes an automatic compatibility check that compiles your document with both versions, makes a verdict, and lists new errors and warnings.&lt;/p&gt;
    &lt;head rend="h2"&gt;Community Call&lt;/head&gt;
    &lt;p&gt;Typst 0.14 is the result of 8 months of hard work by us and the community. We hope you are as excited about it as we are!&lt;/p&gt;
    &lt;p&gt;Speaking of the community—We're hosting a community call on Discord on Friday, November 7th. Join us to share your experiences with the new version and to chat with the community!&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://typst.app/blog/2025/typst-0.14/"/><published>2025-10-24T12:33:10+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45694111</id><title>Traffic Light Protocol</title><updated>2025-10-24T16:44:02.325498+00:00</updated><content>&lt;doc fingerprint="e6926b83d677835f"&gt;
  &lt;main&gt;
    &lt;p&gt;TLP version 2.0 is the current version of TLP standardized by FIRST. It is authoritative from August 2022 onwards&lt;/p&gt;
    &lt;p&gt;a. The Traffic Light Protocol (TLP) was created to facilitate greater sharing of potentially sensitive information and more effective collaboration. Information sharing happens from an information source, towards one or more recipients. TLP is a set of four labels used to indicate the sharing boundaries to be applied by the recipients. Only labels listed in this standard are considered valid by FIRST.&lt;/p&gt;
    &lt;p&gt;b. The four TLP labels are: TLP:RED, TLP:AMBER, TLP:GREEN, and TLP:CLEAR. In written form, they MUST not contain spaces and SHOULD be in capitals. TLP labels MUST remain in their original form, even when used in other languages: content can be translated, but the labels cannot.&lt;/p&gt;
    &lt;p&gt;c. TLP provides a simple and intuitive schema for indicating with whom potentially sensitive information can be shared. TLP is not a formal classification scheme. TLP was not designed to handle licensing terms, nor information handling or encryption rules. TLP labels and their definitions are not intended to have any effect on freedom of information or “sunshine” laws in any jurisdiction.&lt;/p&gt;
    &lt;p&gt;d. TLP is optimized for ease of adoption, human readability and person-to-person sharing; it may be used in automated information exchange systems, such as MISP or IEP.&lt;/p&gt;
    &lt;p&gt;e. TLP is distinct from the Chatham House Rule, but may be used in conjunction when appropriate. When a meeting is held under the Chatham House Rule, participants are free to use the information received, but neither the identity nor the affiliation of the speaker(s), nor that of any other participant, may be revealed.&lt;/p&gt;
    &lt;p&gt;f. The source is responsible for ensuring that recipients of TLP-labeled information understand and can follow TLP sharing guidance.&lt;/p&gt;
    &lt;p&gt;g. The source is at liberty to specify additional sharing restrictions. These must be adhered to by recipients.&lt;/p&gt;
    &lt;p&gt;h. If a recipient needs to share information more widely than indicated by the TLP label it came with, they must obtain explicit permission from the source.&lt;/p&gt;
    &lt;p&gt;a. How to use TLP in messaging (such as email and chat)&lt;lb/&gt; TLP-labeled messaging MUST indicate the TLP label of the information, as well as any additional restrictions, directly prior to the information itself. The TLP label SHOULD be in the subject line of email. Where needed, also make sure to designate the end of the text to which the TLP label applies.&lt;/p&gt;
    &lt;p&gt;b. How to use TLP in documents TLP-labeled documents MUST indicate the TLP label of the information, as well as any additional restrictions, in the header and footer of each page. The TLP label SHOULD be in 12-point type or greater for users with low vision. It is recommended to right-justify TLP labels.&lt;/p&gt;
    &lt;p&gt;c. How to use TLP in automated information exchanges TLP usage in automated information exchanges is not defined: this is left to the designers of such exchanges, but MUST be in accordance with this standard.&lt;/p&gt;
    &lt;p&gt;d. TLP color-coding in RGB, CMYK and Hex&lt;/p&gt;
    &lt;table&gt;
      &lt;row span="17"&gt;
        &lt;cell&gt;RGB:&lt;p&gt;font&lt;/p&gt;&lt;/cell&gt;
        &lt;cell&gt;RGB:&lt;p&gt;background&lt;/p&gt;&lt;/cell&gt;
        &lt;cell&gt;CMYK:&lt;p&gt;font&lt;/p&gt;&lt;/cell&gt;
        &lt;cell&gt;CMYK:&lt;p&gt;background&lt;/p&gt;&lt;/cell&gt;
        &lt;cell&gt;Hex:&lt;p&gt;font&lt;/p&gt;&lt;/cell&gt;
        &lt;cell&gt;Hex:&lt;p&gt;background&lt;/p&gt;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="17"&gt;
        &lt;cell&gt;R&lt;/cell&gt;
        &lt;cell&gt;G&lt;/cell&gt;
        &lt;cell&gt;B&lt;/cell&gt;
        &lt;cell&gt;R&lt;/cell&gt;
        &lt;cell&gt;G&lt;/cell&gt;
        &lt;cell&gt;B&lt;/cell&gt;
        &lt;cell&gt;C&lt;/cell&gt;
        &lt;cell&gt;M&lt;/cell&gt;
        &lt;cell&gt;Y&lt;/cell&gt;
        &lt;cell&gt;K&lt;/cell&gt;
        &lt;cell&gt;C&lt;/cell&gt;
        &lt;cell&gt;M&lt;/cell&gt;
        &lt;cell&gt;Y&lt;/cell&gt;
        &lt;cell&gt;K&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="17"&gt;
        &lt;cell&gt;TLP:RED&lt;/cell&gt;
        &lt;cell&gt;255&lt;/cell&gt;
        &lt;cell&gt;43&lt;/cell&gt;
        &lt;cell&gt;43&lt;/cell&gt;
        &lt;cell&gt;0&lt;/cell&gt;
        &lt;cell&gt;0&lt;/cell&gt;
        &lt;cell&gt;0&lt;/cell&gt;
        &lt;cell&gt;0&lt;/cell&gt;
        &lt;cell&gt;83&lt;/cell&gt;
        &lt;cell&gt;83&lt;/cell&gt;
        &lt;cell&gt;0&lt;/cell&gt;
        &lt;cell&gt;0&lt;/cell&gt;
        &lt;cell&gt;0&lt;/cell&gt;
        &lt;cell&gt;0&lt;/cell&gt;
        &lt;cell&gt;100&lt;/cell&gt;
        &lt;cell&gt;#FF2B2B&lt;/cell&gt;
        &lt;cell&gt;#000000&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="17"&gt;
        &lt;cell&gt;TLP:AMBER&lt;/cell&gt;
        &lt;cell&gt;255&lt;/cell&gt;
        &lt;cell&gt;192&lt;/cell&gt;
        &lt;cell&gt;0&lt;/cell&gt;
        &lt;cell&gt;0&lt;/cell&gt;
        &lt;cell&gt;0&lt;/cell&gt;
        &lt;cell&gt;0&lt;/cell&gt;
        &lt;cell&gt;0&lt;/cell&gt;
        &lt;cell&gt;25&lt;/cell&gt;
        &lt;cell&gt;100&lt;/cell&gt;
        &lt;cell&gt;0&lt;/cell&gt;
        &lt;cell&gt;0&lt;/cell&gt;
        &lt;cell&gt;0&lt;/cell&gt;
        &lt;cell&gt;0&lt;/cell&gt;
        &lt;cell&gt;100&lt;/cell&gt;
        &lt;cell&gt;#FFC000&lt;/cell&gt;
        &lt;cell&gt;#000000&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="17"&gt;
        &lt;cell&gt;TLP:GREEN&lt;/cell&gt;
        &lt;cell&gt;51&lt;/cell&gt;
        &lt;cell&gt;255&lt;/cell&gt;
        &lt;cell&gt;0&lt;/cell&gt;
        &lt;cell&gt;0&lt;/cell&gt;
        &lt;cell&gt;0&lt;/cell&gt;
        &lt;cell&gt;0&lt;/cell&gt;
        &lt;cell&gt;79&lt;/cell&gt;
        &lt;cell&gt;0&lt;/cell&gt;
        &lt;cell&gt;100&lt;/cell&gt;
        &lt;cell&gt;0&lt;/cell&gt;
        &lt;cell&gt;0&lt;/cell&gt;
        &lt;cell&gt;0&lt;/cell&gt;
        &lt;cell&gt;0&lt;/cell&gt;
        &lt;cell&gt;100&lt;/cell&gt;
        &lt;cell&gt;#33FF00&lt;/cell&gt;
        &lt;cell&gt;#000000&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;cell&gt;TLP:CLEAR&lt;/cell&gt;
        &lt;cell&gt;255&lt;/cell&gt;
        &lt;cell&gt;255&lt;/cell&gt;
        &lt;cell&gt;255&lt;/cell&gt;
        &lt;cell&gt;0&lt;/cell&gt;
        &lt;cell&gt;0&lt;/cell&gt;
        &lt;cell&gt;0&lt;/cell&gt;
        &lt;cell&gt;0&lt;/cell&gt;
        &lt;cell&gt;0&lt;/cell&gt;
        &lt;cell&gt;0&lt;/cell&gt;
        &lt;cell&gt;0&lt;/cell&gt;
        &lt;cell&gt;0&lt;/cell&gt;
        &lt;cell&gt;0&lt;/cell&gt;
        &lt;cell&gt;0&lt;/cell&gt;
        &lt;cell&gt;100&lt;/cell&gt;
        &lt;cell&gt;#FFFFFF&lt;/cell&gt;
        &lt;cell&gt;#000000&lt;/cell&gt;
      &lt;/row&gt;
    &lt;/table&gt;
    &lt;p&gt;Note on color-coding: when there is too little color contrast between text and background, those with low vision struggle to read text or cannot see it at all. TLP is designed to accommodate those with low vision. Sources SHOULD adhere to the TLP color-coding to ensure enough color contrast for such readers.&lt;/p&gt;
    &lt;p&gt;Community: Under TLP, a community is a group who share common goals, practices, and informal trust relationships. A community can be as broad as all cybersecurity practitioners in a country (or in a sector or region).&lt;/p&gt;
    &lt;p&gt;Organization: Under TLP, an organization is a group who share a common affiliation by formal membership and are bound by common policies set by the organization. An organization can be as broad as all members of an information sharing organization, but rarely broader.&lt;/p&gt;
    &lt;p&gt;Clients: Under TLP, clients are those people or entities that receive cybersecurity services from an organization. Clients are by default included in TLP:AMBER so that the recipients may share information further downstream in order for clients to take action to protect themselves. For teams with national responsibility this definition includes stakeholders and constituents.&lt;/p&gt;
    &lt;p&gt;a. TLP:RED = For the eyes and ears of individual recipients only, no further disclosure. Sources may use TLP:RED when information cannot be effectively acted upon without significant risk for the privacy, reputation, or operations of the organizations involved. Recipients may therefore not share TLP:RED information with anyone else. In the context of a meeting, for example, TLP:RED information is limited to those present at the meeting.&lt;/p&gt;
    &lt;p&gt;b. TLP:AMBER = Limited disclosure, recipients can only spread this on a need-to-know basis within their organization and its clients. Note that TLP:AMBER+STRICT restricts sharing to the organization only. Sources may use TLP:AMBER when information requires support to be effectively acted upon, yet carries risk to privacy, reputation, or operations if shared outside of the organizations involved. Recipients may share TLP:AMBER information with members of their own organization and its clients, but only on a need-to-know basis to protect their organization and its clients and prevent further harm. Note: if the source wants to restrict sharing to the organization only, they must specify TLP:AMBER+STRICT.&lt;/p&gt;
    &lt;p&gt;c. TLP:GREEN = Limited disclosure, recipients can spread this within their community. Sources may use TLP:GREEN when information is useful to increase awareness within their wider community. Recipients may share TLP:GREEN information with peers and partner organizations within their community, but not via publicly accessible channels. TLP:GREEN information may not be shared outside of the community. Note: when “community” is not defined, assume the cybersecurity/defense community.&lt;/p&gt;
    &lt;p&gt;d. TLP:CLEAR = Recipients can spread this to the world, there is no limit on disclosure. Sources may use TLP:CLEAR when information carries minimal or no foreseeable risk of misuse, in accordance with applicable rules and procedures for public release. Subject to standard copyright rules, TLP:CLEAR information may be shared without restriction.&lt;/p&gt;
    &lt;p&gt;Notes:&lt;lb/&gt; 1. This document uses MUST and SHOULD as defined by RFC-2119.&lt;lb/&gt; 2. Comments or suggestions on this document can be sent to tlp-sig@first.org.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://www.first.org/tlp/"/><published>2025-10-24T12:52:22+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45694122</id><title>A sharded DuckDB on 63 nodes runs 1T row aggregation challenge in 5 sec</title><updated>2025-10-24T16:44:01.938163+00:00</updated><link href="https://gizmodata.com/blog/gizmoedge-one-trillion-row-challenge"/><published>2025-10-24T12:54:47+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45694767</id><title>Asahi Linux Still Working on Apple M3 Support, M1n1 Bootloader Going Rust</title><updated>2025-10-24T16:44:01.774366+00:00</updated><content>&lt;doc fingerprint="8f41bb17d99430ec"&gt;
  &lt;main&gt;
    &lt;head rend="h1"&gt;Asahi Linux Still Working On Apple M3 Support, m1n1 Bootloader Going Rust&lt;/head&gt;
    &lt;p&gt; The Asahi Linux developers involved with working on Linux support for Apple Silicon M-Series devices have put out a new progress report on their development efforts. &lt;lb/&gt;Asahi Linux developers have kept working on new kernel patches and some being upstreamed for Linux 6.17 and 6.18 cycles, as previously covered on Phoronix. Notably with Linux 6.18 is the Device Trees for the Apple M2 Pro / Max / Ultra devices albeit more driver code is still working its way upstream.&lt;lb/&gt;Asahi Linux developers are also working on moving toward the Rust programming language with their important m1n1 bootloader for Apple Silicon. They feel going to Rust is important for such a critical piece of software for better maintainability, safety, and ensuring the correct logic.&lt;lb/&gt;Asahi Linux developers have also made progress on getting more games working on Apple Silicon devices. Wine is also now working outside of muvm and their graphics driver support continues maturing:&lt;lb/&gt;With the upstream Linux kernel work around Apple Silicon so far being focused on Apple M1 and M2, you may be wondering about M3 and M4 or the recently announced M5... They still are battling Apple M3 bring-up. Today's progress report comments:&lt;lb/&gt;See the progress report in full over on AsahiLinux.org.&lt;/p&gt;
    &lt;p&gt;Asahi Linux developers have kept working on new kernel patches and some being upstreamed for Linux 6.17 and 6.18 cycles, as previously covered on Phoronix. Notably with Linux 6.18 is the Device Trees for the Apple M2 Pro / Max / Ultra devices albeit more driver code is still working its way upstream.&lt;/p&gt;
    &lt;p&gt;Asahi Linux developers are also working on moving toward the Rust programming language with their important m1n1 bootloader for Apple Silicon. They feel going to Rust is important for such a critical piece of software for better maintainability, safety, and ensuring the correct logic.&lt;/p&gt;
    &lt;p&gt;Asahi Linux developers have also made progress on getting more games working on Apple Silicon devices. Wine is also now working outside of muvm and their graphics driver support continues maturing:&lt;/p&gt;
    &lt;p&gt;With the upstream Linux kernel work around Apple Silicon so far being focused on Apple M1 and M2, you may be wondering about M3 and M4 or the recently announced M5... They still are battling Apple M3 bring-up. Today's progress report comments:&lt;/p&gt;
    &lt;quote&gt;"It may be surprising to learn that very basic, low-level support for M3 has existed for quite some time now. m1n1 is capable of initialising the CPU cores, turning on some critical peripheral devices, and booting the Asahi kernel. However, the level of support right now begins and ends with being able to boot to a blinking cursor. Naturally, this level of support is not at all useful for anything but low-level reverse engineering, but we of course plan on rectifying this in due time..."&lt;/quote&gt;
    &lt;p&gt;See the progress report in full over on AsahiLinux.org.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://www.phoronix.com/news/Asahi-Linux-M3-m1n1-Update"/><published>2025-10-24T14:03:22+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45695956</id><title>The Mainframe Six</title><updated>2025-10-24T16:44:01.303208+00:00</updated><content>&lt;doc fingerprint="777c131edaf3f7e9"&gt;
  &lt;main&gt;
    &lt;div&gt;
      &lt;head rend="h2"&gt;Sidenote: The Mainframe Six&lt;/head&gt;
      &lt;p&gt;Created 23 September 2022 - Updated 24 September 2022&lt;/p&gt;
      &lt;p&gt;There are six companies remaining in the mainframe industry - Hitachi, NEC, Fujitsu, Atos (formerly Bull), Unisys, and IBM. Three of those - Fujitsu, NEC, and IBM - still develop their own CPUs, though Fujitsu is likely to do so for only one more generation. If I had to speculate about where each of them is used, this is more or less what I'd end up with.&lt;/p&gt;
      &lt;list rend="ul"&gt;
        &lt;item&gt;IBM is global and has, as best I can tell, between 3000 and 7000 Z customers. Many of these are on very large systems; IBM scales to far higher performance levels and core counts than other vendors.&lt;/item&gt;
        &lt;item&gt;Unisys is global, with higher concentrations in Latin America (especially for MCP) and East Asia (especially for OS 2200.) MCP is more common in banking and telecom, OS 2200 in airline and government. Both exited custom CPUs in the early 2010s but have fast emulators. I'd guess there's 800-1200 MCP sites and a much smaller number of OS 2200 sites - which is a little sad because OS 2200 is awesome. MCP uses an impressive high-level-language-oriented descriptor ISA, while OS 2200 uses a 36-bit ones' complement ISA with some unusual characteristics.&lt;/item&gt;
        &lt;item&gt;Fujitsu is mostly global, with the notable exception of North America, and has several distinct mainframe families. The ex-Siemens BS2000 lineup and the semi-IBM-compatible GS21 family use different software but on the same 390-based custom CPUs. The former ICL family, the 29-series descriptor systems, lives on in Britain in finance and government but is slowly declining and has been primarily run emulated for over 20 years. BS2000 is concentrated in Germany, the GS21 userbase in Japan. I'd guess there's a total of 1000-1500 Fujitsu mainframe customers, with a majority being in Japan, but I'm not super confident in that.&lt;/item&gt;
        &lt;item&gt;Hitachi, though they once had a thriving global business including North America, markets their systems exclusively in Japan. Until approximately 2020, they built custom CPUs, but in the latest generation - the AP10000 - they rebadge IBM Z running their own MVS-derived VOS3 operating system. I'd guess they have 200-300 sites, almost all in Japan.&lt;/item&gt;
        &lt;item&gt;Atos, which recently finished devouring the French computer company Groupe Bull, owns Bull's GCOS 7 and GCOS 8 operating systems. Both are unique ISAs, incompatible with each other and running completely different software; GCOS 7 is 32-bit, EBCDIC, vaguely MVS-like, and even includes a POSIX subsystem (which it uses for TCP/IP support.) GCOS 8 is older, ASCII, and 36-bit word-oriented. GCOS 7 is emulated on x86, GCOS 8 (as far as I'm aware) is still emulated on Itanium; I would guess the combined total of customer sites for G7 and G8 is less than 100, mostly in Western Europe but with a handful in North America and probably Africa.&lt;/item&gt;
        &lt;item&gt;NEC's ACOS-4 operating system is a distant cousin of Bull's GCOS 7, and NEC still designs its own processors to run it. These are fairly big systems by the standards of non-IBM mainframes - up to 48 custom-designed cores and 256GB RAM - and while the customer base is almost exclusively Japanese, they've historically sold a few ACOS systems elsewhere in Asia and even North America. I would guess that at this point there are 200-400 sites remaining, almost all in Japan.&lt;/item&gt;
      &lt;/list&gt;
      &lt;p&gt;[1] Bull is the exception; GCOS 7 and GCOS 8 are at least as incompatible as MCP and OS 2200 are. One could probably make a case for Fujitsu, but generally the markets for GS, BS, and VME have little overlap (except in Britain.)&lt;/p&gt;
      &lt;p&gt;Back to Let's Play OS 2200!&lt;/p&gt;
    &lt;/div&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://arcanesciences.com/os2200/app1.html"/><published>2025-10-24T16:01:23+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45696183</id><title>Ivy League psychologist: 'Bring your whole self to work' is bad advice</title><updated>2025-10-24T16:44:01.135378+00:00</updated><content>&lt;doc fingerprint="7c48910d8062552f"&gt;
  &lt;main&gt;
    &lt;p&gt;If someone tells you to "bring your whole self to work," don't listen, says psychologist Tomas Chamorro-Premuzic.&lt;/p&gt;
    &lt;p&gt;Like many other workplace platitudes, the intention of the phrase is "truly positive, even if naive," according to Chamorro-Premuzic, a professor of business psychology at Columbia University.&lt;/p&gt;
    &lt;p&gt;"It's an attempt to tell particularly individuals that are part of the outgroup that they should not feel any pressure to conform to the norm," he tells CNBC Make It, adding that it's "an invitation to feel free to express themselves."&lt;/p&gt;
    &lt;p&gt;People tend to be more engaged and satisfied when they feel that they can bring "more dimensions of themselves," if not their entire selves, to work, Chamorro-Premuzic says.&lt;/p&gt;
    &lt;p&gt;Still, he wouldn't recommend that employees take "bring your whole self to work" too literally.&lt;/p&gt;
    &lt;p&gt;At the end of the day, "the workplace values professional demeanor over personal idiosyncrasies," he writes in his recent book "Don't Be Yourself: Why Authenticity Is Overrated (and What to Do Instead)," and employees who take the phrase to heart may find themselves in awkward social situations.&lt;/p&gt;
    &lt;p&gt;No matter how much your company promotes authenticity, "parts of your self are best left at home," Chamorro-Premuzic writes.&lt;/p&gt;
    &lt;head rend="h2"&gt;Better in theory than in practice&lt;/head&gt;
    &lt;p&gt;One issue with telling people to be themselves at work is that "more often than not, it's not a genuine invitation," says Chamorro-Premuzic.&lt;/p&gt;
    &lt;p&gt;"Authenticity may be celebrated in theory, but in practice, it tends to succumb to the age-old requirement to 'fit in,'" he writes in "Don't Be Yourself."&lt;/p&gt;
    &lt;p&gt;As a rule, conformity is rewarded in the workplace, Chamorro-Premuzic says.&lt;/p&gt;
    &lt;p&gt;The invitation to 'bring your whole self to work' is often "constrained to those attitudes, beliefs and preferences that happen to match existing cultural norms," he writes.&lt;/p&gt;
    &lt;p&gt;People whose behavior and beliefs align with their company's prevailing culture may benefit from sharing more about themselves at work, Chamorro-Premuzic says.&lt;/p&gt;
    &lt;p&gt;However, people who express "authentic" opinions that run counter to the group's views may risk damaging their reputations or relationships.&lt;/p&gt;
    &lt;p&gt;Due to their limited knowledge of workplace etiquette, young professionals are especially vulnerable to being misled by "be yourself" rhetoric, he says.&lt;/p&gt;
    &lt;p&gt;In scenarios like job interviews, when candidates should be making a conscious effort to showcase their best qualities, following advice to "bring your whole self" will put them at a significant disadvantage.&lt;/p&gt;
    &lt;p&gt;"You're never going to get a job if you do that," he says.&lt;/p&gt;
    &lt;head rend="h2"&gt;It 'rarely ends well'&lt;/head&gt;
    &lt;p&gt;Most people's "whole selves" encompass a range of emotions, behaviors and actions, some of which are less professionally and socially acceptable than others.&lt;/p&gt;
    &lt;p&gt;"For most people, the authentic self is the one that doesn't want to get out of bed on a Monday morning to go to work," Chamorro-Premuzic writes.&lt;/p&gt;
    &lt;p&gt;In most workplaces, your career is likely to suffer if you engage in unprofessional conduct like snapping at co-workers, stealing other people's lunches or taking naps at your desk, regardless of how 'authentic' those behaviors may be.&lt;/p&gt;
    &lt;p&gt;Conversely, a company culture that prizes 'being yourself' over social etiquette is likely to enable bad behavior, especially from higher-ups, according to Chamorro-Premuzic.&lt;/p&gt;
    &lt;p&gt;When authenticity is valued more than accountability, people in power may feel empowered to behave in "very antisocial and discouraging" ways toward others, he says.&lt;/p&gt;
    &lt;p&gt;"They may become entitled and they say, 'Well, I don't need to be accountable for anything I do. I can do whatever I want,'" Chamorro-Premuzic says.&lt;/p&gt;
    &lt;p&gt;Of course, plenty of leaders continue to behave in "a humble and considered way," Chamorro-Premuzic says, but those qualities more often stem from self-awareness and respect for others, than from 'being themselves.'&lt;/p&gt;
    &lt;p&gt;If we spend less time exhorting people to be authentic, and more time encouraging respectful behavior, "the world will be a better place," he says.&lt;/p&gt;
    &lt;p&gt;Want to level up your AI skills? Sign up for Smarter by CNBC Make It's new online course, How To Use AI To Communicate Better At Work. Get specific prompts to optimize emails, memos and presentations for tone, context and audience. Sign up today with coupon code EARLYBIRD for an introductory discount of 20% off. Offer valid Oct. 21 through Oct. 28, 2025.&lt;/p&gt;
    &lt;p&gt;Plus, sign up for CNBC Make It's newsletter to get tips and tricks for success at work, with money and in life, and request to join our exclusive community on LinkedIn to connect with experts and peers.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://www.cnbc.com/2025/10/24/bring-your-whole-self-to-work-is-bad-advice-ivy-league-psychologist-saysheres-why.html"/><published>2025-10-24T16:22:38+00:00</published></entry></feed>