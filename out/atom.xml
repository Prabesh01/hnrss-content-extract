<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><id>hnrss.org/frontpage</id><title>Hacker News: Front Page</title><updated>2025-11-08T03:14:45.646277+00:00</updated><link href="https://news.ycombinator.com/" rel="alternate"/><link href="https://raw.githubusercontent.com/Prabesh01/hnrss-content-extract/refs/heads/main/out/rss.xml" rel="self"/><generator uri="https://lkiesow.github.io/python-feedgen" version="1.0.0">python-feedgen</generator><subtitle>Hacker News RSS</subtitle><entry><id>https://news.ycombinator.com/item?id=45849342</id><title>Myna: Monospace typeface designed for symbol-heavy programming languages</title><updated>2025-11-08T03:17:17.541294+00:00</updated><content>&lt;doc fingerprint="bf9b609b0166edfd"&gt;
  &lt;main&gt;
    &lt;p&gt;Do you ever feel like your font treats symbols as second-class glyphs? Are you frustrated that &lt;code&gt;-&amp;gt;&lt;/code&gt; looks nothing like an arrow, and &lt;code&gt;$&lt;/code&gt;, &lt;code&gt;@&lt;/code&gt;, &lt;code&gt;%&lt;/code&gt; seem ever mismatched?&lt;/p&gt;
    &lt;p&gt;Want to experience the beauty of ligatures without losing the simplicity of ASCII?&lt;/p&gt;
    &lt;p&gt;Myna (Gracula religiosa üê¶‚¨õ) is a monospace font which aims to bring harmony to your editor by treating symbols as first-class glyphs alongside alphanumeric characters.&lt;/p&gt;
    &lt;p&gt;Myna was borne out of a need to scratch a persistent typographical itch. While I've tried many otherwise well-crafted monospace fonts, I always found myself wanting to tweak a glyph here or adjust a shape there. After developing Myna and using it almost exclusively in my professional and personal work, I'm sharing it as a small contribution to the wonderful community of monospace typography enthusiasts.&lt;/p&gt;
    &lt;p&gt;Here are a few of its attractive features that might make it your next favourite monospace font:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Symbol-First Design: clear emphasis on ASCII symbols which are ubiquitous in programming languages&lt;/item&gt;
      &lt;item&gt;Near-Perfect Alignment: multi-character symbols like &lt;code&gt;-&amp;gt;&lt;/code&gt;,&lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;,&lt;code&gt;=~&lt;/code&gt;,&lt;code&gt;::&lt;/code&gt;align seamlessly&lt;/item&gt;
      &lt;item&gt;Balanced Weight: symbols have just the right visual weight against your code&lt;/item&gt;
      &lt;item&gt;Minimalist Forms: geometric shapes for quotes and commas&lt;/item&gt;
      &lt;item&gt;Clear Distinction: no more confusing &lt;code&gt;1 l I |&lt;/code&gt;or&lt;code&gt;0 O o&lt;/code&gt;&lt;/item&gt;
      &lt;item&gt;Language-Aware Design: clean sigils for Perl + elegant operators for Haskell + clear symbols for C&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;NB: Myna is designed to be a simple font. The current release is a single weight without ligatures, though future updates may expand its features if demand arises. It does work out nicely with synthesised bold generated by fontconfig and pango on Linux.&lt;/p&gt;
    &lt;p&gt;Please click on the image to view it in full in a new tab.&lt;/p&gt;
    &lt;table&gt;
      &lt;row span="3"&gt;
        &lt;cell role="head"&gt;Language&lt;/cell&gt;
        &lt;cell role="head"&gt;Light&lt;/cell&gt;
        &lt;cell role="head"&gt;Dark&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;Perl&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;Haskell&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;C&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;Bash&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;Clojure&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;Erlang&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;OCaml&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;Rust&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;LaTeX&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;HTML&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;cell&gt;SQL&lt;/cell&gt;
      &lt;/row&gt;
    &lt;/table&gt;
    &lt;code&gt;git clone https://github.com/sayyadirfanali/Myna.git
cd Myna
cp Myna.otf ~/.local/share/fonts/
fc-cache -v&lt;/code&gt;
    &lt;code&gt;git clone https://github.com/sayyadirfanali/Myna.git
cd Myna
cp Myna.otf ~/Library/Fonts/&lt;/code&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Download the release&lt;/item&gt;
      &lt;item&gt;Right-click &lt;code&gt;Myna.otf&lt;/code&gt;and select "Install for all users"&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;SIL Open Font License, Version 1.1&lt;/p&gt;
    &lt;p&gt;Myna started out as Hera which was a customised version of Source Code Pro but now has come a long way after stealing many beautiful designs from Fira Mono, Inconsolata, Plex Mono, Office Code Pro, Anonymous Pro. Detailed credits could be found in the Hera repository.&lt;/p&gt;
    &lt;p&gt;Code banner and illustrations were produced using ImageMagick and Ray.so.&lt;/p&gt;
    &lt;p&gt;Myna is designed to be used universally in every kind of terminal and editor. I've tried to include a reasonable subset of non-ASCII glyphs (mostly geometrical and mathematical characters). However, I'm considering expanding it based on community interest and would welcome contributions in these areas:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Bug Reports: spacing and kerning issues, rendering problems, unavailable/incorrect glyphs&lt;/item&gt;
      &lt;item&gt;Feature Requests: suggest new glyphs or features via GitHub Issues&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Please feel free to open issues and also contact me at irfan@irfanali.org.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://github.com/sayyadirfanali/Myna"/><published>2025-11-07T18:27:36+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45849528</id><title>Ruby Solved My Problem</title><updated>2025-11-08T03:17:17.333986+00:00</updated><content>&lt;doc fingerprint="3e6c285f6ce2a7b9"&gt;
  &lt;main&gt;
    &lt;head rend="h1"&gt;Ruby already solved my problem üòÖ&lt;/head&gt;
    &lt;head rend="h3"&gt;One great question in office hours led me to delete a whole class.&lt;/head&gt;
    &lt;p&gt;Yesterday I hosted November‚Äôs Hotwire Native Office Hours.&lt;/p&gt;
    &lt;p&gt;Every month I host an hour long Zoom session for developers to directly ask me questions. The topics range greatly: some folks are just getting started and others are asking very specific, advanced questions.&lt;/p&gt;
    &lt;p&gt;This month we covered everything from registering bridge components to native vs. web-based tabs to authenticating Apple Watch apps! It‚Äôs really fun to see what folks are working on in the Hotwire Native space.&lt;/p&gt;
    &lt;p&gt;During the session I shared some code I wrote to figure out what version a Hotwire Native app is running. The app sends the version in the user agent (e.g. &lt;code&gt;v1.2.3&lt;/code&gt;) and then I parse it with the following Ruby class on the server:&lt;/p&gt;
    &lt;code&gt;class AppVersion
  include Comparable

  attr_reader :major, :minor, :patch

  def initialize(version_string)
    parts = version_string.to_s.split(‚Äù.‚Äù).map(&amp;amp;:to_i)
    @major, @minor, @patch = parts[0] || 0, parts[1] || 0, parts[2] || 0
  end

  def &amp;lt;=&amp;gt;(other)
    [major, minor, patch] &amp;lt;=&amp;gt; [other.major, other.minor, other.patch]
  end

  def to_s
    ‚Äú#{major}.#{minor}.#{patch}‚Äù
  end
end&lt;/code&gt;
    &lt;p&gt;And it works great! I use this throughout my apps to feature flag code based on which version the app is running.&lt;/p&gt;
    &lt;p&gt;But someone brought up something even better: &lt;code&gt;Gem::Version&lt;/code&gt;. This class accomplishes the same goal: ‚Äúprocess string versions into comparable values‚Äù.&lt;/p&gt;
    &lt;code&gt;irb(main)&amp;gt; Gem::Version.new("1.2.3") &amp;gt; Gem::Version.new("1.2.2")
=&amp;gt; true

irb(main)&amp;gt; Gem::Version.new("2.0") &amp;gt; Gem::Version.new("1.2.2")
=&amp;gt; true&lt;/code&gt;
    &lt;p&gt;It can even compare prerelease versions, like alphas or betas.&lt;/p&gt;
    &lt;code&gt;irb(main)&amp;gt; Gem::Version.new("2.0.b1") &amp;gt; Gem::Version.new("1.9")
=&amp;gt; true
irb(main)&amp;gt; Gem::Version.new("2.0") &amp;gt; Gem::Version.new("2.0.b1")
=&amp;gt; true&lt;/code&gt;
    &lt;p&gt;The big advantage this class has over my implementation is that it‚Äôs built into Ruby!&lt;/p&gt;
    &lt;p&gt;It‚Äôs not even a Rails dependency but part of the standard Ruby library. Internally, this class is used to compare version numbers when parsing your &lt;code&gt;Gemfile&lt;/code&gt;. Check out the documentation, I picked up a few things on semantic versioning when reading it.&lt;/p&gt;
    &lt;p&gt;I‚Äôve already replaced my &lt;code&gt;AppVersion&lt;/code&gt; class with &lt;code&gt;Gem::Version&lt;/code&gt;. But it makes me wonder what other Ruby/Rails features I don‚Äôt know about and am implementing on my own!&lt;/p&gt;
    &lt;head rend="h2"&gt;The power of community, no matter how small&lt;/head&gt;
    &lt;p&gt;I never would have learned about &lt;code&gt;Gem::Version&lt;/code&gt; if it wasn‚Äôt for someone bringing it up during office hours. I‚Äôd still be using my custom (and most likely buggy!) &lt;code&gt;AppVersion&lt;/code&gt; implementation‚Ä¶¬†like a chump. üòÖ&lt;/p&gt;
    &lt;p&gt;But seriously, this is why I love connecting with folks in the Ruby/Rails community. Every time I go to an event, host a workshop, give a talk‚Ä¶ I learn something new. Sometimes it‚Äôs small things like &lt;code&gt;Gem::Version&lt;/code&gt;. Other times it completely changes my career, like the first time I heard about Hotwire Native.&lt;/p&gt;
    &lt;p&gt;I‚Äôve taken this to heart and recently started organizing monthly Coffee and Code coworking sessions in my city, Portland, OR. Every month I post up at a local coffee shop with my laptop and invite all of the Portland Ruby Brigade to join.&lt;/p&gt;
    &lt;p&gt;This month we had five people! It‚Äôs no corporate-sponsored-meetup but it sure is something. And the connections that folks are making during these casual events are real. I‚Äôve already seen folks exchange emails for potential future contract gigs.&lt;/p&gt;
    &lt;p&gt;What‚Äôs the first step you can take today to build some community in your local area? Even if it is just finally inviting that connection-to-be for a beverage‚Ä¶ I say go for it.&lt;/p&gt;
    &lt;p&gt;If you want to join next month‚Äôs office hours then consider becoming a paid subscriber of my newsletter. I hope to see you there! üëã&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://newsletter.masilotti.com/p/ruby-already-solved-my-problem"/><published>2025-11-07T18:45:35+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45850069</id><title>James Watson has died</title><updated>2025-11-08T03:17:17.089570+00:00</updated><content/><link href="https://www.nytimes.com/2025/11/07/science/james-watson-dead.html"/><published>2025-11-07T19:30:18+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45850382</id><title>How did I get here?</title><updated>2025-11-08T03:17:07.756082+00:00</updated><content>&lt;doc fingerprint="b798a1154e30abef"&gt;
  &lt;main&gt;
    &lt;p&gt;This part of the page is still loading while I wait for the above traceroute to load.&lt;/p&gt;
    &lt;head rend="h2"&gt;Behind the Scenes&lt;/head&gt;
    &lt;p&gt;To reach this website, your computer sent some packets across the Internet. If we‚Äôre curious what that path was, we can run a tool to generate a traceroute ‚Äî a rough list of every server your packets touched to reach their destination. To build this website (source code on GitHub), I wrote my own traceroute program called ktr (also open source) that can stream results in real time while concurrently looking up interesting information about each hop.&lt;/p&gt;
    &lt;p&gt;How does ktr work? Let‚Äôs start with a simplified explanation of Internet routing.&lt;/p&gt;
    &lt;p&gt;Starting with the source device, each computer that handles a packet has to choose the best device to forward it to ‚Äî I will explain how these routing decisions are made in a bit. Assuming everything works correctly, the packet will eventually reach a router that knows how to send it directly to its destination.&lt;/p&gt;
    &lt;p&gt;My traceroute implementation uses a protocol called ICMP. ICMP was designed specifically for sending diagnostic information around the Internet, and, helpfully, almost every Internet-connected device speaks it. Interestingly, ICMP packets have a ‚ÄúTTL‚Äù (time to live) field. This isn‚Äôt actually a ‚Äútime‚Äù as implied by a name ‚Äî it‚Äôs a countdown! Every time a router forwards an ICMP packet along, it‚Äôs supposed to decrement the TTL number. When the TTL hits zero, the router should stop forwarding it along and instead send an error message to the packet‚Äôs source IP saying that the packet has reached its maximum number of hops.&lt;/p&gt;
    &lt;p&gt;We can take advantage of this TTL feature! To do a traceroute, we can send a bunch of ICMP packets with increasingly large TTLs. The first packet with a TTL of 1 will error on the first device it reaches, and so on, until we hopefully get an error back from every routing device that touched the packet. These error packets include diagnostic information like the IP address of the device that sent the error, allowing us to trace your packets‚Äô rough path across the Internet.&lt;/p&gt;
    &lt;head rend="h3"&gt;Frontend Fun&lt;/head&gt;
    &lt;p&gt;This page will work perfectly fine with JavaScript disabled. From the browser‚Äôs perspective, this website just loaded slowly. From your perspective, a traceroute magically loaded in.&lt;/p&gt;
    &lt;p&gt;When you loaded this website, my program received a HTTP request coming from your IP address. It immediately started running a traceroute to your IP. Then, the server started responding to the HTTP request: it sent the beginning of this web page, and then it left the connection open. As ktr, my traceroute program, gave the server updates on your traceroute, it rendered the relevant HTML and sent it to your computer. When the traceroute finished, the server generated all the text and sent the rest of the website along the line before closing out the connection.&lt;/p&gt;
    &lt;p&gt;You may have noticed that the traceroute progressively loads in lines above the bottom line. Web pages can only load forward. Since I didn‚Äôt want to use any JavaScript, I did the hackiest thing possible: every time I update the traceroute display, I embed a CSS block that hides the previous iteration! Since browsers render CSS as the page is loading, this made it look like the traceroute was being edited over time.&lt;/p&gt;
    &lt;head rend="h3"&gt;Front to Back, Back to Front&lt;/head&gt;
    &lt;p&gt;My claim that this website‚Äôs traceroute was the path your packets took to reach my server was a bit of a white lie. To calculate that, I would‚Äôve had to be able to run a traceroute to my server from your computer. Instead, I ran the traceroute from my server to your computer and just reversed it. That‚Äôs also why the traceroute at the top seemingly loads in reverse order.&lt;/p&gt;
    &lt;p&gt;Does running a ‚Äúreverse traceroute‚Äù sacrifice accuracy? A little, actually.&lt;/p&gt;
    &lt;p&gt;As I said when describing Internet routing, each device a packet traverses makes a decision about where to send the packet next until it reaches its final destination. If you send a packet in the other direction, the devices might make different routing decisions‚Ä¶ and if one device makes one different decision, the rest of the path will certainly be different.&lt;/p&gt;
    &lt;p&gt;This reverse traceroute is still helpful. The paths will be roughly the same, likely differing only in terms of which specific routers see your packet.&lt;/p&gt;
    &lt;head rend="h3"&gt;So, What Are All Those Networks?&lt;/head&gt;
    &lt;p&gt;This site began with talk about the ‚Äúnetworks‚Äù you traversed to reach my server. What, concretely, are these networks?&lt;/p&gt;
    &lt;p&gt;Each network, also called an autonomous system (AS), is a collection of routers and servers that are privately connected to each other and generally owned by the same company. The owners of these autonomous systems decide the shape of the Internet by choosing which other autonomous systems to connect to. Internet traffic travels across autonomous systems that have ‚Äúpeering arrangements‚Äù with each other.&lt;/p&gt;
    &lt;p&gt;The Internet is often described as an open, almost anarchistic network connecting computers, some owned by people like you and me, and some owned by companies. In reality, the Internet is a network of corporation-owned networks, access and control to which is governed by financial transactions and dripping with bureaucracy.&lt;/p&gt;
    &lt;p&gt;If you want your own autonomous system, you can apply for an autonomous system number (ASN) with one of the five regional Internet registries (RIRs) that govern the Internet‚Äôs numbers. Be warned, they probably won‚Äôt listen to you if you aren‚Äôt backed by a company or you don‚Äôt have enough points of presence on the Internet. Just like we use IP addresses to identify‚Äî&lt;/p&gt;
    &lt;p&gt;Wait, what exactly do IP addresses identify? Uh‚Ä¶ let‚Äôs say they represent devices with Internet access.&lt;/p&gt;
    &lt;p&gt;‚Ä¶ Just like we use IP addresses to identify devices with Internet access, we use ASNs to identify the networks of the Internet. Those are the numbers like ‚ÄúAS24940‚Äù in the traceroute from the start.&lt;/p&gt;
    &lt;head rend="h3"&gt;Notes on WHOIS&lt;/head&gt;
    &lt;p&gt;One of the reasons I wrote a cool traceroute program myself is so I could pull information on which autonomous systems own the IPs along your traceroute. A couple of organizations try to keep track of which ASes contain which IP addresses. Many of them let you perform ASN lookups using the WHOIS protocol, so I wrote a small client to parse the responses from some servers I arbitrarily selected.&lt;/p&gt;
    &lt;p&gt;I then used this cool database called PeeringDB to figure out the companies behind the ASNs; PeeringDB has information on about 1/3rd of all autonomous systems. I used all of this information, alongside a couple hundred lines of if statements, to generate the text about network traversal for you.&lt;/p&gt;
    &lt;p&gt;WHOIS is actually an... interesting protocol to make a parser for. It turns out that the WHOIS protocol specification doesn't actually specify much. It specifies that you should make a TCP connection to the WHOIS server, send whatever you want to look up, and the server will send back some info and then terminate the connection. That‚Äôs all.&lt;/p&gt;
    &lt;p&gt;And yet, a lot of WHOIS servers will respond with structured-seeming information:&lt;/p&gt;
    &lt;p&gt;It turns out this structure is made up by the WHOIS server administrator and there just happen to be some shared conventions between servers. Even with the level of structure, the fields you want often show up with different names (origin? originas?) or even under multiple places at once.&lt;/p&gt;
    &lt;p&gt;My ‚Äúparser‚Äù ended up as less of a parser and more as a lightweight simulator of how I, a human, might read through WHOIS results to find the ASN I need.&lt;/p&gt;
    &lt;head rend="h2"&gt;BGP&lt;/head&gt;
    &lt;p&gt;When you send a packet across the Internet, routers sitting at the borders where these networks connect decide which network to send your packet to next, until it reaches the network that contains the destination device.&lt;/p&gt;
    &lt;p&gt;These border routers talk to each other about which networks they‚Äôre able to connect to using a protocol called Border Gateway Protocol (BGP).&lt;/p&gt;
    &lt;p&gt;BGP is the protocol that gives the Internet its shape, and you can‚Äôt directly speak it yourself.&lt;/p&gt;
    &lt;head rend="h3"&gt;History Time&lt;/head&gt;
    &lt;p&gt;In 1969, the same year Neil Armstrong landed on the moon, a message was (partially) sent on a prototype of the ARPANET. Over the next 20 years, this ‚Äúnetwork of interconnected computers‚Äù thing got pretty popular and everyone wanted on the train. Various universities, government agencies, and a couple random companies started making networks of their computers left and right.&lt;/p&gt;
    &lt;p&gt;A couple of these organizations started connecting their networks together so they could share data more easily. The Internet as we know it didn‚Äôt exist yet, but these network interconnections were getting out of hand and there wasn‚Äôt a great standard for coordinating them. In 1989, engineers at Cisco and IBM published RFC 1105, describing the first ever version of BGP.&lt;/p&gt;
    &lt;p&gt;Over the next couple of years, interconnected-network people got really busy as ‚Äúthe Internet‚Äù rapidly became a thing. Just one year after the BGP v1 RFC, Cisco went public and brought a lot of money into the networking industry, the term ‚ÄúIANA‚Äù was first used to refer to the random guy and his college department that were keeping track of numbers on the Internet, ARPANET shut down for good, and BGP v2 was released.&lt;/p&gt;
    &lt;p&gt;In 1994, as the Internet-is-a-thing-now whirlwind was just beginning to calm, the final major version of BGP, v4, was specified in RFC 1654. It was revised twice (in 1995 and 2006) and got some patches, but BGP v4 is still the protocol we use for choosing routes across the interconnected networks that make up the modern Internet.&lt;/p&gt;
    &lt;head rend="h3"&gt;How Does This BGP Thing Work?&lt;/head&gt;
    &lt;p&gt;Routers at the borders between autonomous systems (‚Äúborder gateways‚Äù) keep a list of every BGP route they know about, called a routing table. Each BGP route specifies the path of ASNs that could be followed to reach an autonomous system that controls a certain collection of IP addresses.&lt;/p&gt;
    &lt;p&gt;These routes across the Internet are formed by peering relationships between autonomous systems. When the border gateways of two autonomous systems peer, they are typically agreeing to:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;
        &lt;p&gt;Allow traffic to travel between the two routers, meaning BGP routes can go directly between the two ASNs.&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Keep each other up to date about the BGP routes they know about.&lt;/p&gt;
      &lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Example time! Router A of AS0001 is physically connected with Router B of AS0002 and they want to peer with each other. They send BGP messages to each other to establish a BGP session. Router A now knows that it should go through Router B for any BGP route that starts with AS0002, and vice versa.&lt;/p&gt;
    &lt;p&gt;BGP peers share the routes they know about with each other in a process called route advertisement. In our above example, when Router A connects to Router B, it would tell Router B ‚Äúhey, here are all the routes I know about, you can go through my ASN (and by extension, me) to reach all of them.‚Äù Router B adds all of those routes through Router A ‚Äî so, starting with AS0001 ‚Äî to its routing table. Whenever another one of Router A‚Äôs peers advertises a new route, Router A will advertise those forward to Router B.&lt;/p&gt;
    &lt;p&gt;AS0001 probably directly controls some IP addresses itself. Router A would advertise those to Router B as well. Router B would then, in turn, advertise those direct routes forward, telling its peers that AS0002 ‚Üí AS0001 is a valid route to reach those IPs. Through this process of forwarding route advertisements to peers, BGP routes are propagated across the entire network of autonomous systems such that any border gateway hopefully knows one or multiple AS paths to reach any IP on the Internet.&lt;/p&gt;
    &lt;p&gt;To route a packet to a certain IP, a border gateway first searches its routing table for every route that would bring it to an AS that controls that IP. The router then picks the ‚Äúbest‚Äù route by various heuristics that include looking for the shortest path and weighing hardcoded preferences for or against certain autonomous systems. Finally, it routes the packet to the first AS in that path by sending it to that AS‚Äôs gateway router which it is peered with. That router, in turn, looks at its own routing table and makes its own decision about where to send the packet next.&lt;/p&gt;
    &lt;head rend="h2"&gt;Recap&lt;/head&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;
        &lt;p&gt;When you loaded this website, it used my custom traceroute program to run a traceroute to your public IP (135.237.130.147), stream that over HTTP, and then render a textual explanation of the traceroute.&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;A traceroute depicts the path of routers traversed between two devices on the Internet. My particular implementation works by sending ICMP packets with increasing TTL fields.&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;These routers are in networks called autonomous systems. Routers on the edges of these ASes peer with each other using BGP. Border routers use BGP to share their routing tables with each other, and then use this knowledge to make routing decisions.&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;BGP peering sessions are created according to (often private) arrangements between the owners of autonomous systems. Since traffic can only pass between peered networks, these arrangements are the sole governor of reachability on the Internet.&lt;/p&gt;
      &lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h2"&gt;Epilogue&lt;/head&gt;
    &lt;p&gt;I was frustrated with the state of understanding on the structure of the Internet and sought to write a comprehensive, interactive article covering its history and politics through the lens of protocols. However, I got caught up in a lot of complexity in life and, facing tight deadlines, didn't have the time to reach the lofty goals I had set for myself.&lt;/p&gt;
    &lt;p&gt;Thanks to the encouragement of my friends at Hack Club, I made the best out of what I had. ‚ÄúBetter to ship a tiny raft than never ship that cruise yacht!‚Äù If nothing else, I got to make use of the sick ass traceroute program that powers the shiniest part of this site :)&lt;/p&gt;
    &lt;p&gt;I hope this serves as another fun, informative, and well-crafted thing on the web that can last, be shared around, and inspire people.&lt;/p&gt;
    &lt;p&gt;With love,&lt;lb/&gt;Lexi&lt;/p&gt;
    &lt;head rend="h3"&gt;Other Stuff&lt;/head&gt;
    &lt;p&gt;Some things to check out:&lt;/p&gt;
    &lt;p&gt;Proudly open source:&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://how-did-i-get-here.net/"/><published>2025-11-07T20:01:09+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45850671</id><title>Ribir: Non-intrusive GUI framework for Rust/WASM</title><updated>2025-11-08T03:17:07.299362+00:00</updated><content>&lt;doc fingerprint="3f0af00b0dad9a36"&gt;
  &lt;main&gt;
    &lt;p&gt;Use Rust to build multi-platform applications from a single codebase.&lt;/p&gt;
    &lt;p&gt;Ribir is a Rust GUI framework that helps you build beautiful and native multi-platform applications from a single codebase.&lt;/p&gt;
    &lt;p&gt;Experience a novel approach to UI development that's directly based on your data structure APIs. Any data mutation will trigger a precise UI update. Your focus should be on designing your data structure and its APIs. Then, you can describe your data's UI without intruding on its logic.&lt;/p&gt;
    &lt;p&gt;A simple example of a counter:&lt;/p&gt;
    &lt;p&gt;To use Ribir without DSL:&lt;/p&gt;
    &lt;code&gt;use ribir::prelude::*;
fn main() {
  App::run_with_data(
    || Stateful::new(0),
    move |cnt: &amp;amp;'static Stateful&amp;lt;i32&amp;gt;| {
      let c_cnt = cnt.clone_writer();
      let mut btn = Button::declarer();
      btn
        .on_tap(move |_| *c_cnt.write() += 1)
        .with_h_align(HAlign::Center)
        .with_v_align(VAlign::Center);
      btn.finish().with_child(pipe!($read(cnt).to_string()))
    });
}&lt;/code&gt;
    &lt;p&gt;More Examples&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Declarative language It doesn't introduce a completely new language. Instead, it provides a set of Rust macros for easier interaction. You can choose to use it or not.&lt;/item&gt;
      &lt;item&gt;Widgets compose system has four kinds of widgets to support you can implement your widget in different ways: &lt;list rend="ul"&gt;&lt;item&gt;function widget and &lt;code&gt;Compose&lt;/code&gt;, from other widgets composition.&lt;/item&gt;&lt;item&gt;&lt;code&gt;Render&lt;/code&gt;, implement your layout and paint anything you want.&lt;/item&gt;&lt;item&gt;&lt;code&gt;ComposeChild&lt;/code&gt;, control the compose logic between parent and child widgets and specify the template of child widgets.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;function widget and &lt;/item&gt;
      &lt;item&gt;Non-intrusive state converts your data to a listenable state and updates the view according to the change of the state.&lt;/item&gt;
      &lt;item&gt;Layout system learning and inspired by Flutter Sublinear layout, but not the same.&lt;/item&gt;
      &lt;item&gt;Event system is a composition event system, that supports event bubbling and capture. Allow to compose with any widget, and exists only if you use it.&lt;/item&gt;
      &lt;item&gt;Theme System: Supports using different themes for various parts of the sub-tree and enables theme modifications at runtime.&lt;/item&gt;
      &lt;item&gt;Painter converts the view to 2D paths.&lt;/item&gt;
      &lt;item&gt;GPU render is a backend of the Painter, do path tessellation so that you can easily render the triangles in any GPU render engine. A wgpu implementation is provided as the default GPU render engine. Tessellation base on [lyon].&lt;/item&gt;
      &lt;item&gt;Text support basic text typography and IME input, in a usable but rough stage.&lt;/item&gt;
      &lt;item&gt;Widgets library provides 20+ basic widgets, but all are in a rough stage, and the API is not stable yet.&lt;/item&gt;
    &lt;/list&gt;
    &lt;table&gt;
      &lt;row span="2"&gt;
        &lt;cell role="head"&gt;Platform&lt;/cell&gt;
        &lt;cell role="head"&gt;Support situation&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;Linux&lt;/cell&gt;
        &lt;cell&gt;‚úÖ&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;Windows&lt;/cell&gt;
        &lt;cell&gt;‚úÖ&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;macOS&lt;/cell&gt;
        &lt;cell&gt;‚úÖ&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;iOS&lt;/cell&gt;
        &lt;cell&gt;üöß Not yet&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;Android&lt;/cell&gt;
        &lt;cell&gt;üöß Not yet&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;cell&gt;Web&lt;/cell&gt;
        &lt;cell&gt;‚úÖ&lt;/cell&gt;
      &lt;/row&gt;
    &lt;/table&gt;
    &lt;p&gt;Ribir is actively being developed and tested on desktop platforms, with both desktop and web platforms integrated into our CI/CD pipeline.&lt;/p&gt;
    &lt;p&gt;While the framework can compile and run on mobile platforms, we haven't fully tested or adapted the user interface for them yet. We plan to focus on mobile support once the core framework is stable and a production-ready widget library is released.&lt;/p&gt;
    &lt;p&gt;If you like Ribir, give our repo a ‚≠ê STAR ‚¨ÜÔ∏è and WATCH üëÄ our repository to stay updated with the latest developments!&lt;/p&gt;
    &lt;p&gt;Every encouragement and feedback can support us to go further.&lt;/p&gt;
    &lt;p&gt;We are grateful to the community for contributing bug fixes and improvements.&lt;/p&gt;
    &lt;p&gt;üòé New to Ribir?&lt;/p&gt;
    &lt;p&gt;Start learning about the framework by helping us improve our documentation. Feel free to open a new "Documentation" issue. We are also very welcome:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Point out to us where our document has misunderstandings&lt;/item&gt;
      &lt;item&gt;Pull requests which improve test coverage&lt;/item&gt;
      &lt;item&gt;Add undocumented code (e.g. built-in widget)&lt;/item&gt;
      &lt;item&gt;Report typo&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;For more information please readÔºö&lt;/p&gt;
    &lt;p&gt;ü§î Confused about something?&lt;/p&gt;
    &lt;p&gt;Feel free to go to Discussions and open a new "Q&amp;amp;A" to get help from contributors. Often questions lead to improvements to the ergonomics of the framework, better documentation, and even new features!&lt;/p&gt;
    &lt;p&gt;üò± Found a bug?&lt;/p&gt;
    &lt;p&gt;Please report all bugs! We are happy to help support developers fix the bugs they find if they are interested and have the time.&lt;/p&gt;
    &lt;p&gt;This project exists thanks to all the people who contributed:&lt;/p&gt;
    &lt;p&gt;We also found inspiration from the following frameworks:&lt;/p&gt;
    &lt;p&gt;Ribir is MIT-licensed&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://github.com/RibirX/Ribir"/><published>2025-11-07T20:26:26+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45850751</id><title>VLC's Jean-Baptiste Kempf Receives the European SFS Award 2025</title><updated>2025-11-08T03:17:06.698650+00:00</updated><content>&lt;doc fingerprint="b6d75310e006ab2c"&gt;
  &lt;main&gt;
    &lt;head rend="h1"&gt;Jean-Baptiste Kempf receives the European SFS Award 2025 at SFSCON&lt;/head&gt;
    &lt;p&gt;The FSFE and LUGBZ have recognized VLC president and core developer with this European award for his long-term dedication to the project. What began as a student initiative has, through his continuous effort, evolved into one of the most widely used media players, with billion of users worldwide.&lt;/p&gt;
    &lt;p&gt;The Free Software Foundation Europe (FSFE), together with the Linux User Group Bolzano‚ÄëBozen (LUGBZ), is proud to recognize Jean-Baptiste Kempf with the European SFS Award 2025, in recognition of his outstanding and lasting contributions to the Free Software movement and his long-term dedication to the VLC project.&lt;/p&gt;
    &lt;p&gt;Born as a student project in 1996, this software has evolved into an essential, all-in-one media player that plays almost anything effortlessly. Originally a simple network streaming client, it has grown into a powerful universal media player that continues to evolve and impress.&lt;/p&gt;
    &lt;p&gt;‚ÄúFor many people running non-free operating systems, it was the very first Free Software they ever installed. For many people running Free Software, it saved them from installing and booting into a proprietary operating system‚Äù, declared Matthias Kirschner, president of the FSFE during the Award ceremony.&lt;/p&gt;
    &lt;p&gt;Jean-Baptiste Kempf joined the project as a student, and when it faced the risk of dying after the graduation of its original developers, he took the reins. With the help of other core developers, he transformed it into the indispensable media player we rely on today.&lt;/p&gt;
    &lt;p&gt;Over the years, Kempf has become not only the president of the VideoLAN non-profit but also one of the lead developers of VLC Media Player and the founder of VideoLabs. ‚ÄúIt‚Äôs small, fast, friendly, and seems to "understand everything you throw at it. I have always thought of it as "the program that eats everything", said Raphael Barbieri, a member of LUGBZ, during the winner‚Äôs announcement.&lt;/p&gt;
    &lt;quote&gt;"I am extremely honoured to receive the European SFS Award. The Free Software multimedia community is quite niche and unknown, but we work hard so that video content can be free, can be played and processed. The work done around the VideoLAN community has been tremendous, despite its little resources. I want to thank the whole VideoLAN and FFmpeg teams, who spend their time on those projects, often with little recognition", declares Jean-Baptiste Kemp.&lt;/quote&gt;
    &lt;head rend="h3"&gt;The European SFS Award&lt;/head&gt;
    &lt;p&gt;The European SFS Award recognizes individuals whose work has made a significant and sustained difference in advancing Free Software across Europe. Since 2023 it is presented jointly by LUGBZ and the FSFE and honours those whose efforts strengthen software freedom, community building, and the ethical foundations of technology.&lt;/p&gt;
    &lt;p&gt;In previous years, the award was given to Frank Karlitschek (2023) for his leadership with Nextcloud, and posthumously to Bram Moolenaar (2024) for creating the Vim editor.&lt;/p&gt;
    &lt;head rend="h3"&gt;2025 Laudatio&lt;/head&gt;
    &lt;p&gt;Raphael: There‚Äôs a program most of us have used - on laptops, phones, tablets or desktops computers. It might have run on screens in supermarkets or shops. It‚Äôs small, fast, friendly, and seems to "understand everything you throw at it". I have always thought of it as "the program that eats everything."&lt;/p&gt;
    &lt;p&gt;Matthias: This amazing software did not come from a giant technology company with a huge budget. It began more than twenty years ago - as a modest experiment by a few students at an engineering school. They wanted to solve a problem they identified. Nothing fancy - just a student project to tinker, experiment, share, and have fun. No one knew that those first lines of code written for ‚Äúnetwork 2000‚Äù would one day reach billions of users.&lt;/p&gt;
    &lt;p&gt;Raphael: Like many student projects, it almost faded away when graduation came and the contributors had other priorities. But one young engineer, who had joined the group in 2000, refused to let it die. He reorganised the code, inspired new contributors, and slowly turned a university experiment into a world-class piece of software.&lt;/p&gt;
    &lt;p&gt;Matthias: He built a healthy community fostering the software. Hundreds of volunteers joined. They contributed by programming, testing, auditing, helping others, with translations, improving the design, or promoting the software. Thereby the community grew and people started using the software on every platform ‚Äì GNU/Linux and other Unix like operating systems, Windows, Android, or MacOS and iOS. For many people running non-free operating systems, it was the very first Free Software they ever installed. For many people running Free Software, it saved them from installing and booting into a proprietary operating system.&lt;/p&gt;
    &lt;p&gt;Raphael: With this success our winner was offered tempting deals - big money, advertising, corporate buyouts. Every time, he gently said no. Because it was not about maximising profit. It was about maximising freedom for computer users.&lt;/p&gt;
    &lt;p&gt;Matthias: To protect that freedom, he later founded a non-profit organisation - so the software would always belong to its community. He also founded a company to support the technical side - keeping development professional while staying true to the values of software freedom. Under his leadership, the initiative has reached billions of downloads, maintained and added amazing features - all without losing its soul.&lt;/p&gt;
    &lt;p&gt;Raphael: And there‚Äôs another thing this community is famous for - its sense of humour. Their symbol? A bright orange-and-white traffic cone. Legend has it that the original students used to collect these cones after late nights out. When it came time to pick a logo, they chose it proudly - a playful symbol of creativity, chaos, and collaboration.&lt;/p&gt;
    &lt;p&gt;Matthias: Nowadays, that little cone has become an icon you find on a huge amount of computers worldwide. At conferences their contributors wear the cones on their heads with pride as a clear sign of who they are and what they stand for.&lt;/p&gt;
    &lt;p&gt;Raphael: And the person behind it? He‚Äôs not just a brilliant engineer. He‚Äôs a leader, a mentor, and a true advocate for software freedom. In 2018, his contributions were honoured with the title of Chevalier de l‚ÄôOrdre National du M√©rite - the first Free Software developer ever to receive that distinction. Yes - a real knight of software freedom.&lt;/p&gt;
    &lt;p&gt;Matthias: His ‚ÄúHoly Grail‚Äù was not fame or fortune - it‚Äôs freedom: the freedom for billions of people to watch, listen, and share multimedia files without restrictions or surveillance. He has shown the world that integrity, community, and a bit of humour can change how we experience digital media.&lt;/p&gt;
    &lt;p&gt;Raphael: Today, we celebrate someone who has made it possible for all of us to enjoy open, universal access to media - and who continues to prove that Free Software is powerful, beautiful, and fun.&lt;/p&gt;
    &lt;p&gt;Matthias: It is our great pleasure to present the European SFS Award 2025 to the president of the VideoLAN non-profit, one of the lead developers of VLC media player, the founder of VideoLabs, the bearer of the traffic cone, and a true knight of Free Software....&lt;/p&gt;
    &lt;p&gt;Matthias &amp;amp; Raphael: Jean-Baptiste Kempf!&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://fsfe.org/news/2025/news-20251107-01.en.html"/><published>2025-11-07T20:31:36+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45850963</id><title>YouTube Removes Windows 11 Bypass Tutorials, Claims 'Risk of Physical Harm'</title><updated>2025-11-08T03:17:06.192691+00:00</updated><content>&lt;doc fingerprint="b1c7b814f997e5f3"&gt;
  &lt;main&gt;
    &lt;p&gt;We are no strangers to Big Tech platforms occasionally reprimanding us for posting Linux and homelab content. YouTube and Facebook have done it. The pattern is familiar. Content gets flagged or removed. Platforms offer little explanation.&lt;/p&gt;
    &lt;p&gt;And when that happens, there is rarely any recourse for creators.&lt;/p&gt;
    &lt;p&gt;Now, a popular tech YouTuber, CyberCPU Tech, has faced the same treatment. This time, their entire channel was at risk.&lt;/p&gt;
    &lt;head rend="h2"&gt;YouTube's High-Handedness on Display&lt;/head&gt;
    &lt;p&gt;Two weeks ago, Rich had posted a video on installing Windows 11 25H2 with a local account. YouTube removed it, saying that it was "encouraging dangerous or illegal activities that risk serious physical harm or death."&lt;/p&gt;
    &lt;p&gt;Days later, Rich posted another video showing how to bypass Windows 11's hardware requirements to install the OS on unsupported systems. YouTube took that down too.&lt;/p&gt;
    &lt;p&gt;Both videos received community guidelines strikes. Rich appealed both immediately. The first appeal was denied in 45 minutes. The second in just five.&lt;/p&gt;
    &lt;p&gt;Rich initially suspected overzealous AI moderation was behind the takedowns. Later, he wondered if Microsoft was somehow involved. Without clear answers from YouTube, it was all guesswork.&lt;/p&gt;
    &lt;p&gt;Then came the twist. YouTube eventually restored both videos. The platform claimed its "initial actions" (could be either the first takedown or appeal denial, or both) were not the result of automation.&lt;/p&gt;
    &lt;p&gt;Now, if you have an all-organic, nature-given brain inside your head (yes, I am not counting the cyberware-equipped peeps in the house). Then you can easily see the problem.&lt;/p&gt;
    &lt;p&gt;If humans reviewed these videos, how did YouTube conclude that these Windows tutorials posed "risk of death"?&lt;/p&gt;
    &lt;p&gt;This incident highlights how automated moderation systems struggle to distinguish legitimate content from harmful material. These systems lack context. Big Tech companies pour billions into AI. Yet their moderation tools flag harmless tutorials as life-threatening content. Another recent instance is the removal of Enderman's personal channel.&lt;/p&gt;
    &lt;p&gt;Meanwhile, actual spam slips through unnoticed. What these platforms need is human oversight. Automation can assist but cannot replace human judgment in complex cases.&lt;/p&gt;
    &lt;p&gt;Suggested Reads üìñ&lt;/p&gt;
    &lt;p&gt;- Even the biggest players in the Linux world don't care about desktop Linux users. We do.&lt;/p&gt;
    &lt;p&gt;- We don't put informational content behind paywall. Your support keeps it open for everyone. Think of it like 'pay it forward'.&lt;/p&gt;
    &lt;p&gt;- Don't like ads? With the Plus membership, you get an ad-free reading experience.&lt;/p&gt;
    &lt;p&gt;- When millions of AI-generated content is being published daily, you read and learn from real human Linux users.&lt;/p&gt;
    &lt;p&gt;- It costs just $2 a month, less than the cost of your favorite burger.&lt;/p&gt;
    &lt;p&gt;Become a Plus Member today and join over 300 people in supporting our work.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://news.itsfoss.com/youtube-removes-windows-11-bypass-tutorials/"/><published>2025-11-07T20:50:40+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45851495</id><title>Becoming a Compiler Engineer</title><updated>2025-11-08T03:17:06.118792+00:00</updated><content/><link href="https://rona.substack.com/p/becoming-a-compiler-engineer"/><published>2025-11-07T21:45:03+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45851786</id><title>Using the Web Monetization API for fun and profit</title><updated>2025-11-08T03:17:05.622027+00:00</updated><content>&lt;doc fingerprint="225cb0f3640da9b9"&gt;
  &lt;main&gt;
    &lt;p&gt;Then you're ready to receive payments. Here's me browsing my blog and seeing payments go out from and come in to my GateHub wallet. This is of course effectively a zero sum game, me paying myself. The 0.01 cent are the streamed payments that go out and then come in again. I tested a one-time payment as well. The 0.50 cents (not shown) was a successful one-time payment.&lt;/p&gt;
    &lt;p&gt;There's also a JavaScript API, so you can adjust the content of your page when your page notices that the user is paying.&lt;/p&gt;
    &lt;code&gt;window.addEventListener('monetization', (event) =&amp;gt; {
  const { value, currency } = event.amountSent;
  console.log(`Browser sent ${currency} ${value}.`);
  const linkElem = event.target;
  console.log('for link element:', linkElem, linkElem.href);
});&lt;/code&gt;
    &lt;p&gt;For testing purposes, you can observe these &lt;code&gt;monetization&lt;/code&gt; events in Chrome DevTools by pasting in the snippet above in the Console.&lt;/p&gt;
    &lt;p&gt;This way you could, for example, remove ads, or unlock an article when you notice a one-time payment. On my blog, I just show a "thank you" message for now.&lt;/p&gt;
    &lt;p&gt;I'm really bulli$h on this proposed standard. Hopefully someone else will try it and let me know how it goes. I truly and honestly believe that this could be the future for making the Web of tomorrow financially sustainable for publishers, big and small.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://blog.tomayac.com/2025/11/07/using-the-web-monetization-api-for-fun-and-profit/"/><published>2025-11-07T22:13:37+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45852011</id><title>He Jiankui PhD Thesis: Spontaneous Emergence of Hierarchy in Biological Systems (2010)</title><updated>2025-11-08T03:14:49.751858+00:00</updated><content>&lt;doc fingerprint="365a9065c1379239"&gt;
  &lt;main&gt;
    &lt;head rend="h1"&gt;Let's Design an RP2040 Devboard!&lt;/head&gt;
    &lt;p&gt;Today, we're going to be designing our own dev board, using one of the most popular and beginner friendly SoC's, the RP2040. This guide doesn't serve as just a tutorial, but also as an opportunity to learn what everything on the PCB fundamentally does, and what every single component on your PCB is actually for!&lt;/p&gt;
    &lt;p&gt;All the source files for this tutorial can be found here, so if you need any help, feel free to resort to the repository!&lt;/p&gt;
    &lt;p&gt;Now let's start off with the basic question, what's an SoC! An SoC or system on chip, basically has all the basic components like SRAM, processors, USB controllers, and other peripherals you'll break out onto your board. The RP2040 is a good SoC to start with, because the datasheets are simple, it's low-cost, has good on-chip memory and is really flexible with plenty of IO's.&lt;/p&gt;
    &lt;p&gt;Now let's get right into it, we'll be using KiCad for this tutorial, and I would suggest completing the hackpad tutorial and maybe a keyboard before trying to make your own devboard, not because you won't be able to make it, but you'll understand how it works a bit better.&lt;/p&gt;
    &lt;p&gt;So create a new KiCad project by going: &lt;code&gt;File -&amp;gt; new project, and choosing your name/folder for the project&lt;/code&gt;&lt;/p&gt;
    &lt;p&gt;After that, double click your schematic to start working on your PCB. PCB's essentially have 2 main parts, the schematic, and the actual PCB.&lt;/p&gt;
    &lt;p&gt;The schematic is basically a wiring diagram, that shows how everything will connect, but isn't like exactly where the components are placed or how thick your traces are, it's solely to show how everything is wired, not where.&lt;/p&gt;
    &lt;p&gt;This is how are schematic will look when done the tutorial&lt;/p&gt;
    &lt;p&gt;The PCB editor is where you'll place down all your components and route everything for when you get it actually manufactured.&lt;/p&gt;
    &lt;head rend="h2"&gt;Starting the schematic&lt;/head&gt;
    &lt;p&gt;So enter in your schematic, and then tap "a", this will open up the symbol library, which is the place where you can find component blocks that you'll wire together to form the schematic for your project. Search for the RP2040, and just place it down in the center of your schematic.&lt;/p&gt;
    &lt;p&gt;You'll notice the symbol and actual component are 2 different things if you look at the first screenshot. The symbol just tells you all the pins on the component, and how they'll be wired to what. The actual component has the physical pads where traces will actually connect to on your PCB!&lt;/p&gt;
    &lt;p&gt;Our entire schematic will consist of 5 main elements: power, flash storage, the crystal oscillator, I/O (input/outputs), and your SoC, the RP2040! The Raspberry Pi datasheet explains how all of this will pretty much be wired, and I'm kind of just here to explain exactly how it all works too.&lt;/p&gt;
    &lt;p&gt;So first let's talk about power and some schematic good practices!&lt;/p&gt;
    &lt;p&gt;You'll notice that the RP2040 has capacitors, these are called decoupling capacitors. These capacitors are used for 2 main things, filtering out power supply noise and giving a local power supply if components need it at short notice. You can think of it like a stream of water, without the capacitors it can be jittery and unpredictable, but with the capacitors, the stream smooths out, making your PCB function more reliable.&lt;/p&gt;
    &lt;p&gt;You usually want to put one 0.1uF (or 100nF, the F stands for Farads) decoupling capacitor per power pin, but it's fine to deviate a bit from that, but that's the most optimal way of doing it and what we're going to do.&lt;/p&gt;
    &lt;p&gt;We're also going to put a 1uF decoupling capacitor on each power line. You'll notice that the RP2040 has a +1V1 (1.1V) and a +3V3 (3.3V) line, we want to put a 1uF decoupling capacitor per line, to act as a larger reservoir and to smoothen out larger ripples that could occur. With the RP2040, these 1uF capacitors are mostly to help provide a stable 1.1V supply. With this combination, we'll filter out nearly all the noise and have a smooth functioning PCB.&lt;/p&gt;
    &lt;p&gt;So go back into your schematic and then tap on the "Draw Wires" icon to connect the VREF_VOUT and DVDD, and then separately connect the IO_VDD, USB_VDD, ADC_AVDD and VREG_IN, because these pins have different voltages.&lt;/p&gt;
    &lt;p&gt;Now before we go further, remember that all power labels face UPWARDS, and all ground labels face DOWNWARDS, this isn't necessary for the schematic to work, but it's good schematic practices that you should always follow&lt;/p&gt;
    &lt;p&gt;Then tap "p" to open up the POWER symbol library (you can also tap a, but searching in p will be faster because there's less symbols), and search for "1V1" and "3V3" and place the 1.1V on the VREG_VOUT and DVDD, and 3.3V on the IOVDD and those other pins.&lt;/p&gt;
    &lt;p&gt;Now schematic good practices is to always put at least a small wire between symbols like this for clarity.&lt;/p&gt;
    &lt;p&gt;Now that we have our power symbols in, we're going to add the decoupling. You could technically wire them like the screenshot I showed before, but I prefer to separate them because you use less wire which I find looks cleaner, but it's up to personal preference, and readability.&lt;/p&gt;
    &lt;p&gt;You'll also notice that the symbol contains less pins than the symbol the RP2040 datasheet has, this is because symbols in KiCad tend to not repeat the same pins, so they just merge like all the same VDD pins into one.&lt;/p&gt;
    &lt;p&gt;But using the RP2040 datasheet as reference, we know that there's 8 IO VDD pins, so eight 0.1uF decoupling, and one 1uF cap because we're wiring the entire 3.3V line and need to smooth out the larger ripples. So let's just place all those in!&lt;/p&gt;
    &lt;p&gt;Again type "a" and search for "c" (the shorthand for capacitor). Make sure to double tap the capacitors to add a value, and make eight of them 0.1uF, and one of them 1uF.&lt;/p&gt;
    &lt;p&gt;These are the decoupling capacitors for the 3.3V line, now we need to do the caps for the 1.1V line. There's 2 VDD pins, so two, 0.1uF caps, and we need one for the line too, so a 1uF cap aswell:&lt;/p&gt;
    &lt;p&gt;Now we have all of our power decoupling. We also need to connect GND to the SoC, this is pretty self-explanatory, but it allows power to actually flow properly in our PCB.&lt;/p&gt;
    &lt;head rend="h2"&gt;Working on USB-C&lt;/head&gt;
    &lt;p&gt;We have our power decoupling, but we don't actually have a power source yet or a way to program our devboard yet, so let's do that now. I'm going to be using USB-C because it's standard and fast!&lt;/p&gt;
    &lt;p&gt;So tap "a", type in whatever receptacle you want, and add it in. Make sure you pick "receptacle" and not plug because a plug would plug into your laptop instead of having a cable plug into it.&lt;/p&gt;
    &lt;p&gt;Now let's explain each of these pins:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;SHIELD/GND will both go to ground, shield is conductive material wrapped around the data pins on the receptacle, and this just improves EMI by grounding it.&lt;/item&gt;
      &lt;item&gt;D+/D- are the data pins, these transfer data to/from the USB-C receptacle. You'll want to connect the D-'s and D+'s together so that they both transfer data.&lt;/item&gt;
      &lt;item&gt;CC1 and CC2 basically tell the receptacle to allow power to go through to power the board. These by standard (the datasheet tells you) are pulled down (go to GND) through 5.1K resistors.&lt;/item&gt;
      &lt;item&gt;VBUS is the 5V input, this will need to be stepped down to 3.3V to power our MCU (microcontroller)&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Now that we know what everything does, let's wire it up. Shield/GND go to GND:&lt;/p&gt;
    &lt;p&gt;D+ and D- are attached to their relative pair, and then will go into the MCU, but for now, we'll just have a global label going out of them. Global labels are basically like little teleporters, that allow you to say that something is wiring, without manually putting a wire between them.&lt;/p&gt;
    &lt;p&gt;Technically global labels are meant to be used between different schematic sheets and net labels would be the correct thing to use here, but I find global labels are cleaner if you only have one schematic for your PCB.&lt;/p&gt;
    &lt;p&gt;To do this, tap global label in the right hand toolbar, type in the name for your label (USB_D+ and USB_D-), and add them to the pins:&lt;/p&gt;
    &lt;p&gt;Next, pulldown the CC pins through a 5.1K resistor to GND to enable power to go through the USB-C receptacle. Open up the symbol library, and then type "r" the shorthand for resistors, and then place it down and edit the value to be 5.1K:&lt;/p&gt;
    &lt;p&gt;Remember to follow proper schematic good practices, and to have clearly visible values, and labels for your components. Feel free to edit the text of stuff to make your schematic cleaner, just don't make stuff too small.&lt;/p&gt;
    &lt;p&gt;Now we just need to wire in the input voltage, but the thing is, the voltage of USB-C is 5V, while the voltage that the RP2040 uses as input, needs to be 3.3V so you don't cook it. To achieve this, we'll use what's called an LDO, or a Low-Dropout Regulator to take the voltage down.&lt;/p&gt;
    &lt;p&gt;Specifically, we'll be using the NCP1117, a classic and reliable fixed voltage regulator (I actually switch this regulator out later for the MCP1700, 3.3V, because it's really big on our PCB). A fixed voltage regulator is handy here, because we only need to go down to 3.3V instead of like 1.5V per say or something random, and it uses less components. We'll also be using the SOT-223 footprint (or package is the common term) because it's small and we don't really have any thermal issues with a devboard.&lt;/p&gt;
    &lt;p&gt;So add in the NCP1117-3.3_SOT223 symbol, wire GND and attach VBUS to the VI (voltage input) of the LDO.&lt;/p&gt;
    &lt;p&gt;Remember to always keep your schematic clean and feel free to use up quite a bit of space. Now like the decoupling capacitors on our RP2040, we need capacitors on the LDO. But we don't need fine decoupling capacitors for precise input lines into an MCU, and instead we need bulk capacitors, to handle the large voltage ripples when moving a voltage down.&lt;/p&gt;
    &lt;p&gt;So we need to place two, 10uF capacitors on each side of the LDO, for input/output, so add them into your schematic:&lt;/p&gt;
    &lt;p&gt;Next, we want to add our power labels to the LDO, we'll put a VBUS label before the LDO/Bulk cap, and a +3V3 label to the VO (voltage out) of the LDO. We might use 5V to power some other devices so we'll want to provide a power line for that too:&lt;/p&gt;
    &lt;p&gt;Now to finish off the USB-C wiring, we need to make sure the MCU receives the data lines. It's standard to have these going through 27 ohm resistors into the MCU to prevent distortions of the signals at high speeds, these are called termination resistors.&lt;/p&gt;
    &lt;p&gt;So wire the USB D+ and D- pairs into the MCU USB_DP and USB_DM (the P is for + and the M is for -) through 27 ohm resistors:&lt;/p&gt;
    &lt;p&gt;Now USB D+ and D- are actually what's called "bidirectional", this means that they work both ways. You don't actually need to specify this, but good schematic practices is to make sure your global labels reflect that. Currently they're just set as "inputs" because the triangle is facing inwards, so double click on all the D+ and D- labels and set them to bidirectional:&lt;/p&gt;
    &lt;head rend="h2"&gt;The crystal oscillator&lt;/head&gt;
    &lt;p&gt;Now to make our USB and other peripherals actually work properly, we need to have what's called a crystal oscillator. This is a little piezoelectric quartz crystal that vibrates very precisely, and then it's amplified and fed into the MCU to act as a clock signal that controls the digital peripherals.&lt;/p&gt;
    &lt;p&gt;For example, you definitely want a crystal oscillator if you're using USB-C, because the data needs to come in at specific times, so it makes sure no data is incorrectly received. Because the clock is such a precise component, you want to wire it really carefully. That means it should be as close to the MCU as possible on the PCB (schematic doesn't matter, it's just a reference), and it needs really small capacitors, to smooth out the signals.&lt;/p&gt;
    &lt;p&gt;First add the global labels to the MCU XIN and XOUT, just called their relative name. XOUT is the output from the crystal so an input to the MCU, and XIN is an output from the MCU to help the crystal oscillate properly:&lt;/p&gt;
    &lt;p&gt;Remember to accurately represent your global label direction, but just keep in mind it doesn't actually change your schematic, it's only for whoever is reading it!&lt;/p&gt;
    &lt;p&gt;Based off the RP2040 datasheet, we're going to be using a 12 MHz crystal with two, 15pF (I switch these later to 33pF because we use a different crystal than the Pi Pico) decoupling capacitors. Make sure to use the crystal footprint with 4 pins and 1 and 3, as the input/output pins so pay attention to the symbol I use:&lt;/p&gt;
    &lt;p&gt;Pins 2, and 4 just go to GND, pins 1 and 3 need a 15pF cap in series, and XOUT will have a 1K resistor. This resistor is called a damping resistor and it prevents the crystal from being damaged and ensures good signal integrity:&lt;/p&gt;
    &lt;p&gt;Remember all your schematic good practices and make sure everything looks clean.&lt;/p&gt;
    &lt;p&gt;We haven't actually seen these types of caps yet, these are called external load capacitors, and they're placed in series with the crystal I/O's, these basically just ensure that the crystal resonates at it's proper frequency, I'd suggest researching a bit more if you're interested!&lt;/p&gt;
    &lt;head rend="h2"&gt;Flash storage&lt;/head&gt;
    &lt;p&gt;Now lot's of SoC's include flash storage, but the RP2040 actually doesn't, so we need to add on our own flash storage! You can think of flash storage as like a faster version of an HDD, with less power consumption, more reliability but is usually a bit more expensive.&lt;/p&gt;
    &lt;p&gt;Sadly, the RP2040 only supports up to 16mb of memory, so we'll just use a quad SPI flash memory IC (integrated circuit, those little chips on a board) like the W25Q128JVS used in the datasheet.&lt;/p&gt;
    &lt;p&gt;Now before we actually add it to our schematic, let's talk about what SPI is. If you continue to build PCB's, you'll see this communication interface very often, it's basically just a standardized way of transferring data. The signal comes out of the master, and then goes into slave devices. The master is our MCU in this case, and the slave, is our flash memory.&lt;/p&gt;
    &lt;p&gt;It has 4 major pins you need to understand:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;MOSI - Master output, slave input&lt;/item&gt;
      &lt;item&gt;MISO - Master input, slave output&lt;/item&gt;
      &lt;item&gt;SCLK - Clock signal (remember that oscillator we added to our board, this will basically do that for other devices)&lt;/item&gt;
      &lt;item&gt;SS/CS - Slave select, let's you choose what device you're communicating with&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;So you usually need to have all 4 of those, and then you can add SS pins as you wish if you want to communicate with more and more devices.&lt;/p&gt;
    &lt;p&gt;But we're actually using quad SPI in this case.&lt;/p&gt;
    &lt;p&gt;Quad SPI uses the same CLK and CS pin, but has 4 IO pins, so it can transfer data, 4x as fast as SPI, which is ideal for flash memory, but it does take up more pins, so that's why it's not always used.&lt;/p&gt;
    &lt;p&gt;Now you can't just attach SPI to any GPIO, you have to use what's called a hardware controller, which you can imagine, is like a little block on the RP2040 SoC that is specifically meant for SPI. There are 2 SPI controllers on the RP2040, so we're going to use them for our flash memory. You can also technically do SPI via software, but it just makes way more sense to use the actual controller provided.&lt;/p&gt;
    &lt;p&gt;So add a global label to the QSPI pins with their relative name, IO's are bidirectional, and CLK and CS/SS are inputs to the slave (the flash memory) or outputs from the MCU.&lt;/p&gt;
    &lt;p&gt;Next, add in our flash memory IC (chip), W25Q128JVS, and wire up all the QSPI pins, and put GND to GND, and VCC to 3.3V:&lt;/p&gt;
    &lt;p&gt;Next, we need to add our 100nF/0.1uF decoupling capacitor to our VCC line to filter high-frequency noise. And then, we're going to add a button to the CS line, so that we can enter what's called BOOTSEL mode.&lt;/p&gt;
    &lt;p&gt;Based off of the RP2040 datasheet, if the QSPI SS pin, see's a 0 or GND when it's booting up, it'll go into BOOTSEL, where it will appear as a USB device on our computer so that we can copy code onto it to set it up.&lt;/p&gt;
    &lt;p&gt;Now there's 2 resistors you're probably wondering about here, the pullup to 3.3V, and the one in series with the button.&lt;/p&gt;
    &lt;p&gt;The pullup to 3.3V is important, because usually the QSPI pin will show up as 3.3V to the flash memory, but during bootup, you can't guarantee that it will, because the pin isn't active, so you might have some weird thing that happens with your board. The 10K resistor is just standard that the RP2040 datasheet wants us to use (and is also pretty commonly used to filter noise and stuff).&lt;/p&gt;
    &lt;p&gt;The 1K resistor in series limits the amount of current that can flow in this part of the circuit to prevent damage to the CS pin.&lt;/p&gt;
    &lt;p&gt;And just like that, we have our button and decoupling in, and our flash memory is completed!&lt;/p&gt;
    &lt;head rend="h2"&gt;Breaking out I/O Headers&lt;/head&gt;
    &lt;p&gt;Now we have all the components for our board to actually work, so we just need to breakout all the GPIO's on the RP2040, onto header pins so that we can use them in our circuit and whatnot!&lt;/p&gt;
    &lt;p&gt;But before we do this, let's just make sure we attach TESTEN to GND on the RP2040, this pin is just meant for factories to make sure that the RP2040 SoC actually works before sending them out.&lt;/p&gt;
    &lt;p&gt;Next, we'll label all the other pins we haven't broken out (all the GPIO's, SWCLK and SWD), with their relative name on the RP2040. These are all bidirectional pins except the SWCLK pin, which is a clock output from the SoC:&lt;/p&gt;
    &lt;p&gt;I actually labelled mine the wrong direction for the rest of this tutorial, but it's purely cosmetic and won't actually impact my PCB, this is how it should actually look, don't mind the GPIO labels, I took this screenshot after being done the PCB:&lt;/p&gt;
    &lt;p&gt;Next, we're going to add the actual header pin symbols into our schematic. You can technically do this whoever you want, but I'm going to adhere to the raspberry Pi Pico pinout:&lt;/p&gt;
    &lt;p&gt;So add in a two, 1x20 header pin symbols, and one 1x3 header pin symbol, I just used generic symbols, but you could use pin header symbols if you want, it's just up to preference:&lt;/p&gt;
    &lt;p&gt;Usually you don't want to make your symbol layout look exactly like your PCB, but I think it makes it more obvious so that we don't mess up our pinout!&lt;/p&gt;
    &lt;p&gt;Next, we'll just add in all the pins, and we'll just leave out the ones we don't know yet like VSYS, 3V3_EN and ADC_VREF, I'll explain those after:&lt;/p&gt;
    &lt;p&gt;Now the Pi Pico can actually be powered by a battery, but we're not implementing a battery (if you want to, check out the Pi Pico datasheet), so there's a diode on the VBUS power line, so they have a VSYS line after the diode and a VBUS line before it, but because we don't need a diode, we don't need VSYS.&lt;/p&gt;
    &lt;p&gt;We also don't need 3V3_EN, and then ADC_VREF is kind of just another thing to give a reference voltage to ADC, but it isn't really necessary, and we're just making a simple devboard so we won't use it.&lt;/p&gt;
    &lt;p&gt;Because we have these free pins, and also some GPIO's still left, let's just fill these pins with some GPIO's. I'm going to move the ADC pins up, and then fill the other pins with GPIO's. I also want to use GPIO29 which is an ADC pin and replace GPIO25 with that just so we get the added ADC pin:&lt;/p&gt;
    &lt;p&gt;Because of this, you'll want to just no-connect GPIO25 on the MCU, just to tell KiCad and others that we're not using that pin:&lt;/p&gt;
    &lt;p&gt;If you want to add battery support, you can do so yourself, but I'm keeping to a minimum framework. And just like that, we have all of our header pins in!&lt;/p&gt;
    &lt;head rend="h2"&gt;Finishing up the schematic&lt;/head&gt;
    &lt;p&gt;Now that we have our I/O headers in, we're actually finished with all the symbols in our schematic, this is how your schematic should look:&lt;/p&gt;
    &lt;p&gt;Now to organize our schematic, even more, let's separate our design into different blocks using the text boxes in the schematic editor. When doing this, you usually want to place your component blocks by flow of your PCB. So if you could image, power flows in through the USB, so we'll put that in the corner, the MCU should be center because it's the fundamental of the PCB, and then the other stuff can just be organized around:&lt;/p&gt;
    &lt;p&gt;You don't have to do this, but I feel like it keeps everything nice and clean!&lt;/p&gt;
    &lt;p&gt;Next, run ERC to just make sure you don't have any unconnected or weird stuff happening in your schematic. The only error you might get is Input Power pin not driven by any Output Power pins. You can just ignore this error, it's basically just the fact that we're labelling our power as bidirectional, and with no input/output, but we know that the MCU takes in 3.3V and that the USB-C outputs 3.3V, so we're totally fine to ignore it.&lt;/p&gt;
    &lt;head rend="h2"&gt;Footprint time!&lt;/head&gt;
    &lt;p&gt;Now that we've finished out schematic, we need to start working on the actual PCB. The first thing you need to do for the actual PCB, is to add in all the footprints for your components.&lt;/p&gt;
    &lt;p&gt;A footprint on a PCB basically just defines it's pads, outline, etc, that your component needs in order to be solder able on a PCB. So just tap on the assign footprints tab in the top toolbar to open up the footprints tab:&lt;/p&gt;
    &lt;p&gt;Now before we add in our footprints, let's talk about standard imperial sizes of SMD components, and SMD vs THT components.&lt;/p&gt;
    &lt;p&gt;So if you don't know, there's SMD components, which are surface mount, which means that the components are attached to the surface of the PCB like caps, and then there's THT components, which are soldered through the board, these are things like the headers.&lt;/p&gt;
    &lt;p&gt;For SMD footprints, you'll want to understand what the imperial sizes are:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;0402 are the smallest footprint we'll have on our PCB, these are tiny footprints and anything smaller than this becomes too small to easily solder, these are good for low current applications, and are fine for our fine signal decoupling.&lt;/item&gt;
      &lt;item&gt;0603 footprints are a bit larger than 0402, and are better for slightly higher current and will maintain better physical stability for the larger decoupling needed for 10uF caps and such.&lt;/item&gt;
      &lt;item&gt;0805 footprints are pretty large and are really just needed in higher current applications, we won't be using any of these because we don't have any crazy large caps/components&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;So all of our 0.1uF/1uF/resistors will be 0402, and then the 10uF caps will be 0603, so just filter in the search bar for 0402/0603, and choose the resistor/capacitor footprint for the relative component:&lt;/p&gt;
    &lt;p&gt;Now these other components need to usually be found on LCSC and then you go into the datasheet to find the footprint, and then add it in, but I'm decently experienced and know what footprints to use already, so you can just copy what ones I'm using or find your own if you want and add them in:&lt;/p&gt;
    &lt;p&gt;These are my thought process behind the other components, JLCPCB has what's called basic and extended parts, and extended parts cost $3 each to add to a PCB because they have to be loaded into the assembly machines, this will be important here:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;USB_C_Receptacle_HRO_TYPE-C-31-M-12: JLCPCB doesn't have any basic part USB-C receptacles, so I just chose this one I kind of like from a previous board. PART&lt;/item&gt;
      &lt;item&gt;PinHeader_1x20_P2.54mm_Vertical: This is just the proper size header pins we need, they should be through hole/THT to be stronger instead of SMD, I mean if you wanted to, it could be SMD though. The part is just pin headers I'll buy separately&lt;/item&gt;
      &lt;item&gt;SW_Push_SPST_NO_Alps_SKRK: This is a small SMD size button footprint found in the JLCPCB basic library, so it doesn't cost anything extra and is pretty compact. This isn't actually the EXACT footprint, but it's close by like .1mm, and I found it by just scrolling through footprints with some filters. PART&lt;/item&gt;
      &lt;item&gt;Crystal_SMD_3225-4Pin_3.2x2.5mm: I found this crystal on JLCPCB basic parts, and looked at the datasheet to find the footprint. You really have to make sure your crystal footprint pinout is proper because lots of people accidentally use the wrong footprint or symbol. PART&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Now we actually need to modify our crystal schematic a bit because of the part we chose on JLCPCB has a load capacitance is slightly different, so we actually need 33pF caps. You can just search up the math if you want to learn how to do this:&lt;/p&gt;
    &lt;p&gt;And just like that, our schematic and footprint selection is finished, so we can actually get to the real fun stuff.. the PCB!&lt;/p&gt;
    &lt;head rend="h2"&gt;Let's design a PCB&lt;/head&gt;
    &lt;p&gt;Now that all that stuffs done, tap the switch to PCB editor button on the far right of the top toolbar!&lt;/p&gt;
    &lt;p&gt;This will bring you into a new editor you haven't seen yet, this is where we'll actually place down the components on our PCB, and route everything.&lt;/p&gt;
    &lt;p&gt;So in the top toolbar, tap the update PCB from schematic or F8, and then tap the update PCB button that shows up, to bring in all the components into your PCB, and just put them all in the top left corner of your PCB:&lt;/p&gt;
    &lt;p&gt;You might get some warnings which can be ignored usually (I just got some pin warnings which are fine), but there shouldn't be any errors.&lt;/p&gt;
    &lt;p&gt;Now you'll see our actual components on the PCB, our USB-C, the RP2040, the button, crystal, LDO, flash, headers and our caps/resistors!&lt;/p&gt;
    &lt;head rend="h2"&gt;PCB Layout&lt;/head&gt;
    &lt;p&gt;Now before we actually lay out all of our components, we need to define our PCB outline, holes, etc. So using the datasheet as a reference, we'll place down everything accordingly. Start with the board outline, and then do holes and stuff.&lt;/p&gt;
    &lt;p&gt;To add in a board outline, tap on the Edge.Cuts layer and then tap on Draw Rectangles, and then just put whatever size rectangle you want. After that, we'll add in the proper size from the datasheet, which is 21x51mm, so tap on the rectangle, then tap "e" and use the By Center and Size tab to do this:&lt;/p&gt;
    &lt;p&gt;Next, we'll align the header pins onto our PCB by using the position tool. So right click on one of the header pins, go Positioning Tools -&amp;gt; Position Relative To, and then go Select Point and tap one of the top corners of the board outline. And then using the datasheet, align the X to 1.61/-1.61 based off of the side, and the Y to 1.37:&lt;/p&gt;
    &lt;p&gt;(I actually swapped my pin headers here which I fix later, but just put J2 as the first header, and J3 as the second one, so it's easier to route)&lt;/p&gt;
    &lt;p&gt;Next, we need to put our bottom header in, these are aligned to Y -1.61 and the X should be centered so 7.96 (10.5 is the center, minus 2.54 the pin spacing), and use the bottom left/right as reference (make sure it's flipped horizontally when aligning):&lt;/p&gt;
    &lt;p&gt;Next, I'm going to put in the RP2040 dead center, but with the Y slightly farther down, because there's more components above the Pico than below, so I want a bit more space for signals, I'm going to put it down an extra 4mm, but you can do how much you want.&lt;/p&gt;
    &lt;p&gt;Then, I'm going to center the USB-C, down a bit to the top of the devboard:&lt;/p&gt;
    &lt;p&gt;Now looking at the flash memory and LDO IC, they're really big, so let's use different components for them:&lt;/p&gt;
    &lt;p&gt;I'm going to switch to the MCP1700 LDO, which is smaller, but does handle less current (250ma), so if you plan on drawing more current, you might want to just keep the current LDO. So just replace the NCP1700 with the MCP1700x-330xxTT, which is the 3.3V MCP1700:&lt;/p&gt;
    &lt;p&gt;And then, we're going to change the flash memory to what the Pi Pico uses and has a slightly smaller package, which is the W25Q16JVZPIQ TR and uses the Package_SON:Winbond_USON-8-1EP_3x2mm_P0.5mm_EP0.2x1.6mm footprint, so switch the footprint to that new one!&lt;/p&gt;
    &lt;p&gt;Now your footprints should be much better:&lt;/p&gt;
    &lt;p&gt;Anyways next, we're going to organize our parts onto the PCB (I also fixed my header pins and MCU orientation in this step). The LDO is going to go really close to the USB-C VBUS, and the flash storage will go close to the RP2040's QSPI pins, just so we have an efficient layout:&lt;/p&gt;
    &lt;p&gt;I use exact positioning when doing things like this, but you can just place them on if you want, I just like everything to be nicely symmetrical.&lt;/p&gt;
    &lt;p&gt;Next, I'm going to put the crystal on. The crystal should be very close to the RP2040 XIN/XOUT pins because it's a very precise signal, and the load capacitors should be RIGHT next to the pins too so the signals don't get messed up. You can then just put the resistor right by the XOUT pin of the RP2040 to have a nice and efficient layout:&lt;/p&gt;
    &lt;p&gt;Now I'm going to put all the decoupling capacitors on my board. Decoupling capacitors should be as close as possible to the pins they're decoupling, the larger the cap is, the farther it can be, but try to keep them close to their pins.&lt;/p&gt;
    &lt;p&gt;Also feel free to mess with layout a bit during this step just so everything fits in efficiently! Try to use whatever capacitor you used in your schematic for organization purposes.&lt;/p&gt;
    &lt;p&gt;First I usually group all the caps that go together, and then I usually either start with the SoC caps, or components caps, I'm going to start with the components caps:&lt;/p&gt;
    &lt;p&gt;Remember, caps go close to whatever they're decoupling. Now all the RP2040 caps are grouped together, and this is because it's just a general rule to have one cap per VDD pin, and then the larger cap/bulk cap near the largest group of them:&lt;/p&gt;
    &lt;p&gt;This is the layout I decided on, some of my thought process for this layout was:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Leave enough space to route the USB differential pair&lt;/item&gt;
      &lt;item&gt;Be able to route QSPI without via's for fast signals&lt;/item&gt;
      &lt;item&gt;Leave enough space by the crystal to be able to route those traces&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;And I'll still definitely actively update it while I route my traces, but this is a good starting point.&lt;/p&gt;
    &lt;p&gt;Now all that's left to add in, is our resistors, but I'm going to actually put these to the side, and start routing a couple things! This is because it's going to be easier to place components not in the way of where traces are going to go.&lt;/p&gt;
    &lt;p&gt;Not before we start routing, remember a couple key things about routing:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Never have a trace at a 90 degree angle, these mess with your signals, and also sometimes get manufactured weirdly&lt;/item&gt;
      &lt;item&gt;Think about what you're going to route next, so that you don't route where that trace needs to go&lt;/item&gt;
      &lt;item&gt;Know what you're routing, things like decoupling caps need to have short, small traces, etc.&lt;/item&gt;
      &lt;item&gt;Never put via's on pads, this makes it hard to solder them, and makes the component unstable&lt;/item&gt;
      &lt;item&gt;Try to route front signals vertically, and back signals horizontally, this isn't a fixed rule, but just try to do it in most spots to have efficient routing&lt;/item&gt;
      &lt;item&gt;Don't be afraid to move your components a bunch while routing, a lot of intuition is required for efficient routing&lt;/item&gt;
      &lt;item&gt;You might hear me use the term "ratlines", these are the blue lines on the PCB, I actually have mine set as curved because of personal preference, but yours will probably be straight&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;So, the first thing I'm going to route is my flash memory, I'm going to move the capacitors away temporarily while I do this and then add them back on later. So tap on the route single track in the right hand toolbar, and then route all the signals like so:&lt;/p&gt;
    &lt;p&gt;I usually start my route from the RP2040, and then put it into the component just because I find it's easier. I always start with routing my higher speed signals, and then do the lower ones.&lt;/p&gt;
    &lt;p&gt;Next, I'm going to route the USB-C data lines. Now these lines are actually special on our PCB, these need to be routed as differential pairs, basically perfectly even traces, next to each other. This is because they're carrying high speed data, so the traces need to be the same length so that data arrives at the same time.&lt;/p&gt;
    &lt;p&gt;The termination resistors for these data lines also need to be right by the RP2040 pins to smooth the signals. I'd suggest placing these perfectly evenly apart, centered on the pins so it's easy to route our differential pairs:&lt;/p&gt;
    &lt;p&gt;Now to route a differential pair. First wire the USB D+'s/D-'s together:&lt;/p&gt;
    &lt;p&gt;Then, hold the route tracks button, and go over to the symbol with 2 traces on it, or just tap 6. Then, go over to your USB-C, and tap on one of the D+/D- pins to start the trace, and route it down to your resistors. If the traces won't go into your resistors pads, that means that your resistors aren't evenly positioned, you can just the relative positioning tool to do this.&lt;/p&gt;
    &lt;p&gt;And then you can just route the resistors nets into the RP2040 nets (Make sure they're centered so the traces are the same length, you could technically do this as a differential pair if you change your schematic slightly, but it's fine if you just position properly):&lt;/p&gt;
    &lt;p&gt;I added left a space inside of the USB traces for the decoupling capacitors to go.&lt;/p&gt;
    &lt;p&gt;Now we need to make sure all these traces are the same sizes, you can check the resistor traces by using the Tune length of a single track tool on the right toolbar, they should be the same length if you did it right:&lt;/p&gt;
    &lt;p&gt;And then, your USB-C lines, are probably not the same length, so we need to fix that. You can do that by going to route -&amp;gt; Tune skew of a differential pair in the top menu, and then selecting the trace with a negative skew, and just tapping it, and then tapping ok, and then just drag to make it slightly longer:&lt;/p&gt;
    &lt;p&gt;This makes all of our traces the exact same size, so that we have proper data flow!&lt;/p&gt;
    &lt;p&gt;Now we just need to wire the extra pair of D+/D-'s on the USB-C to the route that we already have. Just wire these directly&lt;/p&gt;
    &lt;p&gt;Now that we have our fast signals on the PCB, the other signals are fine to go through via's, so we can put in our decoupling caps now:&lt;/p&gt;
    &lt;p&gt;Leave all of the ground pins for last, I'll explain this soon&lt;/p&gt;
    &lt;p&gt;Now my routing of course isn't perfect, but I did manage to get it pretty nice and tight. You'll notice some blue on the PCB, and that's me routing on the other layer. You can change layers by tapping the other layer on the right layers view, or by tapping "v". But for SMD components, you'll need what's called a "via" in order to get to the other layer, which is essentially just a hole that allows traces to transfer to another layer of a board. Feel free to use the backside for routing if you don't have any space!&lt;/p&gt;
    &lt;p&gt;Anyways, next I'm going to route the crystal, the USB-C pull downs, and button pull ups, and then I'm going to leave the button/button resistor for very last because there's no specific spot that needs to be:&lt;/p&gt;
    &lt;p&gt;Now, we're going to route power to our board, I'm distributing power to the main cluster of VDD pins, and then once I'm finished routing the other signals, I'm going to route it to the other pins, just so power is even about my board:&lt;/p&gt;
    &lt;p&gt;Now, wire every single header pin on the board, try to keep organized when doing this, and save via's/the other layer for when you have like absolutely no space left:&lt;/p&gt;
    &lt;p&gt;And with a bit of finesse, all of our routing is pretty much done, we just have all of our ground signals left. Now you're probably wondering why we didn't route those. Well instead of using wires to do those, we can use what's called a ground fill.&lt;/p&gt;
    &lt;p&gt;This is basically like a giant pool of just ground on our PCB that connects all of our grounds together. We do this because it helps with signal integrity, and because there's always going to be a lot of ground signals on a PCB so it simplifies stuff. It also helps with thermal regulation!&lt;/p&gt;
    &lt;p&gt;So on the right toolbar, tap Draw Filled Zone, and select both layers, with GND as the net, and select Thermal reliefs as the Pad connections. Basically, with a ground fill, soldering can become harder because the fill dissipates heat, so doing thermal reliefs puts like less ground area to the hole so it's easier to solder stuff on!&lt;/p&gt;
    &lt;p&gt;Then, select the entire PCB with your ground fill, and then tap "B" to fill it:&lt;/p&gt;
    &lt;p&gt;Now you'll notice that all your ground ratlines disappear. Their might be a couple that are still there though, this is because the pads are isolated, so you might need to put a via from the pad onto the ground fill. You also might need to adjust like some of the header pins signals and such to make it work!&lt;/p&gt;
    &lt;p&gt;I'd also suggest adding via's to all the isolated islands of ground for signal integrity, but this is just good practice, and also putting extra near the SoC and stuff that get's hot like the LDO:&lt;/p&gt;
    &lt;p&gt;Next, we'll need to add in our button that we haven't put in yet. Just find a free spot on your PCB for it, I'm going to put mine near the flash memory though because it's got some space and it's a close connection:&lt;/p&gt;
    &lt;p&gt;And then, if you just have any ratlines still on the PCB, just connect them up, and you'll be on the final step of designing our PCB:&lt;/p&gt;
    &lt;p&gt;Now you probably think, we'll we're done the PCB, what else could there be, well there's actually a couple more things we need to do. The first thing is running DRC to make sure there's no problems with our PCB. So go to the top toolbar, and run DRC:&lt;/p&gt;
    &lt;p&gt;My PCB has 16 errors, yours might have more, but all of these need to be properly resolved. The first things I'm going to look at is my unconnected items. These just tell me what I forgot to route, you can just tap on them to see where they are, just make sure you get all those routed before continuing.&lt;/p&gt;
    &lt;p&gt;Most of these are problems with the ground pour, so I'm actually going to modify the ground fill to fix a lot of these errors, I'm changing the thermal relief gap and clearance to 0.3mm instead of 0.5mm which just makes it so the traces and pads can be closer to the fill:&lt;/p&gt;
    &lt;p&gt;You'll probably also have a bunch of thermal relief errors. These require some finesse to fix, but essentially you just need to have like a thick enough ground on each component. And you can solve this by adding via's, traces, and a bunch of other stuff like editing the fill. So you'll need to research a bit and try different things to fix these. And not all of them are even too crucial, but I'd suggest fixing them all.&lt;/p&gt;
    &lt;p&gt;The rest of the DRC errors you'll have to figure out, but here's how mine looks with no errors left:&lt;/p&gt;
    &lt;head rend="h2"&gt;Congrats on finishing your devboard √∞¬•¬≥&lt;/head&gt;
    &lt;p&gt;Now you've finished making your actual PCB, if you want to get an idea of how it'll look when manufactured, you can tap the 3D Viewer in the top toolbar:&lt;/p&gt;
    &lt;p&gt;The headers will be facing the other way and you can't see the USB-C because it doesn't have a 3D model, but this is how your PCB will look. If you want the header pins to actually be right, you might be able to flip them on your PCB, or double tap the footprint and directly change it! Pretty cool huh, but you know what would make it even cooler... Art!&lt;/p&gt;
    &lt;head rend="h2"&gt;Working on silkscreen&lt;/head&gt;
    &lt;p&gt;Now before we get all excited, let's polish up our PCB a little bit! We're going to do this by modifying what's called the silkscreen, this is all the white stuff you see on the PCB, it's purely decoration and used to show where components should go when soldering, and also to label stuff, and you can make art with it.&lt;/p&gt;
    &lt;p&gt;But before we get to make the art, let's move all the labels on our PCB to look nice and organized! Now the capacitors and stuff aren't too useful to us, so we can delete those silkscreen labels like "C#" or "R#", and just leave the important ones for the connect, the pi, etc.&lt;/p&gt;
    &lt;p&gt;I'd suggest hiding some layers to make it easier to see, so delete all the stuff we don't want, and organize the stuff we do want (You can also hide the fab layer for now, but there's no need to delete that stuff, it won't be on your PCB):&lt;/p&gt;
    &lt;p&gt;This is how mine looks when done:&lt;/p&gt;
    &lt;p&gt;Now, let's add our own art! Try out the KiCad image converter, and also add some text and stuff to your PCB. I personally like to add things like my website, github handle, favorite animals, anime, whatever you want really.&lt;/p&gt;
    &lt;p&gt;I personally use excalidraw to draw my art but you can do whatever:&lt;/p&gt;
    &lt;p&gt;And that's our PCB finished! Run DRC one last time to make sure you have no errors, and then continue on to the final step, which is getting this thing manufactured!&lt;/p&gt;
    &lt;head rend="h2"&gt;Fabrication time!&lt;/head&gt;
    &lt;p&gt;Now that we've finished our PCB, let's get it fabricated. Save your PCB, and then go to:&lt;/p&gt;
    &lt;code&gt;File -&amp;gt; Fabrication Outputs
&lt;/code&gt;
    &lt;p&gt;and then export every single thing there, if you want my gerber settings, here they are:&lt;/p&gt;
    &lt;p&gt;Now you can also use the KiCad fabrication toolkit to do this all for you if you're having problems, but I like to teach the whole process&lt;/p&gt;
    &lt;p&gt;And before you turn all these files into a zip, you'll want to modify the CPL file, because JLCPCB expects the CPL file headers to be called something else, so add it into google sheets. This file will be called something like "your-project-top-pos.csv", we're doing one sided assembly so you can delete the bottom file. Anyways change the headers from:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Ref -&amp;gt; Designator&lt;/item&gt;
      &lt;item&gt;PosX -&amp;gt; Mid X&lt;/item&gt;
      &lt;item&gt;PosY -&amp;gt; Mid Y&lt;/item&gt;
      &lt;item&gt;Rot -&amp;gt; Rotation&lt;/item&gt;
      &lt;item&gt;Side -&amp;gt; Layer&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Next, you need to replace the headers on your BOM file, this is just changing Designation -&amp;gt; Comment&lt;/p&gt;
    &lt;p&gt;Once you've renamed those headers exactly, export is as a .csv and replace your old CPL/BOM file with this one. And then take all of the files you exported, and compress them into a zip folder, called "PRODUCTION" or whatever you want really:&lt;/p&gt;
    &lt;p&gt;And now I usually make another folder called production in my root, and put this zip file inside of there:&lt;/p&gt;
    &lt;p&gt;Now head on over to JLCPCB and drag that zip folder into the quote section. You should see your PCB show up, and the only thing you're going to add onto your order is PCBA, this just makes sure that JLCPCB doesn't just give you the raw PCB, but also assembles it:&lt;/p&gt;
    &lt;p&gt;Now you don't actually need to use PCBA, if you want to save some money, you can just buy the components on LCSC or the JLCPCB parts manager (which will probably be cheaper), but you'll need to have all the tools to assemble SMD, but I'm going to include an SMD soldering part to this tutorial too if you want to do that&lt;/p&gt;
    &lt;p&gt;Now tap next, and then add your BOM, and the CPL CSV you just created. If you have any errors when uploading this, check the internet, double check you modified the CPL/BOM properly, and worst case, tap the chat button on the website and ask the JLCPCB help desk.&lt;/p&gt;
    &lt;p&gt;If you did everything properly though, you should be presented with the JLCPCB BOM page:&lt;/p&gt;
    &lt;p&gt;Now we need to assign the parts that JLCPCB couldn't automatically find and the ones it got wrong. In most cases this is just a quick search and then tapping the first result, but make sure what you select is exactly what you actually want. The 27 ohm termination resistor is also probably going to be wrong, so you'll want to re-assigned this to a proper 27 ohm resistor.&lt;/p&gt;
    &lt;p&gt;Make sure not to select the pin headers for PCBA, these are easy to solder our self and aren't worth it to pay for, just buy these separately.&lt;/p&gt;
    &lt;p&gt;Also make sure you're using as many basic parts as possible, filter for these so that your PCB is cheaper when selecting parts, but sometimes parts aren't available as basic&lt;/p&gt;
    &lt;p&gt;This is what my final BOM looks like, feel free to copy mine (it'll be in my GitHub repository under /PRODUCTION/files too):&lt;/p&gt;
    &lt;p&gt;Now continue on, and don't place the header pins (it'll prompt you), and then you'll see your assembled board show up:&lt;/p&gt;
    &lt;p&gt;But there's a couple components that aren't properly assembled on our boards so we need to move them manually!&lt;/p&gt;
    &lt;p&gt;You'll need to move:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;The USB-C to fit within the holes nicely&lt;/item&gt;
      &lt;item&gt;The LDO just needs to be turned a bit&lt;/item&gt;
      &lt;item&gt;The flash memory needs to be rotated right so that the dot aligns with the triangle&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;And then everything else you should just double check, but it should be fine:&lt;/p&gt;
    &lt;p&gt;Now, tap next, and congratulations, you're done your PCB!!!!&lt;/p&gt;
    &lt;p&gt;Congratulations on making your first PCB!! I know that this seemed pretty hard and complicated, but it gets so much easier with practice, so keep on making cool stuff!&lt;/p&gt;
    &lt;p&gt;Now try to challenge yourself in your next endeavor, and don't just make another devboard, try your hand at a motherboard, or a power controller, just something that challenges you and helps you learn!&lt;/p&gt;
    &lt;p&gt;Feel free to also modify this board you've created to include an LED matrix, motor drivers, literally whatever your heart desires.&lt;/p&gt;
    &lt;p&gt;I hope you learned alot, if you want to checkout some of the other stuff I've created, check out my projects on GitHub or my personal website https://kaipereira.com/! Don't forget to post your finished projects in #ship and ping me (@KaiPereira) too!&lt;/p&gt;
    &lt;p&gt;Now if you want to stick around, we're going to go through assembling your PCB, if you didn't want to get JLC to do PCBA!&lt;/p&gt;
    &lt;head rend="h2"&gt;Hand-soldering your Devboard!&lt;/head&gt;
    &lt;p&gt;Now if you've decided to take the VERY FUN ROUTE of hand soldering your devboard, I'll continue with a small tutorial on how to do so!&lt;/p&gt;
    &lt;p&gt;Now hand soldering is mildly difficult, and takes quite a bit of time, but you'll learn invaluable skills lots of other people don't learn, and also earn a lot of tickets while you're at it :D&lt;/p&gt;
    &lt;p&gt;So the first step is buying all your components for hand soldering! Everything can just be bought on LCSC, and I'd suggest buying a couple extra components of each thing, just in case you accidentally mess up/break components!&lt;/p&gt;
    &lt;p&gt;You'll also want to have a couple other key components:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Flux paste (not solder paste), this helps the solder bond to the pads of your board, helping to fix mistakes and is crucial. This will come in a little syringe container, and looks white/yellow depending on where you get it from (solder paste, which you don't want usually look gray!&lt;/item&gt;
      &lt;item&gt;Fine tip soldering iron, this makes soldering in really tight spots so much easier, most tips are usually fine enough, but you just don't want like a super wide one.&lt;/item&gt;
      &lt;item&gt;Solder, usually smaller solder is usually more convenient, but it's honestly fine to use larger&lt;/item&gt;
      &lt;item&gt;Fine tip tweezers, I honestly wish mine were finer, but I'd suggest trying to find the smallest fine tip tweezers in your house that aren't ribbed/textured at the end&lt;/item&gt;
      &lt;item&gt;Brass sponge, for cleaning your tip, you just dip your iron into this every once in a while to get the excess solder off!&lt;/item&gt;
      &lt;item&gt;Silicon mat, this isn't needed, but I would HIGHLY suggest, so that your soldering iron doesn't fall off and burn you, and so you have a nice grippy surface to hold your PCB on&lt;/item&gt;
      &lt;item&gt;Decently ventilated area, honestly I find this is less for saving you from the unhealthy fumes and more to get the smoke out of your eyes so you actually see what you're doing!&lt;/item&gt;
      &lt;item&gt;Isopropyl alcohol and Q-Tips, these are to clean up the flux on your board after soldering, it's just once you're done, so you don't really have to have it on hand before starting!&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;This is what my setup looks like with all of these things:&lt;/p&gt;
    &lt;p&gt;Pretty sweet right :D&lt;/p&gt;
    &lt;p&gt;Now you're ready to get soldering!&lt;/p&gt;
    &lt;p&gt;When you're soldering a small board like this, and most PCB's for that matter, you'll want to start with your smallest components first and then work your way up. In our case, we have quite a few 0402 components, which are going to be SO MUCH FUN to solder.&lt;/p&gt;
    &lt;p&gt;Lots of people don't spend time to actually learn how to properly solder these components and just go at it, but I'll try my best to describe it and you'll also want to watch this video in it's entirety!&lt;/p&gt;
    &lt;p&gt;So basically:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Apply your flux around/in the pads of the footprint of the components you're going to solder&lt;/item&gt;
      &lt;item&gt;Apply solder to one pad of the footprint&lt;/item&gt;
      &lt;item&gt;Place your component onto the footprint&lt;/item&gt;
      &lt;item&gt;Apply heat on the pad with solder while it's touching your component&lt;/item&gt;
      &lt;item&gt;Take your tweezers off the component&lt;/item&gt;
      &lt;item&gt;Apply heat to the other pad, and solder it to the component&lt;/item&gt;
      &lt;item&gt;Apply more solder to the pad you first soldered to create a stronger connection&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;And then you're done! I sometimes add some more flux and then clean up my joints, but it's up to you if you want to do so! This will be hard when you first start off, but it get's much easier with practice, and also better tools help a lot!&lt;/p&gt;
    &lt;p&gt;Now you want to pay close attention to your joints, to make sure that your solder is actually joined with the component! I find being in a WELL lit room helps a lot to see everything, and a microscope can be very handy!&lt;/p&gt;
    &lt;p&gt;If your component didn't form a joint with one of it's pads, you might need to get the component closer to the pad or apply flux, or apply more solder!&lt;/p&gt;
    &lt;p&gt;If you ever bridge 2 pads with solder, apply flux and they should go back to their relevant pads, it's MAGICAL....&lt;/p&gt;
    &lt;p&gt;Tutorials help a LOT here where words sometimes can't explain all, so take your time, and do it right.&lt;/p&gt;
    &lt;p&gt;I started by soldering my 0.1uF caps, because there's quite a few of them, but you could really start with whatever 0402 component you want, and then work your way up to 0603, then 0805, and then small components, then large components!&lt;/p&gt;
    &lt;p&gt;(unfinished)&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://repository.rice.edu/server/api/core/bitstreams/85449216-b2ec-4519-87cf-83eafe4534e7/content"/><published>2025-11-07T22:34:15+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45852029</id><title>How a devboard works (and how to make your own)</title><updated>2025-11-08T03:14:49.489078+00:00</updated><content>&lt;doc fingerprint="365a9065c1379239"&gt;
  &lt;main&gt;
    &lt;head rend="h1"&gt;Let's Design an RP2040 Devboard!&lt;/head&gt;
    &lt;p&gt;Today, we're going to be designing our own dev board, using one of the most popular and beginner friendly SoC's, the RP2040. This guide doesn't serve as just a tutorial, but also as an opportunity to learn what everything on the PCB fundamentally does, and what every single component on your PCB is actually for!&lt;/p&gt;
    &lt;p&gt;All the source files for this tutorial can be found here, so if you need any help, feel free to resort to the repository!&lt;/p&gt;
    &lt;p&gt;Now let's start off with the basic question, what's an SoC! An SoC or system on chip, basically has all the basic components like SRAM, processors, USB controllers, and other peripherals you'll break out onto your board. The RP2040 is a good SoC to start with, because the datasheets are simple, it's low-cost, has good on-chip memory and is really flexible with plenty of IO's.&lt;/p&gt;
    &lt;p&gt;Now let's get right into it, we'll be using KiCad for this tutorial, and I would suggest completing the hackpad tutorial and maybe a keyboard before trying to make your own devboard, not because you won't be able to make it, but you'll understand how it works a bit better.&lt;/p&gt;
    &lt;p&gt;So create a new KiCad project by going: &lt;code&gt;File -&amp;gt; new project, and choosing your name/folder for the project&lt;/code&gt;&lt;/p&gt;
    &lt;p&gt;After that, double click your schematic to start working on your PCB. PCB's essentially have 2 main parts, the schematic, and the actual PCB.&lt;/p&gt;
    &lt;p&gt;The schematic is basically a wiring diagram, that shows how everything will connect, but isn't like exactly where the components are placed or how thick your traces are, it's solely to show how everything is wired, not where.&lt;/p&gt;
    &lt;p&gt;This is how are schematic will look when done the tutorial&lt;/p&gt;
    &lt;p&gt;The PCB editor is where you'll place down all your components and route everything for when you get it actually manufactured.&lt;/p&gt;
    &lt;head rend="h2"&gt;Starting the schematic&lt;/head&gt;
    &lt;p&gt;So enter in your schematic, and then tap "a", this will open up the symbol library, which is the place where you can find component blocks that you'll wire together to form the schematic for your project. Search for the RP2040, and just place it down in the center of your schematic.&lt;/p&gt;
    &lt;p&gt;You'll notice the symbol and actual component are 2 different things if you look at the first screenshot. The symbol just tells you all the pins on the component, and how they'll be wired to what. The actual component has the physical pads where traces will actually connect to on your PCB!&lt;/p&gt;
    &lt;p&gt;Our entire schematic will consist of 5 main elements: power, flash storage, the crystal oscillator, I/O (input/outputs), and your SoC, the RP2040! The Raspberry Pi datasheet explains how all of this will pretty much be wired, and I'm kind of just here to explain exactly how it all works too.&lt;/p&gt;
    &lt;p&gt;So first let's talk about power and some schematic good practices!&lt;/p&gt;
    &lt;p&gt;You'll notice that the RP2040 has capacitors, these are called decoupling capacitors. These capacitors are used for 2 main things, filtering out power supply noise and giving a local power supply if components need it at short notice. You can think of it like a stream of water, without the capacitors it can be jittery and unpredictable, but with the capacitors, the stream smooths out, making your PCB function more reliable.&lt;/p&gt;
    &lt;p&gt;You usually want to put one 0.1uF (or 100nF, the F stands for Farads) decoupling capacitor per power pin, but it's fine to deviate a bit from that, but that's the most optimal way of doing it and what we're going to do.&lt;/p&gt;
    &lt;p&gt;We're also going to put a 1uF decoupling capacitor on each power line. You'll notice that the RP2040 has a +1V1 (1.1V) and a +3V3 (3.3V) line, we want to put a 1uF decoupling capacitor per line, to act as a larger reservoir and to smoothen out larger ripples that could occur. With the RP2040, these 1uF capacitors are mostly to help provide a stable 1.1V supply. With this combination, we'll filter out nearly all the noise and have a smooth functioning PCB.&lt;/p&gt;
    &lt;p&gt;So go back into your schematic and then tap on the "Draw Wires" icon to connect the VREF_VOUT and DVDD, and then separately connect the IO_VDD, USB_VDD, ADC_AVDD and VREG_IN, because these pins have different voltages.&lt;/p&gt;
    &lt;p&gt;Now before we go further, remember that all power labels face UPWARDS, and all ground labels face DOWNWARDS, this isn't necessary for the schematic to work, but it's good schematic practices that you should always follow&lt;/p&gt;
    &lt;p&gt;Then tap "p" to open up the POWER symbol library (you can also tap a, but searching in p will be faster because there's less symbols), and search for "1V1" and "3V3" and place the 1.1V on the VREG_VOUT and DVDD, and 3.3V on the IOVDD and those other pins.&lt;/p&gt;
    &lt;p&gt;Now schematic good practices is to always put at least a small wire between symbols like this for clarity.&lt;/p&gt;
    &lt;p&gt;Now that we have our power symbols in, we're going to add the decoupling. You could technically wire them like the screenshot I showed before, but I prefer to separate them because you use less wire which I find looks cleaner, but it's up to personal preference, and readability.&lt;/p&gt;
    &lt;p&gt;You'll also notice that the symbol contains less pins than the symbol the RP2040 datasheet has, this is because symbols in KiCad tend to not repeat the same pins, so they just merge like all the same VDD pins into one.&lt;/p&gt;
    &lt;p&gt;But using the RP2040 datasheet as reference, we know that there's 8 IO VDD pins, so eight 0.1uF decoupling, and one 1uF cap because we're wiring the entire 3.3V line and need to smooth out the larger ripples. So let's just place all those in!&lt;/p&gt;
    &lt;p&gt;Again type "a" and search for "c" (the shorthand for capacitor). Make sure to double tap the capacitors to add a value, and make eight of them 0.1uF, and one of them 1uF.&lt;/p&gt;
    &lt;p&gt;These are the decoupling capacitors for the 3.3V line, now we need to do the caps for the 1.1V line. There's 2 VDD pins, so two, 0.1uF caps, and we need one for the line too, so a 1uF cap aswell:&lt;/p&gt;
    &lt;p&gt;Now we have all of our power decoupling. We also need to connect GND to the SoC, this is pretty self-explanatory, but it allows power to actually flow properly in our PCB.&lt;/p&gt;
    &lt;head rend="h2"&gt;Working on USB-C&lt;/head&gt;
    &lt;p&gt;We have our power decoupling, but we don't actually have a power source yet or a way to program our devboard yet, so let's do that now. I'm going to be using USB-C because it's standard and fast!&lt;/p&gt;
    &lt;p&gt;So tap "a", type in whatever receptacle you want, and add it in. Make sure you pick "receptacle" and not plug because a plug would plug into your laptop instead of having a cable plug into it.&lt;/p&gt;
    &lt;p&gt;Now let's explain each of these pins:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;SHIELD/GND will both go to ground, shield is conductive material wrapped around the data pins on the receptacle, and this just improves EMI by grounding it.&lt;/item&gt;
      &lt;item&gt;D+/D- are the data pins, these transfer data to/from the USB-C receptacle. You'll want to connect the D-'s and D+'s together so that they both transfer data.&lt;/item&gt;
      &lt;item&gt;CC1 and CC2 basically tell the receptacle to allow power to go through to power the board. These by standard (the datasheet tells you) are pulled down (go to GND) through 5.1K resistors.&lt;/item&gt;
      &lt;item&gt;VBUS is the 5V input, this will need to be stepped down to 3.3V to power our MCU (microcontroller)&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Now that we know what everything does, let's wire it up. Shield/GND go to GND:&lt;/p&gt;
    &lt;p&gt;D+ and D- are attached to their relative pair, and then will go into the MCU, but for now, we'll just have a global label going out of them. Global labels are basically like little teleporters, that allow you to say that something is wiring, without manually putting a wire between them.&lt;/p&gt;
    &lt;p&gt;Technically global labels are meant to be used between different schematic sheets and net labels would be the correct thing to use here, but I find global labels are cleaner if you only have one schematic for your PCB.&lt;/p&gt;
    &lt;p&gt;To do this, tap global label in the right hand toolbar, type in the name for your label (USB_D+ and USB_D-), and add them to the pins:&lt;/p&gt;
    &lt;p&gt;Next, pulldown the CC pins through a 5.1K resistor to GND to enable power to go through the USB-C receptacle. Open up the symbol library, and then type "r" the shorthand for resistors, and then place it down and edit the value to be 5.1K:&lt;/p&gt;
    &lt;p&gt;Remember to follow proper schematic good practices, and to have clearly visible values, and labels for your components. Feel free to edit the text of stuff to make your schematic cleaner, just don't make stuff too small.&lt;/p&gt;
    &lt;p&gt;Now we just need to wire in the input voltage, but the thing is, the voltage of USB-C is 5V, while the voltage that the RP2040 uses as input, needs to be 3.3V so you don't cook it. To achieve this, we'll use what's called an LDO, or a Low-Dropout Regulator to take the voltage down.&lt;/p&gt;
    &lt;p&gt;Specifically, we'll be using the NCP1117, a classic and reliable fixed voltage regulator (I actually switch this regulator out later for the MCP1700, 3.3V, because it's really big on our PCB). A fixed voltage regulator is handy here, because we only need to go down to 3.3V instead of like 1.5V per say or something random, and it uses less components. We'll also be using the SOT-223 footprint (or package is the common term) because it's small and we don't really have any thermal issues with a devboard.&lt;/p&gt;
    &lt;p&gt;So add in the NCP1117-3.3_SOT223 symbol, wire GND and attach VBUS to the VI (voltage input) of the LDO.&lt;/p&gt;
    &lt;p&gt;Remember to always keep your schematic clean and feel free to use up quite a bit of space. Now like the decoupling capacitors on our RP2040, we need capacitors on the LDO. But we don't need fine decoupling capacitors for precise input lines into an MCU, and instead we need bulk capacitors, to handle the large voltage ripples when moving a voltage down.&lt;/p&gt;
    &lt;p&gt;So we need to place two, 10uF capacitors on each side of the LDO, for input/output, so add them into your schematic:&lt;/p&gt;
    &lt;p&gt;Next, we want to add our power labels to the LDO, we'll put a VBUS label before the LDO/Bulk cap, and a +3V3 label to the VO (voltage out) of the LDO. We might use 5V to power some other devices so we'll want to provide a power line for that too:&lt;/p&gt;
    &lt;p&gt;Now to finish off the USB-C wiring, we need to make sure the MCU receives the data lines. It's standard to have these going through 27 ohm resistors into the MCU to prevent distortions of the signals at high speeds, these are called termination resistors.&lt;/p&gt;
    &lt;p&gt;So wire the USB D+ and D- pairs into the MCU USB_DP and USB_DM (the P is for + and the M is for -) through 27 ohm resistors:&lt;/p&gt;
    &lt;p&gt;Now USB D+ and D- are actually what's called "bidirectional", this means that they work both ways. You don't actually need to specify this, but good schematic practices is to make sure your global labels reflect that. Currently they're just set as "inputs" because the triangle is facing inwards, so double click on all the D+ and D- labels and set them to bidirectional:&lt;/p&gt;
    &lt;head rend="h2"&gt;The crystal oscillator&lt;/head&gt;
    &lt;p&gt;Now to make our USB and other peripherals actually work properly, we need to have what's called a crystal oscillator. This is a little piezoelectric quartz crystal that vibrates very precisely, and then it's amplified and fed into the MCU to act as a clock signal that controls the digital peripherals.&lt;/p&gt;
    &lt;p&gt;For example, you definitely want a crystal oscillator if you're using USB-C, because the data needs to come in at specific times, so it makes sure no data is incorrectly received. Because the clock is such a precise component, you want to wire it really carefully. That means it should be as close to the MCU as possible on the PCB (schematic doesn't matter, it's just a reference), and it needs really small capacitors, to smooth out the signals.&lt;/p&gt;
    &lt;p&gt;First add the global labels to the MCU XIN and XOUT, just called their relative name. XOUT is the output from the crystal so an input to the MCU, and XIN is an output from the MCU to help the crystal oscillate properly:&lt;/p&gt;
    &lt;p&gt;Remember to accurately represent your global label direction, but just keep in mind it doesn't actually change your schematic, it's only for whoever is reading it!&lt;/p&gt;
    &lt;p&gt;Based off the RP2040 datasheet, we're going to be using a 12 MHz crystal with two, 15pF (I switch these later to 33pF because we use a different crystal than the Pi Pico) decoupling capacitors. Make sure to use the crystal footprint with 4 pins and 1 and 3, as the input/output pins so pay attention to the symbol I use:&lt;/p&gt;
    &lt;p&gt;Pins 2, and 4 just go to GND, pins 1 and 3 need a 15pF cap in series, and XOUT will have a 1K resistor. This resistor is called a damping resistor and it prevents the crystal from being damaged and ensures good signal integrity:&lt;/p&gt;
    &lt;p&gt;Remember all your schematic good practices and make sure everything looks clean.&lt;/p&gt;
    &lt;p&gt;We haven't actually seen these types of caps yet, these are called external load capacitors, and they're placed in series with the crystal I/O's, these basically just ensure that the crystal resonates at it's proper frequency, I'd suggest researching a bit more if you're interested!&lt;/p&gt;
    &lt;head rend="h2"&gt;Flash storage&lt;/head&gt;
    &lt;p&gt;Now lot's of SoC's include flash storage, but the RP2040 actually doesn't, so we need to add on our own flash storage! You can think of flash storage as like a faster version of an HDD, with less power consumption, more reliability but is usually a bit more expensive.&lt;/p&gt;
    &lt;p&gt;Sadly, the RP2040 only supports up to 16mb of memory, so we'll just use a quad SPI flash memory IC (integrated circuit, those little chips on a board) like the W25Q128JVS used in the datasheet.&lt;/p&gt;
    &lt;p&gt;Now before we actually add it to our schematic, let's talk about what SPI is. If you continue to build PCB's, you'll see this communication interface very often, it's basically just a standardized way of transferring data. The signal comes out of the master, and then goes into slave devices. The master is our MCU in this case, and the slave, is our flash memory.&lt;/p&gt;
    &lt;p&gt;It has 4 major pins you need to understand:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;MOSI - Master output, slave input&lt;/item&gt;
      &lt;item&gt;MISO - Master input, slave output&lt;/item&gt;
      &lt;item&gt;SCLK - Clock signal (remember that oscillator we added to our board, this will basically do that for other devices)&lt;/item&gt;
      &lt;item&gt;SS/CS - Slave select, let's you choose what device you're communicating with&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;So you usually need to have all 4 of those, and then you can add SS pins as you wish if you want to communicate with more and more devices.&lt;/p&gt;
    &lt;p&gt;But we're actually using quad SPI in this case.&lt;/p&gt;
    &lt;p&gt;Quad SPI uses the same CLK and CS pin, but has 4 IO pins, so it can transfer data, 4x as fast as SPI, which is ideal for flash memory, but it does take up more pins, so that's why it's not always used.&lt;/p&gt;
    &lt;p&gt;Now you can't just attach SPI to any GPIO, you have to use what's called a hardware controller, which you can imagine, is like a little block on the RP2040 SoC that is specifically meant for SPI. There are 2 SPI controllers on the RP2040, so we're going to use them for our flash memory. You can also technically do SPI via software, but it just makes way more sense to use the actual controller provided.&lt;/p&gt;
    &lt;p&gt;So add a global label to the QSPI pins with their relative name, IO's are bidirectional, and CLK and CS/SS are inputs to the slave (the flash memory) or outputs from the MCU.&lt;/p&gt;
    &lt;p&gt;Next, add in our flash memory IC (chip), W25Q128JVS, and wire up all the QSPI pins, and put GND to GND, and VCC to 3.3V:&lt;/p&gt;
    &lt;p&gt;Next, we need to add our 100nF/0.1uF decoupling capacitor to our VCC line to filter high-frequency noise. And then, we're going to add a button to the CS line, so that we can enter what's called BOOTSEL mode.&lt;/p&gt;
    &lt;p&gt;Based off of the RP2040 datasheet, if the QSPI SS pin, see's a 0 or GND when it's booting up, it'll go into BOOTSEL, where it will appear as a USB device on our computer so that we can copy code onto it to set it up.&lt;/p&gt;
    &lt;p&gt;Now there's 2 resistors you're probably wondering about here, the pullup to 3.3V, and the one in series with the button.&lt;/p&gt;
    &lt;p&gt;The pullup to 3.3V is important, because usually the QSPI pin will show up as 3.3V to the flash memory, but during bootup, you can't guarantee that it will, because the pin isn't active, so you might have some weird thing that happens with your board. The 10K resistor is just standard that the RP2040 datasheet wants us to use (and is also pretty commonly used to filter noise and stuff).&lt;/p&gt;
    &lt;p&gt;The 1K resistor in series limits the amount of current that can flow in this part of the circuit to prevent damage to the CS pin.&lt;/p&gt;
    &lt;p&gt;And just like that, we have our button and decoupling in, and our flash memory is completed!&lt;/p&gt;
    &lt;head rend="h2"&gt;Breaking out I/O Headers&lt;/head&gt;
    &lt;p&gt;Now we have all the components for our board to actually work, so we just need to breakout all the GPIO's on the RP2040, onto header pins so that we can use them in our circuit and whatnot!&lt;/p&gt;
    &lt;p&gt;But before we do this, let's just make sure we attach TESTEN to GND on the RP2040, this pin is just meant for factories to make sure that the RP2040 SoC actually works before sending them out.&lt;/p&gt;
    &lt;p&gt;Next, we'll label all the other pins we haven't broken out (all the GPIO's, SWCLK and SWD), with their relative name on the RP2040. These are all bidirectional pins except the SWCLK pin, which is a clock output from the SoC:&lt;/p&gt;
    &lt;p&gt;I actually labelled mine the wrong direction for the rest of this tutorial, but it's purely cosmetic and won't actually impact my PCB, this is how it should actually look, don't mind the GPIO labels, I took this screenshot after being done the PCB:&lt;/p&gt;
    &lt;p&gt;Next, we're going to add the actual header pin symbols into our schematic. You can technically do this whoever you want, but I'm going to adhere to the raspberry Pi Pico pinout:&lt;/p&gt;
    &lt;p&gt;So add in a two, 1x20 header pin symbols, and one 1x3 header pin symbol, I just used generic symbols, but you could use pin header symbols if you want, it's just up to preference:&lt;/p&gt;
    &lt;p&gt;Usually you don't want to make your symbol layout look exactly like your PCB, but I think it makes it more obvious so that we don't mess up our pinout!&lt;/p&gt;
    &lt;p&gt;Next, we'll just add in all the pins, and we'll just leave out the ones we don't know yet like VSYS, 3V3_EN and ADC_VREF, I'll explain those after:&lt;/p&gt;
    &lt;p&gt;Now the Pi Pico can actually be powered by a battery, but we're not implementing a battery (if you want to, check out the Pi Pico datasheet), so there's a diode on the VBUS power line, so they have a VSYS line after the diode and a VBUS line before it, but because we don't need a diode, we don't need VSYS.&lt;/p&gt;
    &lt;p&gt;We also don't need 3V3_EN, and then ADC_VREF is kind of just another thing to give a reference voltage to ADC, but it isn't really necessary, and we're just making a simple devboard so we won't use it.&lt;/p&gt;
    &lt;p&gt;Because we have these free pins, and also some GPIO's still left, let's just fill these pins with some GPIO's. I'm going to move the ADC pins up, and then fill the other pins with GPIO's. I also want to use GPIO29 which is an ADC pin and replace GPIO25 with that just so we get the added ADC pin:&lt;/p&gt;
    &lt;p&gt;Because of this, you'll want to just no-connect GPIO25 on the MCU, just to tell KiCad and others that we're not using that pin:&lt;/p&gt;
    &lt;p&gt;If you want to add battery support, you can do so yourself, but I'm keeping to a minimum framework. And just like that, we have all of our header pins in!&lt;/p&gt;
    &lt;head rend="h2"&gt;Finishing up the schematic&lt;/head&gt;
    &lt;p&gt;Now that we have our I/O headers in, we're actually finished with all the symbols in our schematic, this is how your schematic should look:&lt;/p&gt;
    &lt;p&gt;Now to organize our schematic, even more, let's separate our design into different blocks using the text boxes in the schematic editor. When doing this, you usually want to place your component blocks by flow of your PCB. So if you could image, power flows in through the USB, so we'll put that in the corner, the MCU should be center because it's the fundamental of the PCB, and then the other stuff can just be organized around:&lt;/p&gt;
    &lt;p&gt;You don't have to do this, but I feel like it keeps everything nice and clean!&lt;/p&gt;
    &lt;p&gt;Next, run ERC to just make sure you don't have any unconnected or weird stuff happening in your schematic. The only error you might get is Input Power pin not driven by any Output Power pins. You can just ignore this error, it's basically just the fact that we're labelling our power as bidirectional, and with no input/output, but we know that the MCU takes in 3.3V and that the USB-C outputs 3.3V, so we're totally fine to ignore it.&lt;/p&gt;
    &lt;head rend="h2"&gt;Footprint time!&lt;/head&gt;
    &lt;p&gt;Now that we've finished out schematic, we need to start working on the actual PCB. The first thing you need to do for the actual PCB, is to add in all the footprints for your components.&lt;/p&gt;
    &lt;p&gt;A footprint on a PCB basically just defines it's pads, outline, etc, that your component needs in order to be solder able on a PCB. So just tap on the assign footprints tab in the top toolbar to open up the footprints tab:&lt;/p&gt;
    &lt;p&gt;Now before we add in our footprints, let's talk about standard imperial sizes of SMD components, and SMD vs THT components.&lt;/p&gt;
    &lt;p&gt;So if you don't know, there's SMD components, which are surface mount, which means that the components are attached to the surface of the PCB like caps, and then there's THT components, which are soldered through the board, these are things like the headers.&lt;/p&gt;
    &lt;p&gt;For SMD footprints, you'll want to understand what the imperial sizes are:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;0402 are the smallest footprint we'll have on our PCB, these are tiny footprints and anything smaller than this becomes too small to easily solder, these are good for low current applications, and are fine for our fine signal decoupling.&lt;/item&gt;
      &lt;item&gt;0603 footprints are a bit larger than 0402, and are better for slightly higher current and will maintain better physical stability for the larger decoupling needed for 10uF caps and such.&lt;/item&gt;
      &lt;item&gt;0805 footprints are pretty large and are really just needed in higher current applications, we won't be using any of these because we don't have any crazy large caps/components&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;So all of our 0.1uF/1uF/resistors will be 0402, and then the 10uF caps will be 0603, so just filter in the search bar for 0402/0603, and choose the resistor/capacitor footprint for the relative component:&lt;/p&gt;
    &lt;p&gt;Now these other components need to usually be found on LCSC and then you go into the datasheet to find the footprint, and then add it in, but I'm decently experienced and know what footprints to use already, so you can just copy what ones I'm using or find your own if you want and add them in:&lt;/p&gt;
    &lt;p&gt;These are my thought process behind the other components, JLCPCB has what's called basic and extended parts, and extended parts cost $3 each to add to a PCB because they have to be loaded into the assembly machines, this will be important here:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;USB_C_Receptacle_HRO_TYPE-C-31-M-12: JLCPCB doesn't have any basic part USB-C receptacles, so I just chose this one I kind of like from a previous board. PART&lt;/item&gt;
      &lt;item&gt;PinHeader_1x20_P2.54mm_Vertical: This is just the proper size header pins we need, they should be through hole/THT to be stronger instead of SMD, I mean if you wanted to, it could be SMD though. The part is just pin headers I'll buy separately&lt;/item&gt;
      &lt;item&gt;SW_Push_SPST_NO_Alps_SKRK: This is a small SMD size button footprint found in the JLCPCB basic library, so it doesn't cost anything extra and is pretty compact. This isn't actually the EXACT footprint, but it's close by like .1mm, and I found it by just scrolling through footprints with some filters. PART&lt;/item&gt;
      &lt;item&gt;Crystal_SMD_3225-4Pin_3.2x2.5mm: I found this crystal on JLCPCB basic parts, and looked at the datasheet to find the footprint. You really have to make sure your crystal footprint pinout is proper because lots of people accidentally use the wrong footprint or symbol. PART&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Now we actually need to modify our crystal schematic a bit because of the part we chose on JLCPCB has a load capacitance is slightly different, so we actually need 33pF caps. You can just search up the math if you want to learn how to do this:&lt;/p&gt;
    &lt;p&gt;And just like that, our schematic and footprint selection is finished, so we can actually get to the real fun stuff.. the PCB!&lt;/p&gt;
    &lt;head rend="h2"&gt;Let's design a PCB&lt;/head&gt;
    &lt;p&gt;Now that all that stuffs done, tap the switch to PCB editor button on the far right of the top toolbar!&lt;/p&gt;
    &lt;p&gt;This will bring you into a new editor you haven't seen yet, this is where we'll actually place down the components on our PCB, and route everything.&lt;/p&gt;
    &lt;p&gt;So in the top toolbar, tap the update PCB from schematic or F8, and then tap the update PCB button that shows up, to bring in all the components into your PCB, and just put them all in the top left corner of your PCB:&lt;/p&gt;
    &lt;p&gt;You might get some warnings which can be ignored usually (I just got some pin warnings which are fine), but there shouldn't be any errors.&lt;/p&gt;
    &lt;p&gt;Now you'll see our actual components on the PCB, our USB-C, the RP2040, the button, crystal, LDO, flash, headers and our caps/resistors!&lt;/p&gt;
    &lt;head rend="h2"&gt;PCB Layout&lt;/head&gt;
    &lt;p&gt;Now before we actually lay out all of our components, we need to define our PCB outline, holes, etc. So using the datasheet as a reference, we'll place down everything accordingly. Start with the board outline, and then do holes and stuff.&lt;/p&gt;
    &lt;p&gt;To add in a board outline, tap on the Edge.Cuts layer and then tap on Draw Rectangles, and then just put whatever size rectangle you want. After that, we'll add in the proper size from the datasheet, which is 21x51mm, so tap on the rectangle, then tap "e" and use the By Center and Size tab to do this:&lt;/p&gt;
    &lt;p&gt;Next, we'll align the header pins onto our PCB by using the position tool. So right click on one of the header pins, go Positioning Tools -&amp;gt; Position Relative To, and then go Select Point and tap one of the top corners of the board outline. And then using the datasheet, align the X to 1.61/-1.61 based off of the side, and the Y to 1.37:&lt;/p&gt;
    &lt;p&gt;(I actually swapped my pin headers here which I fix later, but just put J2 as the first header, and J3 as the second one, so it's easier to route)&lt;/p&gt;
    &lt;p&gt;Next, we need to put our bottom header in, these are aligned to Y -1.61 and the X should be centered so 7.96 (10.5 is the center, minus 2.54 the pin spacing), and use the bottom left/right as reference (make sure it's flipped horizontally when aligning):&lt;/p&gt;
    &lt;p&gt;Next, I'm going to put in the RP2040 dead center, but with the Y slightly farther down, because there's more components above the Pico than below, so I want a bit more space for signals, I'm going to put it down an extra 4mm, but you can do how much you want.&lt;/p&gt;
    &lt;p&gt;Then, I'm going to center the USB-C, down a bit to the top of the devboard:&lt;/p&gt;
    &lt;p&gt;Now looking at the flash memory and LDO IC, they're really big, so let's use different components for them:&lt;/p&gt;
    &lt;p&gt;I'm going to switch to the MCP1700 LDO, which is smaller, but does handle less current (250ma), so if you plan on drawing more current, you might want to just keep the current LDO. So just replace the NCP1700 with the MCP1700x-330xxTT, which is the 3.3V MCP1700:&lt;/p&gt;
    &lt;p&gt;And then, we're going to change the flash memory to what the Pi Pico uses and has a slightly smaller package, which is the W25Q16JVZPIQ TR and uses the Package_SON:Winbond_USON-8-1EP_3x2mm_P0.5mm_EP0.2x1.6mm footprint, so switch the footprint to that new one!&lt;/p&gt;
    &lt;p&gt;Now your footprints should be much better:&lt;/p&gt;
    &lt;p&gt;Anyways next, we're going to organize our parts onto the PCB (I also fixed my header pins and MCU orientation in this step). The LDO is going to go really close to the USB-C VBUS, and the flash storage will go close to the RP2040's QSPI pins, just so we have an efficient layout:&lt;/p&gt;
    &lt;p&gt;I use exact positioning when doing things like this, but you can just place them on if you want, I just like everything to be nicely symmetrical.&lt;/p&gt;
    &lt;p&gt;Next, I'm going to put the crystal on. The crystal should be very close to the RP2040 XIN/XOUT pins because it's a very precise signal, and the load capacitors should be RIGHT next to the pins too so the signals don't get messed up. You can then just put the resistor right by the XOUT pin of the RP2040 to have a nice and efficient layout:&lt;/p&gt;
    &lt;p&gt;Now I'm going to put all the decoupling capacitors on my board. Decoupling capacitors should be as close as possible to the pins they're decoupling, the larger the cap is, the farther it can be, but try to keep them close to their pins.&lt;/p&gt;
    &lt;p&gt;Also feel free to mess with layout a bit during this step just so everything fits in efficiently! Try to use whatever capacitor you used in your schematic for organization purposes.&lt;/p&gt;
    &lt;p&gt;First I usually group all the caps that go together, and then I usually either start with the SoC caps, or components caps, I'm going to start with the components caps:&lt;/p&gt;
    &lt;p&gt;Remember, caps go close to whatever they're decoupling. Now all the RP2040 caps are grouped together, and this is because it's just a general rule to have one cap per VDD pin, and then the larger cap/bulk cap near the largest group of them:&lt;/p&gt;
    &lt;p&gt;This is the layout I decided on, some of my thought process for this layout was:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Leave enough space to route the USB differential pair&lt;/item&gt;
      &lt;item&gt;Be able to route QSPI without via's for fast signals&lt;/item&gt;
      &lt;item&gt;Leave enough space by the crystal to be able to route those traces&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;And I'll still definitely actively update it while I route my traces, but this is a good starting point.&lt;/p&gt;
    &lt;p&gt;Now all that's left to add in, is our resistors, but I'm going to actually put these to the side, and start routing a couple things! This is because it's going to be easier to place components not in the way of where traces are going to go.&lt;/p&gt;
    &lt;p&gt;Not before we start routing, remember a couple key things about routing:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Never have a trace at a 90 degree angle, these mess with your signals, and also sometimes get manufactured weirdly&lt;/item&gt;
      &lt;item&gt;Think about what you're going to route next, so that you don't route where that trace needs to go&lt;/item&gt;
      &lt;item&gt;Know what you're routing, things like decoupling caps need to have short, small traces, etc.&lt;/item&gt;
      &lt;item&gt;Never put via's on pads, this makes it hard to solder them, and makes the component unstable&lt;/item&gt;
      &lt;item&gt;Try to route front signals vertically, and back signals horizontally, this isn't a fixed rule, but just try to do it in most spots to have efficient routing&lt;/item&gt;
      &lt;item&gt;Don't be afraid to move your components a bunch while routing, a lot of intuition is required for efficient routing&lt;/item&gt;
      &lt;item&gt;You might hear me use the term "ratlines", these are the blue lines on the PCB, I actually have mine set as curved because of personal preference, but yours will probably be straight&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;So, the first thing I'm going to route is my flash memory, I'm going to move the capacitors away temporarily while I do this and then add them back on later. So tap on the route single track in the right hand toolbar, and then route all the signals like so:&lt;/p&gt;
    &lt;p&gt;I usually start my route from the RP2040, and then put it into the component just because I find it's easier. I always start with routing my higher speed signals, and then do the lower ones.&lt;/p&gt;
    &lt;p&gt;Next, I'm going to route the USB-C data lines. Now these lines are actually special on our PCB, these need to be routed as differential pairs, basically perfectly even traces, next to each other. This is because they're carrying high speed data, so the traces need to be the same length so that data arrives at the same time.&lt;/p&gt;
    &lt;p&gt;The termination resistors for these data lines also need to be right by the RP2040 pins to smooth the signals. I'd suggest placing these perfectly evenly apart, centered on the pins so it's easy to route our differential pairs:&lt;/p&gt;
    &lt;p&gt;Now to route a differential pair. First wire the USB D+'s/D-'s together:&lt;/p&gt;
    &lt;p&gt;Then, hold the route tracks button, and go over to the symbol with 2 traces on it, or just tap 6. Then, go over to your USB-C, and tap on one of the D+/D- pins to start the trace, and route it down to your resistors. If the traces won't go into your resistors pads, that means that your resistors aren't evenly positioned, you can just the relative positioning tool to do this.&lt;/p&gt;
    &lt;p&gt;And then you can just route the resistors nets into the RP2040 nets (Make sure they're centered so the traces are the same length, you could technically do this as a differential pair if you change your schematic slightly, but it's fine if you just position properly):&lt;/p&gt;
    &lt;p&gt;I added left a space inside of the USB traces for the decoupling capacitors to go.&lt;/p&gt;
    &lt;p&gt;Now we need to make sure all these traces are the same sizes, you can check the resistor traces by using the Tune length of a single track tool on the right toolbar, they should be the same length if you did it right:&lt;/p&gt;
    &lt;p&gt;And then, your USB-C lines, are probably not the same length, so we need to fix that. You can do that by going to route -&amp;gt; Tune skew of a differential pair in the top menu, and then selecting the trace with a negative skew, and just tapping it, and then tapping ok, and then just drag to make it slightly longer:&lt;/p&gt;
    &lt;p&gt;This makes all of our traces the exact same size, so that we have proper data flow!&lt;/p&gt;
    &lt;p&gt;Now we just need to wire the extra pair of D+/D-'s on the USB-C to the route that we already have. Just wire these directly&lt;/p&gt;
    &lt;p&gt;Now that we have our fast signals on the PCB, the other signals are fine to go through via's, so we can put in our decoupling caps now:&lt;/p&gt;
    &lt;p&gt;Leave all of the ground pins for last, I'll explain this soon&lt;/p&gt;
    &lt;p&gt;Now my routing of course isn't perfect, but I did manage to get it pretty nice and tight. You'll notice some blue on the PCB, and that's me routing on the other layer. You can change layers by tapping the other layer on the right layers view, or by tapping "v". But for SMD components, you'll need what's called a "via" in order to get to the other layer, which is essentially just a hole that allows traces to transfer to another layer of a board. Feel free to use the backside for routing if you don't have any space!&lt;/p&gt;
    &lt;p&gt;Anyways, next I'm going to route the crystal, the USB-C pull downs, and button pull ups, and then I'm going to leave the button/button resistor for very last because there's no specific spot that needs to be:&lt;/p&gt;
    &lt;p&gt;Now, we're going to route power to our board, I'm distributing power to the main cluster of VDD pins, and then once I'm finished routing the other signals, I'm going to route it to the other pins, just so power is even about my board:&lt;/p&gt;
    &lt;p&gt;Now, wire every single header pin on the board, try to keep organized when doing this, and save via's/the other layer for when you have like absolutely no space left:&lt;/p&gt;
    &lt;p&gt;And with a bit of finesse, all of our routing is pretty much done, we just have all of our ground signals left. Now you're probably wondering why we didn't route those. Well instead of using wires to do those, we can use what's called a ground fill.&lt;/p&gt;
    &lt;p&gt;This is basically like a giant pool of just ground on our PCB that connects all of our grounds together. We do this because it helps with signal integrity, and because there's always going to be a lot of ground signals on a PCB so it simplifies stuff. It also helps with thermal regulation!&lt;/p&gt;
    &lt;p&gt;So on the right toolbar, tap Draw Filled Zone, and select both layers, with GND as the net, and select Thermal reliefs as the Pad connections. Basically, with a ground fill, soldering can become harder because the fill dissipates heat, so doing thermal reliefs puts like less ground area to the hole so it's easier to solder stuff on!&lt;/p&gt;
    &lt;p&gt;Then, select the entire PCB with your ground fill, and then tap "B" to fill it:&lt;/p&gt;
    &lt;p&gt;Now you'll notice that all your ground ratlines disappear. Their might be a couple that are still there though, this is because the pads are isolated, so you might need to put a via from the pad onto the ground fill. You also might need to adjust like some of the header pins signals and such to make it work!&lt;/p&gt;
    &lt;p&gt;I'd also suggest adding via's to all the isolated islands of ground for signal integrity, but this is just good practice, and also putting extra near the SoC and stuff that get's hot like the LDO:&lt;/p&gt;
    &lt;p&gt;Next, we'll need to add in our button that we haven't put in yet. Just find a free spot on your PCB for it, I'm going to put mine near the flash memory though because it's got some space and it's a close connection:&lt;/p&gt;
    &lt;p&gt;And then, if you just have any ratlines still on the PCB, just connect them up, and you'll be on the final step of designing our PCB:&lt;/p&gt;
    &lt;p&gt;Now you probably think, we'll we're done the PCB, what else could there be, well there's actually a couple more things we need to do. The first thing is running DRC to make sure there's no problems with our PCB. So go to the top toolbar, and run DRC:&lt;/p&gt;
    &lt;p&gt;My PCB has 16 errors, yours might have more, but all of these need to be properly resolved. The first things I'm going to look at is my unconnected items. These just tell me what I forgot to route, you can just tap on them to see where they are, just make sure you get all those routed before continuing.&lt;/p&gt;
    &lt;p&gt;Most of these are problems with the ground pour, so I'm actually going to modify the ground fill to fix a lot of these errors, I'm changing the thermal relief gap and clearance to 0.3mm instead of 0.5mm which just makes it so the traces and pads can be closer to the fill:&lt;/p&gt;
    &lt;p&gt;You'll probably also have a bunch of thermal relief errors. These require some finesse to fix, but essentially you just need to have like a thick enough ground on each component. And you can solve this by adding via's, traces, and a bunch of other stuff like editing the fill. So you'll need to research a bit and try different things to fix these. And not all of them are even too crucial, but I'd suggest fixing them all.&lt;/p&gt;
    &lt;p&gt;The rest of the DRC errors you'll have to figure out, but here's how mine looks with no errors left:&lt;/p&gt;
    &lt;head rend="h2"&gt;Congrats on finishing your devboard √∞¬•¬≥&lt;/head&gt;
    &lt;p&gt;Now you've finished making your actual PCB, if you want to get an idea of how it'll look when manufactured, you can tap the 3D Viewer in the top toolbar:&lt;/p&gt;
    &lt;p&gt;The headers will be facing the other way and you can't see the USB-C because it doesn't have a 3D model, but this is how your PCB will look. If you want the header pins to actually be right, you might be able to flip them on your PCB, or double tap the footprint and directly change it! Pretty cool huh, but you know what would make it even cooler... Art!&lt;/p&gt;
    &lt;head rend="h2"&gt;Working on silkscreen&lt;/head&gt;
    &lt;p&gt;Now before we get all excited, let's polish up our PCB a little bit! We're going to do this by modifying what's called the silkscreen, this is all the white stuff you see on the PCB, it's purely decoration and used to show where components should go when soldering, and also to label stuff, and you can make art with it.&lt;/p&gt;
    &lt;p&gt;But before we get to make the art, let's move all the labels on our PCB to look nice and organized! Now the capacitors and stuff aren't too useful to us, so we can delete those silkscreen labels like "C#" or "R#", and just leave the important ones for the connect, the pi, etc.&lt;/p&gt;
    &lt;p&gt;I'd suggest hiding some layers to make it easier to see, so delete all the stuff we don't want, and organize the stuff we do want (You can also hide the fab layer for now, but there's no need to delete that stuff, it won't be on your PCB):&lt;/p&gt;
    &lt;p&gt;This is how mine looks when done:&lt;/p&gt;
    &lt;p&gt;Now, let's add our own art! Try out the KiCad image converter, and also add some text and stuff to your PCB. I personally like to add things like my website, github handle, favorite animals, anime, whatever you want really.&lt;/p&gt;
    &lt;p&gt;I personally use excalidraw to draw my art but you can do whatever:&lt;/p&gt;
    &lt;p&gt;And that's our PCB finished! Run DRC one last time to make sure you have no errors, and then continue on to the final step, which is getting this thing manufactured!&lt;/p&gt;
    &lt;head rend="h2"&gt;Fabrication time!&lt;/head&gt;
    &lt;p&gt;Now that we've finished our PCB, let's get it fabricated. Save your PCB, and then go to:&lt;/p&gt;
    &lt;code&gt;File -&amp;gt; Fabrication Outputs
&lt;/code&gt;
    &lt;p&gt;and then export every single thing there, if you want my gerber settings, here they are:&lt;/p&gt;
    &lt;p&gt;Now you can also use the KiCad fabrication toolkit to do this all for you if you're having problems, but I like to teach the whole process&lt;/p&gt;
    &lt;p&gt;And before you turn all these files into a zip, you'll want to modify the CPL file, because JLCPCB expects the CPL file headers to be called something else, so add it into google sheets. This file will be called something like "your-project-top-pos.csv", we're doing one sided assembly so you can delete the bottom file. Anyways change the headers from:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Ref -&amp;gt; Designator&lt;/item&gt;
      &lt;item&gt;PosX -&amp;gt; Mid X&lt;/item&gt;
      &lt;item&gt;PosY -&amp;gt; Mid Y&lt;/item&gt;
      &lt;item&gt;Rot -&amp;gt; Rotation&lt;/item&gt;
      &lt;item&gt;Side -&amp;gt; Layer&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Next, you need to replace the headers on your BOM file, this is just changing Designation -&amp;gt; Comment&lt;/p&gt;
    &lt;p&gt;Once you've renamed those headers exactly, export is as a .csv and replace your old CPL/BOM file with this one. And then take all of the files you exported, and compress them into a zip folder, called "PRODUCTION" or whatever you want really:&lt;/p&gt;
    &lt;p&gt;And now I usually make another folder called production in my root, and put this zip file inside of there:&lt;/p&gt;
    &lt;p&gt;Now head on over to JLCPCB and drag that zip folder into the quote section. You should see your PCB show up, and the only thing you're going to add onto your order is PCBA, this just makes sure that JLCPCB doesn't just give you the raw PCB, but also assembles it:&lt;/p&gt;
    &lt;p&gt;Now you don't actually need to use PCBA, if you want to save some money, you can just buy the components on LCSC or the JLCPCB parts manager (which will probably be cheaper), but you'll need to have all the tools to assemble SMD, but I'm going to include an SMD soldering part to this tutorial too if you want to do that&lt;/p&gt;
    &lt;p&gt;Now tap next, and then add your BOM, and the CPL CSV you just created. If you have any errors when uploading this, check the internet, double check you modified the CPL/BOM properly, and worst case, tap the chat button on the website and ask the JLCPCB help desk.&lt;/p&gt;
    &lt;p&gt;If you did everything properly though, you should be presented with the JLCPCB BOM page:&lt;/p&gt;
    &lt;p&gt;Now we need to assign the parts that JLCPCB couldn't automatically find and the ones it got wrong. In most cases this is just a quick search and then tapping the first result, but make sure what you select is exactly what you actually want. The 27 ohm termination resistor is also probably going to be wrong, so you'll want to re-assigned this to a proper 27 ohm resistor.&lt;/p&gt;
    &lt;p&gt;Make sure not to select the pin headers for PCBA, these are easy to solder our self and aren't worth it to pay for, just buy these separately.&lt;/p&gt;
    &lt;p&gt;Also make sure you're using as many basic parts as possible, filter for these so that your PCB is cheaper when selecting parts, but sometimes parts aren't available as basic&lt;/p&gt;
    &lt;p&gt;This is what my final BOM looks like, feel free to copy mine (it'll be in my GitHub repository under /PRODUCTION/files too):&lt;/p&gt;
    &lt;p&gt;Now continue on, and don't place the header pins (it'll prompt you), and then you'll see your assembled board show up:&lt;/p&gt;
    &lt;p&gt;But there's a couple components that aren't properly assembled on our boards so we need to move them manually!&lt;/p&gt;
    &lt;p&gt;You'll need to move:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;The USB-C to fit within the holes nicely&lt;/item&gt;
      &lt;item&gt;The LDO just needs to be turned a bit&lt;/item&gt;
      &lt;item&gt;The flash memory needs to be rotated right so that the dot aligns with the triangle&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;And then everything else you should just double check, but it should be fine:&lt;/p&gt;
    &lt;p&gt;Now, tap next, and congratulations, you're done your PCB!!!!&lt;/p&gt;
    &lt;p&gt;Congratulations on making your first PCB!! I know that this seemed pretty hard and complicated, but it gets so much easier with practice, so keep on making cool stuff!&lt;/p&gt;
    &lt;p&gt;Now try to challenge yourself in your next endeavor, and don't just make another devboard, try your hand at a motherboard, or a power controller, just something that challenges you and helps you learn!&lt;/p&gt;
    &lt;p&gt;Feel free to also modify this board you've created to include an LED matrix, motor drivers, literally whatever your heart desires.&lt;/p&gt;
    &lt;p&gt;I hope you learned alot, if you want to checkout some of the other stuff I've created, check out my projects on GitHub or my personal website https://kaipereira.com/! Don't forget to post your finished projects in #ship and ping me (@KaiPereira) too!&lt;/p&gt;
    &lt;p&gt;Now if you want to stick around, we're going to go through assembling your PCB, if you didn't want to get JLC to do PCBA!&lt;/p&gt;
    &lt;head rend="h2"&gt;Hand-soldering your Devboard!&lt;/head&gt;
    &lt;p&gt;Now if you've decided to take the VERY FUN ROUTE of hand soldering your devboard, I'll continue with a small tutorial on how to do so!&lt;/p&gt;
    &lt;p&gt;Now hand soldering is mildly difficult, and takes quite a bit of time, but you'll learn invaluable skills lots of other people don't learn, and also earn a lot of tickets while you're at it :D&lt;/p&gt;
    &lt;p&gt;So the first step is buying all your components for hand soldering! Everything can just be bought on LCSC, and I'd suggest buying a couple extra components of each thing, just in case you accidentally mess up/break components!&lt;/p&gt;
    &lt;p&gt;You'll also want to have a couple other key components:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Flux paste (not solder paste), this helps the solder bond to the pads of your board, helping to fix mistakes and is crucial. This will come in a little syringe container, and looks white/yellow depending on where you get it from (solder paste, which you don't want usually look gray!&lt;/item&gt;
      &lt;item&gt;Fine tip soldering iron, this makes soldering in really tight spots so much easier, most tips are usually fine enough, but you just don't want like a super wide one.&lt;/item&gt;
      &lt;item&gt;Solder, usually smaller solder is usually more convenient, but it's honestly fine to use larger&lt;/item&gt;
      &lt;item&gt;Fine tip tweezers, I honestly wish mine were finer, but I'd suggest trying to find the smallest fine tip tweezers in your house that aren't ribbed/textured at the end&lt;/item&gt;
      &lt;item&gt;Brass sponge, for cleaning your tip, you just dip your iron into this every once in a while to get the excess solder off!&lt;/item&gt;
      &lt;item&gt;Silicon mat, this isn't needed, but I would HIGHLY suggest, so that your soldering iron doesn't fall off and burn you, and so you have a nice grippy surface to hold your PCB on&lt;/item&gt;
      &lt;item&gt;Decently ventilated area, honestly I find this is less for saving you from the unhealthy fumes and more to get the smoke out of your eyes so you actually see what you're doing!&lt;/item&gt;
      &lt;item&gt;Isopropyl alcohol and Q-Tips, these are to clean up the flux on your board after soldering, it's just once you're done, so you don't really have to have it on hand before starting!&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;This is what my setup looks like with all of these things:&lt;/p&gt;
    &lt;p&gt;Pretty sweet right :D&lt;/p&gt;
    &lt;p&gt;Now you're ready to get soldering!&lt;/p&gt;
    &lt;p&gt;When you're soldering a small board like this, and most PCB's for that matter, you'll want to start with your smallest components first and then work your way up. In our case, we have quite a few 0402 components, which are going to be SO MUCH FUN to solder.&lt;/p&gt;
    &lt;p&gt;Lots of people don't spend time to actually learn how to properly solder these components and just go at it, but I'll try my best to describe it and you'll also want to watch this video in it's entirety!&lt;/p&gt;
    &lt;p&gt;So basically:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Apply your flux around/in the pads of the footprint of the components you're going to solder&lt;/item&gt;
      &lt;item&gt;Apply solder to one pad of the footprint&lt;/item&gt;
      &lt;item&gt;Place your component onto the footprint&lt;/item&gt;
      &lt;item&gt;Apply heat on the pad with solder while it's touching your component&lt;/item&gt;
      &lt;item&gt;Take your tweezers off the component&lt;/item&gt;
      &lt;item&gt;Apply heat to the other pad, and solder it to the component&lt;/item&gt;
      &lt;item&gt;Apply more solder to the pad you first soldered to create a stronger connection&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;And then you're done! I sometimes add some more flux and then clean up my joints, but it's up to you if you want to do so! This will be hard when you first start off, but it get's much easier with practice, and also better tools help a lot!&lt;/p&gt;
    &lt;p&gt;Now you want to pay close attention to your joints, to make sure that your solder is actually joined with the component! I find being in a WELL lit room helps a lot to see everything, and a microscope can be very handy!&lt;/p&gt;
    &lt;p&gt;If your component didn't form a joint with one of it's pads, you might need to get the component closer to the pad or apply flux, or apply more solder!&lt;/p&gt;
    &lt;p&gt;If you ever bridge 2 pads with solder, apply flux and they should go back to their relevant pads, it's MAGICAL....&lt;/p&gt;
    &lt;p&gt;Tutorials help a LOT here where words sometimes can't explain all, so take your time, and do it right.&lt;/p&gt;
    &lt;p&gt;I started by soldering my 0.1uF caps, because there's quite a few of them, but you could really start with whatever 0402 component you want, and then work your way up to 0603, then 0805, and then small components, then large components!&lt;/p&gt;
    &lt;p&gt;(unfinished)&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://kaipereira.com/journal/build-a-devboard"/><published>2025-11-07T22:35:28+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45852257</id><title>Mind captioning: Evolving descriptive text of mental content of brain activity</title><updated>2025-11-08T03:14:49.222399+00:00</updated><content/><link href="https://www.science.org/doi/10.1126/sciadv.adw1464"/><published>2025-11-07T22:57:18+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45852275</id><title>FAA to restrict commercial rocket launches to overnight hours</title><updated>2025-11-08T03:14:48.041382+00:00</updated><content>&lt;doc fingerprint="198f45b224807bd9"&gt;
  &lt;main&gt;
    &lt;head rend="h1"&gt;FAA restricts commercial rocket launches indefinitely due to air traffic risks from government shutdown&lt;/head&gt;
    &lt;p&gt;Restrictions begin just after NASA's upcoming mission to Mars.&lt;/p&gt;
    &lt;p&gt;Beginning next week, daytime rocket launches are all officially scrubbed thanks to the government shutdown.&lt;/p&gt;
    &lt;p&gt;As the record-long shutdown of the U.S. federal government stretches into its second month, commercial air travelers are beginning to feel the impacts at the nation's airports. To help ease the strain, the Federal Aviation Administration (FAA) has issued an emergency order to limit who can access navigable airspace, which includes restricted hours on commercial rocket launches.&lt;/p&gt;
    &lt;p&gt;Beginning 6 a.m. EST (1100 GMT) on Nov. 10, commercial launches to space can only take place between the hours of 10 p.m. EST (0300 GMT) and 6 a.m. EST (1100 GMT), according to the FAA order. This will help keep airspace restrictions in Florida, near NASA's Kennedy Space Center and Cape Canaveral Space Force Station, as well as Vandenberg Space Force Station in California, to a minimum while air traffic delays stack up due to staffing shortages caused by the government shutdown.&lt;/p&gt;
    &lt;p&gt;Though its impact on greater U.S. air traffic delays across the country will be hard to measure, the restrictions coincide with the busiest coast-to-coast launch cadence in history. The order will primarily affect SpaceX, which routinely launches Starlink satellite stacks into low Earth orbit as it expands its wireless internet megaconstellation, though other launch providers and missions will likely need to reassess their launch manifests. SpaceX has launched over 140 Starlink missions this year alone.&lt;/p&gt;
    &lt;p&gt;One launch hoping to get off the ground before the order goes into effect is NASA's ESCAPADE mission to Mars. The Rocket Lab-built twin orbiters are scheduled to liftoff on a Blue Origin New Glenn rocket at 2:45 p.m. EST (1945 GMT) on Nov. 9. The impending restrictions mean the ESCAPADE mission won't have a chance to reset for a second launch attempt if the Nov. 9 liftoff is scrubbed for some reason.&lt;/p&gt;
    &lt;p&gt;United Launch Alliance's Atlas V launch of the ViaSat-3 F2 satellite could face further delays under the new launch restrictions, after two previous mission scrubs earlier this week due to issues with the rocket.&lt;/p&gt;
    &lt;p&gt;During the shutdown, all federal employees deemed non-essential are furloughed. Those whose job falls into the essential category are still required to go to work, but are not currently getting paid and must rely on backpay once the government reopens.&lt;/p&gt;
    &lt;p&gt;Breaking space news, the latest updates on rocket launches, skywatching events and more!&lt;/p&gt;
    &lt;p&gt;For NASA, this means nearly 15,000 people staying home from work. That's about 95% of the space agency's workforce. In contrast, 95% of employees at the Transportation Security Administration (TSA) are considered "excepted" and have continued to work without pay since the shutdown began Oct. 1.&lt;/p&gt;
    &lt;quote&gt;
      &lt;p&gt;.@USDOT has many responsibilities, but our number one job is safety. This isn‚Äôt about politics ‚Äì it‚Äôs about assessing the data and alleviating building risk in the system as controllers continue working without pay. It‚Äôs safe to fly today, tomorrow, and the day after because‚Ä¶ pic.twitter.com/YRrq5sdy4TNovember 7, 2025&lt;/p&gt;
    &lt;/quote&gt;
    &lt;p&gt;In a post on X, Department of Transportation Secretary and Acting NASA Administrator Sean Duffy said the emergency order was, "about assessing the data and alleviating building risk in the system as controllers continue working without pay. It's safe to fly today, tomorrow, and the day after because of the proactive actions we are taking."&lt;/p&gt;
    &lt;p&gt;Josh Dinner is the Staff Writer for Spaceflight at Space.com. He is a writer and photographer with a passion for science and space exploration, and has been working the space beat since 2016. Josh has covered the evolution of NASA's commercial spaceflight partnerships and crewed missions from the Space Coast, as well as NASA science missions and more. He also enjoys building 1:144-scale model rockets and human-flown spacecraft. Find some of Josh's launch photography on Instagram and his website, and follow him on X, where he mostly posts in haiku.&lt;/p&gt;
    &lt;p&gt;You must confirm your public display name before commenting&lt;/p&gt;
    &lt;p&gt;Please logout and then login again, you will then be prompted to enter your display name.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://www.space.com/space-exploration/launches-spacecraft/faa-restricts-commercial-rocket-launches-indefinitely-due-to-air-traffic-risks-from-government-shutdown"/><published>2025-11-07T22:59:04+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45852328</id><title>Why is Zig so cool?</title><updated>2025-11-08T03:14:47.793952+00:00</updated><content>&lt;doc fingerprint="2e0298192ea533d8"&gt;
  &lt;main&gt;&lt;p&gt;I can‚Äôt think of any other language in my 45 years long career that surprised more than Zig. I can easily say that Zig is not only a new programming language, but it‚Äôs a totally new way to write programs, in my opinion. To say it‚Äôs merely a language to replace C or C++, it‚Äôs a huge understatement.&lt;/p&gt;&lt;p&gt;In this article, I will present the features that I found to be most seductive in the language, and I will also present a brief overview about it. The goal is to present simple features for programmers to quick start in the language. Be aware, though, that many more features are affecting its acceptability in the industry.&lt;/p&gt;&lt;p&gt;Probably the most incredible virtue of Zig compiler is its ability to compile C code. This associated with the ability to cross-compile code to be run in another architecture, different than the machine where it is was originally compiled, is already something quite different and unique. These features alone, completely out-of-the-box, are causing an incredible impact in the industry already. In spite of that what we want to concentrate on is how to program in Zig and why should one choose Zig instead of any other language.&lt;/p&gt;&lt;p&gt;Installing the compiler is quite simple. In Zinglang‚Äôs download page one finds the compiler in several formats, depending on the processor or OS:&lt;/p&gt;&lt;p&gt;On Windows 10, for example, one chooses the x86_64 zip file and copy its decompressed content in the desired directory. For example, in ‚ÄúProgram Files‚Äù. I modified the root directory name to ‚Äúzig-windows-x86_64‚Äù because in this way I can just copy another version of the compiler with no need to modify the path in Path environment variable.&lt;/p&gt;&lt;p&gt;Next, one adds this root directory path to the Path environment variable using Advanced System Properties (clicking on 1-4, pasting path on 5, and clicking ‚ÄúOK‚Äù on 6-8):&lt;/p&gt;&lt;p&gt;Notice that after setting the path to Zig‚Äôs root directory one can already use the compiler in CLI mode. That‚Äôs the recommended way to use it for the sake of simplicity.&lt;/p&gt;&lt;p&gt;It‚Äôs recommended to build a ‚ÄúHello World!‚Äù program using the instructions in the ‚ÄúGetting Started‚Äù section in this site. An alternative installation procedure is also presented there, including for MacOS and Linux (‚ÄúInstalling manually‚Äù is highly recommended). It‚Äôs also recommended to check the ‚ÄúLanguage‚Äù Basis section, for a deeper insight of Zig language.&lt;/p&gt;&lt;p&gt;The following sections will give a bird‚Äôs eye view of Zig language. Their goal is to instruct the programmer how to quickly start programming in Zig by just knowing a few basic concepts and commands.&lt;/p&gt;&lt;p&gt;Then, a compact view on how to build programs and test modules is given.&lt;/p&gt;&lt;p&gt;Finally, a deeper view on how low level programming can be done in Zig. A more detailed explanation on the examples used is also given.&lt;/p&gt;&lt;p&gt;Normally, variable declarations in Zig have potentially three parts. The first part contains the accessibility (&lt;code&gt;pub&lt;/code&gt; or nothing),
followed by the word &lt;code&gt;var&lt;/code&gt; or &lt;code&gt;const&lt;/code&gt;, followed by
the variable name. The second part, separated of the first part by a
colon, contains the variable type declaration. The third part is the
initialization of the variable. Only the first and third part are
compulsory in Zig, which is kind of puzzling, coming from Java or C. One
may wonder how the compiler discovers the variable type. The type in
this case is inferred by the initialization.&lt;/p&gt;&lt;code&gt;var sum : usize = 0;         // variable declaration with 3 parts&lt;/code&gt;&lt;p&gt;Variables that don‚Äôt have their accessibility explicitly &lt;code&gt;pub&lt;/code&gt; are local to the module, that is, they aren‚Äôt
accessible outside the source file it was declared (just like
&lt;code&gt;static&lt;/code&gt; variables in C). It‚Äôs not recommended to have
variables declared &lt;code&gt;pub&lt;/code&gt; and it‚Äôs recommended to have just
few functions declared &lt;code&gt;pub&lt;/code&gt; in a module to discourage
coupling and encourage cohesion. The &lt;code&gt;pub&lt;/code&gt; functions behave
as the module‚Äôs API.&lt;/p&gt;&lt;p&gt;In Zig, a &lt;code&gt;.{&lt;/code&gt; closed with a &lt;code&gt;}&lt;/code&gt; is an
‚Äúanonymous struct literal‚Äù - an anonymous struct mostly used to
initialize the elements of another structure or to create a new
structure with its elements initialized. A &lt;code&gt;.{ }&lt;/code&gt; is an an
empty anonymous struct literal. The word &lt;code&gt;struct&lt;/code&gt; followed by
a &lt;code&gt;{&lt;/code&gt; and closed with a &lt;code&gt;}&lt;/code&gt; is a struct
declaration. One can initialize a variable with a type, which functions
as an alias to the type. Notice the ‚Äútest block‚Äù allowing to
compile and execute tests without the need of an executable.&lt;/p&gt;&lt;p&gt;Bitfields are declared fields with types having specific sizes in a &lt;code&gt;packed struct&lt;/code&gt;. Pointers can point to a specific bit field
as shown here:&lt;/p&gt;&lt;p&gt;Zig syntax is clearer than C‚Äôs, except that one would think it should be &lt;code&gt;[0..8]&lt;/code&gt;, but in reality it‚Äôs an open interval:
&lt;code&gt;[0..9)&lt;/code&gt;. Advantage in Zig: the type
declaration of &lt;code&gt;i&lt;/code&gt;, its initialization, test, and
incrementation are automatic.&lt;/p&gt;&lt;p&gt;A &lt;code&gt;[_]&lt;/code&gt; defines an array with unknown size. It must be followed
by the type of its elements (here &lt;code&gt;u8&lt;/code&gt;, unsigned
byte) and its initialization between &lt;code&gt;{&lt;/code&gt; and
&lt;code&gt;}&lt;/code&gt;. In this example below, the initialization is saying that
this is an array of unknown size (&lt;code&gt;[_]&lt;/code&gt;) where each element
is of type &lt;code&gt;u8&lt;/code&gt; (unsigned byte) and each element initialized
with zeros (&lt;code&gt;{0} ** 81&lt;/code&gt;). Notice that the size is also
inferred by the repetition factor (&lt;code&gt;81&lt;/code&gt;) of the
initialization (&lt;code&gt;{0}&lt;/code&gt;).&lt;/p&gt;&lt;code&gt;var grid = [_]u8{0} ** 81;&lt;/code&gt;&lt;p&gt;We see in the figure below a test environment with a loop interacting over the array and adding its elements. The &lt;code&gt;try expect&lt;/code&gt;
statement verifies that &lt;code&gt;sum&lt;/code&gt; is correct.&lt;/p&gt;&lt;p&gt;The word &lt;code&gt;byte&lt;/code&gt; is not a type or reserved word in Zig.
Here, it‚Äôs a variable to hold each of the array‚Äôs elements on each step
of the loop. Notice that a variable declared between two &lt;code&gt;|&lt;/code&gt;
with an array between the parenthesis of a for loop is always assumed of
the same type as the array elements.&lt;/p&gt;&lt;p&gt;Notice also, that &lt;code&gt;usize&lt;/code&gt; is the natural unsigned integer
for the platform. That means on 64 bits machines it‚Äôs an
&lt;code&gt;u64&lt;/code&gt;, and in 32 bits machines it‚Äôs an &lt;code&gt;u32&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;Pointers to arrays can use pointer arithmetic only if the pointer is explicitly declared as a many-item pointer, here &lt;code&gt;[*]const i32&lt;/code&gt;. Notice that the array below is
&lt;code&gt;const&lt;/code&gt;, can‚Äôt be changed, but that the pointer is
&lt;code&gt;var&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;When attributed the address of an individual array position, a pointer cannot be updated with pointer arithmetic. In this case, &lt;code&gt;const&lt;/code&gt; only prevents its value to be changed with another
direct address attribution. To dereference pointers in Zig one uses the
&lt;code&gt;ptr.*&lt;/code&gt; as shown below:&lt;/p&gt;&lt;p&gt;Zig can do many things in compilation time. Let‚Äôs initialize an array, for example. Here, a labelled break is used. The block is labelled with an &lt;code&gt;:&lt;/code&gt; after its name &lt;code&gt;init&lt;/code&gt; and
then a value is returned from the block with &lt;code&gt;break&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;This syntax may look overwhelming. &lt;code&gt;0..&lt;/code&gt; means an infinite
range starting with zero. In the &lt;code&gt;for&lt;/code&gt;, variables &lt;code&gt;pt&lt;/code&gt; and
&lt;code&gt;i&lt;/code&gt; are respectively initialized with the address of
&lt;code&gt;initial_value&lt;/code&gt; array and zero. During the loop both are
incremented automatically and the loop stops right after dealing with
the array‚Äôs last position. Also notice how to dereference the
&lt;code&gt;pt&lt;/code&gt; pointer: &lt;code&gt;pt.*&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;Also interesting it‚Äôs how the array is declared in the labelled block. The array is called &lt;code&gt;initial_value&lt;/code&gt; and has 10
positions of the type &lt;code&gt;Point&lt;/code&gt; (declared afterwards).
Variables must be initialized in Zig. The way to explicitly not
initialize is with the reserved word &lt;code&gt;undefined&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;Functions in Zig are declared with &lt;code&gt;fn&lt;/code&gt; and are static by
default (cannot be imported in other files) in the file they are
declared, except when &lt;code&gt;fn&lt;/code&gt; is preceded by &lt;code&gt;pub&lt;/code&gt;. A
function can be ‚Äúinlined.‚Äù Function pointers are preceded by
&lt;code&gt;const&lt;/code&gt; and followed by the function prototype.&lt;/p&gt;&lt;p&gt;Structs can have functions. Here, a simple stack is implemented. This stack is declared and used only inside the module it is defined, and it accesses and modifies other data structures in the module that are irrelevant in this example. The stack can have at maximum 81 elements (as seen in &lt;code&gt;stk&lt;/code&gt; declaration), each one of type
&lt;code&gt;StkNode&lt;/code&gt;. Notice that ++ and ‚Äì‚Äì operators don‚Äôt exist in Zig.
The equivalent += and ‚Äì= should be used instead. The stack pointer is
just an integer used as an index in the &lt;code&gt;stk&lt;/code&gt; array.&lt;/p&gt;&lt;p&gt;Notice that the pointer &lt;code&gt;self&lt;/code&gt; (&lt;code&gt;self&lt;/code&gt; is not a
reserved word, but it‚Äôs just a convention) is not passed explicitly as a
parameter as one would normally expect. It is indirectly assumed that it
is a pointer to the instance of the stack the function is been called
from. In the example below, a stack pop would be called with
&lt;code&gt;stack.pop();&lt;/code&gt;. In this case the pointer &lt;code&gt;self&lt;/code&gt;
corresponds to a pointer to &lt;code&gt;stack&lt;/code&gt;. This pointer is then
somewhat equivalent to &lt;code&gt;this&lt;/code&gt; in Java or C++.&lt;/p&gt;&lt;p&gt;Function &lt;code&gt;init()&lt;/code&gt; is the stack constructor.&lt;/p&gt;&lt;p&gt;Notice as well that functions &lt;code&gt;pop&lt;/code&gt; and &lt;code&gt;push&lt;/code&gt;
are ‚Äúinlined.‚Äù&lt;/p&gt;&lt;p&gt;To build an executable program one needs a &lt;code&gt;main&lt;/code&gt;
function, which indicates the program entry point as in Java or C
programs. When this function exists the set of modules can be compiled
to an executable code. A simple program can have a &lt;code&gt;main&lt;/code&gt;
function in the same file as the rest of the program. In many cases one
can also insert a main function at the end of a module to create an
executable in order to debug the module independently. Once debugged
this function can be commented out.&lt;/p&gt;&lt;p&gt;In these situations one can use the following command line to compile &lt;code&gt;program.zig&lt;/code&gt; and to generate an executable program (on
Windows, a &lt;code&gt;program.exe&lt;/code&gt;):&lt;/p&gt;&lt;code&gt;zig build-exe -O ReleaseFast program.zig&lt;/code&gt;&lt;p&gt;This can be put inside a batch file to prevent typos.&lt;/p&gt;&lt;p&gt;This is probably the best feature of Zig as a programming language. This environment is normally used for testing, but it can also be used for prototyping.&lt;/p&gt;&lt;p&gt;A block in Zig is similar to a block in C or Java, that is, some code between &lt;code&gt;{&lt;/code&gt; and &lt;code&gt;}&lt;/code&gt;. A test block is a
block that starts with &lt;code&gt;test "message" {&lt;/code&gt; and finishes with
&lt;code&gt;}&lt;/code&gt;, where &lt;code&gt;"message"&lt;/code&gt; is a string containing the
message to be displayed when the test is executed (in this case only the
word message).&lt;/p&gt;&lt;p&gt;Test blocks are executed independently from an executable file. The final executable file does not execute the tests. The test blocks in a given &lt;code&gt;module.zig&lt;/code&gt; are compiled together with the entire code
in that file and executed by the following command:&lt;/p&gt;&lt;code&gt;zig test module.zig&lt;/code&gt;&lt;p&gt;As a real life example, the test block from module example.zig is shown below:&lt;/p&gt;&lt;code&gt;test " =&amp;gt; testing set and print functions" {
    set(
      "800000000003600000070090200" ++
      "050007000000045700000100030" ++
      "001000068008500010090000400"
    );
    std.debug.print("\n" ++
      "===================\n" ++
      "Input Grid\n" ++
      "===================\n",
      .{}
    );
    print();
}&lt;/code&gt;&lt;p&gt;Notice that &lt;code&gt;example.zig&lt;/code&gt; alone has no main
function and, therefore, cannot generate an executable, but its test
block can be executed by using the following command:&lt;/p&gt;&lt;code&gt;zig test example.zig&lt;/code&gt;&lt;p&gt;As the message says, the test block above tests the functions &lt;code&gt;set&lt;/code&gt; and &lt;code&gt;print&lt;/code&gt;. As the code shows,
&lt;code&gt;set&lt;/code&gt; passes a string of decimal digits as a parameter,
followed by a print statement (which prints a header saying ‚ÄúInput Grid‚Äù
), followed itself by a call of the &lt;code&gt;print&lt;/code&gt; function.&lt;/p&gt;&lt;p&gt;The real display in a command tool is the following:&lt;/p&gt;&lt;p&gt;Let‚Äôs focus now on the &lt;code&gt;std.debug.print&lt;/code&gt; statement. This
statement is in fact a call to the function &lt;code&gt;print&lt;/code&gt; in
&lt;code&gt;debug.zig&lt;/code&gt; in the standard Zig library &lt;code&gt;std&lt;/code&gt;. The
first parameter is a format string, and the second is an anonymous
struct (preceded by a dot) containing a list of variables to be
displayed using the format string. Since there is no formatting in the
format string, the struct is empty. This is how formatted prints are
done. This one will display in the stderr by default, as shown
above.&lt;/p&gt;&lt;p&gt;This all looks just like in C language, but there is a fundamental difference here. In C, the printf function dynamically interprets the format string in execution time, whereas in Zig it‚Äôs possible to deal with the literal string and the list of variables in compilation time. This is a difficult principle to grasp at the start. Many things can be executed in compilation time.&lt;/p&gt;&lt;p&gt;Using a debugger is not usually a straightforward task, except in IDEs that already integrate a debugger (as in Java IDEs such as Eclipse or Intellij IDEA) or in integrated development kits (such as w64devkit for C/C++).&lt;/p&gt;&lt;p&gt;A huge inconvenient in using debuggers in this way is that one must integrate the symbols, which not only bloats the code with information that is not useful to the program, but also requires compiling in Debug mode, which generates executable code that‚Äôs notoriously less efficient. Someone with practice in complex systems knows that it can be a very time consuming task.&lt;/p&gt;&lt;p&gt;Zig offers a quite convenient hack in order to avoid these headaches.&lt;/p&gt;&lt;p&gt;This built-in stops a program at the point where a &lt;code&gt;@breakpoint();&lt;/code&gt; is inserted in the source code when its
executable is run in a debugger. This is actually an useful feature to
debug optimized Zig code without the need of symbols.&lt;/p&gt;&lt;p&gt;All it‚Äôs needed is to trace the variables one wants to watch using &lt;code&gt;std.debug.print&lt;/code&gt; right before &lt;code&gt;@breakpoint();&lt;/code&gt; In
this way one can know what are the values of the variables at that exact
moment.&lt;/p&gt;&lt;p&gt;As a real life example, one generates an executable for module debug_example.zig which has the has the following &lt;code&gt;main&lt;/code&gt; function:&lt;/p&gt;&lt;code&gt;pub fn main() !void {
    set(
      "800000000003600000070090200" ++
      "050007000000045700000100030" ++
      "001000068008500010090000400"
    );
}&lt;/code&gt;&lt;p&gt;To be able to double check with the results from example.zig, the parameter passed to &lt;code&gt;set&lt;/code&gt; function in this
&lt;code&gt;main&lt;/code&gt; is the same string as the one passed to
&lt;code&gt;set&lt;/code&gt; in the test block in example.zig,
but this time one inserts the following code inside &lt;code&gt;set&lt;/code&gt;
function:&lt;/p&gt;&lt;code&gt;        if (c != 0) {
           print();
           std.debug.print(
              "Current digit {}\nposition in string {}\n" ++
              "line {}\ncolumn {}\ncode {b}\n", 
              .{c, k, i, j, code}
           );
           @breakpoint();
        }&lt;/code&gt;&lt;p&gt;One can then generate the &lt;code&gt;debug_example.exe&lt;/code&gt; executable
with the following build command:&lt;/p&gt;&lt;code&gt;zig build-exe debug_example.zig&lt;/code&gt;&lt;p&gt;Next, one uses a debugger to call &lt;code&gt;debug_example.exe&lt;/code&gt;. In
this case I used &lt;code&gt;gdb&lt;/code&gt;, a debugger for C/C++ included in
w64devkit, but it could be any debugger for executable programs. Once
inside &lt;code&gt;gdb&lt;/code&gt;, one needs to run the program using an
&lt;code&gt;r&lt;/code&gt; command and typing &lt;code&gt;Enter&lt;/code&gt; right after as
shown below. Notice that the program printed the grid with its contents
so far as well as the variables, stopping
at the point expected. Then, by typing &lt;code&gt;c&lt;/code&gt; command followed
by an &lt;code&gt;Enter&lt;/code&gt; one continues tracing the grid contents and 
the variables. After that, one can continue by just typing 
&lt;code&gt;Enter&lt;/code&gt; (it repeats the last command - &lt;code&gt;c&lt;/code&gt;, in this 
case). By continuing typing &lt;code&gt;Enter&lt;/code&gt; until the program finishes, 
the values found in the grid correspond to the values shown by the test 
block in &lt;code&gt;example.zig&lt;/code&gt; above, since both examples have the same
parameter passed to &lt;code&gt;set&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;With the introduction and the examples given in the previous sections, one can already start programming Zig for writing generic applications. For more advanced programmers, what follows is a more in-depth analysis of some interesting low-level features already used in the examples, but not yet explicitly commented.&lt;/p&gt;&lt;p&gt;The idea of the examples shown is to construct a module that sets (initializes) and displays a 9x9 matrix. This matrix will hold a Sudoku grid, that is, it will only contain elements with decimal digits. The initialization of the grid should guarantee that the grid satisfies the rules of Sudoku game, so it will contain no errors.&lt;/p&gt;&lt;p&gt;At the same time it would be also an excellent opportunity to demonstrate Zig‚Äôs low level capabilities, at least the most noticeable ones, and these examples fit this goal quite well.&lt;/p&gt;&lt;p&gt;The whole hypothesis behind these examples is the representation of a grid digit as a bit in the position given by its value. This representation is quite convenient to detect if a digit is already present in the grid or not (these are basic rules of Sudoku grids). In spite of that, this is so encrypted it is only used internally in the module.&lt;/p&gt;&lt;p&gt;With the purpose of having values that are easily understood by humans, the digits are actually stored in the matrix as standard &lt;code&gt;u8&lt;/code&gt; integers. Even though the input grid in the examples is
given in string format, the ASCII characters are internally converted to
&lt;code&gt;u8&lt;/code&gt; integers. The digits‚Äô storage in the grid is organized
linearly, line by line, in an array with 81 positions, called
&lt;code&gt;grid&lt;/code&gt; in the examples:&lt;/p&gt;&lt;code&gt;var grid = [_]u8{0} ** 81;        // Sudoku grid stored linearly&lt;/code&gt;&lt;p&gt;To verify grid correctness, one needs to access the elements by its respective line and column. In other words, one needs to access the elements as in a matrix. The strategy is to create an array of pointers with 9 positions, each one pointing to the start of each line. Blocks of code cannot in principle return a value, but in Zig they can with labeled breaks:&lt;/p&gt;&lt;code&gt;const matrix = fill9x9: {         // matrix array to allow access  
   var m : [9][*]u8 = undefined;  // to grid element as a matrix, 
   var pt : [*]u8 = &amp;amp;grid;        // thus: element = matrix[i][j]
   for (0..9) |i| {               //
      m[i] = pt;                  // stores pointers of each line
      pt += 9;                    // at each position of matrix
   }                              //
   break :fill9x9 m;              // initializes matrix with m
};&lt;/code&gt;&lt;p&gt;At the end of the loop, &lt;code&gt;m&lt;/code&gt; is returned outside the block
using a &lt;code&gt;break :fill9x9 m;&lt;/code&gt; command. Notice that
&lt;code&gt;fill9x9&lt;/code&gt; corresponds to the name of a label placed right
before the beginning of the block.&lt;/p&gt;&lt;p&gt;Supposing &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt;, respectively an
element‚Äôs line and column, any element of the grid can be accessed using
this notation:&lt;/p&gt;&lt;code&gt;element = matrix[i][j]&lt;/code&gt;&lt;p&gt;The key concept used here is the replacement of an integer decimal digit &lt;code&gt;i&lt;/code&gt; by an integer &lt;code&gt;code&lt;/code&gt; such as:&lt;/p&gt;&lt;code&gt;      i ‚àà [1,9]  ‚Üí  code = 2‚Å±‚Åª¬π
      i = 0      ‚Üí  code = 0&lt;/code&gt;&lt;p&gt;In other words, the only bit of &lt;code&gt;code&lt;/code&gt; that is set to
&lt;code&gt;1&lt;/code&gt; is the bit at the position &lt;code&gt;i-1&lt;/code&gt; if
&lt;code&gt;i&lt;/code&gt; is between &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;9&lt;/code&gt;, otherwise
all bits of &lt;code&gt;code&lt;/code&gt; are zero.&lt;/p&gt;&lt;code&gt;code&lt;/code&gt; for
each digit&lt;p&gt;The table below shows the correspondence between digits and their binary representation:&lt;/p&gt;&lt;code&gt;code&lt;/code&gt; in
Zig&lt;p&gt;The value of &lt;code&gt;code&lt;/code&gt; is calculated in the function
&lt;code&gt;set&lt;/code&gt; using a left shift operator only if &lt;code&gt;c&lt;/code&gt; is
not zero:&lt;/p&gt;&lt;code&gt;code = @as(u9,1) &amp;lt;&amp;lt; (c-1);&lt;/code&gt;
&lt;p&gt;In Zig, constants must have a proper size in order to allow an operation to be compiled and to attribute the the result of an operation to a given variable. In this case, &lt;code&gt;code&lt;/code&gt; is declared of type
&lt;code&gt;u9&lt;/code&gt;. That‚Äôs another fundamental quality of Zig, to be able
to have variables with arbitrary bit size. As can be
seen in the table above, the maximum value that &lt;code&gt;code&lt;/code&gt; can have is 256,
which requires at least 9 bits to represent. The built-in
&lt;code&gt;@as&lt;/code&gt; allows to cast the &lt;code&gt;1&lt;/code&gt; constant to type
&lt;code&gt;u9&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;By representing digits as bits one can mirror the entire grid in much simpler ways.&lt;/p&gt;&lt;p&gt;The array &lt;code&gt;lines&lt;/code&gt; mirrors the entire grid by representing
each line with a &lt;code&gt;9&lt;/code&gt; bits integer, each bit representing a
decimal digit that might be present in the a line:&lt;/p&gt;&lt;code&gt;var   lines   = [_]u9{0} ** 9; &lt;/code&gt;
&lt;p&gt;In this way, by just accessing this array with the line &lt;code&gt;i&lt;/code&gt; of an element in the 9x9 grid one can know if a given
digit is already present in that line, by just performing a bitwise
and ( &lt;code&gt;&amp;amp;&lt;/code&gt; ) with the digit‚Äôs
&lt;code&gt;code&lt;/code&gt;, in this way:&lt;/p&gt;&lt;code&gt;lines[i] &amp;amp; code&lt;/code&gt;
&lt;p&gt;If the result of the operation above is zero, this means the digit is not yet present in the line &lt;code&gt;i&lt;/code&gt;. Otherwise we have a
duplicate.&lt;/p&gt;&lt;p&gt;The array &lt;code&gt;columns&lt;/code&gt; mirrors the entire grid by
representing each column with a &lt;code&gt;9&lt;/code&gt; bits integer:&lt;/p&gt;&lt;code&gt;var   columns = [_]u9{0} ** 9;&lt;/code&gt;
&lt;p&gt;In this way, by just accessing this array with the column &lt;code&gt;j&lt;/code&gt; of an element in the 9x9 grid one can know if a given
digit is already present in that column, by just performing a bitwise
and ( &lt;code&gt;&amp;amp;&lt;/code&gt; ) with the digit‚Äôs
&lt;code&gt;code&lt;/code&gt;, in this way:&lt;/p&gt;&lt;code&gt;columns[i] &amp;amp; code&lt;/code&gt;
&lt;p&gt;If the result of the operation above is zero, this means the digit is not yet present in the column &lt;code&gt;j&lt;/code&gt; . Otherwise it‚Äôs a
duplicate.&lt;/p&gt;&lt;p&gt;Let‚Äôs suppose an empty Sudoku grid, as it is the case when one is populating the grid with the input string as done in the examples. A new digit inserted at any empty element, must not already exist in the entire line, column or cell containing the new element.&lt;/p&gt;&lt;p&gt;Let‚Äôs suppose now this grid, already initialized:&lt;/p&gt;&lt;p&gt;A cell is each one of the nine 3x3 grids delimited by the thick lines. The key knowledge to understand at this point is that each specific element in the 9x9 grid has a unique line, column and cell that contains this element.&lt;/p&gt;&lt;p&gt;For example, the first cell of the grid contains the values: 3, 5, 6, 8, and 9. Therefore, the values: 1, 2, 4 and 7 are missing. Let‚Äôs suppose one is willing to place the value 7 in one of the empty places in the first cell. Obviously, one cannot place it in the only empty element of the first line, because 7 is already present in that line. One cannot place it in the only empty place in the first column either since 7 is already in that column. One can only place the 7 in one of the two empty elements of the second line. But one can‚Äôt know for sure which one is the good one.&lt;/p&gt;&lt;p&gt;Let‚Äôs examine now the second cell, which contains the values: 1, 5, 7, and 9. One can see that the only possible element in this cell where an 8 can be placed is in the first line at the empty position on the right of the value 7.&lt;/p&gt;&lt;p&gt;Arrays &lt;code&gt;lines&lt;/code&gt; and &lt;code&gt;columns&lt;/code&gt; take care of
checking duplicates in lines and in columns. A new array is then needed
to check duplicates in cells.&lt;/p&gt;&lt;p&gt;The array &lt;code&gt;cells&lt;/code&gt; mirrors the entire grid by representing
each cell with a &lt;code&gt;9&lt;/code&gt; bits integer:&lt;/p&gt;&lt;code&gt;var   cells   = [_]u9{0} ** 9;    // all elements at each cell&lt;/code&gt;
&lt;p&gt;Here is where things get more complicated. One cannot access &lt;code&gt;cells&lt;/code&gt; directly using the line or the column. It would be
easier if one could access &lt;code&gt;cells&lt;/code&gt; as a 3x3 matrix. This can
be done mimicking what has been done for the 9x9 matrix, that is,
filling the array &lt;code&gt;cell&lt;/code&gt; as follows:&lt;/p&gt;&lt;code&gt;const cell = fill3x3: {           // cell array to allows access
   var m : [3][*]u9 = undefined;  // cell elements as a matrix,
   var pt : [*]u9 = &amp;amp;cells;       // cell[cindx[i]][cindx[j]]
   for (0..3) |i| {               // 
      m[i] = pt;                  // stores pointers of each line
      pt += 3;                    // at each position of cell
   }                              //
   break :fill3x3 m;              // initializes cell with m
};                                //&lt;/code&gt;
&lt;p&gt;But now one needs to determine the line and column in &lt;code&gt;cell&lt;/code&gt; matrix from the line and column of the element in the
original 9x9 grid. One could use integer divisions to divide the line
and column by 3 to obtain the proper indexes, but a division operation
is notoriously slow. Two divisions makes it even worse. One can use the
following array to give the result of the division as follows:&lt;/p&gt;&lt;code&gt;const cindx   = [_]usize{ 0,0,0, 1,1,1, 2,2,2 };&lt;/code&gt;
&lt;p&gt;In this way, by just accessing this matrix with the line &lt;code&gt;i&lt;/code&gt; and column &lt;code&gt;j&lt;/code&gt; of an element in the 9x9 grid,
one can know if a given digit is already present in this element‚Äôs cell
by just performing a bitwise and ( &lt;code&gt;&amp;amp;&lt;/code&gt; )
with the digit‚Äôs &lt;code&gt;code&lt;/code&gt;, in this way:&lt;/p&gt;&lt;code&gt;cell[cindx[i]][cindx[j]] &amp;amp; code&lt;/code&gt;
&lt;p&gt;If the result of the operation above is zero, this means the digit is not yet present in the cell. Otherwise it‚Äôs a duplicate.&lt;/p&gt;&lt;p&gt;The complete test to verify if an element is duplicated can be done by composing with a bitwise or ( &lt;code&gt;|&lt;/code&gt; )
all the previous elements in the same line, column and cell, and then
performing a bitwise and ( &lt;code&gt;&amp;amp;&lt;/code&gt; ) with
the element‚Äôs &lt;code&gt;code&lt;/code&gt;, in this way:&lt;/p&gt;&lt;code&gt;if (((lines[i]|columns[j]|cell[cindx[i]][cindx[j]])&amp;amp;code) !=  0) {
    unreachable;
}&lt;/code&gt;
&lt;p&gt;If the result is zero it‚Äôs because the element doesn‚Äôt exist yet in its line, column or cell. If the result is not zero the program stops because it tries to run the instruction &lt;code&gt;unreacheable&lt;/code&gt;. This
is the simplest way to explicitly indicate an execution error in Zig.
Notice that the actual code in &lt;code&gt;set&lt;/code&gt; function also prints the
details where the error occurs.&lt;/p&gt;&lt;p&gt;For example, replacing the &lt;code&gt;'0'&lt;/code&gt; right after the first
&lt;code&gt;'8'&lt;/code&gt; by a &lt;code&gt;'5'&lt;/code&gt; in the string passed to
&lt;code&gt;set&lt;/code&gt; gives the following error while testing example.zig:&lt;/p&gt;&lt;p&gt;This is because in column 1 there was already a 5 in line 3 as the error message says. The error is due to a panic caused by reaching an unreachable code at function &lt;code&gt;set&lt;/code&gt; as indicated.&lt;/p&gt;&lt;p&gt;In function &lt;code&gt;set&lt;/code&gt;, a double &lt;code&gt;for&lt;/code&gt; loop
interacts line by line to copy each new element from the input string
&lt;code&gt;s&lt;/code&gt; into the grid as indicated below (variable &lt;code&gt;k&lt;/code&gt;
keeps the index of the new input character in the string
&lt;code&gt;s&lt;/code&gt;):&lt;/p&gt;&lt;code&gt;   for ( 0..9 ) |i| {
      line = matrix[i];
      for ( 0..9 ) |j| {
        c = @intCast(s[k]-'0');
        if (c != 0) {
          code = @as(u9,1) &amp;lt;&amp;lt; (c-1);
          ‚ãÆ  // rest of the code
        }
        line[j] = c;
        k+= 1;  
      }
   }&lt;/code&gt;
&lt;p&gt;The character is converted to an &lt;code&gt;u4&lt;/code&gt; (variable
&lt;code&gt;c&lt;/code&gt;) by subtracting &lt;code&gt;'0'&lt;/code&gt; from it. If the new
element to be inserted in the grid is not equal to zero (
&lt;code&gt;c != 0&lt;/code&gt; ), &lt;code&gt;code&lt;/code&gt; (calculated with a left shift
instruction as indicated) is copied in each of the mirror grids, by
doing a bitwise or ( &lt;code&gt;|=&lt;/code&gt; ) with the
corresponding mirror grid, that is:&lt;/p&gt;&lt;code&gt;    lines[i] |= code;
    columns[j] |= code;
    cell[cindx[i]][cindx[j]] |= code;&lt;/code&gt;
&lt;p&gt;No test is required to explicitly test if the value of &lt;code&gt;c&lt;/code&gt;
is between &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;9&lt;/code&gt; because an overflow will
occur at execution time when the shift operation is executed. For
example, replacing the &lt;code&gt;'0'&lt;/code&gt; right after the first
&lt;code&gt;'8'&lt;/code&gt; of the input string by a &lt;code&gt;':'&lt;/code&gt; in the string
passed to &lt;code&gt;set&lt;/code&gt; gives the following error while testing example.zig:&lt;/p&gt;&lt;p&gt;By substituting the same &lt;code&gt;'0'&lt;/code&gt; by a &lt;code&gt;'/'&lt;/code&gt; a
similar execution error will issued. The program will work only if the
values are between &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;9&lt;/code&gt;, that is, if the
input grid contains only decimal digits.&lt;/p&gt;&lt;p&gt;Many Sudoku grids on the web also represent &lt;code&gt;'0'&lt;/code&gt; as a
&lt;code&gt;'.'&lt;/code&gt;. That‚Äôs the reason the following line exists in
&lt;code&gt;set&lt;/code&gt; function:&lt;/p&gt;&lt;code&gt;if (s[k] == '.') c = 0;&lt;/code&gt;
&lt;p&gt;This will conveniently bypass the shift operation because the value of &lt;code&gt;c&lt;/code&gt; is zero.&lt;/p&gt;&lt;p&gt;The forced errors shown in the two sections above demonstrate important features of Zig that might have passed inconspicuously. One is Zig‚Äôs robustness. In the case of the shift operation no wrong behavior is allowed and the situation is caught at execution time, as has been shown.&lt;/p&gt;&lt;p&gt;One might think that all the efforts in Zig are towards efficiency, but here it‚Äôs a typical case where performance was traded for robustness. One can have mixed feelings about this decision, when performance was the ultimate goal. In C, for example, it‚Äôs the programmer‚Äôs problem if a shift operation loses a bit and this translates in better performance for this specific Assembler instruction.&lt;/p&gt;&lt;p&gt;Another feature demonstrated in the two sections above is the possibility of using the test blocks for prototyping as suggested at the beginning of the article. The possibilities are numerous, even though the application shown was only to debug certain situations in cases of error.&lt;/p&gt;&lt;p&gt;These features alone demonstrate an awesome power, very rare in programming languages, particularly in compiled programing languages.&lt;/p&gt;&lt;p&gt;This is all quite surprising and let one think that many advantages previously found only in interpreted languages are gradually migrating to compiled languages in order to offer more performance. [A reference to Mojo here looks appropriate].&lt;/p&gt;&lt;p&gt;Zig resemblance to interpreted languages is quite striking, particularly with its concept of compile time execution, unfortunately not stressed enough in this article. This is an aspect of Zig that on one hand makes it particularly different and powerful but on the other hand difficult to grasp.&lt;/p&gt;&lt;p&gt;I concentrated more in instructing how to have a quick and easy start with the language, and in simple aspects that make Zig language cool, although there are many other aspects not mentioned here that are also quite impressive.&lt;/p&gt;&lt;p&gt;The examples shown here are simplified versions of a more involved program to solve Sudoku grids, which was also developed in Java and in C. The documentation in this repository explains in detail most of the structures and algorithms used to accomplish that.&lt;/p&gt;&lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://nilostolte.github.io/tech/articles/ZigCool.html"/><published>2025-11-07T23:04:39+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45852642</id><title>Analysis of Hedy Lamarr's Contribution to Spread-Spectrum Communication</title><updated>2025-11-08T03:14:47.580256+00:00</updated><content>&lt;doc fingerprint="92afdfbf3cdfd3e0"&gt;
  &lt;main&gt;
    &lt;p&gt;JavaScript is required to use this app.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://researchers.one/articles/24.01.00001v4"/><published>2025-11-07T23:42:01+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45852854</id><title>Snapchat open-sources Valdi a cross-platform UI framework</title><updated>2025-11-08T03:14:47.115300+00:00</updated><content>&lt;doc fingerprint="777bc13e072966c6"&gt;
  &lt;main&gt;
    &lt;p&gt;Note&lt;/p&gt;
    &lt;p&gt;Beta Status: Valdi has been widely used in Snap's production apps for the last 8 years. We're calling this a beta because our tools and documentation need more battle testing in the open source world. Valdi will exit beta when we're happy with the developer experience.&lt;/p&gt;
    &lt;p&gt;Valdi is a cross-platform UI framework that delivers native performance without sacrificing developer velocity. Write your UI once in declarative TypeScript, and it compiles directly to native views on iOS, Android, and macOS‚Äîno web views, no JavaScript bridges.&lt;/p&gt;
    &lt;p&gt;A basic Valdi component:&lt;/p&gt;
    &lt;code&gt;import { Component } from 'valdi_core/src/Component';

class HelloWorld extends Component {
  onRender() {
    const message = 'Hello World! üëª';
    &amp;lt;view backgroundColor='#FFFC00' padding={30}&amp;gt;
      &amp;lt;label color='black' value={message} /&amp;gt;
    &amp;lt;/view&amp;gt;;
  }
}&lt;/code&gt;
    &lt;p&gt;Valdi is a cross-platform UI framework designed to solve the fundamental problem of cross-platform development: velocity vs. runtime performance. For 8 years, it has powered a large portion of Snap's production apps.&lt;/p&gt;
    &lt;p&gt;Unlike frameworks that rely on web views or JavaScript bridges, Valdi compiles declaratively rendered TypeScript components into platform-native views. Valdi also includes several other performance advantages:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Automatic view recycling - Global view pooling system reuses native views across all screens, dramatically reducing inflation latency&lt;/item&gt;
      &lt;item&gt;Optimized component rendering - Components re-render independently without triggering parent re-renders, enabling fast incremental updates&lt;/item&gt;
      &lt;item&gt;Optimized layout engine - C++ layout engine runs on the main thread with minimal marshalling overhead&lt;/item&gt;
      &lt;item&gt;Viewport-aware rendering - Only visible views are inflated, making infinite scrolling performant by default&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Learn more in our Performance Optimization Guide.&lt;/p&gt;
    &lt;p&gt;Valdi eliminates the traditional compile-test-debug cycle that slows native development:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Instant hot reload - See changes in milliseconds on iOS, Android, or desktop without recompiling&lt;/item&gt;
      &lt;item&gt;Full VSCode debugging - Set breakpoints, inspect variables, profile performance, and capture heap dumps directly in VSCode&lt;/item&gt;
      &lt;item&gt;Familiar syntax - TSX components with TypeScript for type safety&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Valdi integrates easily into existing apps - start small and scale as needed:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Embed Valdi in native - Drop Valdi components into existing UIKit or Android view hierarchies&lt;/item&gt;
      &lt;item&gt;Embed native in Valdi - Use platform-specific views within Valdi layouts via &lt;code&gt;&amp;lt;custom-view&amp;gt;&lt;/code&gt;&lt;/item&gt;
      &lt;item&gt;Polyglot modules - Write performance-critical code in C++, Swift, Kotlin, or Objective-C with type-safe bindings to TypeScript&lt;/item&gt;
      &lt;item&gt;Full-stack architecture - Build entire features in Valdi with worker threads for background processing, eliminating platform-specific bridge code&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Valdi generates type-safe bindings between TypeScript and native platforms:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Automatic code generation - TypeScript interfaces compile to Kotlin, Objective-C, and Swift bindings&lt;/item&gt;
      &lt;item&gt;Native API access - Direct access to platform APIs and third-party native libraries through polyglot modules&lt;/item&gt;
      &lt;item&gt;Bidirectional communication - Pass complex data structures and callbacks between TypeScript and native code safely&lt;/item&gt;
      &lt;item&gt;Native protobuf support - Seamless integration with protobuf for efficient data serialization&lt;/item&gt;
    &lt;/list&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Powers critical features in production Snap apps.&lt;/item&gt;
      &lt;item&gt;Supports advanced animations, real-time rendering, and complex gesture systems&lt;/item&gt;
    &lt;/list&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Flexbox layout system with automatic RTL support&lt;/item&gt;
      &lt;item&gt;Worker threads for multi-threaded JavaScript execution&lt;/item&gt;
      &lt;item&gt;Native animations for native look and feel&lt;/item&gt;
      &lt;item&gt;Advanced gesture recognition with platform-native handling&lt;/item&gt;
      &lt;item&gt;Built-in testing framework with component-level unit tests&lt;/item&gt;
      &lt;item&gt;Bazel integration for reproducible, incremental builds&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Join our Discord for support.&lt;/p&gt;
    &lt;p&gt;Please follow the contributing guidelines.&lt;/p&gt;
    &lt;p&gt;Valdi is made available under the MIT License.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://github.com/Snapchat/Valdi"/><published>2025-11-08T00:14:50+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45852895</id><title>Immutable Software Deploys Using ZFS Jails on FreeBSD</title><updated>2025-11-08T03:14:46.933003+00:00</updated><content>&lt;doc fingerprint="eab8fd53f56d28e5"&gt;
  &lt;main&gt;
    &lt;head rend="h1"&gt;Immutable Software Deploys Using ZFS Jails on FreeBSD&lt;/head&gt;
    &lt;p&gt;FreeBSD‚Äôs native support for ZFS snapshots and jails provides a powerful foundation for immutable deployments. By creating a new jail from a ZFS snapshot for every release, we get instant roll‚Äëbacks, zero‚Äëdowntime upgrades, and a clean, reproducible environment. This article walks through the (very opinionated) flow that we use. From jails setup through running Caddy as a health‚Äëchecked reverse proxy in front of the jails.&lt;/p&gt;
    &lt;head rend="h1"&gt;1. Prerequisites&lt;/head&gt;
    &lt;p&gt;FreeBSD 14+ (or the latest stable release) offers the necessary ZFS and jail primitives. Enabling ZFS with a zpool installed allows cheap, instant cloning. The Caddy v2 binary handles TLS, reverse-proxying, and health checks.&lt;/p&gt;
    &lt;head rend="h1"&gt;2. Architecture Overview&lt;/head&gt;
    &lt;code&gt;+--------------------+      +------------------------+      +-------------------+
|                    |      |                        |      |                   |
|   Caddy (reverse   | &amp;lt;-&amp;gt;  |  Immutable Jails       | &amp;lt;-&amp;gt;  |  Application      |
|   proxy &amp;amp; health-  |      |  (ZFS snapshot/clone)  |      |  inside each jail |
|   check)           |      |                        |      |                   |
|                    |      |                        |      |                   |
+--------------------+      +------------------------+      +-------------------+
&lt;/code&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Caddy routes to the currently healthy jail.&lt;/item&gt;
      &lt;item&gt;Each deployment clones a ZFS snapshot ‚Üí new jail.&lt;/item&gt;
      &lt;item&gt;After passing health‚Äëchecks, Caddy reconfigures to the new jail.&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h1"&gt;3. Configure the Jails Host Server&lt;/head&gt;
    &lt;p&gt;Create a new loopback network interface for the jails. We'll use 172.16.0.0/12 which means jails can use any IP address within the range 172.16.0.1 ‚Äì 172.31.255.254. Then create a new service to manage the loopback interface via a file at '/usr/local/etc/rc.d/lo1' with the following content:&lt;/p&gt;
    &lt;code&gt;#!/bin/sh
# PROVIDE: lo1
# REQUIRE: NETWORKING
# BEFORE:  jail
# KEYWORD: shutdown

. /etc/rc.subr

name="lo1"
command="ifconfig"

start_cmd="${command} ${name} create &amp;amp;&amp;amp; ${command} ${name} inet 172.16.0.1 netmask 255.240.0.0 up"
stop_cmd="${command} ${name} down"

run_rc_command "$1"
&lt;/code&gt;
    &lt;p&gt;Then make the service start at boot and enable it:&lt;/p&gt;
    &lt;code&gt;chmod +x /usr/local/etc/rc.d/lo1
sysrc lo1_enable="YES"
service lo1 start
&lt;/code&gt;
    &lt;p&gt;Now we can go onwards to enabling jails:&lt;/p&gt;
    &lt;code&gt;sysrc jail_enable="YES"
sysrc jail_parallel_start="YES"
&lt;/code&gt;
    &lt;p&gt;Create a /etc/jail.conf file with the below configurations so that it includes the configurations for each jail.&lt;/p&gt;
    &lt;quote&gt;&lt;p&gt;NOTE: Each jail configuration should be placed in a separate file in '/etc/jail.conf.d/'.&lt;/p&gt;&lt;lb/&gt;NOTE: The leading '.' before include is required.&lt;/quote&gt;
    &lt;code&gt;.include "/etc/jail.conf.d/*.conf";
&lt;/code&gt;
    &lt;p&gt;Create a ZFS dataset mount point and paths for the jails:&lt;/p&gt;
    &lt;code&gt;zfs create -o mountpoint=/usr/local/jails zroot/jails
&lt;/code&gt;
    &lt;p&gt;Create child datasets for the jails:&lt;/p&gt;
    &lt;code&gt;# Contains the compressed files of the downloaded userlands.
zfs create zroot/jails/media
# Will contain the templates.
zfs create zroot/jails/templates
# Will contain the containers.
zfs create zroot/jails/containers
&lt;/code&gt;
    &lt;head rend="h1"&gt;4. Build the Base Image Template&lt;/head&gt;
    &lt;p&gt;Download the base FreeBSD image and unpack it:&lt;/p&gt;
    &lt;code&gt;# Set environment variable for the FreeBSD version. Note that the cut is to remove the patch level.
export FREEBSD_VERSION=$(freebsd-version | cut -d- -f1-2)
zfs create -p zroot/jails/templates/$FREEBSD_VERSION
fetch https://download.freebsd.org/ftp/releases/$(uname -m)/$FREEBSD_VERSION/base.txz -o /usr/local/jails/media/$FREEBSD_VERSION-base.txz
tar -xf /usr/local/jails/media/$FREEBSD_VERSION-base.txz -C /usr/local/jails/templates/$FREEBSD_VERSION --unlink
&lt;/code&gt;
    &lt;p&gt;Copy critical files to the image template:&lt;/p&gt;
    &lt;code&gt;cp /etc/resolv.conf /usr/local/jails/templates/$FREEBSD_VERSION/etc/resolv.conf
cp /etc/localtime /usr/local/jails/templates/$FREEBSD_VERSION/etc/localtime
&lt;/code&gt;
    &lt;p&gt;Update the image template to the latest patch level.&lt;/p&gt;
    &lt;code&gt;freebsd-update -b /usr/local/jails/templates/$FREEBSD_VERSION fetch install
&lt;/code&gt;
    &lt;p&gt;Finally, create a ZFS snapshot of the base image template. From this snapshot we we'll use ZFS clones to create new jails.&lt;/p&gt;
    &lt;code&gt;zfs snapshot zroot/jails/templates/$FREEBSD_VERSION@base
&lt;/code&gt;
    &lt;head rend="h1"&gt;5. Create a New Jail&lt;/head&gt;
    &lt;p&gt;Check which ip addresses on the 'lo1' loopback interface are in use so that we can assign an available ip address to the new jail.&lt;/p&gt;
    &lt;code&gt;ifconfig lo1 | grep 'inet ' | awk '{print $2}'
&lt;/code&gt;
    &lt;p&gt;Lookup the git repo commit hash for the latest commit.&lt;/p&gt;
    &lt;code&gt;git ls-remote https://github.com/yourusername/mygitrepo.git | head
&lt;/code&gt;
    &lt;p&gt;Clone the base image template to create a new jail. We'll be creating a new jail within our git repo path.&lt;/p&gt;
    &lt;code&gt;export FREEBSD_VERSION=$(freebsd-version | cut -d- -f1-2)
export JAIL_NAME=mygitrepo_gitSHA
zfs clone zroot/jails/templates/$FREEBSD_VERSION@base zroot/jails/containers/$JAIL_NAME
&lt;/code&gt;
    &lt;p&gt;Create a config file for the jail to be located at '/etc/jail.conf.d/$JAIL_NAME.conf'.&lt;lb/&gt; We name the jail using the SHA of the git commit that we're deploying.&lt;/p&gt;
    &lt;code&gt;mygitrepo_gitSHA {
	# STARTUP/LOGGING
	exec.start = "/bin/sh /etc/rc";
	exec.stop = "/bin/sh /etc/rc.shutdown";
	exec.consolelog = "/var/log/jail_console_${name}.log";

	# PERMISSIONS
	allow.raw_sockets;
	exec.clean;
	mount.devfs;

	# HOSTNAME/PATH
	host.hostname = "${name}";
	path = "/usr/local/jails/containers/${name}";

	# NETWORK. We're using the lo1 loopback interface that we created for jails to use.
	interface = lo1;
	ip4.addr = 172.16.0.2; # Use an available ip address within the range of the lo1 interface. You can find available ip addresses by running "ifconfig lo1 | grep 'inet ' | awk '{print $2}'"
}
&lt;/code&gt;
    &lt;p&gt;Start the jail.&lt;/p&gt;
    &lt;code&gt;service jail start $JAIL_NAME
&lt;/code&gt;
    &lt;p&gt;Confirm that the jail's ipaddress is within the range of the lo1 interface:&lt;/p&gt;
    &lt;code&gt;jexec $JAIL_NAME ifconfig lo1 | awk '/inet /{print $2}'
&lt;/code&gt;
    &lt;p&gt;Confirm that the jail is up and what it's running:&lt;/p&gt;
    &lt;code&gt;jls
jexec $JAIL_NAME ps aux
&lt;/code&gt;
    &lt;head rend="h1"&gt;6 Create a Proof of Concept Service Within Our Newly Created Jail&lt;/head&gt;
    &lt;p&gt;Here is the proof of concept Go hello world binary that we'll run as a service within the jail.&lt;/p&gt;
    &lt;code&gt;// main.go
package main

import (
	"fmt"
	"log"
	"net/http"
)

func main() {
	http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
		fmt.Fprintf(w, "Hello World!")
	})
	http.HandleFunc("/up", func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusOK)
	})
	log.Fatal(http.ListenAndServe(":8080", nil))
}
&lt;/code&gt;
    &lt;p&gt;Build the binary and place it in the jail's bin directory.&lt;/p&gt;
    &lt;code&gt;go build main.go
mkdir -p /usr/local/jails/containers/$JAIL_NAME/usr/local/bin
cp main /usr/local/jails/containers/$JAIL_NAME/usr/local/bin/main
&lt;/code&gt;
    &lt;p&gt;Create a service file for the binary.&lt;/p&gt;
    &lt;code&gt;#!/bin/sh
#
# PROVIDE: main
# REQUIRE: LOGIN
# KEYWORD: shutdown

. /etc/rc.subr

name="main"
rcvar="main_enable"

# Path to your Go binary
command="/usr/local/bin/main"
pidfile="/var/run/${name}.pid"

# Redirect output to a log file
logfile="/var/log/${name}.log"

# How to start the process
start_cmd="${name}_start"
stop_cmd="${name}_stop"

main_start() {
	echo "Starting ${name}..."
	daemon -p "${pidfile}" -f -o "${logfile}" "${command}"
}

main_stop() {
	echo "Stopping ${name}..."
	if [ -f "${pidfile}" ]; then
		kill "$(cat ${pidfile})" &amp;amp;&amp;amp; rm -f "${pidfile}"
	else
		echo "No pidfile found; process may not be running."
	fi
}

load_rc_config $name
: ${main_enable:="NO"}

run_rc_command "$1"
&lt;/code&gt;
    &lt;p&gt;Copy the service file to the jail's /etc/rc.d directory and enable it.&lt;/p&gt;
    &lt;code&gt;mkdir -p /usr/local/jails/containers/$JAIL_NAME/usr/local/etc/rc.d
cp /usr/local/etc/rc.d/main /usr/local/jails/containers/$JAIL_NAME/usr/local/etc/rc.d/main
jexec $JAIL_NAME chmod +x /usr/local/etc/rc.d/main
jexec $JAIL_NAME sysrc main_enable=YES
jexec $JAIL_NAME service main start
&lt;/code&gt;
    &lt;p&gt;Setup log rotation so they don't fill up the disk, and do the initial rotation.&lt;/p&gt;
    &lt;code&gt;jexec $JAIL_NAME sh -c "echo '/var/log/main.log  root:wheel  644  5  100  *  Z  /var/run/main.pid' &amp;gt;&amp;gt; /etc/newsyslog.conf.d/main.conf"
jexec $JAIL_NAME newsyslog -vF
&lt;/code&gt;
    &lt;p&gt;Confirm the service is running.&lt;/p&gt;
    &lt;code&gt;jexec $JAIL_NAME service main status
curl 172.16.0.2:8080 # Use the ip address of the jail.
&lt;/code&gt;
    &lt;head rend="h1"&gt;7 Setup Caddy (reverse proxy)&lt;/head&gt;
    &lt;p&gt;Add a 'service', or similar, group to the system if it doesn't already exist. This group should have permissions to write to the pid and log files. Make sure to use the same group in the next step when we create a user.&lt;/p&gt;
    &lt;code&gt;pw groupadd service
chown root:service /var/run
chown root:service /var/log
chmod 770 /var/run
chmod 770 /var/log
&lt;/code&gt;
    &lt;p&gt;Add a user and assign permissions. Make sure to add the user without login capabilities and assign to the 'service' group.&lt;/p&gt;
    &lt;code&gt;pw useradd caddy -d /nonexistent -s /sbin/nologin -c "Caddy Service Account" -g service
&lt;/code&gt;
    &lt;quote&gt;
      &lt;p&gt;Note: We're running Caddy behind a Cloudflare Tunnel on port 8080. If you're not and using a port below 1024 then you'll need to setup security/portacl-rc to enable privileged port binding, and configure for user 'caddy'. This will allow the caddy user to bind to ports below 1024.&lt;/p&gt;
      &lt;code&gt;pkg install security/portacl-rc sysrc portacl_users+=caddy sysrc portacl_user_caddy_tcp="http https" sysrc portacl_user_caddy_udp="https" service portacl enable service portacl start&lt;/code&gt;
    &lt;/quote&gt;
    &lt;p&gt;Install Caddy.&lt;/p&gt;
    &lt;code&gt;cd /usr/ports/www/caddy
make install clean
&lt;/code&gt;
    &lt;p&gt;Change the ownership of the caddy binary and required files to the caddy user.&lt;/p&gt;
    &lt;code&gt;chown caddy:service /usr/local/bin/caddy
chmod 740 /usr/local/bin/caddy
chown -R caddy:service /var/log/caddy
chown -R caddy:service /usr/local/etc/caddy
chown -R caddy:service /var/db/caddy
&lt;/code&gt;
    &lt;p&gt;Setup log rotation so they don't fill up the disk.&lt;/p&gt;
    &lt;code&gt;echo '/var/log/caddy.log  root:wheel  644  5  100  *  Z  /var/run/caddy.pid' &amp;gt;&amp;gt; /etc/newsyslog.conf.d/caddy.conf
newsyslog -vF
&lt;/code&gt;
    &lt;p&gt;Add the caddy service to the system startup and make sure it runs as the caddy user.&lt;/p&gt;
    &lt;code&gt;sysrc -f /etc/rc.conf caddy_enable="YES"
sysrc -f /etc/rc.conf caddy_user="caddy"
sysrc -f /etc/rc.conf caddy_group="service"
&lt;/code&gt;
    &lt;p&gt;Caddy reads the configuration file at '/usr/local/etc/caddy/Caddyfile'.&lt;lb/&gt; Inside the jail, '/up' returns '200 OK' when healthy.&lt;lb/&gt; Caddy polls the specified health‚Äëcheck endpoint using the healthcheck directive, routing traffic exclusively to backends that return a successful health check.&lt;/p&gt;
    &lt;quote&gt;
      &lt;p&gt;Important: We're only disabling automatic HTTPS because we're running behind a Cloudflare Tunnel. If that's not the case, you should enable automatic HTTPS by removing the 'auto_https off' line.&lt;/p&gt;
    &lt;/quote&gt;
    &lt;code&gt;# /usr/local/etc/caddy/Caddyfile
{
	auto_https off # Note: Disable automatic HTTPS since we're running behind a Cloudflare Tunnel.
}

:8080 {

	# Matcher and reverse proxy for serviceA.null.live.
	@serviceA host serviceA.null.live # Change the hostname to your actual hostname.
	reverse_proxy @serviceA 172.16.0.2:8080 {
		health_uri /up
		health_interval 10s
		health_timeout 5s
	}

	# Matcher and reverse proxy for serviceB.null.live.
	@serviceB host serviceB.null.live # Change the hostname to your actual hostname.
	reverse_proxy @serviceB 172.16.0.3:8080 {
		health_uri /up
		health_interval 10s
		health_timeout 5s
	}
}
&lt;/code&gt;
    &lt;head rend="h1"&gt;8. Deploy a New Jail and Switch Caddy to the New Jail&lt;/head&gt;
    &lt;p&gt;Create a config file for the jail to be located at '/etc/jail.conf.d/$JAIL_NAME.conf'.&lt;lb/&gt; Make sure to replace the ip4.addr variable value with the next available ip address.&lt;/p&gt;
    &lt;code&gt;ifconfig lo1 | grep 'inet ' | awk '{print $2}'
&lt;/code&gt;
    &lt;code&gt;mygitrepo_gitSHA {
	# STARTUP/LOGGING
	exec.start = "/bin/sh /etc/rc";
	exec.stop = "/bin/sh /etc/rc.shutdown";
	exec.consolelog = "/var/log/jail_console_${name}.log";

	# PERMISSIONS
	allow.raw_sockets;
	exec.clean;
	mount.devfs;

	# HOSTNAME/PATH
	host.hostname = "${name}";
	path = "/usr/local/jails/containers/${name}";

	# NETWORK. We're using the lo1 loopback interface that we created for jails to use.
	interface = lo1;
	ip4.addr = 172.16.0.3; # Use the ip address we found in the previous step.
}
&lt;/code&gt;
    &lt;p&gt;Create a new jail. We name our jail using the format: mygitrepo_gitSHA. For the repo of the application being deployed. This makes it easy to track which version of the application is running in each jail. The last line is used to confirm the jail is running.&lt;/p&gt;
    &lt;code&gt;git ls-remote https://github.com/yourusername/mygitrepo.git | head
export FREEBSD_VERSION=$(freebsd-version | cut -d- -f1-2)
export JAIL_NAME=mygitrepo_gitSHA
export SERVICE_NAME=conradresearchcom # Note: '-' are not allowed in service names.
zfs clone zroot/jails/templates/$FREEBSD_VERSION@base zroot/jails/containers/$JAIL_NAME

# Copy the binary of the application to the jail. We'll use our 'main' demo app from previous steps.
go build main.go
mkdir -p /usr/local/jails/containers/$JAIL_NAME/usr/local/bin
cp $SERVICE_NAME /usr/local/jails/containers/$JAIL_NAME/usr/local/bin/$SERVICE_NAME

# Copy the rc.d script to the jail.
mkdir -p /usr/local/jails/containers/$JAIL_NAME/usr/local/etc/rc.d
cp $SERVICE_NAME /usr/local/jails/containers/$JAIL_NAME/usr/local/etc/rc.d/$SERVICE_NAME

# Start the jail.
service jail start $JAIL_NAME
jexec $JAIL_NAME chmod +x /usr/local/etc/rc.d/$SERVICE_NAME
jexec $JAIL_NAME sysrc ${SERVICE_NAME}_enable=YES
jexec $JAIL_NAME service $SERVICE_NAME start
while ! curl -s -o /dev/null -w "%{http_code}" http://172.16.0.3:8080/up; do sleep 1; done
&lt;/code&gt;
    &lt;p&gt;Using your favorite text editor, update the Caddy configuration at '/usr/local/etc/caddy/Caddyfile' to point to the new jail via updating the jail's IP address to the new jail's IP address. Then run the following command to reload Caddy:&lt;/p&gt;
    &lt;code&gt;service caddy reload
&lt;/code&gt;
    &lt;head rend="h1"&gt;9. Conclusion&lt;/head&gt;
    &lt;p&gt;By combining ZFS snapshots, FreeBSD jails, and a Caddy reverse‚Äëproxy, you get:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Zero‚Äëdowntime upgrades.&lt;/item&gt;
      &lt;item&gt;Instant rollbacks.&lt;/item&gt;
      &lt;item&gt;A predictable environment that can be reproduced at any time.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Give it a try, tweak the scripts for your own stack, and enjoy the peace of mind that comes with immutable infrastructure.&lt;/p&gt;
    &lt;p&gt;Cheers ü•Ç&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://conradresearch.com/articles/immutable-software-deploy-zfs-jails"/><published>2025-11-08T00:21:45+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45852974</id><title>Mullvad: Shutting down our search proxy Leta</title><updated>2025-11-08T03:14:46.312426+00:00</updated><content>&lt;doc fingerprint="9e42cf9623e0a788"&gt;
  &lt;main&gt;
    &lt;head rend="h1"&gt;Shutting down our search proxy Leta&lt;/head&gt;
    &lt;p&gt;News√Ç&lt;/p&gt;
    &lt;p&gt;On November 27, 2025, we will shut down our search proxy, Leta.&lt;/p&gt;
    &lt;p&gt;Leta's primary benefit was that it acted as a privacy proxy for search. Pooling and caching requests on behalf of a great number of users.&lt;/p&gt;
    &lt;p&gt;The search industry continues to undergo big changes. Leta will not be able to follow and will likely become less useful over time.&lt;/p&gt;
    &lt;p&gt;Similar privacy can be achieved through the combination of a VPN and a privacy-focused browser.&lt;/p&gt;
    &lt;p&gt;We have therefore decided to discontinue Leta and continue to advance the development of state-of-the-art of VPNs and browser privacy - through our own work and research and in collaboration with our partners.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://mullvad.net/en/blog/shutting-down-our-search-proxy-leta"/><published>2025-11-08T00:37:36+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45853155</id><title>Older Adults Outnumber Children in 11 States</title><updated>2025-11-08T03:14:46.095587+00:00</updated><content>&lt;doc fingerprint="1d99783e13a23a2f"&gt;
  &lt;main&gt;
    &lt;p&gt;JUNE 26, 2025 ‚Äî The U.S. population age 65 and older rose by 3.1% (to 61.2 million) while the population under age 18 decreased by 0.2% (to 73.1 million) from 2023 to 2024, according to the Vintage 2024 Population Estimates released today by the U.S. Census Bureau.&lt;/p&gt;
    &lt;p&gt;The data show the population continued to age, with the share of the population age 65 and older steadily increasing from 12.4% in 2004 to 18.0% in 2024, and the share of children declining from 25.0% to 21.5%.&lt;/p&gt;
    &lt;p&gt;Ongoing growth among the older population, coupled with persistent annual declines in the population under age 18 has reduced the size difference between these two age groups from just over 20 million in 2020 to just below 12 million in 2024. From 2020 to 2024, the older population grew by 13.0%, significantly outpacing the 1.4% growth of working-age adults (ages 18 to 64), while the number of children declined by 1.7%.&lt;/p&gt;
    &lt;p&gt;"Children still outnumber older adults in the United States, despite a decline in births this decade,‚Äù said Lauren Bowers, chief of the Census Bureau‚Äôs Population Estimates Branch. "However, the gap is narrowing as baby boomers continue to age into their retirement years. In fact, the number of states and counties where older adults outnumber children is on the rise, especially in sparsely populated areas.‚Äù&lt;/p&gt;
    &lt;p&gt;As recently as 2020, there were just three states where older adults outnumbered children: Maine, Vermont, and Florida. By 2024, this number had increased to 11, with Delaware, Hawaii, Montana, New Hampshire, Oregon, Pennsylvania, Rhode Island, and West Virginia joining their ranks.&lt;/p&gt;
    &lt;p&gt;Similarly, from 2020 to 2024, the number of U.S. metro areas with more older adults than children increased from 58 to 112. This represents nearly 30% of the nation‚Äôs 387 metro areas. Additionally, in 2024, three metro areas with at least 1 million people (Cleveland, OH; Providence-Warwick, RI-MA; and Hartford-West Hartford-East Hartford, CT) had more older people than younger people for the first time.&lt;/p&gt;
    &lt;p&gt;In 2020, 31.3% (or 983) of the nation‚Äôs 3,144 counties had more older adults than children. This figure increased to almost 45% (1,411 counties) in 2024. In both years, most of these counties had small populations and were located outside of metro and micro areas.&lt;/p&gt;
    &lt;p&gt;Note: References to race and Hispanic origin compositions are for non-Hispanic race alone groups. Hispanic or Latino populations are of any race unless otherwise specified.&lt;/p&gt;
    &lt;table&gt;
      &lt;row span="6"&gt;
        &lt;cell role="head"&gt;Race alone or Hispanic origin&lt;/cell&gt;
        &lt;cell role="head"&gt;April 1, 2020 (estimates base)&lt;/cell&gt;
        &lt;cell role="head"&gt;July 1, 2023&lt;/cell&gt;
        &lt;cell role="head"&gt;July 1, 2024&lt;/cell&gt;
        &lt;cell role="head"&gt;Numeric change 2023-2024&lt;/cell&gt;
        &lt;cell role="head"&gt;Percent change 2023-2024&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="6"&gt;
        &lt;cell&gt;Source: U.S. Census Bureau, Vintage 2024 Population Estimates&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="6"&gt;
        &lt;cell&gt;White&lt;/cell&gt;
        &lt;cell&gt;197,579,168&lt;/cell&gt;
        &lt;cell&gt;195,659,296&lt;/cell&gt;
        &lt;cell&gt;195,433,224&lt;/cell&gt;
        &lt;cell&gt;-226,072&lt;/cell&gt;
        &lt;cell&gt;-0.1%&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="6"&gt;
        &lt;cell&gt;Hispanic or Latino&lt;/cell&gt;
        &lt;cell&gt;62,075,161&lt;/cell&gt;
        &lt;cell&gt;66,142,156&lt;/cell&gt;
        &lt;cell&gt;68,086,153&lt;/cell&gt;
        &lt;cell&gt;1,943,997&lt;/cell&gt;
        &lt;cell&gt;2.9%&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="6"&gt;
        &lt;cell&gt;Black or African American&lt;/cell&gt;
        &lt;cell&gt;41,716,008&lt;/cell&gt;
        &lt;cell&gt;42,514,641&lt;/cell&gt;
        &lt;cell&gt;42,951,595&lt;/cell&gt;
        &lt;cell&gt;436,954&lt;/cell&gt;
        &lt;cell&gt;1.0%&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="6"&gt;
        &lt;cell&gt;Asian&lt;/cell&gt;
        &lt;cell&gt;19,539,797&lt;/cell&gt;
        &lt;cell&gt;21,182,731&lt;/cell&gt;
        &lt;cell&gt;22,080,844&lt;/cell&gt;
        &lt;cell&gt;898,113&lt;/cell&gt;
        &lt;cell&gt;4.2%&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="6"&gt;
        &lt;cell&gt;Two or More Races&lt;/cell&gt;
        &lt;cell&gt;7,577,977&lt;/cell&gt;
        &lt;cell&gt;8,217,797&lt;/cell&gt;
        &lt;cell&gt;8,441,923&lt;/cell&gt;
        &lt;cell&gt;224,126&lt;/cell&gt;
        &lt;cell&gt;2.7%&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="6"&gt;
        &lt;cell&gt;American Indian and Alaska Native&lt;/cell&gt;
        &lt;cell&gt;2,409,713&lt;/cell&gt;
        &lt;cell&gt;2,432,832&lt;/cell&gt;
        &lt;cell&gt;2,442,428&lt;/cell&gt;
        &lt;cell&gt;9,596&lt;/cell&gt;
        &lt;cell&gt;0.4%&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;cell&gt;Native Hawaiian and Other Pacific Islander&lt;/cell&gt;
        &lt;cell&gt;617,912&lt;/cell&gt;
        &lt;cell&gt;656,778&lt;/cell&gt;
        &lt;cell&gt;674,821&lt;/cell&gt;
        &lt;cell&gt;18,043&lt;/cell&gt;
        &lt;cell&gt;2.7%&lt;/cell&gt;
      &lt;/row&gt;
    &lt;/table&gt;
    &lt;p&gt;Today‚Äôs release includes estimates of population by race, age, sex and Hispanic origin for the nation, states, metropolitan and micropolitan statistical areas, and counties, and estimates of population by age and sex for Puerto Rico Commonwealth and its municipios.&lt;/p&gt;
    &lt;p&gt;This is the final release of the Vintage 2024 Population Estimates. The Census Bureau previously released total population estimates for the nation, states and Puerto Rico Commonwealth; metropolitan and micropolitan statistical areas; counties and Puerto Rico municipios; and incorporated places and minor civil divisions. Components of population change and housing unit estimates for the nation, states and counties are also available on the Population and Housing Unit Estimates webpage.&lt;/p&gt;
    &lt;p&gt;This release does not incorporate data from the 2020 Modified Age and Race Census files.&lt;/p&gt;
    &lt;p&gt;The full release schedule for the Population Estimates Program can be found on the Census Bureau‚Äôs website.&lt;/p&gt;
    &lt;p&gt;With each new release of annual estimates, the entire time series of estimates is revised for all years back to the date of the last census. All previously published (vintage) estimates are superseded and archived on the FTP2 site.&lt;/p&gt;
    &lt;p&gt;###&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://www.census.gov/newsroom/press-releases/2025/older-adults-outnumber-children.html"/><published>2025-11-08T01:07:26+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45853292</id><title>Sam Altman's pants are on fire</title><updated>2025-11-08T03:14:45.947340+00:00</updated><content/><link href="https://garymarcus.substack.com/p/sam-altmans-pants-are-totally-on"/><published>2025-11-08T01:39:18+00:00</published></entry></feed>