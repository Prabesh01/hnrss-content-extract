<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><id>hnrss.org/frontpage</id><title>Hacker News: Front Page</title><updated>2025-11-23T08:13:01.371398+00:00</updated><link href="https://news.ycombinator.com/" rel="alternate"/><link href="https://raw.githubusercontent.com/Prabesh01/hnrss-content-extract/refs/heads/main/out/rss.xml" rel="self"/><generator uri="https://lkiesow.github.io/python-feedgen" version="1.0.0">python-feedgen</generator><subtitle>Hacker News RSS</subtitle><entry><id>https://news.ycombinator.com/item?id=46004326</id><title>Pixel Art Tips for Programmers</title><updated>2025-11-23T08:13:10.003517+00:00</updated><content/><link href="https://jslegenddev.substack.com/p/5-pixel-art-tips-for-programmers-3d6"/><published>2025-11-21T13:25:59+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=46008332</id><title>We Induced Smells With Ultrasound</title><updated>2025-11-23T08:13:09.719183+00:00</updated><content>&lt;doc fingerprint="260999164f2bc5f8"&gt;
  &lt;main&gt;
    &lt;head rend="h1"&gt;We Induced Smells With Ultrasound&lt;/head&gt;
    &lt;p&gt;We stimulated the scent-processing brain regions with focused ultrasound. As far as we know, no one seems to have done this kind of stimulation before - even in animals. We reliably produced distinct scents such as a campfire burn or fresh air!&lt;/p&gt;
    &lt;p&gt;We pointed an ultrasound probe at the scent-processing region of the brain to obtain different sensations. Different focal spots corresponded to different smells, which we’ve replicated first-try on two people and validated with a blind trial. The sensations we obtained are:&lt;/p&gt;
    &lt;p&gt;Here is a video from our blind tasting:&lt;/p&gt;
    &lt;head rend="h2"&gt;The Setup&lt;/head&gt;
    &lt;p&gt;Smells are processed in the olfactory bulb. We decided to try to stimulate it with focused ultrasound through the skull. As far as we know, no one seems to have done this kind of olfactory stimulation before - even in animals.&lt;lb/&gt; However, after being able to induce sensations of motion the previous week, it seemed promising to try the same for olfactory.&lt;/p&gt;
    &lt;head rend="h3"&gt;The Anatomy&lt;/head&gt;
    &lt;p&gt;The olfactory bulb, our target, is tucked behind the top of the nose. That turns out to be a pretty inconvenient location for a couple of reasons:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;The nose doesn’t provide a flat surface for mounting a transducer for stimulation.&lt;/item&gt;
      &lt;item&gt;It's mostly filled with air, which interferes with ultrasound. Ultrasound needs a continuous medium to travel through, and filling the nose with gel seemed rather unappealing.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Instead, we found that you can place the transducer on the forehead and aim the ultrasound downward towards the olfactory bulb. While this isn’t a perfect solution because the frontal sinuses can weaken the signal, careful device positioning above the sinuses still allows us to reach our general target region.&lt;/p&gt;
    &lt;head rend="h3"&gt;The ultrasound&lt;/head&gt;
    &lt;p&gt;We got our first effects using just a handheld probe and some gel, but it quickly became obvious that holding a probe steady by hand makes it nearly impossible to keep the focal spot in the same place. To improve stability, we improvised a makeshift headset, allowing for more reliable positioning. We switched from gel to a solid, jello-like pad for stability and general comfort. In the end, our headset got a bit hacky:&lt;/p&gt;
    &lt;p&gt;It ended up having a knife taped to the probe for mechanical support At the time, all of our headsets had a knife taped to the probe, as untaping the knife lead to software errors.. At some point we thought of using a mouthguard for fixing the probe relative to the brain. This was a great idea considering the teeth are the only exposed part of the skull, except it turns out you can’t talk about smells while wearing a mouthguard.&lt;/p&gt;
    &lt;p&gt;To guide placement, we used an MRI of Lev’s skull to roughly determine where the transducer would point and how the focal region (where ultrasound waves actually concentrate) aligned with the olfactory bulb (the target for stimulation).&lt;/p&gt;
    &lt;p&gt;We found our “sweet spot” to be low-frequency ultrasound focused right below the forehead and angled downward toward the bulbs. Specifically:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;300 kHz frequency (low enough to penetrate the skull well)&lt;/item&gt;
      &lt;item&gt;Focal depth of about 39 mm (where the ultrasound energy converged beneath the forehead)&lt;/item&gt;
      &lt;item&gt;50–55° steering angles (to point the focus down toward the bulbs)&lt;/item&gt;
      &lt;item&gt;5-cycle pulses at a 1200 Hz repetition rate (short, rapidly repeating bursts)&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;While Albert did not have an MRI available, this general configuration still worked for him with minor adjustments to the focal spot position.&lt;/p&gt;
    &lt;head rend="h3"&gt;Safety&lt;/head&gt;
    &lt;p&gt;The largest chunk of the time was spent on making sure the ultrasound sequences behaved safely and in the manner we expected, split between two directions:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Measuring the output field. We put the transducer in a water tank and measured the pressure at the focal spot. With our parameters, it ranged from 150 to 250 kPa, which corresponded to a mechanical index of at most 0.4. That implied that the average intensity at the focal spot was by an order of magnitude lower than what's typically used in tFUS and has been proven safe. We were also far within safety limits on mechanical index and thermal dose.&lt;/item&gt;
      &lt;item&gt;Avoiding the optic nerve by reducing asymmetry in the system: the nerves are further from the middle of the head. The olfactory bulb also has its two components slightly off-center, so a bit of asymmetry was necessary: we focused at an angle of 2 degrees to the side in one of the presets. However, we stayed within the limit of 15 degrees, which is enough not to touch the optic nerves.&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h2"&gt;Results&lt;/head&gt;
    &lt;p&gt;We have managed to induce four different sensations, all of them in two people:&lt;/p&gt;
    &lt;p&gt;We distinguish between a smell and a sensation here because, subjectively, they feel different. The smells are strong and localized to the noise, almost like you could sniff around and find the source. The sensations are more diffuse: a weak, slow-onset impression of a smell, often paired with other (likely placebo) feelings, such as a light tingling on the face.&lt;/p&gt;
    &lt;p&gt;Both smells and sensations are strongest on a light in-breath, so we tested by sitting there, with a probe to the forehead, mildly sniffing. Sometimes there is a slight waft of a smell that comes on over a few breaths, and sometimes it just hits you. The first time Albert smelled the garbage, he jerked his eyes open thinking a garbage truck just drove in! This was indoors.&lt;/p&gt;
    &lt;p&gt;Many of these scents correspond not to specific receptor types but rather combinations of receptors. We think this is because the focal spot is pretty large—300kHz ultrasound in tissue has a wavelength of 5mm, while the adult human olfactory bulb is roughly 6-14mm in length The olfactory bulb can vary in size by up to 3x, depending on "age and olfactory experience", so perhaps (we're making this up) with more usage your olfactory bulb might actually get bigger, leading to better resolution stimulation!.&lt;/p&gt;
    &lt;p&gt;We found different scents by steering the beam over ~14 mm (20 degrees at 4 cm radius). The distance between freshness and burning was ~3.5 mm. We ensured that the effect was not placebo with an auditory mask (blasting music through airpods) so you don’t hear the probe, though you cannot distinguish the different focal spots through sound anyways. We then tested discrimination in a trial where Thomas selected the focal spots, and Lev was naming the scents. You can check out the full video here.&lt;/p&gt;
    &lt;p&gt;It is remarkable that we could induce different scents with such little steering (40% of the diffraction-limited focal spot size And potentially even higher, because there was some dead space in between the focal spots, where you don't feel anything.). This suggests that the resolution we have access to is much higher than the spatial resolution of the ultrasound (a kind of super-resolution for neurostim!) In particular, we do not need single-neuron resolution to find an independent basis of scents, upon which we can construct our latent space. To improve this system, the next steps are a more stable setup, increased frequency, more play with focal location, spot size, and stimulus waveform.&lt;/p&gt;
    &lt;head rend="h3"&gt;Can you feel the meaning&lt;/head&gt;
    &lt;p&gt;The reason stimulating olfactory sensations is interesting is not just "VR for smells", as one might initially assume. The nose has 400 distinct receptor types, and we can distinguish subtle combinations of their activations, so they could serve as a channel of writing directly into the brain, as a means of non-invasive neuromodulation.&lt;/p&gt;
    &lt;p&gt;The olfactory system potentially allows writing up to 400, if not 800 due to two nostrils, dimensions into the brain. That is comparable to the dimensionality of latent spaces of LLMs, which implies you could reasonably encode the meaning of a paragraph into a 400-dimensional vector. If you had a device which allows for this kind of writing, you could learn to associate the input patterns with their corresponding meanings. After that, you could directly smell the latent space. A bit of ultrasound, a breath in - and you understood a paragraph.&lt;/p&gt;
    &lt;p&gt;People are able to develop synesthesia - being able to hear colors and see smells, and it might be possible to extend that to semantics. However, at this stage it is speculative.&lt;/p&gt;
    &lt;p&gt;One could try to make a similar argument for the eyes: take 400 cones on the retina, hijack them, and you've got yourself a 400-dimensional channel. But we think the nose is better. The olfactory system is much simpler and more directly interfaces with core brain regions, like the hippocampus. The signal through the olfactory system is simply less filtered and processed. If you tried to write arbitrary light intensities into a patch of cones, the next step of the processing would be a convolutional neural network-like structure in the visual cortex, and the signal would get averaged out. The embeddings you'd write would never make it into the higher levels of processing in the brain. You can try to encode the information in a more easily perceptible way, such as Chernoff faces, but it would reduce the bandwidth, and learning the remapping would still be very difficult.&lt;/p&gt;
    &lt;p&gt;In contrast, only a few synapses separate the olfactory receptors from the hippocampus This is why certain smells bring up such strong memories!, which is responsible for memory, as well as from the amygdala, which does emotional regulation.&lt;/p&gt;
    &lt;p&gt;Finally, personally speaking, the authors use their eyes and ears more than their noses during office work Raphael Hotter noted that this is in fact a general statement, as the usage of eyes and ears extends beyond office work.. The nose is an underutilized channel that imposes fewer bad priors (spatial/tonal maps) than the visual, auditory, and somatosensory.&lt;/p&gt;
    &lt;p&gt;We found four scents in a couple of days. With a little more engineering, it should be possible to increase the bit rate of olfactory stimulation by a lot.&lt;/p&gt;
    &lt;p&gt;If we gain control of all 400 basis vectors, we might be able to smell meaning.&lt;lb/&gt; And we’ve already covered the first one percent.&lt;/p&gt;
    &lt;head rend="h2"&gt;Acknowledgements&lt;/head&gt;
    &lt;p&gt;We thank Raffi Hotter, Aidan Smith, and especially Mason Wang for thoughtful feedback on this blogpost.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://writetobrain.com/olfactory"/><published>2025-11-21T20:02:45+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=46013935</id><title>Agent design is still hard</title><updated>2025-11-23T08:13:09.287392+00:00</updated><content>&lt;doc fingerprint="67169c5569238917"&gt;
  &lt;main&gt;
    &lt;p&gt;written on November 21, 2025&lt;/p&gt;
    &lt;p&gt;I felt like it might be a good time to write about some new things I’ve learned. Most of this is going to be about building agents, with a little bit about using agentic coding tools.&lt;/p&gt;
    &lt;p&gt;TL;DR: Building agents is still messy. SDK abstractions break once you hit real tool use. Caching works better when you manage it yourself, but differs between models. Reinforcement ends up doing more heavy lifting than expected, and failures need strict isolation to avoid derailing the loop. Shared state via a file-system-like layer is an important building block. Output tooling is surprisingly tricky, and model choice still depends on the task.&lt;/p&gt;
    &lt;p&gt;When you build your own agent, you have the choice of targeting an underlying SDK like the OpenAI SDK or the Anthropic SDK, or you can go with a higher level abstraction such as the Vercel AI SDK or Pydantic. The choice we made a while back was to adopt the Vercel AI SDK but only the provider abstractions, and to basically drive the agent loop ourselves. At this point we would not make that choice again. There is absolutely nothing wrong with the Vercel AI SDK, but when you are trying to build an agent, two things happen that we originally didn’t anticipate:&lt;/p&gt;
    &lt;p&gt;The first is that the differences between models are significant enough that you will need to build your own agent abstraction. We have not found any of the solutions from these SDKs that build the right abstraction for an agent. I think this is partly because, despite the basic agent design being just a loop, there are subtle differences based on the tools you provide. These differences affect how easy or hard it is to find the right abstraction (cache control, different requirements for reinforcement, tool prompts, provider-side tools, etc.). Because the right abstraction is not yet clear, using the original SDKs from the dedicated platforms keeps you fully in control. With some of these higher-level SDKs you have to build on top of their existing abstractions, which might not be the ones you actually want in the end.&lt;/p&gt;
    &lt;p&gt;We also found it incredibly challenging to work with the Vercel SDK when it comes to dealing with provider-side tools. The attempted unification of messaging formats doesn’t quite work. For instance, the web search tool from Anthropic routinely destroys the message history with the Vercel SDK, and we haven’t yet fully figured out the cause. Also, in Anthropic’s case, cache management is much easier when targeting their SDK directly instead of the Vercel one. The error messages when you get things wrong are much clearer.&lt;/p&gt;
    &lt;p&gt;This might change, but right now we would probably not use an abstraction when building an agent, at least until things have settled down a bit. The benefits do not yet outweigh the costs for us.&lt;/p&gt;
    &lt;p&gt;Someone else might have figured it out. If you’re reading this and think I’m wrong, please drop me a mail. I want to learn.&lt;/p&gt;
    &lt;p&gt;The different platforms have very different approaches to caching. A lot has been said about this already, but Anthropic makes you pay for caching. It makes you manage cache points explicitly, and this really changes the way you interact with it from an agent engineering level. I initially found the manual management pretty dumb. Why doesn’t the platform do this for me? But I’ve fully come around and now vastly prefer explicit cache management. It makes costs and cache utilization much more predictable.&lt;/p&gt;
    &lt;p&gt;Explicit caching allows you to do certain things that are much harder otherwise. For instance, you can split off a conversation and have it run in two different directions simultaneously. You also have the opportunity to do context editing. The optimal strategy here is unclear, but you clearly have a lot more control, and I really like having that control. It also makes it much easier to understand the cost of the underlying agent. You can assume much more about how well your cache will be utilized, whereas with other platforms we found it to be hit and miss.&lt;/p&gt;
    &lt;p&gt;The way we do caching in the agent with Anthropic is pretty straightforward. One cache point is after the system prompt. Two cache points are placed at the beginning of the conversation, where the last one moves up with the tail of the conversation. And then there is some optimization along the way that you can do.&lt;/p&gt;
    &lt;p&gt;Because the system prompt and the tool selection now have to be mostly static, we feed a dynamic message later to provide information such as the current time. Otherwise, this would trash the cache. We also leverage reinforcement during the loop much more.&lt;/p&gt;
    &lt;p&gt;Every time the agent runs a tool you have the opportunity to not just return data that the tool produces, but also to feed more information back into the loop. For instance, you can remind the agent about the overall objective and the status of individual tasks. You can also provide hints about how the tool call might succeed when a tool fails. Another use of reinforcement is to inform the system about state changes that happened in the background. If you have an agent that uses parallel processing, you can inject information after every tool call when that state changed and when it is relevant for completing the task.&lt;/p&gt;
    &lt;p&gt;Sometimes it’s enough for the agent to self-reinforce. In Claude Code, for instance, the todo write tool is a self-reinforcement tool. All it does is take from the agent a list of tasks that it thinks it should do and echo out what came in. It’s basically just an echo tool; it really doesn’t do anything else. But that is enough to drive the agent forward better than if the only task and subtask were given at the beginning of the context and too much has happened in the meantime.&lt;/p&gt;
    &lt;p&gt;We also use reinforcements to inform the system if the environment changed during execution in a way that’s problematic for the agent. For instance, if our agent fails and retries from a certain step forward but the recovery operates off broken data, we inject a message informing it that it might want to back off a couple of steps and redo an earlier step.&lt;/p&gt;
    &lt;p&gt;If you expect a lot of failures during code execution, there is an opportunity to hide those failures from the context. This can happen in two ways. One is to run tasks that might require iteration individually. You would run them in a subagent until they succeed and only report back the success, plus maybe a brief summary of approaches that did not work. It is helpful for an agent to learn about what did not work in a subtask because it can then feed that information into the next task to hopefully steer away from those failures.&lt;/p&gt;
    &lt;p&gt;The second option doesn’t exist in all agents or foundation models, but with Anthropic you can do context editing. So far we haven’t had a lot of success with context editing, but we believe it’s an interesting thing we would love to explore more. We would also love to learn if people have success with it. What is interesting about context editing is that you should be able to preserve tokens for further down the iteration loop. You can take out of the context certain failures that didn’t drive towards successful completion of the loop, but only negatively affected certain attempts during execution. But as with the point I made earlier: it is also useful for the agent to understand what didn’t work, but maybe it doesn’t require the full state and full output of all the failures.&lt;/p&gt;
    &lt;p&gt;Unfortunately, context editing will automatically invalidate caches. There is really no way around it. So it can be unclear when the trade-off of doing that compensates for the extra cost of trashing the cache.&lt;/p&gt;
    &lt;p&gt;As I mentioned a couple of times on this blog already, most of our agents are based on code execution and code generation. That really requires a common place for the agent to store data. Our choice is a file system—in our case a virtual file system—but that requires different tools to access it. This is particularly important if you have something like a subagent or subinference.&lt;/p&gt;
    &lt;p&gt;You should try to build an agent that doesn’t have dead ends. A dead end is where a task can only continue executing within the sub-tool that you built. For instance, you might build a tool that generates an image, but is only able to feed that image back into one more tool. That’s a problem because you might then want to put those images into a zip archive using the code execution tool. So there needs to be a system that allows the image generation tool to write the image to the same place where the code execution tool can read it. In essence, that’s a file system.&lt;/p&gt;
    &lt;p&gt;Obviously it has to go the other way around too. You might want to use the code execution tool to unpack a zip archive and then go back to inference to describe all the images so that the next step can go back to code execution and so forth. The file system is the mechanism that we use for that. But it does require tools to be built in a way that they can take file paths to the virtual file system to work with.&lt;/p&gt;
    &lt;p&gt;So basically an &lt;code&gt;ExecuteCode&lt;/code&gt; tool would have access to the same file system as
the &lt;code&gt;RunInference&lt;/code&gt; tool which could take a &lt;code&gt;path&lt;/code&gt; to a file on that same
virtual file system.&lt;/p&gt;
    &lt;p&gt;One interesting thing about how we structured our agent is that it does not represent a chat session. It will eventually communicate something to the user or the outside world, but all the messages that it sends in between are usually not revealed. The question is: how does it create that message? We have one tool which is the output tool. The agent uses it explicitly to communicate to the human. We then use a prompt to instruct it when to use that tool. In our case the output tool sends an email.&lt;/p&gt;
    &lt;p&gt;But that turns out to pose a few other challenges. One is that it’s surprisingly hard to steer the wording and tone of that output tool compared to just using the main agent loop’s text output as the mechanism to talk to the user. I cannot say why this is, but I think it’s probably related to how these models are trained.&lt;/p&gt;
    &lt;p&gt;One attempt that didn’t work well was to have the output tool run another quick LLM like Gemini 2.5 Flash to adjust the tone to our preference. But this increases latency and actually reduces the quality of the output. In part, I think the model just doesn’t word things correctly and the subtool doesn’t have sufficient context. Providing more slices of the main agentic context into the subtool makes it expensive and also didn’t fully solve the problem. It also sometimes reveals information in the final output that we didn’t want to be there, like the steps that led to the end result.&lt;/p&gt;
    &lt;p&gt;Another problem with an output tool is that sometimes it just doesn’t call the tool. One of the ways in which we’re forcing this is we remember if the output tool was called. If the loop ends without the output tool, we inject a reinforcement message to encourage it to use the output tool.&lt;/p&gt;
    &lt;p&gt;Overall our choices for models haven’t dramatically changed so far. I think Haiku and Sonnet are still the best tool callers available, so they make for excellent choices in the agent loop. They are also somewhat transparent with regards to what the RL looks like. The other obvious choices are the Gemini models. We so far haven’t found a ton of success with the GPT family of models for the main loop.&lt;/p&gt;
    &lt;p&gt;For the individual sub-tools, which in part might also require inference, our current choice is Gemini 2.5 if you need to summarize large documents or work with PDFs and things like that. That is also a pretty good model for extracting information from images, in particular because the Sonnet family of models likes to run into a safety filter which can be annoying.&lt;/p&gt;
    &lt;p&gt;There’s also probably the very obvious realization that token cost alone doesn’t really define how expensive an agent. A better tool caller will do the job in fewer tokens. There are some cheaper models available than sonnet today, but they are not necessarily cheaper in a loop.&lt;/p&gt;
    &lt;p&gt;But all things considered, not that much has changed in the last couple of weeks.&lt;/p&gt;
    &lt;p&gt;We find testing and evals to be the hardest problem here. This is not entirely surprising, but the agentic nature makes it even harder. Unlike prompts, you cannot just do the evals in some external system because there’s too much you need to feed into it. This means you want to do evals based on observability data or instrumenting your actual test runs. So far none of the solutions we have tried have convinced us that they found the right approach here. Unfortunately, I have to report that at the moment we haven’t found something that really makes us happy. I hope we’re going to find a solution for this because it is becoming an increasingly frustrating aspect of building an agent.&lt;/p&gt;
    &lt;p&gt;As for my experience with coding agents, not really all that much has changed. The main new development is that I’m trialing Amp more. In case you’re curious why: it’s not that it’s objectively a better agent than what I’m using, but I really quite like the way they’re thinking about agents from what they’re posting. The interactions of the different sub agents like the Oracle with the main loop is beautifully done, and not many other harnesses do this today. It’s also a good way for me to validate how different agent designs work. Amp, similar to Claude Code, really feels like a product built by people who also use their own tool. I do not feel every other agent in the industry does this.&lt;/p&gt;
    &lt;p&gt;That’s just a random assortment of things that I feel might also be worth sharing:&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://lucumr.pocoo.org/2025/11/21/agents-are-hard/"/><published>2025-11-22T11:27:24+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=46016249</id><title>The privacy nightmare of browser fingerprinting</title><updated>2025-11-23T08:13:08.880128+00:00</updated><content>&lt;doc fingerprint="d73014573db7254d"&gt;
  &lt;main&gt;
    &lt;head rend="h1"&gt;The privacy nightmare of browser fingerprinting&lt;/head&gt;
    &lt;p&gt;I imagine that most people who take an interest in de-Googling are concerned about privacy. Privacy on the Internet is a somewhat nebulous concept, but one aspect of privacy is surely the prevention of your web browsing behaviour being propagated from one organization to another. I don’t want my medical insurers to know, for example, that I’ve been researching coronary artery disease. And even though my personal safety and liberty probably aren’t at stake, I don’t want to give any support to the global advertising behemoth, by allowing advertisers access to better information about me.&lt;/p&gt;
    &lt;p&gt;Unfortunately, while distancing yourself from Google and its services might be a necessary first step in protecting your privacy, it’s far from the last. There’s more to do, and it’s getting harder to do it, because of browser fingerprinting.&lt;/p&gt;
    &lt;head rend="h2"&gt;How we got here&lt;/head&gt;
    &lt;p&gt;Until about five years ago, our main concern surrounding browser privacy was probably the use of third-party tracking cookies. The original intent behind cookies was that they would allow a web browser and a web server to engage in a conversation over a period of time. The HTTP protocol that web servers use is stateless; that is, each interaction between browser and server is expected to be complete in itself. Having the browser and the server exchange a cookie (which could just be a random number) in each interaction allowed the server to associate each browser with an ongoing conversation. This was, and is, a legitimate use of cookies, one that is necessary for almost all interactive web-based services. If the cookie is short-lived, and only applies to a single conversation with a single web server, it’s not a privacy concern.&lt;/p&gt;
    &lt;p&gt;Unfortunately, web browsers for a long time lacked the ability to distinguish between privacy-sparing and privacy-breaking uses of cookies. If many different websites issue pages that contain links to the same server – usually some kind of advertising service – then the browser would send cookies to that server, thinking it was being helpful. This behaviour effectively linked web-based services together, allowing them to share information about their users. The process is a bit more complicated than I’m making it out to be, but these third-party cookies were of such concern that, in Europe at least, legislation was enacted to force websites to disclose that they were using them.&lt;/p&gt;
    &lt;p&gt;Browsers eventually got better at figuring out which cookies were helpful and which harmful and, for the most part, we don’t need to be too concerned about ‘tracking cookies’ these days. Not only can browsers mitigate their risks, there’s a far more sinister one: browser fingerprinting.&lt;/p&gt;
    &lt;head rend="h2"&gt;Browser fingerprinting&lt;/head&gt;
    &lt;p&gt;Browser fingerprinting does not depend on cookies. It’s resistant, to some extent, to privacy measures like VPNs. Worst of all, steps that we might take to mitigate the risk of fingerprinting can actually worsen the risk. It’s a privacy nightmare, and it’s getting worse.&lt;/p&gt;
    &lt;p&gt;Fingerprinting works by having the web server extract certain discrete elements of information from the browser, and combining those elements into a numerical identifier. Some of the information supplied by the browser is fundamental and necessary and, although a browser could fake it, such a measure is likely to break the website.&lt;/p&gt;
    &lt;p&gt;For example, a fingerprinting system knows, just from information that my browser always supplies (and probably has to), that I’m using version 144 of the Firefox browser, on Linux; my preferred language is English, and my time-zone is GMT. That, by itself, isn’t enough information to identify me uniquely, but it’s a step towards doing so.&lt;/p&gt;
    &lt;p&gt;To get more information, the fingerprinter needs to use more sophisticated methods which the browser could, in theory, block. For example, if the browser supports JavaScript – and they nearly all do – then the fingerprinter can figure out what fonts I have installed, what browser extensions I use, perhaps even what my hardware is. Worst of all, perhaps, it can extract a canvas fingerprint. Canvas fingerprinting works by having the browser run code that draws text (perhaps invisibly), and then retrieving the individual pixel data that it drew. This pixel data will differ subtly from one system to another, even drawing the same text, because of subtle differences in the graphics hardware and the operating system.&lt;/p&gt;
    &lt;p&gt;It appears that only about one browser in every thousand share the same canvas fingerprint. Again, this alone isn’t enough to identify me, but it’s another significant data point.&lt;/p&gt;
    &lt;p&gt;Fingerprinting can make use of even what appears to be trivial information. If, for example, I resize my browser window, the browser will probably make the next window the same size. It will probably remember my preference from one day to the next. If the fingerprinter knows my preferred browser window size is, say, 1287x892 pixels, that probably narrows down the search for my identify by a factor of a thousand or more.&lt;/p&gt;
    &lt;head rend="h2"&gt;Why crude methods to defeat fingerprinting don’t work&lt;/head&gt;
    &lt;p&gt;You might think that a simple way to prevent, or at least hamper, fingerprinting would be simply to disable JavaScript support in the browser. While this does defeat measures like canvas fingerprinting, it generates a significant data point of its own: the fact that JavaScript is disabled. Since almost every web browser in the world now supports JavaScript, turning it off as a measure to protect privacy is like going to the shopping mall wearing a ski mask. Sure, it hides your identify; but nobody’s going to want to serve you in stores. And disabling JavaScript will break many websites, including some pages on this one, because I use it to render math equations.&lt;/p&gt;
    &lt;p&gt;Less dramatic approaches to fingerprinting resistance have their own problems. For example, a debate has long raged about whether a browser should actually identify itself at all. The fact that I’m running Firefox on Linux probably puts me in a small, easily identified group. Perhaps my browser should instead tell the server I’m running Chrome on Windows? That’s a much larger group, after all.&lt;/p&gt;
    &lt;p&gt;The problem is that the fingerprinters can guess the browser and platform with pretty good accuracy using other methods, whether the browser reports this information or not. If the browser says something different to what the fingerprinter infers, we’re back in ski-mask territory.&lt;/p&gt;
    &lt;p&gt;What about more subtle methods to spoof the client’s behaviour? Browsers (or plug-ins) can modify the canvas drawing procedures, for example, to spoof the results of canvas fingerprinting. Unfortunately, these methods leave traces of their own, if they aren’t applied subtly. What’s more, if they’re applied rigorously enough to be effective, they can break websites that rely on them for normal operation.&lt;/p&gt;
    &lt;p&gt;All in all, browser fingerprinting is very hard to defeat, and organizations that want to track us have gotten disturbingly good at it.&lt;/p&gt;
    &lt;head rend="h2"&gt;Is there any good news?&lt;/head&gt;
    &lt;p&gt;Not much, frankly.&lt;/p&gt;
    &lt;p&gt;Before sinking into despondency, it’s worth bearing in mind that websites that attempt to demonstrate the efficacy of fingerprinting, like amiunique and fingerprint.com do not reflect how fingerprinting works in the real world. They’re operating on comparatively small sets of data and, for the most part, they’re not tracking users over days. Real-world tracking is much harder than these sites make it out to be. That’s not to say it’s too hard but it is, at best, a statistical approach, rather than an exact one.&lt;/p&gt;
    &lt;p&gt;In addition ‘uniqueness’, in itself, is not a strong measure of traceability. That my browser fingerprint is unique at some point in time is irrelevant if my fingerprint will be different tomorrow, whether it remains unique within the fingerprinter’s database or not.&lt;/p&gt;
    &lt;p&gt;Of course, these facts also mean that it’s difficult to assess the effectiveness of our countermeasures: our assessment can only be approximate, because we don’t actually know what real fingerprinters are doing.&lt;/p&gt;
    &lt;p&gt;Another small piece of good news is that browser developers are starting to realize how much of a hazard fingerprinting is, and to integrate more robust countermeasures. We don’t necessarily need to resort to plug-ins and extensions, which are themselves detectable and become part of the fingerprint. At present, Brave and Mullvad seems to be doing the most to resist fingerprinting, albeit in different ways. Librewolf has the same fingerprint resistance as Firefox, but it is turned on by default. Probably anti-fingerprinting methods will improve over time but, of course, the fingerprinters will get better at what they do, too.&lt;/p&gt;
    &lt;head rend="h2"&gt;So what can we do?&lt;/head&gt;
    &lt;p&gt;First, and most obviously, if you care about avoiding tracking, you must prevent long-lived cookies hanging around in the browser, and you must use a VPN. Ideally the VPN should rotate its endpoint regularly.&lt;/p&gt;
    &lt;p&gt;The fact that you’re using a VPN, of course, is something that the fingerprinters will know, and it is does make you stand out. Sophisticated fingerprinters won’t be defeated by a VPN alone. But if you don’t use a VPN, the trackers don’t even need to fingerprint you: your IP number, combined with a few other bits of routine information, will identify you immediately, and with near-certainty.&lt;/p&gt;
    &lt;p&gt;Many browsers can be configured to remove cookies when they seem not to be in use; Librewolf does this by default, and Firefox and Chrome do it in ‘incognito’ mode. The downside, of course, is that long-lived cookies are often used to store authentication status so, if you delete them, you’ll find yourself having to log in every time you look at a site that requires authentication. To mitigate this annoyance, browsers generally allow particular sites to be excluded from their cookie-burning policies.&lt;/p&gt;
    &lt;p&gt;Next, you need to be as unremarkable as possible. Fingerprinting is about uniqueness, so you should use the most popular browser on the most popular operating system on the kind of hardware you can buy from PC World. If you’re running the latest Chrome on the latest Windows 11 on a two-year-old, bog-standard laptop, you’re going to be one of a very large group. Of course Chrome, being a Google product, has its own privacy concerns, so you might be better off using a Chromium-based browser with reduced Google influence, like Brave.&lt;/p&gt;
    &lt;p&gt;You should endeavour to keep your computer in as near its stock configuration as possible. Don’t install anything (like fonts) that are reportable by the browser. Don’t install any extensions, and don’t change any settings. Use the same ‘light’ theme as everybody else, and use the browser with a maximized window, and always the same size. And so on.&lt;/p&gt;
    &lt;p&gt;If possible, use a browser that has built-in fingerprint resistance, like Mullvad or Librewolf (or Firefox with these features turned on).&lt;/p&gt;
    &lt;p&gt;If you take all these precautions, you can probably reduce the probability that you can be tracked by you browser fingerprint, over days or weeks, from about 99% to about 50%.&lt;/p&gt;
    &lt;p&gt;50% is still too high, of course.&lt;/p&gt;
    &lt;head rend="h2"&gt;The downsides of resisting fingerprinting&lt;/head&gt;
    &lt;p&gt;If you enable fingerprinting resistance in Firefox, or use Librewolf, you’ll immediately encounter oddities. Most obviously, every time you open a new browser window, it will be the same size. Resizing the window may have odd results, as the browser will try to constrain certain screen elements to common size multiples. In addition, you won’t be able to change the theme.&lt;/p&gt;
    &lt;p&gt;You’ll probably find yourself facing more ‘CAPTCHA’ and similar identity challenges, because your browser will be unknown to the server. Websites don’t do this out of spite: hacking and fraud are rife on the Internet, and the operators of web-based services are rightly paranoid about client behaviour.&lt;/p&gt;
    &lt;p&gt;You’ll likely find that some websites just don’t work properly, in many small ways: wrong colours, misplaced text, that kind of thing. I’ve found these issues to be irritations rather than show-stoppers, but you might discover otherwise.&lt;/p&gt;
    &lt;head rend="h2"&gt;Is browser fingerprinting legal?&lt;/head&gt;
    &lt;p&gt;The short answer, I think, is that nobody knows, even within a specific jurisdiction. In the UK, the Information Commissioner’s Office takes a dim view of it, and it probably violates the spirit of the GDPR, if not the letter.&lt;/p&gt;
    &lt;p&gt;The GDPR is, for the most part, technologically neutral, although it has specific provisions for cookies, which were a significant concern at the time it was drafted. So far as I know, nobody has yet challenged browser fingerprinting under the GDPR, even though it seems to violate the provisions regarding consent. Since there are legitimate reasons for fingerprinting, such as hacking detection, organizations that do it could perhaps defend against a legal challenge on the basis that fingerprinting is necessary to operate their services safely. In the end, we really need specific, new legislation to address this privacy threat.&lt;/p&gt;
    &lt;head rend="h2"&gt;Closing remarks&lt;/head&gt;
    &lt;p&gt;I suspect that many people who take an interest in Internet privacy don’t appreciate how hard it is to resist browser fingerprinting. Taking steps to reduce it leads to inconvenience and, with the present state of technology, even the most intrusive approaches are only partially effective. The data collected by fingerprinting is invisible to the user, and stored somewhere beyond the user’s reach.&lt;/p&gt;
    &lt;p&gt;On the other hand, browser fingerprinting produces only statistical results, and usually can’t be used to track or identify a user with certainty. The data it collects has a relatively short lifespan – days to weeks, not months or years. While it probably can be used for sinister purposes, my main concern is that it supports the intrusive, out-of-control online advertising industry, which has made a wasteland of the Internet.&lt;/p&gt;
    &lt;p&gt;In the end, it’s probably only going to be controlled by legislation and, even when that happens, the advertisers will seek new ways to make the Internet even more of a hellscape – they always do.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://kevinboone.me/fingerprinting.html"/><published>2025-11-22T17:08:36+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=46016613</id><title>The realities of being a pop star</title><updated>2025-11-23T08:13:08.786641+00:00</updated><content/><link href="https://itscharlibb.substack.com/p/the-realities-of-being-a-pop-star"/><published>2025-11-22T17:47:23+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=46016639</id><title>China reaches energy milestone by "breeding" uranium from thorium</title><updated>2025-11-23T08:13:08.494583+00:00</updated><content>&lt;doc fingerprint="35c25b54af5ed989"&gt;
  &lt;main&gt;
    &lt;head rend="h1"&gt;China reaches energy independence milestone by ‘breeding’ uranium from thorium&lt;/head&gt;
    &lt;p&gt;Chinese research institute confirms success of fission-based innovation that is poised to reshape clean, sustainable nuclear power&lt;/p&gt;
    &lt;p&gt;The achievement makes the 2 megawatt liquid-fuelled thorium-based molten salt reactor (TMSR) the only operating example of the technology in the world to have successfully loaded and used thorium fuel.&lt;/p&gt;
    &lt;p&gt;According to the academy, the experiment has provided initial proof of the technical feasibility of using thorium resources in molten salt reactor systems and represents a major leap forward for the technology.&lt;/p&gt;
    &lt;p&gt;It is the first time in the world that scientists have been able to acquire experimental data on thorium operations from inside a molten salt reactor, according to a report by Science and Technology Daily.&lt;/p&gt;
    &lt;p&gt;The article, published on Saturday, was China’s first official confirmation of its success in the development of TMSR technology, an innovation that is poised to reshape the future of clean sustainable nuclear energy.&lt;/p&gt;
    &lt;p&gt;Li Qingnuan, Communist Party secretary and deputy director at the Shanghai Institute of Applied Physics, told the newspaper that “since achieving first criticality on October 11, 2023, the thorium molten salt reactor has been steadily generating heat through nuclear fission”.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://www.scmp.com/news/china/science/article/3331312/china-reaches-energy-independence-milestone-breeding-uranium-thorium"/><published>2025-11-22T17:49:27+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=46017175</id><title>Show HN: Forty.News – Daily news, but on a 40-year delay</title><updated>2025-11-23T08:13:08.101076+00:00</updated><link href="https://forty.news"/><published>2025-11-22T18:47:08+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=46017782</id><title>Markdown is holding you back</title><updated>2025-11-23T08:13:06.276447+00:00</updated><content>&lt;doc fingerprint="64c4d8137a1d1bd0"&gt;
  &lt;main&gt;&lt;p&gt;I've used many content formats over the years, and while I love Markdown, I run into its limitations daily when I work on larger documentation projects.&lt;/p&gt;&lt;p&gt;In this issue, you'll look at Markdown and explore why it might not be the best fit for technical content, and what else might work instead.&lt;/p&gt;&lt;p&gt;Markdown is everywhere. It's human-readable, approachable, and has just enough syntax to make docs look good in GitHub or a static site. That ease of use is why it's become the default choice for developer documentation. I'm using Markdown right now to write this newsletter issue. I love it.&lt;/p&gt;&lt;p&gt;But Markdown's biggest advantage is its biggest drawback: it doesn't describe the content like other formats can.&lt;/p&gt;&lt;p&gt;Think about how your content gets consumed. Your content isn't just for human readers. Machines use it too. Your content gets indexed by search engines, and parsed by LLMs, and those things parse the well-formed HTML your systems publish. Markdown's basic syntax only emits a small subset of the available semantic tags HTML allows.&lt;/p&gt;&lt;p&gt;IDE integrations can use your docs, too. And AI agents rely on structure to answer developer questions. If you're only feeding them plain-text Markdown documents to reduce the number of tokens you send, you're not providing as much context as you could.&lt;/p&gt;&lt;p&gt;Worse, when you want to reuse your content or syndicate content into another system, you quickly find out that Markdown is more of the lowest common denominator than a source of truth, as not all Markdown flavors are the same.&lt;/p&gt;&lt;p&gt;There are other options you can use that give you more control. But first, let's look deeper into why you should move away from Markdown for serious work.&lt;/p&gt;&lt;p&gt;If you're a developer, you know all about type systems in programming languages. Some languages use Implicit typing, in which the compiler or interpreter infers the data type from the value. These languages give you flexibility, but no guarantees. That's why many developers prefer languages that use explicit typing, where you predefine data types when writing the code. In those languages, the compiler doesn't just build your code; it guarantees specific rules are followed. That's the main reason for the rise of TypeScript over JavaScript: compile-time guarantees.&lt;/p&gt;&lt;p&gt;Markdown is implicit typing. It lets you write quickly, but without constraints or guarantees. There's no schema. No way to enforce consistency. A heading in one file might be a concept, in another it might be a step, and there's no machine-readable distinction between the two.&lt;/p&gt;&lt;p&gt;To complicate things further, there are multiple flavors of Markdown, each with its own features and markup. Here are just a few:&lt;/p&gt;&lt;p&gt;You think you're writing "Markdown," but what works in one tool may not render in another. Some Markdown processors allow footnotes, Others ignore soft line breaks. And some even require different formatting for code blocks. Inconsistency makes Markdown a shaky foundation for anything beyond the most basic document.&lt;/p&gt;&lt;p&gt;And then there's MDX, which people often use to extend Markdown to support things it doesn't:&lt;/p&gt;&lt;p&gt;Here's a typical MDX snippet:&lt;/p&gt;&lt;code&gt;# Install

&amp;lt;Command&amp;gt;npm install my-library&amp;lt;/Command&amp;gt;
&lt;/code&gt;&lt;p&gt;That &lt;code&gt;&amp;lt;Command&amp;gt;&lt;/code&gt; tag isn't Markdown at all; it's a React component. Instead of using a code block, the author chose to create a special component to standardize how all commands would display in the documentation. &lt;/p&gt;&lt;p&gt;It works beautifully on their site because their publishing system knows what &lt;code&gt;&amp;lt;Command&amp;gt;&lt;/code&gt; means. But if they try to syndicate this content to another system, it breaks because that system also needs to implement that component. And even if it was supported elsewhere, there's no guarantee that the component is implemented the same way. &lt;/p&gt;&lt;p&gt;MDX shows that even in Markdown-centric ecosystems, people instinctively add more expressive markup. They know plain Markdown isn't enough. They're reinventing semantic markup, but in a way that's custom, brittle, and not portable.&lt;/p&gt;&lt;p&gt;Semantic markup describes what content is, not just how it should look. It's the difference between saying "here's a bullet with some text" and "here's a step in a procedure." To a human, those may look the same on a page. To a machine or to a publishing pipeline, they are entirely different.&lt;/p&gt;&lt;p&gt;Web developers already went through all this with HTML. Prior to HTML5, you had &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; as a logical container. But HTML5 introduced &lt;code&gt;&amp;lt;section&amp;gt;&lt;/code&gt;,  &lt;code&gt;&amp;lt;article&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;aside&amp;gt;&lt;/code&gt;, and many other elements that described the content. &lt;/p&gt;&lt;p&gt;Semantic markup matters for two important and related reasons:&lt;/p&gt;&lt;code&gt;&amp;lt;step&amp;gt;&lt;/code&gt; or a paragraph into a &lt;code&gt;&amp;lt;para&amp;gt;&lt;/code&gt; without guessing. You can't add context if it wasn't there to begin with, but you can strip out what you don't need when you transform the document, and you can choose how to present each thing in a consistent way. &lt;code&gt;&amp;lt;step&amp;gt;&lt;/code&gt; is unambiguous. A bullet point might be a step, or a note, or just a list item. The machine has to guess. This is why XML was a preferred mechanism for web services for a long time, and why JSON Schema exists.&lt;p&gt;Let's explore four formats that give you more control over structure than plain Markdown.&lt;/p&gt;&lt;p&gt;reStructuredText is a plain-text markup language from the Python/Docutils ecosystem that supports directives, roles, and structural semantics. It is the foundational format used by Sphinx for generating documentation.&lt;/p&gt;&lt;code&gt;Installation
============

.. code-block:: bash

   npm install my-library

.. note::  
   This library requires Node.JS ≥ 22.

See also :ref:`usage-guide`.
&lt;/code&gt;&lt;p&gt;Here you see a &lt;code&gt;code-block&lt;/code&gt; directive, an admonition (&lt;code&gt;note&lt;/code&gt;), and an explicit cross-reference via &lt;code&gt;:ref:&lt;/code&gt;. You'll find support for images, figures, topics, sidebars, pull quotes, epigraphs, and citations as well.&lt;/p&gt;&lt;p&gt;All of those encode semantics, not just presentation.&lt;/p&gt;&lt;p&gt;AsciiDoc aims to be human-readable but semantically expressive. It has attributes, conditional content, include mechanisms, and more.&lt;/p&gt;&lt;p&gt;Here's an example of AsciiDoc:&lt;/p&gt;&lt;code&gt;= Installation
:revnumber: 1.2
:platform: linux
:prev_section: introduction
:next_section: create-project

[source,bash]
----
npm install my-library
----

NOTE: This library requires Node.JS ≥ 22.

See &amp;lt;&amp;lt;usage,Usage Guide&amp;gt;&amp;gt; for examples.
&lt;/code&gt;&lt;p&gt;AsciiDoc has native support for document front-matter. Attributes like &lt;code&gt;:revnumber:&lt;/code&gt; or &lt;code&gt;:platform:&lt;/code&gt; let you parameterize content. &lt;/p&gt;&lt;p&gt;&lt;code&gt;&amp;lt;&amp;lt;usage,Usage Guide&amp;gt;&amp;gt;&lt;/code&gt; is a cross-reference syntax. &lt;/p&gt;&lt;p&gt;Like reStructuredText, AsciiDoc supports admonitions like &lt;code&gt;NOTE&lt;/code&gt; and &lt;code&gt;WARNING&lt;/code&gt; so you don't have to build your own custom renderer. It also has support for sidebars, and you can add line highlighting and callouts to your code blocks without additional extensions. &lt;/p&gt;&lt;p&gt;And if you're writing technical documentation, there's explicit support for marking up UI elements and keyboard shortcuts.&lt;/p&gt;&lt;p&gt;Using AsciiDoctor, you can transform AsciiDoc into other formats, including HTML, PDF, ePub, and DocBook, which you'll look at next.&lt;/p&gt;&lt;p&gt;DocBook is an XML-based document model explicitly designed for technical publishing. It expresses hierarchical and semantic structure in tags and attributes, enabling industrial-grade transformations.&lt;/p&gt;&lt;p&gt;Here's an example&lt;/p&gt;&lt;code&gt;&amp;lt;article id="install-library"&amp;gt;
  &amp;lt;title&amp;gt;Installation&amp;lt;/title&amp;gt;
  &amp;lt;command&amp;gt;npm install my-library&amp;lt;/command&amp;gt;
  &amp;lt;note&amp;gt;This library requires Node.JS &amp;amp;gt;= 22&amp;lt;/note&amp;gt;
  &amp;lt;xref linkend="usage-chapter"&amp;gt;Usage Guide&amp;lt;/xref&amp;gt;
&amp;lt;/article&amp;gt;
&lt;/code&gt;&lt;p&gt;Every tag is meaningful: &lt;code&gt;&amp;lt;command&amp;gt;&lt;/code&gt; vs &lt;code&gt;&amp;lt;para&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;note&amp;gt;&lt;/code&gt; vs &lt;code&gt;&amp;lt;xref&amp;gt;&lt;/code&gt;. You'll find predefined tags for function names, variables, application names, keyboard shortcuts, UI elements, and much more. Being able to mark up the specific product names and terminology you use makes it so much easier to create glossaries and indexes. And Docbook has tags for defining index terms, too.&lt;/p&gt;&lt;p&gt;DocBook's rich ecosystem of XSLT stylesheets supports transforming to HTML, PDF, man pages, and even Markdown. Using DocBook ensures structure and validation at scale, as long as you use the tags it provides.&lt;/p&gt;&lt;p&gt;Then there's DITA.&lt;/p&gt;&lt;p&gt;DITA is a standard for writing, managing, and publishing content. It's a topic-based XML architecture with built-in reuse, specialization, and modular content design. It's an open standard, and it's widely used in enterprises for multi-channel, structured content that needs standardization and reuse.&lt;/p&gt;&lt;p&gt;Here's an example:&lt;/p&gt;&lt;code&gt;&amp;lt;task id="install"&amp;gt;
  &amp;lt;title&amp;gt;Installation&amp;lt;/title&amp;gt;
  &amp;lt;steps&amp;gt;
    &amp;lt;step&amp;gt;&amp;lt;cmd&amp;gt;npm install my-library&amp;lt;/cmd&amp;gt;&amp;lt;/step&amp;gt;
  &amp;lt;/steps&amp;gt;
  &amp;lt;prolog&amp;gt;
    &amp;lt;note&amp;gt;This library requires Node.js &amp;amp;gt;= 22&amp;lt;/note&amp;gt;
  &amp;lt;/prolog&amp;gt;
&amp;lt;/task&amp;gt;
&lt;/code&gt;&lt;p&gt;DITA defines types like &lt;code&gt;&amp;lt;task&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;step&amp;gt;&lt;/code&gt;, which cleanly map to procedural structure. You can compose topics, reuse via content references (conrefs), and specialize as your domain evolves. &lt;/p&gt;&lt;p&gt;One of the more interesting features DITA provides is the ability to filter content and create multiple versions from a single document.&lt;/p&gt;&lt;p&gt;The DITA Open Toolkit and many enterprise tools handle rendering, transformation, and reuse pipelines.&lt;/p&gt;&lt;p&gt;Yes, XML. The syntax is more verbose than Markdown. Tooling is less ubiquitous than Markdown. Migration requires effort, and your team may resist the learning curve. For small docs, Markdown's features are often enough.&lt;/p&gt;&lt;p&gt;But if you're already bolting semantics onto Markdown with MDX or plugins or custom scripts, you're paying that complexity cost anyway, and you don't get the benefits of standardization or portability. You're building a fragile, custom semantic layer instead of adopting one that already works.&lt;/p&gt;&lt;p&gt;If you're writing a quick &lt;code&gt;README&lt;/code&gt; or a short-lived doc, Markdown is fine. It's fast, approachable, and does the job. If you're building a developer documentation site that needs some structure, reStructuredText or AsciiDoc are better choices. They balance expressiveness with usability. And if you're managing a large doc set that needs syndication, reuse, and multi-channel publishing, DocBook and DITA give you the semantics and tooling to make that process more manageable.&lt;/p&gt;&lt;p&gt;The key is to start with the richest format you can manage and export downward. Markdown makes a great output for developers. It's approachable and familiar. But be careful not to lock yourself into it as your source of truth, because you can't add context back as easily as you can strip it out.&lt;/p&gt;&lt;p&gt;Before the next issue, here are a couple of things you should try to get some hands-on experience with a different format.&lt;/p&gt;&lt;p&gt;As always, thanks for reading. Share this issue with someone who you think would find this helpful.&lt;/p&gt;&lt;p&gt;I'd love to talk with you about this issue on BlueSky, Mastodon, Twitter, or LinkedIn. Let's connect!&lt;/p&gt;&lt;p&gt;Please support this newsletter and my work by encouraging others to subscribe and by buying a friend a copy of Write Better with Vale, tmux 3, Exercises for Programmers, Small, Sharp Software Tools, or any of my other books.&lt;/p&gt;&lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://newsletter.bphogan.com/archive/issue-45-markdown-is-holding-you-back/"/><published>2025-11-22T20:03:14+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=46018158</id><title>A Reverse Engineer's Anatomy of the macOS Boot Chain and Security Architecture</title><updated>2025-11-23T08:13:05.571674+00:00</updated><content>&lt;doc fingerprint="279ad91a65e0bb05"&gt;
  &lt;main&gt;
    &lt;head rend="h1"&gt;A Reverse Engineer’s Anatomy of the macOS Boot Chain &amp;amp; Security Architecture&lt;/head&gt;
    &lt;head rend="h2"&gt;1.0 The Silicon Root of Trust: Pre-Boot &amp;amp; Hardware Primitives&lt;/head&gt;
    &lt;p&gt;The security of the macOS platform on Apple Silicon is not defined by the kernel; it is defined by the physics of the die. Before the first instruction of &lt;code&gt;kernelcache&lt;/code&gt; is fetched, a complex, cryptographic ballet has already concluded within the Application Processor (AP). This section dissects the immutable hardware logic that establishes the initial link in the Chain of Trust.&lt;/p&gt;
    &lt;head rend="h3"&gt;1.1 The Reset Vector &amp;amp; Boot ROM (SecureROM)&lt;/head&gt;
    &lt;p&gt;The Apple Silicon boot process begins in a state of absolute trust, anchored by the Boot ROM (often colloquially referred to as SecureROM). This code is mask-programmed into the silicon during fabrication. It is immutable, unpatchable, and serves as the hardware root of trust for the entire platform.&lt;/p&gt;
    &lt;head rend="h4"&gt;1.1.1 Execution at Reset: Analyzing the Reset Vector (&lt;code&gt;RVBAR_ELx&lt;/code&gt;)&lt;/head&gt;
    &lt;p&gt;Upon Power-On Reset (POR), the cores of the M-series SoC (and A-series) initialize in the highest privilege state implemented by the microarchitecture. In the Armv8/v9 architecture, this role is architecturally associated with Exception Level 3 (EL3) and its reset vector register family &lt;code&gt;RVBAR_ELx&lt;/code&gt;. On Apple Silicon, public reverse engineering strongly suggests that Apple does not expose a persistent, software-visible EL3 monitor in the style of classical TrustZone. Instead, the Application Processor (AP) Boot ROM executes in an implementation-defined reset context that has strictly higher privilege than the runtime EL2/EL1 kernel environment and is the only code allowed to touch certain secure configuration registers.&lt;/p&gt;
    &lt;p&gt;For the purposes of this discussion, the important property is not the exact architectural EL label, but that the Boot ROM runs in a one-shot, highest-privilege reset context that:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;owns the reset vector (&lt;code&gt;RVBAR_ELx&lt;/code&gt;) and initial exception state, and&lt;/item&gt;
      &lt;item&gt;can program security-critical registers that are later hidden from or read-only to EL2/EL1.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The execution flow begins at the address defined in the Reset Vector Base Address Register (one of the &lt;code&gt;RVBAR_ELx&lt;/code&gt; registers, depending on the concrete implementation). Reverse engineering of recent Apple Silicon (M1/M2/M3) indicates the memory map places the Boot ROM at a high base address, typically observed around &lt;code&gt;0x100000000&lt;/code&gt;.&lt;/p&gt;
    &lt;p&gt;The Initial Instruction Stream:&lt;/p&gt;
    &lt;p&gt;The very first instructions executed by the silicon are responsible for establishing a sane C execution environment from a raw hardware state. Analysis of the entry point in similar Apple SoCs reveals a standard initialization sequence:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;&lt;p&gt;Interrupt Masking: The&lt;/p&gt;&lt;code&gt;DAIF&lt;/code&gt;bits are set to mask all interrupts (IRQ, FIQ, SError, Debug). The Boot ROM operates in a strictly polled mode; interrupts are nondeterministic and introduce attack surface.&lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Cache Invalidation: The instruction and data caches are invalidated to prevent cold-boot attacks or stale data usage.&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;&lt;p&gt;Stack Setup: The Stack Pointer for the reset context (architecturally&lt;/p&gt;&lt;code&gt;SP_EL3&lt;/code&gt;, but on Apple Silicon effectively the highest-privilege stack pointer) is initialized to point to a dedicated region of on-chip SRAM. DRAM is not initialized at this stage. The Boot ROM runs entirely within the constraints of the SoC’s internal SRAM.&lt;/item&gt;
      &lt;item&gt;&lt;p&gt;MMU Configuration: The System Control Register for the reset context (&lt;/p&gt;&lt;code&gt;SCTLR_ELx&lt;/code&gt;at the highest implemented level) is programmed to enable the MMU, mapping the Boot ROM text as Read-Only/Executable and the SRAM stack/heap as Read-Write/No-Execute.&lt;/item&gt;
    &lt;/list&gt;
    &lt;quote&gt;
      &lt;p&gt;RE Note: Apple’s high-privilege reset context is ephemeral. There is no persistent EL3 monitor analogous to Qualcomm’s QSEE. Once the Boot ROM has initialized hardware, validated and decrypted the next stage, and “demoted” the core into the runtime EL2/EL1 regime, the reset context is no longer reachable. Subsequent firmware (LLB, iBoot, XNU) can observe the effects of its configuration but cannot re-enter that privilege level or read back the Boot ROM contents directly.&lt;/p&gt;
    &lt;/quote&gt;
    &lt;head rend="h4"&gt;1.1.2 The GID Key (Group ID): Hardware-entangled Decryption&lt;/head&gt;
    &lt;p&gt;The Boot ROM’s primary objective is to load the Low-Level Bootloader (LLB). However, the LLB stored on the boot medium is not a raw binary; it is wrapped in an Image4 (&lt;code&gt;img4&lt;/code&gt;) container, and its payload (&lt;code&gt;IM4P&lt;/code&gt;) is both encrypted and, on production devices, personalized.&lt;/p&gt;
    &lt;p&gt;At the heart of this process is the GID Key (Group ID Key).&lt;/p&gt;
    &lt;p&gt;The GID Key is a 256-bit AES key fused into the silicon during manufacturing. It is shared across processors of the same class (e.g., all M3 Pro chips share a GID, distinct from M3 Max), and it never leaves the confines of the on-die crypto hardware.&lt;/p&gt;
    &lt;p&gt;KBAG Unwrapping: GID as a Wrapping Key&lt;/p&gt;
    &lt;p&gt;Image4 payloads do not store the LLB ciphertext encrypted “directly under GID.” Instead, they contain an embedded Keybag (KBAG): a small structure that holds per-image AES keys and IVs encrypted under the GID (and, where applicable, UID) keys.&lt;/p&gt;
    &lt;p&gt;The flow is:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;&lt;p&gt;Manifest &amp;amp; Payload Parsing:&lt;/p&gt;&lt;lb/&gt;The Boot ROM parses the Image4 container, separates the&lt;code&gt;IM4M&lt;/code&gt;(Manifest) from the&lt;code&gt;IM4P&lt;/code&gt;(Payload), and locates the KBAG for the LLB within&lt;code&gt;IM4P&lt;/code&gt;.&lt;/item&gt;
      &lt;item&gt;&lt;p&gt;KBAG Decryption (GID Slot):&lt;/p&gt;&lt;lb/&gt;The KBAG consists of one or more wrapped key records (e.g., development vs. production keys). To unwrap the appropriate record, the Boot ROM:&lt;list rend="ul"&gt;&lt;item&gt;Writes the KBAG ciphertext (the wrapped IV+key material) into the AES engine’s input FIFO.&lt;/item&gt;&lt;item&gt;Programs the AES configuration register to use the GID key slot as the decryption source (a “use GID” control bit or mode selector).&lt;/item&gt;&lt;item&gt;Triggers the engine. The hardware AES block internally reads the GID key from fuses, decrypts the KBAG fragment, and emits the plaintext IV and AES key for the LLB.&lt;/item&gt;&lt;/list&gt;&lt;p&gt;The GID value itself is never exposed to software; only the result of the KBAG unwrap is visible.&lt;/p&gt;&lt;/item&gt;
      &lt;item&gt;&lt;p&gt;LLB Payload Decryption (Target Key):&lt;/p&gt;&lt;lb/&gt;With the per-image AES key and IV recovered from the KBAG, the Boot ROM then decrypts the LLB payload:&lt;list rend="ul"&gt;&lt;item&gt;It configures the AES engine (or, on some generations, uses the ARMv8 AES instructions) with the target key obtained from the KBAG.&lt;/item&gt;&lt;item&gt;It streams the LLB ciphertext through this AES context into SRAM, yielding the plaintext LLB image.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;&lt;p&gt;Zeroization:&lt;/p&gt;&lt;lb/&gt;After decryption, the AES hardware clears any internal registers holding the GID-derived material. The Boot ROM code has no mechanism to read back the GID key and no direct path to expose the target key outside the immediate decryption context.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;This two-stage scheme (GID → KBAG → LLB) is what makes the system hardware-entangled: the cryptographic key that ultimately decrypts the bootloader exists only as the output of a GID-protected unwrap on that class of silicon.&lt;/p&gt;
    &lt;p&gt;Exploit Implication:&lt;/p&gt;
    &lt;p&gt;Even if an attacker gains arbitrary code execution inside the Boot ROM (as in &lt;code&gt;checkm8&lt;/code&gt;-class vulnerabilities on earlier A-series devices), they still cannot extract the raw GID key and cannot perform offline decryption of production firmware:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;The GID key is never mapped into general-purpose registers or memory.&lt;/item&gt;
      &lt;item&gt;The only decryption primitive available is “unwrap KBAG under GID,” running inside the AES peripheral.&lt;/item&gt;
      &lt;item&gt;Firmware images must be decrypted on-device, with the AES engine acting as a constrained decryption oracle at best, and only for keys/payloads consistent with the KBAG format accepted by the ROM.&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h4"&gt;1.1.3 The Public Key Accelerator (PKA): Hardware-Enforced Verification&lt;/head&gt;
    &lt;p&gt;Decryption provides confidentiality, but not integrity. To prevent the execution of malicious firmware, the Boot ROM enforces strict code signing using the Public Key Accelerator (PKA).&lt;/p&gt;
    &lt;p&gt;The PKA is a dedicated hardware block optimized for asymmetric cryptography (RSA and ECC). The verification flow is as follows:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Root of Trust: The Apple Root CA public key is embedded directly within the immutable Boot ROM code. This serves as the anchor for the chain of trust.&lt;/item&gt;
      &lt;item&gt;Manifest Parsing: The Boot ROM parses the Image4 (img4) container of the LLB. It extracts the Image4 Manifest (IM4M), which contains the payload's signature and the certificate chain used to sign it.&lt;/item&gt;
      &lt;item&gt;Key Verification: The Boot ROM validates the certificate chain found in the manifest against the Root CA embedded in the ROM. If the chain is invalid or does not lead back to the hardware anchor, the boot halts (the device typically enters DFU/Recovery mode).&lt;/item&gt;
      &lt;item&gt;Signature Verification: The Boot ROM offloads the signature verification to the PKA. It passes the hash of the payload (typically SHA-2 family) and the RSA/ECC signature. The PKA performs the mathematical verification and returns a boolean result to a status register.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Fault Injection Hardening:&lt;lb/&gt; Analysis of recent Apple Boot ROMs suggests the implementation of glitch-resistant logic around the PKA check. Rather than a simple &lt;code&gt;B.EQ&lt;/code&gt; (Branch if Equal) instruction following the PKA result—which could be bypassed via voltage glitching—reverse engineering indicates the code often employs redundant checks, loop invariants, or specific register values that must be populated by the PKA hardware itself to allow the boot flow to proceed.&lt;/p&gt;
    &lt;head rend="h4"&gt;1.1.4 RE Focus: Dev vs. Prod Fused Silicon&lt;/head&gt;
    &lt;p&gt;For reverse engineering and exploit development, distinguishing Development (Dev-fused) from Production (Prod) silicon is critical. The Boot ROM and security subsystem change behavior based on fuse fields that encode the security domain of the chip.&lt;/p&gt;
    &lt;p&gt;A central knob here is Apple’s CPFM field (“Chip Production / Firmware Mode”), burned into fuses and exposed in various debug logs and DFU responses.&lt;/p&gt;
    &lt;p&gt;CPFM Observations:&lt;/p&gt;
    &lt;p&gt;Across multiple generations, public Boot ROM banners and tooling logs show a consistent pattern:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;p&gt;CPFM 0x0 / 0x1:&lt;/p&gt;&lt;lb/&gt;Used for development or internal security domains:&lt;list rend="ul"&gt;&lt;item&gt;Enable richer debug visibility.&lt;/item&gt;&lt;item&gt;Allow additional boot modes and demotion paths.&lt;/item&gt;&lt;item&gt;Often relax some signature enforcement or allow alternate signing roots for internal firmware.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;&lt;p&gt;CPFM 0x3:&lt;/p&gt;&lt;lb/&gt;Standard production configuration for consumer devices:&lt;list rend="ul"&gt;&lt;item&gt;Full signature enforcement for all boot stages.&lt;/item&gt;&lt;item&gt;No public demotion path.&lt;/item&gt;&lt;item&gt;Debug interfaces (JTAG/SWD) and invasive trace disabled or tightly restricted.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The exact semantics of intermediary values (e.g., &lt;code&gt;0x2&lt;/code&gt;) and the precise bit-level encoding are SoC- and generation-specific, but the broad distinction above is stable across published ROM dumps and DFU tooling.&lt;/p&gt;
    &lt;p&gt;Production (CPFM ≈ 0x3):&lt;/p&gt;
    &lt;p&gt;This is the configuration for retail hardware:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;JTAG / SWD: Disabled or heavily locked. External debug probes cannot halt the core at reset in any supported way.&lt;/item&gt;
      &lt;item&gt;GID Behavior: The GID key is set to the production group value, shared only across chips of the same class, and never accessible via software.&lt;/item&gt;
      &lt;item&gt;Boot Policy: The Boot ROM enforces the full Apple Root CA chain and Image4 constraints. Unsupported or revoked OS builds fail before DRAM initialization, dropping the device into DFU.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Development (CPFM ≈ 0x0 / 0x1):&lt;/p&gt;
    &lt;p&gt;Dev-fused devices, including security research units and internal engineering hardware, typically relax some of these constraints:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;p&gt;JTAG Enablement: The&lt;/p&gt;&lt;code&gt;DBGEN&lt;/code&gt;/&lt;code&gt;SPIDEN&lt;/code&gt;debug signals are asserted. Hardware debuggers (Lauterbach, Astris, etc.) can halt the core immediately after reset and single-step Boot ROM code.&lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Demotion: Dev-fused chips can usually enter “demoted” modes where unsigned or custom-signed firmware images are bootable. The exact mechanisms (special DFU commands, provisioning profiles, or special Image4 manifests) are implementation details, but the high-level effect is that certain signature and version checks are bypassed or altered for internal workflows.&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;GID Key Variance: Dev silicon often uses a distinct GID key (or set of keys) from production. This means:&lt;/p&gt;
        &lt;list rend="ul"&gt;
          &lt;item&gt;Firmware encrypted for Prod cannot be decrypted on Dev, and vice versa.&lt;/item&gt;
          &lt;item&gt;Dev images are cryptographically bound to dev-fused hardware, preventing accidental cross-leakage into production units.&lt;/item&gt;
        &lt;/list&gt;
      &lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Identifying Silicon State in Practice:&lt;/p&gt;
    &lt;p&gt;From the outside, the security domain can be inferred via DFU and other low-level interfaces:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;p&gt;DFU Responses:&lt;/p&gt;&lt;lb/&gt;USB DFU responses (e.g., from&lt;code&gt;irecovery&lt;/code&gt;,&lt;code&gt;ipwndfu&lt;/code&gt;, or equivalent tooling) expose fields such as&lt;code&gt;CPID&lt;/code&gt;,&lt;code&gt;ECID&lt;/code&gt;, and CPFM-like indicators. On many platforms:&lt;list rend="ul"&gt;&lt;item&gt;Values where CPFM-like bits are &lt;code&gt;0x3&lt;/code&gt;correspond to production devices.&lt;/item&gt;&lt;item&gt;Values where CPFM-like bits are &lt;code&gt;0x0&lt;/code&gt;or&lt;code&gt;0x1&lt;/code&gt;correspond to dev-fused hardware.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;Values where CPFM-like bits are &lt;/item&gt;
      &lt;item&gt;&lt;code&gt;CHIP_ID&lt;/code&gt;/&lt;code&gt;ECID&lt;/code&gt;Patterns:&lt;lb/&gt;Reverse-engineering tools often apply heuristic masks to these fields to classify devices. For example, certain high bits set in&lt;code&gt;CHIP_ID&lt;/code&gt;or specific ranges in&lt;code&gt;ECID&lt;/code&gt;are empirically associated with production vs. development, but the exact encodings vary by SoC and should be treated as version-specific heuristics rather than universal rules.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The “Un-dumpable” Region:&lt;/p&gt;
    &lt;p&gt;Regardless of dev or prod state, once the Boot ROM prepares to jump to the next stage (LLB), it typically performs a lockdown sequence:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Writes to the memory controller or system registers to unmap its own address range (e.g., around &lt;code&gt;0x100000000&lt;/code&gt;) from the normal physical address space.&lt;/item&gt;
      &lt;item&gt;Ensures that any subsequent attempt by LLB or the kernel to read that region either raises a bus error or returns zeros.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;This is why practical Boot ROM dumps require a vulnerability during the Boot ROM execution window (e.g., &lt;code&gt;checkm8&lt;/code&gt;-style exploits or carefully timed glitching) rather than a simple read from a later boot stage. On production (CPFM ≈ 0x3) devices this window is tightly constrained; on dev-fused hardware, JTAG/SWD access and relaxed policy make that window significantly easier to instrument but do not fundamentally change the “self-erasing” behavior.&lt;/p&gt;
    &lt;head rend="h3"&gt;1.2 Proprietary ISA Extensions (arm64e+)&lt;/head&gt;
    &lt;p&gt;While the M-series cores implement the Armv8-A architecture with a comprehensive set of optional extensions (e.g., &lt;code&gt;FEAT_PAuth&lt;/code&gt;, &lt;code&gt;FEAT_BTI&lt;/code&gt;), Apple has aggressively extended the Instruction Set Architecture (ISA) with proprietary logic. For the reverse engineer, standard Arm documentation is insufficient. Understanding the security posture of macOS Tahoe requires mastering these custom extensions, as they form the hardware enforcement layer for the new kernel isolation model.&lt;/p&gt;
    &lt;head rend="h4"&gt;1.2.1 Pointer Authentication (PAC): The Cryptographic Control Flow&lt;/head&gt;
    &lt;p&gt;Apple’s implementation of Armv8.3-PAuth is the most pervasive security mitigation in the XNU kernel. It repurposes the unused high-order bits above the configured virtual address size (the "top" bits of a 64-bit pointer) to store a cryptographic signature, or Pointer Authentication Code (PAC).&lt;/p&gt;
    &lt;p&gt;The Key Hierarchy:&lt;lb/&gt; The hardware maintains five distinct 128-bit keys in system registers. On macOS with VHE (Virtualization Host Extensions) enabled, the kernel accesses these keys via the &lt;code&gt;_EL1&lt;/code&gt; register aliases, which the hardware redirects to the EL2 bank of the key registers:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;APIAKey&lt;/code&gt;/&lt;code&gt;APIBKey&lt;/code&gt;(Instruction): Signs code pointers (function pointers, return addresses).&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;APDAKey&lt;/code&gt;/&lt;code&gt;APDBKey&lt;/code&gt;(Data): Signs data pointers. Crucial for protecting C++ vtables in IOKit (&lt;code&gt;OSObject&lt;/code&gt;).&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;APGAKey&lt;/code&gt;(Generic): Signs arbitrary data blobs, effectively a hardware-accelerated MAC.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The &lt;code&gt;AUT&lt;/code&gt; Failure Mechanism (Canonical Non-Valid):&lt;lb/&gt; For the reverse engineer analyzing crash dumps, understanding the failure mode is critical. When an &lt;code&gt;AUT*&lt;/code&gt; instruction (e.g., &lt;code&gt;AUTIA&lt;/code&gt;) is executed on a corrupted or forged pointer, the CPU does not immediately raise an exception.&lt;/p&gt;
    &lt;p&gt;Instead, the hardware corrupts the pointer in a deterministic way to ensure it causes a translation fault upon dereference.&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Validation: The CPU recalculates the PAC.&lt;/item&gt;
      &lt;item&gt;Mismatch: If the calculated PAC does not match the bits in the pointer, the CPU writes an error pattern into the PAC field, flipping specific high-order bits.&lt;/item&gt;
      &lt;item&gt;Result: The pointer becomes a "canonical non-address": the PAC field is overwritten with an error pattern so that any use of the pointer leads to an architectural fault.&lt;/item&gt;
      &lt;item&gt;Crash: The subsequent &lt;code&gt;LDR&lt;/code&gt;or&lt;code&gt;BLR&lt;/code&gt;triggers a Data Abort or Prefetch Abort.&lt;/item&gt;
    &lt;/list&gt;
    &lt;quote&gt;&lt;p&gt;RE Tip: Empirically, on many M-series SoCs, a PAC authentication failure often manifests as a pointer where the upper byte is partially set (e.g.,&lt;/p&gt;&lt;code&gt;0x007f...&lt;/code&gt;or&lt;code&gt;0x00ff...&lt;/code&gt;). If you see a crash involving such a pointer, you are likely looking at a PAC failure rather than a standard NULL dereference or heap corruption.&lt;/quote&gt;
    &lt;head rend="h4"&gt;1.2.2 Branch Target Identification (BTI): The Landing Pads&lt;/head&gt;
    &lt;p&gt;Often deployed in tandem with PAC (&lt;code&gt;-mbranch-protection=standard&lt;/code&gt;), BTI mitigates Jump-Oriented Programming (JOP). It enforces a state machine on indirect branches.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Marking Pages: The Page Table Entries (PTE) now include a Guarded Page (&lt;code&gt;GP&lt;/code&gt;) bit.&lt;/item&gt;
      &lt;item&gt;The &lt;code&gt;BTI&lt;/code&gt;Instruction: This is a "hint" instruction (NOP on older silicon). It acts as a valid landing pad.&lt;/item&gt;
      &lt;item&gt;Enforcement: When the CPU executes an indirect branch (&lt;code&gt;BR&lt;/code&gt;,&lt;code&gt;BLR&lt;/code&gt;) targeting a Guarded Page, the very next instruction must be a&lt;code&gt;BTI&lt;/code&gt;instruction of the correct type (&lt;code&gt;c&lt;/code&gt;for call,&lt;code&gt;j&lt;/code&gt;for jump,&lt;code&gt;jc&lt;/code&gt;for both).&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;If the target is not a &lt;code&gt;BTI&lt;/code&gt; instruction, the CPU raises a Branch Target Exception. In XNU, observations suggest this often manifests as a &lt;code&gt;SIGILL&lt;/code&gt; (Illegal Instruction) with a specific subcode, distinguishing it from standard undefined opcode exceptions. For exploit development, this necessitates finding gadgets that not only perform the desired operation but are also preceded by a valid landing pad.&lt;/p&gt;
    &lt;head rend="h4"&gt;1.2.3 New in Tahoe: The Guarded Execution Feature (GXF)&lt;/head&gt;
    &lt;p&gt;This is the most significant architectural divergence in the Apple Silicon era. Standard Arm defines a vertical privilege stack (EL0 → EL1 → EL2). Apple has introduced a parallel execution domain, conceptually a Secure World (distinct from Arm TrustZone), accessed via Guarded Levels (GL).&lt;/p&gt;
    &lt;p&gt;GXF allows the processor to switch between the "Normal World" (where macOS runs) and the "Secure World" (where Exclaves run). These worlds share the same physical silicon but possess vastly different hardware permissions and system register views.&lt;/p&gt;
    &lt;p&gt;The Privilege Hierarchy:&lt;lb/&gt; The Guarded Levels mirror the standard Exception Levels but exist within the isolated Secure World context. The mapping for macOS Tahoe is as follows:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Normal World (macOS): &lt;list rend="ul"&gt;&lt;item&gt;EL0: Userland processes (Apps, Daemons).&lt;/item&gt;&lt;item&gt;EL2: The XNU Kernel. (Note: On macOS Apple Silicon, the kernel runs at EL2 using Virtualization Host Extensions (VHE) to support hypervisor functions. On iOS, it typically runs at EL1).&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;Secure World (Exclaves): &lt;list rend="ul"&gt;&lt;item&gt;GL0: Conclaves (secure user workloads) and a privileged Conclave hosting the Trusted Execution Monitor (TXM). This is where policy logic, privacy indicators, and Passkey logic reside.&lt;/item&gt;&lt;item&gt;GL1: The Secure Kernel (ExclaveOS). An L4-inspired microkernel responsible for scheduling and IPC within the secure world.&lt;/item&gt;&lt;item&gt;GL2: The Secure Page Table Monitor (SPTM). The ultimate hardware root of trust, mirroring the privilege of a hypervisor but strictly for security enforcement.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The Proprietary Opcodes:&lt;lb/&gt; Transitions between worlds are not handled by standard &lt;code&gt;SMC&lt;/code&gt; calls. Apple added custom instructions to the ISA:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;GENTER&lt;/code&gt;(Opcode&lt;code&gt;0x00201420&lt;/code&gt;): Synchronous entry into the Secure World. It behaves like a hypercall, atomically switching the hardware context (SPRR state, stack pointer, and system registers) from ELx to GLx.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;GEXIT&lt;/code&gt;(Opcode&lt;code&gt;0x00201400&lt;/code&gt;): Returns from the Secure World to the Normal World.&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h4"&gt;1.2.4 New in Tahoe: Shadow Permission Remapping Registers (SPRR)&lt;/head&gt;
    &lt;p&gt;To enforce isolation between the Normal World (XNU) and the Secure World (Exclaves), Apple replaced the older APRR (Access Permission Remapping Registers) on newer silicon (A15/M2+) with the more robust SPRR (Shadow Permission Remapping Registers).&lt;/p&gt;
    &lt;p&gt;In standard Arm MMUs, the Page Table Entry (PTE) bits define permissions directly. In Apple Silicon with SPRR enabled, the PTE's &lt;code&gt;AP[1:0]&lt;/code&gt; bits and NX bits (&lt;code&gt;UXN&lt;/code&gt;, &lt;code&gt;PXN&lt;/code&gt;) are repurposed as a 4-bit index into a hardware permission table.&lt;/p&gt;
    &lt;p&gt;The Indirection Layer:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;PTE Index: The PTE specifies a permission index (e.g., Index 5).&lt;/item&gt;
      &lt;item&gt;Context Lookup: The hardware checks the current execution mode (EL2, GL1, or GL2).&lt;/item&gt;
      &lt;item&gt;Resolution: It looks up Index 5 in the &lt;code&gt;SPRR_PERM_ELx&lt;/code&gt;register specific to that mode.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The Security Implication:&lt;lb/&gt; This allows for "View-Based" memory protection.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;A particular SPRR index (for example, index 5) is configured so that in GL2 (SPTM) it resolves to Read-Write (RW).&lt;/item&gt;
      &lt;item&gt;The same index resolves to Read-Only (RO) in EL2 (Kernel).&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;This is how the SPTM protects page tables. The physical pages containing the translation tables are marked with a specific SPRR index. The hardware configuration for EL2 (Kernel) maps that index to Read-Only. Even if an attacker has a kernel-level arbitrary write primitive, the MMU will reject the write to the page table because the SPRR configuration for EL2 forbids it. The only way to write to that page is to execute &lt;code&gt;GENTER&lt;/code&gt; to switch to GL2, where the SPRR configuration permits the write.&lt;/p&gt;
    &lt;head rend="h2"&gt;2.0 The Secure Enclave Processor (SEP): The Parallel Computer&lt;/head&gt;
    &lt;p&gt;If the Application Processor (AP) is the brain of the device, the Secure Enclave Processor (SEP) is its conscience. It is not merely a coprocessor; it is a fully independent computer-on-a-chip, sharing the same die but architecturally severed from the AP. It runs its own operating system (&lt;code&gt;sepOS&lt;/code&gt;), based on an Apple-customized L4 microkernel, manages its own peripherals, and holds the keys to the kingdom (UID/GID). In the macOS Tahoe generation, the SEP effectively acts as the root of authority for biometric authentication decisions and for OS-bound key material used in attestation and Data Protection.&lt;/p&gt;
    &lt;head rend="h3"&gt;2.1 SEP Initialization &amp;amp; Boot&lt;/head&gt;
    &lt;p&gt;The SEP boot process is designed to be resilient against a fully compromised Application Processor. From the moment power is applied, the SEP operates under the threat model that the AP is hostile.&lt;/p&gt;
    &lt;head rend="h4"&gt;2.1.1 The SEPROM: SRAM Execution and the Memory Protection Engine (MPE)&lt;/head&gt;
    &lt;p&gt;Like the AP, the SEP begins execution from an immutable on-die Boot ROM, the SEPROM.&lt;/p&gt;
    &lt;p&gt;The Hardware Environment:&lt;lb/&gt; The SEP core (historically an ARMv7-A "Kingfisher" core on A7–A9, though the specific microarchitecture of M-series SEP cores is undocumented) initializes in a highly constrained environment. Execution begins in the SEPROM using a small on-die SRAM for stack and early state. However, the &lt;code&gt;sepOS&lt;/code&gt; is too large to fit entirely in SRAM. To utilize the device's main DRAM securely, the SEP relies on the Memory Protection Engine (MPE). Before the SEP accesses external DRAM, the Boot ROM initializes the MPE, ensuring all subsequent memory transactions are encrypted and authenticated. This isolation prevents early-boot DMA attacks from the AP or Thunderbolt peripherals.&lt;/p&gt;
    &lt;p&gt;The Memory Protection Engine (MPE):&lt;lb/&gt; The MPE sits inline between the SEP core and the memory controller. It creates a cryptographic window into physical memory that is opaque to the rest of the SoC.&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Ephemeral Keys: On system startup, the SEP Boot ROM programs the MPE with a random, ephemeral AES key. This key exists only in the MPE hardware registers and is never exposed to software (even &lt;code&gt;sepOS&lt;/code&gt;). On M-series silicon, the MPE manages distinct ephemeral keys for the SEP and the Secure Neural Engine (SNE), ensuring isolation even between secure subsystems.&lt;/item&gt;
      &lt;item&gt;AES-XEX Encryption: Data written by the SEP to DRAM is encrypted transparently using AES in XEX (XOR-Encrypt-XOR) mode.&lt;/item&gt;
      &lt;item&gt;Authentication: The MPE calculates a CMAC tag for every block of memory (cache line granularity). This tag is stored alongside the encrypted data.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;RE Implication: If you attempt to dump the physical memory range assigned to the SEP from the AP (kernel mode), you will see high-entropy noise. Furthermore, any attempt to modify a single bit of this memory via the AP will invalidate the CMAC tag. The next time the SEP reads that line, the MPE will detect the forgery and trigger a hardware panic, locking down the Enclave until a full system reset.&lt;/p&gt;
    &lt;head rend="h4"&gt;2.1.2 The Boot Monitor: Hardware Enforcement of OS-Bound Keys&lt;/head&gt;
    &lt;p&gt;On modern silicon (A13/M1 and later), Apple introduced the Secure Enclave Boot Monitor to mitigate the risk of Boot ROM exploits (like &lt;code&gt;checkm8&lt;/code&gt;) compromising the chain of trust for key derivation.&lt;/p&gt;
    &lt;p&gt;In older architectures, the SEPROM would verify the &lt;code&gt;sepOS&lt;/code&gt; signature and then jump to it. If the SEPROM was exploited, the attacker could jump to a malicious payload while retaining access to the hardware UID key. The Boot Monitor closes this gap by enforcing System Coprocessor Integrity Protection (SCIP).&lt;/p&gt;
    &lt;p&gt;The Boot Flow:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Payload Staging: The AP (iBoot) loads the &lt;code&gt;sep-firmware.img4&lt;/code&gt;payload into a region of physical memory.&lt;/item&gt;
      &lt;item&gt;Mailbox Signal: The AP signals the SEP via a hardware mailbox register.&lt;/item&gt;
      &lt;item&gt;Verification: The SEPROM parses the Image4 container. It verifies the signature against the SEP-specific Apple Root CA public key embedded within the immutable SEPROM.&lt;/item&gt;
      &lt;item&gt;The Handoff: Crucially, the SEPROM cannot simply jump to the loaded image. The SCIP hardware prevents execution of mutable memory.&lt;/item&gt;
      &lt;item&gt;Monitor Intervention: The SEPROM invokes the Boot Monitor hardware block. &lt;list rend="ul"&gt;&lt;item&gt;The Monitor resets the SEP core to a known clean state.&lt;/item&gt;&lt;item&gt;The Monitor calculates a cryptographic hash of the loaded &lt;code&gt;sepOS&lt;/code&gt;memory range.&lt;/item&gt;&lt;item&gt;The Monitor updates the SCIP registers to permit execution of that specific range.&lt;/item&gt;&lt;item&gt;The Boot ROM and Boot Monitor jointly produce a measurement of the loaded &lt;code&gt;sepOS&lt;/code&gt;and lock it into a dedicated register used by the Public Key Accelerator (PKA).&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;OS-Bound Key Derivation:&lt;lb/&gt; This finalized hash is the critical component. When the &lt;code&gt;sepOS&lt;/code&gt; later requests keys (e.g., to decrypt user data), the hardware Key Derivation Function (KDF) mixes the hardware UID with this locked hash.&lt;/p&gt;
    &lt;p&gt;$$ K_{derived} = KDF(UID, Hash_{sepOS}) $$&lt;/p&gt;
    &lt;p&gt;If an attacker modifies a single byte of the &lt;code&gt;sepOS&lt;/code&gt; (even with a Boot ROM exploit), the Boot Monitor calculates a different hash. Consequently, the KDF derives different OS-bound keys, so any data protected by those keys (e.g., passcode- and SKP-bound Data Protection keys) remains cryptographically inaccessible under the modified &lt;code&gt;sepOS&lt;/code&gt;. This is "Bound Security"—the data is bound not just to the device, but to a specific, signed software version.&lt;/p&gt;
    &lt;head rend="h4"&gt;2.1.3 Anti-Replay Mechanisms: The Integrity Tree&lt;/head&gt;
    &lt;p&gt;A classic attack vector against secure enclaves is the Replay Attack: capturing a snapshot of the encrypted RAM (e.g., when the passcode retry counter is 0) and restoring it later after the counter has incremented.&lt;/p&gt;
    &lt;p&gt;To prevent this, the SEP implements a hardware-enforced Integrity Tree (Merkle Tree).&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;The Root of Trust: The root node of the integrity tree is stored in dedicated on-chip SRAM within the Secure Enclave complex. This memory is physically distinct from the main DRAM and cannot be addressed by the AP.&lt;/item&gt;
      &lt;item&gt;Tree Structure: The protected memory region (where &lt;code&gt;sepOS&lt;/code&gt;data and the Secure Storage Manager reside) is divided into blocks. Each block's hash is stored in a parent node, recursively up to the root.&lt;/item&gt;
      &lt;item&gt;Atomic Updates: When the SEP writes to protected memory (e.g., incrementing a failed attempt counter), the MPE updates the data, recalculates the hashes up the tree, and atomically updates the root hash in the on-chip SRAM.&lt;/item&gt;
      &lt;item&gt;Verification: On every read, the MPE verifies the path from the data block up to the SRAM root.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;If an attacker replays an old DRAM state, the hash of the replayed block will not match the current root hash stored in the internal SRAM. The MPE detects the mismatch (Anti-Replay Violation) and halts the SEP. This mechanism ensures that the SEP has a strictly monotonic view of time and state, rendering snapshot fuzzing and counter rollbacks impossible.&lt;/p&gt;
    &lt;head rend="h3"&gt;2.2 SEP Runtime Architecture&lt;/head&gt;
    &lt;p&gt;Once the &lt;code&gt;sepOS&lt;/code&gt; is bootstrapped and verified, the Secure Enclave transitions into its runtime state. At this point, it functions as a fully autonomous operating system running an Apple-customized variant of the L4 microkernel (historically derived from L4-embedded/Darbat). For the reverse engineer, understanding the runtime architecture is crucial for analyzing how the SEP communicates with the hostile "Rich Execution Environment" (the AP running XNU) and how it persists sensitive state.&lt;/p&gt;
    &lt;head rend="h4"&gt;2.2.1 The Mailbox Interface: Analyzing the IPC Transport&lt;/head&gt;
    &lt;p&gt;Communication between the Application Processor (AP) and the SEP is strictly asynchronous and interrupt-driven. Unlike the tight coupling of the SPTM (which uses synchronous instruction traps), the SEP interaction is mediated by a hardware mechanism known as the Mailbox, which relies on the proprietary Apple Interrupt Controller (AIC) to manage signaling.&lt;/p&gt;
    &lt;p&gt;The Physical Transport: Registers and Shared Memory&lt;lb/&gt; There is no shared virtual memory space; the two processors exchange messages via a combination of Memory-Mapped I/O (MMIO) registers and physical memory buffers.&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;&lt;p&gt;The Control Mailbox (MMIO):&lt;/p&gt;&lt;lb/&gt;The primary control channel consists of dedicated hardware registers within the SEP's configuration space (typically mapped at&lt;code&gt;sep@DA00000&lt;/code&gt;on A-series, with evolving offsets on M-series).&lt;list rend="ul"&gt;&lt;item&gt;Inbox/Outbox: The AP writes a message to the Inbox register, which triggers an IRQ on the SEP. The SEP writes a reply to the Outbox register, which triggers an IRQ on the AP.&lt;/item&gt;&lt;item&gt;M-Series Evolution: On Apple Silicon (M1+), reverse engineering of the &lt;code&gt;apple-mailbox&lt;/code&gt;driver indicates a shift toward using shared memory ring buffers for the control path to handle higher throughput, managed by the AIC's hardware event lines.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;&lt;p&gt;The Doorbell (Apple Interrupt Controller):&lt;/p&gt;&lt;lb/&gt;To signal a message, the sender must trigger an exception on the receiver.&lt;list rend="ul"&gt;&lt;item&gt;AP → SEP: The kernel writes to a specific AIC "Set" register. This asserts a hardware IRQ line wired to the SEP's core.&lt;/item&gt;&lt;item&gt;SEP → AP: When the SEP replies, it asserts an IRQ line routed to the AP's AIC. The kernel's interrupt handler (within &lt;code&gt;AppleSEPDriver&lt;/code&gt;) acknowledges this by writing to the AIC "Clear" register.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The L4 IPC Protocol:&lt;lb/&gt; The data payload passed through the control registers follows a strict, serialized format (often referred to as the SEP Message format). Analysis of the &lt;code&gt;AppleA7IOP&lt;/code&gt; / &lt;code&gt;AppleSEPManager&lt;/code&gt; stack reveals a compact 64-bit structure:&lt;/p&gt;
    &lt;code&gt;struct sep_msg {
    uint8_t endpoint;  // Destination service (e.g., 0x10)
    uint8_t tag;       // Transaction ID for async correlation
    uint8_t opcode;    // Message type / Command
    uint8_t param;     // Immediate parameter
    uint32_t data;     // Payload or pointer to OOL buffer
};
&lt;/code&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Endpoint ID: Routes the message to a specific task within &lt;code&gt;sepOS&lt;/code&gt;(e.g., the Secure Key Store).&lt;/item&gt;
      &lt;item&gt;Out-of-Line (OOL) Buffers: For payloads larger than 32 bits (such as biometric templates or firmware updates), the &lt;code&gt;data&lt;/code&gt;field contains a physical address. The AP allocates a physical page, pins it, and passes the address to the SEP. The SEP maps this page into its address space using its own IOMMU (often implemented via DART on M-series chips).&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;RE Focus: Fuzzing the Boundary&lt;lb/&gt; The mailbox is the primary attack surface for the SEP. Vulnerabilities here (parsing malformed messages) can lead to code execution within the Enclave.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Endpoint Fuzzing: The &lt;code&gt;sepOS&lt;/code&gt;kernel dispatches messages to user-mode L4 tasks based on the Endpoint ID. Fuzzing specific endpoints (especially legacy or debug endpoints left enabled in production) is a standard methodology.&lt;/item&gt;
      &lt;item&gt;Shared Memory Hazards (TOCTOU): While the mailbox registers handle control flow, bulk data is passed via shared memory. A classic attack vector involves the AP modifying the data in the shared buffer after the SEP has validated the header/signature but before it processes the body (Time-of-Check to Time-of-Use).&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h4"&gt;2.2.2 The Secure Storage Component (xART): Encrypted Persistent Storage&lt;/head&gt;
    &lt;p&gt;The SEP has no general-purpose NAND flash of its own. It must rely on the Application Processor’s storage stack to persist long-lived secrets (passcode state, biometric templates, token material). However, it cannot trust the AP or its filesystem to store this data without tampering.&lt;/p&gt;
    &lt;p&gt;To solve this, Apple pairs the SEP with a Secure Storage Component, often referred to in firmware and kexts as xART (eXtended Anti-Replay Technology).&lt;/p&gt;
    &lt;p&gt;At a high level, xART behaves as a dedicated, tamper-resistant non-volatile store that is logically attached exclusively to the SEP:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;It has its own non-volatile memory and cryptographic logic.&lt;/item&gt;
      &lt;item&gt;It is only addressable from within the SEP’s trust domain over a dedicated, authenticated channel.&lt;/item&gt;
      &lt;item&gt;The AP and XNU have no direct protocol to read or write its contents; all access is mediated by &lt;code&gt;sepOS&lt;/code&gt;.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;You can think of xART as a small, secure NVRAM bank whose sole purpose is to hold anti-replay metadata and counters that anchor SEP-managed state.&lt;/p&gt;
    &lt;p&gt;The Architecture:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;
        &lt;p&gt;Physical / Logical Separation:&lt;/p&gt;
        &lt;list rend="ul"&gt;
          &lt;item&gt;At the implementation level, the Secure Storage Component may be a discrete die or a dedicated block within a larger package, but architecturally it presents as a separate secure store accessed only by the SEP.&lt;/item&gt;
          &lt;item&gt;The AP sees none of its registers or address space; there are no MMIO ranges that the kernel can map to talk directly to xART.&lt;/item&gt;
        &lt;/list&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;SEP-Centric View of Storage:&lt;/p&gt;
        &lt;list rend="ul"&gt;
          &lt;item&gt;The SEP treats AP-managed NAND (the main SSD / NVMe) as an untrusted block device.&lt;/item&gt;
          &lt;item&gt;All SEP data structures stored there (keybags, counters, templates, tickets) are encrypted and authenticated using keys derived from the UID/GID and xART’s state.&lt;/item&gt;
          &lt;item&gt;The xART component holds the small, high-value bits: monotonic counters, per-volume or per-domain nonces, and commitment hashes for larger encrypted blobs stored on the AP’s filesystem.&lt;/item&gt;
        &lt;/list&gt;
      &lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The Anti-Replay Guarantee:&lt;/p&gt;
    &lt;p&gt;When the SEP writes persistent state—for example, updating the failed passcode attempt counter or credential state—it performs a two-phase commit:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;
        &lt;p&gt;Write to Untrusted Storage (AP):&lt;/p&gt;
        &lt;list rend="ul"&gt;
          &lt;item&gt;The SEP encrypts the payload (e.g., a keybag or metadata record) with keys derived from the UID and appropriate class keys.&lt;/item&gt;
          &lt;item&gt;It sends the ciphertext to the AP via the mailbox protocol.&lt;/item&gt;
          &lt;item&gt;The AP writes this to its filesystem (e.g., a file under &lt;code&gt;/private/var/db/&lt;/code&gt;), but the contents are opaque to it.&lt;/item&gt;
        &lt;/list&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Commit to xART (Secure Storage Component):&lt;/p&gt;
        &lt;list rend="ul"&gt;
          &lt;item&gt;In parallel, the SEP computes a cryptographic digest (e.g., a hash or MAC) over the new payload and the associated monotonic counter or nonce.&lt;/item&gt;
          &lt;item&gt;It writes this digest and the updated counter/nonce to xART.&lt;/item&gt;
          &lt;item&gt;xART becomes the authoritative record of “what the latest version of this object should look like” and “how many times it has been updated.”&lt;/item&gt;
        &lt;/list&gt;
      &lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;On subsequent reads:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;The SEP requests the ciphertext from the AP.&lt;/item&gt;
      &lt;item&gt;It recomputes the digest and compares it against the value stored in xART for that object.&lt;/item&gt;
      &lt;item&gt;If the digests and counters match, the SEP accepts and decrypts the payload.&lt;/item&gt;
      &lt;item&gt;If the AP has replayed an old copy (e.g., with a lower counter or different hash), the mismatch is detected and the SEP treats it as an anti-replay violation—typically halting access to that data or, in severe cases, triggering a lockout.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Security Properties:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;p&gt;Monotonicity:&lt;/p&gt;&lt;lb/&gt;The SEP’s view of sensitive state (e.g., passcode retry counters, escrow records) is strictly monotonic. An attacker cannot reset or roll back these counters by snapshotting and restoring AP-visible storage, because xART’s internal counters would not match.&lt;/item&gt;
      &lt;item&gt;&lt;p&gt;AP Transparency:&lt;/p&gt;&lt;lb/&gt;From the AP’s perspective, xART is a black box. It sees only that some SEP operation failed or succeeded; it never observes the internal counters, keys, or hashes that xART maintains.&lt;/item&gt;
      &lt;item&gt;&lt;p&gt;Data Binding:&lt;/p&gt;&lt;lb/&gt;SEP-managed data is effectively bound to:&lt;list rend="ul"&gt;&lt;item&gt;The specific SEP instance (via UID).&lt;/item&gt;&lt;item&gt;The xART anti-replay state (counters / nonces).&lt;/item&gt;&lt;item&gt;The software measurement (for SKP-like mechanisms described later).&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;RE Implication:&lt;/p&gt;
    &lt;p&gt;For reverse engineering, the important consequences are:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;
        &lt;p&gt;Dumping or modifying the files that back SEP state on the AP is insufficient to reset security-sensitive conditions (e.g., passcode retry counters, keybag versions). Without aligning xART’s internal state, any replay will be detected and rejected.&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;There is no direct AP-visible interface to xART; all interesting protocol surface is in:&lt;/p&gt;
        &lt;list rend="ul"&gt;
          &lt;item&gt;&lt;code&gt;sepOS&lt;/code&gt;endpoint handlers that manipulate anti-replay state.&lt;/item&gt;
          &lt;item&gt;The &lt;code&gt;AppleSEPKeyStore&lt;/code&gt;and related kexts and daemons that proxy higher-level requests (FileVault, Keychain, biometric state) into SEP commands.&lt;/item&gt;
        &lt;/list&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Exploits that attempt to tamper with SEP persistence must target:&lt;/p&gt;
        &lt;list rend="ul"&gt;
          &lt;item&gt;The integrity of SEP’s logic around xART updates, or&lt;/item&gt;
          &lt;item&gt;The boundary between SEP and AP (e.g., TOCTOU races on the untrusted ciphertext), not the xART hardware itself.&lt;/item&gt;
        &lt;/list&gt;
      &lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h4"&gt;2.2.3 RE Focus: Reverse Engineering the &lt;code&gt;sepOS&lt;/code&gt; L4 Syscall Table&lt;/head&gt;
    &lt;p&gt;For the advanced reverse engineer, the holy grail is understanding the &lt;code&gt;sepOS&lt;/code&gt; kernel itself. Since it is based on L4, it relies heavily on synchronous IPC for system calls.&lt;/p&gt;
    &lt;p&gt;Identifying the Syscall Handler:&lt;lb/&gt; In the disassembled &lt;code&gt;sepOS&lt;/code&gt; binary (decrypted via Boot ROM exploit), the exception vector table is the starting point. The SVC (Supervisor Call) handler dispatches requests based on the immediate value or a register (typically &lt;code&gt;x0&lt;/code&gt; or &lt;code&gt;x8&lt;/code&gt;).&lt;/p&gt;
    &lt;p&gt;Mapping the Tasks:&lt;lb/&gt; The &lt;code&gt;sepOS&lt;/code&gt; is modular, consisting of the kernel and several user-mode "apps" or "tasks." Analysis of firmware dumps reveals the internal naming convention:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;SEPOS&lt;/code&gt;: The root task and kernel.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;sks&lt;/code&gt;(Secure Key Store): The backend for&lt;code&gt;AppleSEPKeyStore&lt;/code&gt;, managing Data Protection and Keychain items.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;sbio-sd&lt;/code&gt;(Secure Biometric Sensor Driver): The backend for&lt;code&gt;biometrickitd&lt;/code&gt;, handling the processing of fingerprint and face data.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;sse&lt;/code&gt;(Secure Element): Manages communication with the NFC Secure Element for Apple Pay.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;sepServices&lt;/code&gt;: A directory service mapping symbolic names to endpoints.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;By tracing the IPC messages dispatched from the Mailbox handler, you can map which L4 task handles which service. For example, messages routed to the endpoint associated with &lt;code&gt;sbio-sd&lt;/code&gt; will contain the proprietary command structures for biometric enrollment and matching. Analyzing the message parsing logic within that specific task reveals the attack surface for biometric bypasses.&lt;/p&gt;
    &lt;quote&gt;&lt;p&gt;Tooling Note: Standard tools like IDA Pro or Ghidra require custom loaders for&lt;/p&gt;&lt;code&gt;sepOS&lt;/code&gt;binaries. The memory layout is non-standard, and the binary format (Mach-O) often has stripped headers or non-standard segment protections that must be manually reconstructed based on the SCIP configuration found in the Boot Monitor logic.&lt;/quote&gt;
    &lt;head rend="h2"&gt;3.0 The Chain of Trust: Firmware &amp;amp; Bootloaders&lt;/head&gt;
    &lt;p&gt;With the hardware root of trust established and the Secure Enclave operating as a parallel authority, the Application Processor begins the process of bootstrapping the mutable software stack. This phase is governed by the Image4 serialization format and a strict chain of cryptographic handover.&lt;/p&gt;
    &lt;head rend="h3"&gt;3.1 Low-Level Bootloader (LLB)&lt;/head&gt;
    &lt;p&gt;On platforms that implement an LLB stage (e.g., Apple Silicon Macs and older A-series SoCs), the Low-Level Bootloader (LLB) is the first piece of mutable code executed by the Application Processor. Loaded by the Boot ROM from the boot partition of the internal flash (NAND, or NOR SPI on some development hardware), it executes initially out of on-die SRAM before DRAM has been brought online. Its primary directive is architectural: it must bridge the gap between the raw silicon state and the feature-rich environment required by iBoot.&lt;/p&gt;
    &lt;head rend="h3"&gt;3.1.1 Parsing the Image4 (&lt;code&gt;img4&lt;/code&gt;) Container&lt;/head&gt;
    &lt;p&gt;To the reverse engineer, "firmware" on Apple Silicon is synonymous with Image4. LLB is not a raw binary; it is encapsulated in an Image4 container, a format based on ASN.1 (Abstract Syntax Notation One) and DER (Distinguished Encoding Rules). Understanding this structure is prerequisite to any firmware analysis.&lt;/p&gt;
    &lt;p&gt;A complete Image4 object consists of an &lt;code&gt;IM4P&lt;/code&gt; (Payload) and an &lt;code&gt;IM4M&lt;/code&gt; (Manifest), with an optional &lt;code&gt;IM4R&lt;/code&gt; (Restore Info) object used in restore flows.&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;&lt;code&gt;IM4P&lt;/code&gt;(Payload): The actual executable code (the LLB binary).&lt;list rend="ul"&gt;&lt;item&gt;Encryption: The payload is encrypted under a per-image AES key. On production devices, this per-image key is wrapped using the SoC’s GID Key and stored in the Keybag (KBAG) tag within the payload. At boot, the hardware AES engine unwraps the KBAG under the GID key to recover the IV and payload key, then decrypts the payload. This means the payload is opaque to external analysis unless decrypted on-device (or via a GID oracle).&lt;/item&gt;&lt;item&gt;Compression: Once decrypted, the payload is typically compressed (LZSS or LZFSE).&lt;/item&gt;&lt;item&gt;Type Tag: A 4-character code (e.g., &lt;code&gt;ibot&lt;/code&gt;,&lt;code&gt;illb&lt;/code&gt;) identifying the component.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;IM4M&lt;/code&gt;(Manifest): The signature and constraints, commonly known as the ApTicket.&lt;list rend="ul"&gt;&lt;item&gt;The Signature: An RSA or ECDSA signature over the SHA-384 hash of the payload.&lt;/item&gt;&lt;item&gt;The Body: A set of entitlements and constraints (tags) that dictate where and how this payload can run.&lt;/item&gt;&lt;item&gt;Certificate Chain: The manifest includes the certificate chain leading back to the Apple Root CA. The Boot ROM holds the corresponding root public key (or its hash) in immutable hardware and verifies the chain using the Public Key Accelerator (PKA).&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;IM4R&lt;/code&gt;(Restore Info): (Optional) Contains hardware-specific personalization data used during the restore process, such as the unique nonce generated by the SEP.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The Validation Logic:&lt;lb/&gt; When the Boot ROM loads LLB (and when LLB subsequently loads iBoot), it performs the following &lt;code&gt;image4_validate&lt;/code&gt; routine:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Parse the ASN.1 structure to separate &lt;code&gt;IM4M&lt;/code&gt;and&lt;code&gt;IM4P&lt;/code&gt;.&lt;/item&gt;
      &lt;item&gt;Hash the &lt;code&gt;IM4P&lt;/code&gt;(ciphertext).&lt;/item&gt;
      &lt;item&gt;Locate the corresponding hash in the &lt;code&gt;IM4M&lt;/code&gt;(under the specific tag, e.g.,&lt;code&gt;illb&lt;/code&gt;).&lt;/item&gt;
      &lt;item&gt;Verify the &lt;code&gt;IM4M&lt;/code&gt;signature using the PKA.&lt;/item&gt;
      &lt;item&gt;If valid, the hardware unwraps the payload key from the KBAG using the GID Key, loads it into the AES engine, and decrypts the &lt;code&gt;IM4P&lt;/code&gt;ciphertext.&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h4"&gt;3.1.2 DRAM Training and Memory Controller Configuration&lt;/head&gt;
    &lt;p&gt;Before external LPDDR4X/LPDDR5 Unified Memory can be used, the memory controller and PHY must be trained. Early boot code (Boot ROM and/or LLB) runs initially from on-die SRAM until DRAM training has converged. The physical characteristics of RAM—signal timing, voltage margins, and skew—vary slightly between every physical device due to manufacturing tolerances.&lt;/p&gt;
    &lt;p&gt;The Training Sequence:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Reading SPD/Calibration Data: The boot code reads calibration data from the device tree or dedicated EEPROM areas.&lt;/item&gt;
      &lt;item&gt;PHY Configuration: It configures the Physical Layer (PHY) interface of the memory controller.&lt;/item&gt;
      &lt;item&gt;Training Loop: The code executes a complex algorithm that writes patterns to DRAM and reads them back, adjusting delay lines (DLLs) and drive strengths until the signal is stable.&lt;/item&gt;
      &lt;item&gt;Remapping: Once training is complete, the MCU is brought online. The Memory Management Unit (MMU) is then reconfigured to map the vast expanse of DRAM into the address space.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;RE Implication:&lt;lb/&gt; If you are attempting to exploit the Boot ROM or early LLB, you are constrained to SRAM. You cannot load large payloads or use heap spraying techniques that require gigabytes of memory until after the bootloader has successfully trained the DRAM. This creates a "choke point" for early-boot exploits.&lt;/p&gt;
    &lt;head rend="h3"&gt;3.1.3 Verifying the Exclusive Chip ID (ECID) and Board ID&lt;/head&gt;
    &lt;p&gt;Apple utilizes a mechanism called Personalization (or Taming) to prevent firmware replay attacks. You cannot simply take a valid, signed LLB from one iPhone and run it on another, nor can you downgrade to an older, vulnerable LLB version.&lt;/p&gt;
    &lt;p&gt;This enforcement happens inside the Image4 parser logic within LLB (checking the next stage) and the Boot ROM (checking LLB).&lt;/p&gt;
    &lt;p&gt;The Constraint Tags:&lt;lb/&gt; The &lt;code&gt;IM4M&lt;/code&gt; manifest contains specific tags that bind the signature to the hardware:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;ECID&lt;/code&gt;(Exclusive Chip ID): A unique per-SoC identifier fused into the chip and exposed as an integer value used for personalization.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;BORD&lt;/code&gt;(Board ID): Identifies the PCB model (e.g.,&lt;code&gt;0x10&lt;/code&gt;for a specific iPhone logic board).&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;CHIP&lt;/code&gt;(Chip ID): Identifies the SoC model (e.g.,&lt;code&gt;0x8103&lt;/code&gt;for M1).&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;SDOM&lt;/code&gt;(Security Domain):&lt;code&gt;0x1&lt;/code&gt;for Production,&lt;code&gt;0x0&lt;/code&gt;for Development.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The Check:&lt;lb/&gt; During boot, the executing code reads the actual values from the hardware fuses and compares them against the values present in the signed &lt;code&gt;IM4M&lt;/code&gt;.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;If &lt;code&gt;Hardware.ECID != Manifest.ECID&lt;/code&gt;, the boot halts.&lt;/item&gt;
      &lt;item&gt;If &lt;code&gt;Hardware.BORD != Manifest.BORD&lt;/code&gt;, the boot halts.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;This mechanism, combined with the Nonce (a random value generated by the SEP during updates and baked into the &lt;code&gt;IM4M&lt;/code&gt;), ensures that the firmware is:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Authentic: Signed by Apple.&lt;/item&gt;
      &lt;item&gt;Targeted: Valid only for this specific device.&lt;/item&gt;
      &lt;item&gt;Fresh: Valid only for this specific boot/update cycle (preventing downgrades).&lt;/item&gt;
    &lt;/list&gt;
    &lt;quote&gt;&lt;p&gt;Note: In the "Tahoe" architecture, reverse engineering suggests this verification logic appears to use redundant checks and bitwise operations that resist simple instruction skipping (e.g., glitching a&lt;/p&gt;&lt;code&gt;B.NE&lt;/code&gt;instruction).&lt;/quote&gt;
    &lt;head rend="h3"&gt;3.2 iBoot (Stage 2 Bootloader)&lt;/head&gt;
    &lt;p&gt;Once LLB has initialized the DRAM and verified the next stage, it hands off execution to iBoot. While LLB is a hardware-focused shim, iBoot is a sophisticated, compact operating system in its own right. It features a cooperative task scheduler (rather than a simple single-threaded loop) that manages concurrent subsystems including a full USB stack, a display driver (for the Apple logo), and a filesystem driver (APFS/HFS+). In the Tahoe architecture, iBoot’s role has expanded beyond merely bootstrapping the XNU kernel; it now serves as the orchestrator of the platform's security domains, responsible for loading and isolating the hardware-enforced monitors before the kernel is permitted to execute.&lt;/p&gt;
    &lt;head rend="h4"&gt;3.2.1 The Apple Device Tree (ADT)&lt;/head&gt;
    &lt;p&gt;The hardware configuration of an Apple Silicon device is not discoverable via standard buses like PCI enumeration alone. Instead, iBoot relies on the Apple Device Tree (ADT)—a hierarchical binary data structure (conceptually similar to OpenFirmware or Linux Device Trees) that describes the SoC's topology.&lt;/p&gt;
    &lt;p&gt;The Source:&lt;lb/&gt; The raw ADT is either embedded within the iBoot binary or loaded as a separate &lt;code&gt;devicetree.img4&lt;/code&gt; payload. It contains nodes describing CPUs, memory maps, interrupt controllers (AIC), and peripherals. Unlike Linux systems which often use a "Flattened Device Tree" (FDT), Apple utilizes its own proprietary binary format for the ADT, which XNU consumes directly via the &lt;code&gt;SecureDTLookup&lt;/code&gt; APIs.&lt;/p&gt;
    &lt;p&gt;Runtime Population (&lt;code&gt;/chosen&lt;/code&gt;):&lt;lb/&gt; Before jumping to the kernel, iBoot populates the &lt;code&gt;/chosen&lt;/code&gt; node of the ADT with critical runtime parameters.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;kaslr-seed&lt;/code&gt;: A high-entropy random value (inferred to be derived from the TRNG). The kernel uses this to randomize its memory slide.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;memory-map&lt;/code&gt;: A critical array of structures defining physical memory regions. iBoot marks regions used by the Boot ROM, LLB, and itself as reserved, ensuring the kernel does not overwrite them.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;boot-args&lt;/code&gt;: The command-line arguments passed to the kernel (e.g.,&lt;code&gt;debug=0x14e&lt;/code&gt;,&lt;code&gt;-v&lt;/code&gt;). On production devices, these are strictly filtered based on the&lt;code&gt;sip3&lt;/code&gt;flags in LocalPolicy; only specific flags are allowed unless the device is in a specific research or demoted state.&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h4"&gt;3.2.2 New in Tahoe: Loading the Security Monitors&lt;/head&gt;
    &lt;p&gt;In pre-Tahoe architectures (iOS 14 / macOS 11), iBoot would simply load the kernelcache and jump to it. In the Tahoe era (A15/M2+), iBoot must construct the Guarded Execution Environment before the kernel can exist.&lt;/p&gt;
    &lt;p&gt;Allocation and Reservation:&lt;lb/&gt; iBoot parses the device tree to identify physical memory ranges reserved for the new monitors. It carves these out of the available DRAM:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;SPTM Region: Reserved for the Secure Page Table Monitor.&lt;/item&gt;
      &lt;item&gt;TXM Region: Reserved for the Trusted Execution Monitor.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Payload Loading:&lt;lb/&gt; iBoot locates the specific Image4 payloads, which are co-packaged with the kernelcache (referenced in the OS firmware manifest):&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;Ap,SecurePageTableMonitor&lt;/code&gt;: The GL2 binary.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;Ap,TrustedExecutionMonitor&lt;/code&gt;: The GL1 binary.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;It decrypts and verifies these payloads just like any other firmware component. However, instead of loading them into standard memory, it loads them into the reserved physical regions identified above.&lt;/p&gt;
    &lt;p&gt;Locking SPRR Regions (Conceptual View):&lt;lb/&gt; This is the critical security pivot. Before handing off control, iBoot establishes the initial Shadow Permission Remapping Registers (SPRR) state to enforce isolation. While the SPTM performs its own fine-grained configuration upon initialization, the architectural guarantee provided by iBoot is:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;The GL2 (SPTM) view is configured to have Read/Write/Execute access to its own memory region.&lt;/item&gt;
      &lt;item&gt;The GL1 (TXM) view is configured to have access to its region.&lt;/item&gt;
      &lt;item&gt;Crucially, the GL0 (Kernel) view is configured to mark the SPTM and TXM regions as Inaccessible (No-Access).&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;This ensures that when the processor eventually drops to EL1 (GL0) to run XNU, the kernel is physically incapable of reading or modifying the monitor code, even though it resides in the same physical DRAM.&lt;/p&gt;
    &lt;head rend="h4"&gt;3.2.3 LocalPolicy &amp;amp; BAA: The Shift to Local Signing&lt;/head&gt;
    &lt;p&gt;For macOS, Apple introduced a mechanism to allow users to boot older OS versions or custom kernels (Permissive Security) without breaking the hardware chain of trust. This is managed via LocalPolicy.&lt;/p&gt;
    &lt;p&gt;The Problem:&lt;lb/&gt; The Boot ROM and LLB enforce strict signature checks using manifests issued by Apple's global signing server (TSS). These checks are performed offline using embedded root keys. If you want to boot a custom kernel, you cannot obtain a valid signature from Apple's TSS.&lt;/p&gt;
    &lt;p&gt;The Solution:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;LocalPolicy: A policy file stored on the Data Volume (in the &lt;code&gt;iSCPreboot&lt;/code&gt;volume). It specifies the security mode (Full, Reduced, Permissive) and the hash of the custom kernel collection.&lt;/item&gt;
      &lt;item&gt;Owner Identity Key (OIK): When a user authorizes a downgrade or custom boot (via Recovery Mode authentication), they are effectively authorizing the use of a device-specific Owner Identity Key (OIK) generated within the Secure Enclave. This key is certified once by Apple's Basic Attestation Authority (BAA).&lt;/item&gt;
      &lt;item&gt;Re-Signing: The LocalPolicy is signed by the SEP using this OIK.&lt;/item&gt;
      &lt;item&gt;Boot Time: iBoot fetches the LocalPolicy. It asks the SEP to verify the signature against the OIK. If the SEP confirms the policy is valid (and matches the user's intent), iBoot proceeds to load the custom kernel hash specified in the policy (enabled via the &lt;code&gt;smb1&lt;/code&gt;bit), effectively "blessing" it for this boot cycle.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;This allows "Permissive Security" to exist while keeping the Boot ROM and LLB strictly locked down to the hardware root of trust.&lt;/p&gt;
    &lt;head rend="h4"&gt;3.2.4 RE Focus: Decrypting iBoot Payloads via the AES MMIO Interface&lt;/head&gt;
    &lt;p&gt;To analyze iBoot, one must decrypt it. Since the GID key is fused into the silicon and physically disconnected from the CPU's register file, it cannot be extracted via software. Reverse engineers must instead turn the device into a Decryption Oracle by manipulating the dedicated AES hardware peripheral.&lt;/p&gt;
    &lt;p&gt;The &lt;code&gt;kbag&lt;/code&gt; Mechanism:&lt;lb/&gt; The Image4 payload (&lt;code&gt;IM4P&lt;/code&gt;) is encrypted with a random, per-file symmetric key (the target key). This target key is wrapped (encrypted) with the GID key and stored in the &lt;code&gt;IM4P&lt;/code&gt; header as a Keybag (&lt;code&gt;kbag&lt;/code&gt;). To decrypt the firmware, one must unwrap this kbag.&lt;/p&gt;
    &lt;p&gt;The Hardware Distinction (ISA vs. MMIO):&lt;lb/&gt; It is critical to distinguish between the ARMv8 Crypto Extensions (instructions like &lt;code&gt;AESE&lt;/code&gt;, &lt;code&gt;AESD&lt;/code&gt;) and the Apple AES Peripheral.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;ARMv8 Crypto: Operates on keys loaded into standard NEON/SIMD registers (&lt;code&gt;v0&lt;/code&gt;-&lt;code&gt;v31&lt;/code&gt;). Useful for TLS or disk encryption where the key is known to the OS.&lt;/item&gt;
      &lt;item&gt;Apple AES Peripheral: A memory-mapped I/O (MMIO) block, typically located at a base offset like &lt;code&gt;0x23D2C0000&lt;/code&gt;(on M1/T8103) or similar&lt;code&gt;0x2...&lt;/code&gt;ranges on newer SoCs. This peripheral has exclusive hardware access to the GID key fuses.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The Oracle Exploit:&lt;lb/&gt; Using a Boot ROM exploit (like &lt;code&gt;checkm8&lt;/code&gt; on A-series) or a specialized iBoot exploit, researchers execute a payload that drives this MMIO interface directly:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Reset: Reset the AES peripheral via the &lt;code&gt;AES_CTRL&lt;/code&gt;register to clear internal state.&lt;/item&gt;
      &lt;item&gt;Key Selection: Write to the configuration register to select the GID Key as the decryption source. This sets an internal mux; the key itself is never exposed to the bus.&lt;/item&gt;
      &lt;item&gt;FIFO Loading: Write the &lt;code&gt;kbag&lt;/code&gt;(IV + Ciphertext) into the&lt;code&gt;AES_DATA_IN&lt;/code&gt;FIFO registers.&lt;/item&gt;
      &lt;item&gt;Execution: Trigger the engine. The hardware pulls the GID key from the fuses, performs the AES-256-CBC unwrap, and pushes the result to the output buffer.&lt;/item&gt;
      &lt;item&gt;Extraction: Read the unwrapped target key (typically formatted as &lt;code&gt;iv:key&lt;/code&gt;) from the&lt;code&gt;AES_DATA_OUT&lt;/code&gt;register.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Hypothesized Countermeasures:&lt;lb/&gt; Modern Apple Silicon (A12+/M1+) implements countermeasures against this oracle usage. Reverse engineering suggests the AES engine may enforce a state machine that requires the output of a GID decryption to be immediately DMA'd to executable memory and jumped to, rather than read back into a general-purpose register. Bypassing this theoretically requires Fault Injection (voltage glitching) to corrupt the state machine or precise timing attacks to race the hardware's "sanitize on read" logic, allowing the extraction of the plaintext key before the hardware scrubs it.&lt;/p&gt;
    &lt;head rend="h2"&gt;4.0 The Security Monitor Layer (GL1/GL2): The Exclave Architecture&lt;/head&gt;
    &lt;p&gt;In the "Tahoe" architecture, the XNU kernel has been demoted. It no longer possesses the ultimate authority to define the virtual memory layout of the system. That power has been migrated to a hardware-enforced monitor running in a proprietary execution state known as the Secure World (specifically, the Guarded Execution Feature or GXF). This section dissects the mechanics of this new layer, which effectively functions as a silicon-enforced hypervisor for the kernel itself.&lt;/p&gt;
    &lt;head rend="h3"&gt;4.1 The Secure Page Table Monitor (SPTM) - GL2&lt;/head&gt;
    &lt;p&gt;The Secure Page Table Monitor (SPTM) operates at Guarded Level 2 (GL2). It is the highest privilege runtime component on the Application Processor, sitting above both the XNU Kernel (EL2) and the Secure Kernel (GL1). The SPTM is the sole entity permitted to write to the physical pages that constitute the translation tables (TTBR0/TTBR1) for the managed domains of both the Normal and Secure worlds.&lt;/p&gt;
    &lt;head rend="h4"&gt;4.1.1 The &lt;code&gt;GENTER&lt;/code&gt; and &lt;code&gt;GEXIT&lt;/code&gt; Instructions: Context Switching&lt;/head&gt;
    &lt;p&gt;Transitions into the SPTM utilize the proprietary &lt;code&gt;GENTER&lt;/code&gt; instruction, which performs a synchronous, atomic context switch.&lt;/p&gt;
    &lt;p&gt;The &lt;code&gt;GENTER&lt;/code&gt; ABI:&lt;lb/&gt; To invoke the SPTM, the kernel populates specific registers and executes the opcode.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Opcode: &lt;code&gt;0x00201420&lt;/code&gt;(Little Endian).&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;x16&lt;/code&gt;(Dispatch Target): The primary control register. It holds the&lt;code&gt;sptm_dispatch_target_t&lt;/code&gt;, a 64-bit value encoding the Domain (e.g., XNU, TXM, SK), the Dispatch Table ID, and the Endpoint ID (function index).&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;x0&lt;/code&gt;-&lt;code&gt;x7&lt;/code&gt;(Arguments): The parameters for the call (e.g., physical addresses, permission flags).&lt;code&gt;x0&lt;/code&gt;is often reserved for the thread stack pointer when relaying calls to the TXM.&lt;/item&gt;
      &lt;item&gt;Immediate Value: The 5-bit immediate encoded in the &lt;code&gt;GENTER&lt;/code&gt;instruction itself serves as an entry index, selecting the specific GXF entry stub (recorded in&lt;code&gt;ESR_GLx&lt;/code&gt;).&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The Hardware Transition:&lt;lb/&gt; Upon execution of &lt;code&gt;GENTER&lt;/code&gt;:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;World Switch: The hardware traps to GL2.&lt;/item&gt;
      &lt;item&gt;SPRR Switch: The hardware swaps the active Shadow Permission Remapping Register configuration. The memory regions containing the SPTM code and data—previously invisible to the kernel—become Read/Write/Execute.&lt;/item&gt;
      &lt;item&gt;Stack Switch: The Stack Pointer (&lt;code&gt;SP&lt;/code&gt;) is switched to the&lt;code&gt;SP_GL2&lt;/code&gt;register, pointing to a dedicated secure stack within the SPTM's private memory.&lt;/item&gt;
      &lt;item&gt;PC Jump: Execution jumps to the vector defined in &lt;code&gt;GXF_ENTRY_EL2&lt;/code&gt;(or equivalent GL2 vector base).&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The Return:&lt;lb/&gt; The SPTM returns control to the kernel using &lt;code&gt;GEXIT&lt;/code&gt; (&lt;code&gt;0x00201400&lt;/code&gt;). This restores the EL2 SPRR configuration and the kernel's stack pointer. Crucially, on the return path, the SPTM and TXM scrub their per-thread state and shared buffers before executing &lt;code&gt;GEXIT&lt;/code&gt;, ensuring that sensitive GL-only data is not left in registers or shared pages exposed to the kernel.&lt;/p&gt;
    &lt;head rend="h4"&gt;4.1.2 The Frame Table (FTE): Tracking Physical Reality&lt;/head&gt;
    &lt;p&gt;To enforce security, the SPTM cannot rely on the kernel's data structures (like &lt;code&gt;vm_page_t&lt;/code&gt;), as they are mutable by a compromised kernel. Instead, the SPTM maintains its own "God View" of physical memory called the Frame Table.&lt;/p&gt;
    &lt;p&gt;The Frame Table is a linear array of Frame Table Entries (FTE), located in SPTM-private memory. There is one FTE for every 16KB page of physical RAM (matching the kernel's translation granule).&lt;/p&gt;
    &lt;p&gt;FTE Structure and Domains:&lt;lb/&gt; The FTE tracks the state of every physical page, enforcing strict ownership by SPTM Domains (&lt;code&gt;sptm_domain_t&lt;/code&gt;). While the internal enum values evolve, the conceptual types include:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;XNU_DATA&lt;/code&gt;(XNU Domain): Generic kernel heap/stack.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;XNU_TEXT&lt;/code&gt;(XNU Domain): Immutable kernel code.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;PAGE_TABLE&lt;/code&gt;(SPTM Domain): A page containing translation entries (TTEs).&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;EXCLAVE_DATA&lt;/code&gt;(SK Domain): Memory owned by the Secure World.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;SPTM_PRIVATE&lt;/code&gt;(SPTM Domain): Internal monitor structures.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The Security Invariant:&lt;lb/&gt; The SPTM enforces that a physical page can only be mapped into a virtual address space if the mapping permissions are compatible with the page's Type and Domain. For example, a page marked &lt;code&gt;XNU_DATA&lt;/code&gt; cannot be mapped as Executable. A page marked &lt;code&gt;PAGE_TABLE&lt;/code&gt; cannot be mapped as Writable by the kernel.&lt;/p&gt;
    &lt;head rend="h4"&gt;4.1.3 The Dispatch Table: Reverse Engineering the Selectors&lt;/head&gt;
    &lt;p&gt;The interface between XNU and the SPTM is a strict, register-based API. However, unlike the stable syscall numbers of the BSD layer, the SPTM Dispatch IDs are not guaranteed to remain static across macOS versions. Apple frequently rotates these IDs to frustrate static analysis tools.&lt;/p&gt;
    &lt;p&gt;The ABI:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;x16&lt;/code&gt;: The&lt;code&gt;sptm_dispatch_target_t&lt;/code&gt;(Domain + Table + Endpoint).&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;x0&lt;/code&gt;-&lt;code&gt;x7&lt;/code&gt;: Arguments (Physical Addresses, Permission Bitmasks, ASIDs).&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Heuristic Identification:&lt;lb/&gt; Since relying on static IDs is brittle, reverse engineers must fingerprint the logic of the handler functions within the &lt;code&gt;Ap,SecurePageTableMonitor&lt;/code&gt; binary to identify the primitives.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;sptm_retype(ppn, old_type, new_type)&lt;/code&gt;:&lt;list rend="ul"&gt;&lt;item&gt;Fingerprint: Look for a function that accepts a Physical Page Number (PPN), reads the corresponding Frame Table Entry (FTE), and performs a Sanitization Loop. The SPTM must zero-fill (&lt;code&gt;bzero&lt;/code&gt;) or cache-invalidate the page before transitioning it from&lt;code&gt;XNU_DATA&lt;/code&gt;to&lt;code&gt;PAGE_TABLE&lt;/code&gt;to prevent the kernel from initializing a page table with pre-computed malicious entries.&lt;/item&gt;&lt;item&gt;Logic: &lt;code&gt;assert(refcount == 0); memset(pa, 0, PAGE_SIZE); fte-&amp;gt;type = new_type;&lt;/code&gt;&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;Fingerprint: Look for a function that accepts a Physical Page Number (PPN), reads the corresponding Frame Table Entry (FTE), and performs a Sanitization Loop. The SPTM must zero-fill (&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;sptm_map(asid, va, ppn, perms)&lt;/code&gt;:&lt;list rend="ul"&gt;&lt;item&gt;Fingerprint: Look for a function that walks the translation tables (reading physical memory) and performs a Permission Check against the FTE. It will contain logic that explicitly compares the requested &lt;code&gt;perms&lt;/code&gt;(e.g., Write) against the&lt;code&gt;fte-&amp;gt;type&lt;/code&gt;(e.g.,&lt;code&gt;XNU_TEXT&lt;/code&gt;).&lt;/item&gt;&lt;item&gt;Logic: &lt;code&gt;if (fte-&amp;gt;type == XNU_TEXT &amp;amp;&amp;amp; (perms &amp;amp; WRITE)) panic(); write_tte(...);&lt;/code&gt;&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;Fingerprint: Look for a function that walks the translation tables (reading physical memory) and performs a Permission Check against the FTE. It will contain logic that explicitly compares the requested &lt;/item&gt;
      &lt;item&gt;&lt;code&gt;sptm_unmap(asid, va)&lt;/code&gt;:&lt;list rend="ul"&gt;&lt;item&gt;Fingerprint: Look for the TLB Invalidation sequence. For SPTM-controlled mappings, TLB invalidation is performed inside GL2 as part of the unmap routine. XNU cannot directly update those page tables and must invoke SPTM to perform any changes, including the corresponding TLB maintenance (&lt;code&gt;TLBI ALLE2IS&lt;/code&gt;or similar).&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;Fingerprint: Look for the TLB Invalidation sequence. For SPTM-controlled mappings, TLB invalidation is performed inside GL2 as part of the unmap routine. XNU cannot directly update those page tables and must invoke SPTM to perform any changes, including the corresponding TLB maintenance (&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;sptm_map_iommu(dart_id, context_id, dva, ppn, perms)&lt;/code&gt;:&lt;list rend="ul"&gt;&lt;item&gt;Fingerprint: Look for writes to MMIO regions associated with DART controllers, rather than standard RAM. This function validates that the &lt;code&gt;ppn&lt;/code&gt;is not a protected kernel page before mapping it into a device's IOVA space.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;Fingerprint: Look for writes to MMIO regions associated with DART controllers, rather than standard RAM. This function validates that the &lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;RE Implication:&lt;lb/&gt; Automated analysis scripts should not rely on &lt;code&gt;CMP x15, #0x1&lt;/code&gt;. Instead, they should symbolically execute the &lt;code&gt;GENTER&lt;/code&gt; handler in the SPTM binary, identifying the dispatch table jump via &lt;code&gt;x16&lt;/code&gt;, and then classify the target functions based on the presence of &lt;code&gt;DC ZVA&lt;/code&gt; (cache zero), &lt;code&gt;TLBI&lt;/code&gt;, or FTE array access patterns.&lt;/p&gt;
    &lt;head rend="h4"&gt;4.1.4 RE Focus: Analyzing Panic Strings and the State Machine&lt;/head&gt;
    &lt;p&gt;The SPTM is designed to be Fail-Secure. Unlike standard kernel APIs that return &lt;code&gt;KERN_FAILURE&lt;/code&gt;, the SPTM treats invalid requests as evidence of kernel compromise.&lt;/p&gt;
    &lt;p&gt;The Panic Mechanism:&lt;lb/&gt; If XNU sends a malformed request (e.g., trying to retype a page that is still mapped), the SPTM returns a fatal error code. XNU, upon receiving this error, triggers a system-wide panic.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Panic String: &lt;code&gt;"received fatal error for a selector from TXM"&lt;/code&gt;or&lt;code&gt;"invalid state transition"&lt;/code&gt;.&lt;/item&gt;
      &lt;item&gt;Analysis: These strings are gold for reverse engineers. They confirm that the SPTM enforces a strict Finite State Machine (FSM) for memory pages.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Mapping the State Machine:&lt;lb/&gt; By analyzing the panic logic and the allowed transition bitmaps, we can deduce the allowed transitions:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;&lt;code&gt;FREE&lt;/code&gt;→&lt;code&gt;XNU_DATA&lt;/code&gt;(Allocation)&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;XNU_DATA&lt;/code&gt;→&lt;code&gt;PAGE_TABLE&lt;/code&gt;(Retype for MMU use - requires sanitization)&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;PAGE_TABLE&lt;/code&gt;→&lt;code&gt;XNU_DATA&lt;/code&gt;(Teardown - requires unmapping all entries)&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;XNU_DATA&lt;/code&gt;→&lt;code&gt;XNU_TEXT&lt;/code&gt;(KEXT loading - One-way transition!)&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Any attempt to deviate from this graph (e.g., trying to turn &lt;code&gt;PAGE_TABLE&lt;/code&gt; directly into &lt;code&gt;XNU_TEXT&lt;/code&gt;) results in an immediate halt. This prevents "Page Table Spraying" and other heap manipulation techniques used to gain kernel execution.&lt;/p&gt;
    &lt;head rend="h3"&gt;4.2 The Trusted Execution Monitor (TXM) – GL0&lt;/head&gt;
    &lt;p&gt;If the SPTM is the brawn—enforcing the physics of memory mapping—the Trusted Execution Monitor (TXM) is the brains. Operating as a privileged Conclave at Guarded Level 0 (GL0), the TXM is the supreme arbiter of system policy. It represents the architectural decoupling of “mechanism” from “policy.” While the SPTM handles how a page is mapped, the TXM decides if it is allowed to be mapped executable under a given policy.&lt;/p&gt;
    &lt;head rend="h4"&gt;4.2.1 Decoupling AMFI: Moving Core Code-Signature Verification&lt;/head&gt;
    &lt;p&gt;Historically, the Apple Mobile File Integrity (AMFI) kernel extension was the primary enforcement point for code signing. While AMFI still exists to handle complex userland policy checks, in the Tahoe architecture the core cryptographic verification logic for platform and protected code has been lifted out of the kernel and placed into the TXM. TXM’s primary currency of trust is the Code Directory Hash (CDHash).&lt;/p&gt;
    &lt;p&gt;The Verification Flow (conceptual):&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;&lt;p&gt;Load &amp;amp; Hash: The kernel (XNU) loads a binary into memory (typed as&lt;/p&gt;&lt;code&gt;XNU_DATA&lt;/code&gt;). It parses the&lt;code&gt;LC_CODE_SIGNATURE&lt;/code&gt;load command and calculates the CDHash (typically SHA-256 over the Code Directory).&lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;The Query: XNU issues a call into the Secure World. The Secure Kernel (GL1) routes this to the TXM (GL0). The kernel passes the CDHash and the physical address range that will back the executable mapping.&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Trust Cache Lookup: The TXM consults its internal Trust Caches:&lt;/p&gt;
        &lt;list rend="ul"&gt;
          &lt;item&gt;Static Trust Cache: CDHashes for immutable OS binaries (kernel collections, dyld shared cache, system daemons shipped in Cryptexes).&lt;/item&gt;
          &lt;item&gt;Loadable / Dynamic Trust Caches: CDHashes for binaries that have been verified previously (third-party apps, JIT regions, auxiliary trust caches).&lt;/item&gt;
        &lt;/list&gt;
      &lt;/item&gt;
      &lt;item&gt;&lt;p&gt;Cold Validation: On a cache miss, the system enters a “cold path”. The kernel, often assisted by&lt;/p&gt;&lt;code&gt;amfid&lt;/code&gt;and&lt;code&gt;syspolicyd&lt;/code&gt;, provides the CMS signature blob and certificate chain for the image. TXM performs the cryptographic verification against the relevant Apple root (or Developer ID root) inside the guarded world. On success, the CDHash is inserted into an appropriate trust cache.&lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Blessing: Once the CDHash is validated according to platform policy, TXM updates its internal state so that the specific physical pages associated with that CDHash are marked as “permitted for execution” when requested with appropriate permissions.&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;&lt;p&gt;Enforcement via SPTM: When XNU later asks the SPTM to map those pages as Executable (&lt;/p&gt;&lt;code&gt;RX&lt;/code&gt;), the SPTM consults TXM (or the trust-cache state driven by TXM). If the pages are not in a state that policy allows to become executable, the SPTM denies the Execute permission, even if EL2 code tries to set it in the PTE.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Platform distinction (iOS-class vs macOS):&lt;/p&gt;
    &lt;p&gt;The exact policy enforced by TXM/SPTM is platform-dependent:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;
        &lt;p&gt;On iOS / iPadOS / watchOS / visionOS, TXM + SPTM implement a hard invariant: only code that is both correctly signed and policy-approved is allowed to become executable. AMFI’s view of “signed or not” is no longer sufficient on its own; the SPTM must agree.&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;On macOS, the platform is explicitly designed to allow arbitrary and ad-hoc user code to run. In that environment:&lt;/p&gt;
        &lt;list rend="ul"&gt;
          &lt;item&gt;TXM still verifies and tracks platform binaries (kernel collections, system frameworks, hardened system daemons) and other code that participates in the system integrity story (e.g. components running with special entitlements or under hardened runtime).&lt;/item&gt;
          &lt;item&gt;SPTM still mediates executable mappings and protects the integrity of page tables and immutable kernel/monitor regions.&lt;/item&gt;
          &lt;item&gt;However, the global “no unsigned code ever executes” property is not applied to general userland on macOS. The set of mappings that SPTM/TXM treat as “must be verified” is narrower and aligned with Apple’s documented policy distinction between macOS and fully locked-down platforms.&lt;/item&gt;
        &lt;/list&gt;
      &lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;RE Implication:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;
        &lt;p&gt;On iOS-class platforms, patching the kernel to ignore AMFI errors is no longer a sufficient route to arbitrary unsigned code execution: the SPTM/TXM stack must still bless the mapping. Attempts to create executable mappings for code that TXM has not accepted will fail at the SPTM boundary.&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;On macOS, a kernel compromise can still influence which user binaries run (for example, by weakening or bypassing Gatekeeper and AMFI checks for user processes), and ad-hoc binaries remain architecturally admissible. The SPTM/TXM stack primarily constrains:&lt;/p&gt;
        &lt;list rend="ul"&gt;
          &lt;item&gt;the integrity of page tables and KIP/KTRR-like regions,&lt;/item&gt;
          &lt;item&gt;the mappings of kernel collections and other protected code, and&lt;/item&gt;
          &lt;item&gt;the ability of a compromised kernel to subvert those invariants.&lt;/item&gt;
        &lt;/list&gt;
      &lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;In all cases, SPTM continues to arbitrate frame typing and protected mappings above EL2. TXM’s policy decisions define which code is eligible for protection and execution under a given mode; SPTM enforces the resulting invariants in the page-table and DART hardware.&lt;/p&gt;
    &lt;head rend="h4"&gt;4.2.2 The Trust Cache: Static vs. Loadable&lt;/head&gt;
    &lt;p&gt;To avoid the performance penalty of cryptographic verification on every page fault, the TXM manages the Trust Cache—a database of known-good CDHashes.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;p&gt;The Static Trust Cache:&lt;/p&gt;&lt;lb/&gt;This is loaded by iBoot and passed to the TXM during the Secure World initialization. It contains the hashes of every binary in the OS (now encapsulated in the immutable Cryptexes). This cache resides in Secure World memory and is strictly Read-Only.&lt;/item&gt;
      &lt;item&gt;&lt;p&gt;Loadable Trust Caches:&lt;/p&gt;&lt;lb/&gt;These handle third-party applications, JIT regions, and auxiliary updates. When a user launches an app, the TXM verifies the signature once and adds the CDHash to a loadable cache.&lt;list rend="ul"&gt;&lt;item&gt;Query Interface: The kernel queries the Trust Cache via a specific &lt;code&gt;GENTER&lt;/code&gt;selector.&lt;/item&gt;&lt;item&gt;Attack Surface: These caches are mutable structures managed by the TXM. A logic bug in the TXM's management of this cache (e.g., a race condition during entry removal or a hash collision attack) is a high-value target for persistence.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;Query Interface: The kernel queries the Trust Cache via a specific &lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h4"&gt;4.2.3 Developer Mode Enforcement and Downgrade Protection&lt;/head&gt;
    &lt;p&gt;The TXM is also the guardian of the device's security posture, specifically Developer Mode.&lt;/p&gt;
    &lt;p&gt;In previous iterations, enabling debugging capabilities was often a matter of setting &lt;code&gt;nvram&lt;/code&gt; variables or &lt;code&gt;boot-args&lt;/code&gt; (like &lt;code&gt;cs_enforcement_disable=1&lt;/code&gt;). In Tahoe, these states are managed by the TXM.&lt;/p&gt;
    &lt;p&gt;The State Transition:&lt;lb/&gt; Enabling Developer Mode requires a reboot and explicit user authorization (Secure Intent via physical buttons). The TXM persists this state (likely via the Secure Enclave's secure storage).&lt;/p&gt;
    &lt;p&gt;Downgrade Protection:&lt;lb/&gt; The TXM enforces that the system cannot transition from a "Production" state to a "Developer" state without a full reboot and authentication ceremony. This prevents a kernel-level attacker from dynamically relaxing security policies to load unsigned modules.&lt;/p&gt;
    &lt;p&gt;Furthermore, the LocalPolicy (signed by the SEP) encodes whether the system is in Full, Reduced, or Permissive Security. Early-boot components (LLB/iBoot) will refuse to start macOS without a valid LocalPolicy, preventing silent downgrades of security policy. At runtime, the TXM consults this configuration when deciding which code-signing and trust-cache policies to enforce.&lt;/p&gt;
    &lt;head rend="h2"&gt;5.0 XNU Kernel Initialization: Entering EL2&lt;/head&gt;
    &lt;p&gt;The handoff from iBoot to the XNU kernel marks the transition from a single-threaded bootloader to a symmetric multiprocessing (SMP) operating system. However, in the Tahoe architecture, this is no longer a handover of absolute power. On modern macOS configurations (where XNU typically executes at Exception Level 2 (EL2) using Virtualization Host Extensions), the kernel enters not as a master, but as a client of the Guarded Level 2 (GL2) monitor.&lt;/p&gt;
    &lt;p&gt;The entry point is defined in &lt;code&gt;osfmk/arm64/start.s&lt;/code&gt;. At this precise moment, the system state is fragile: the MMU is operating under a minimal bootstrap mapping provided by iBoot (or disabled entirely depending on the specific SoC generation), interrupts are masked (&lt;code&gt;DAIF&lt;/code&gt; bits set), and the stack pointer is essentially arbitrary. The kernel's first objective is to orient itself within physical memory, calculate the KASLR slide, and establish the virtual memory structures required to turn on the lights.&lt;/p&gt;
    &lt;head rend="h3"&gt;5.1 The &lt;code&gt;start&lt;/code&gt; routine and KASLR&lt;/head&gt;
    &lt;p&gt;The &lt;code&gt;_start&lt;/code&gt; symbol is the architectural entry point. Unlike x86_64, where the kernel might handle its own decompression and relocation, the Apple Silicon kernel is loaded as a raw Mach-O executable (within the &lt;code&gt;kernelcache&lt;/code&gt; container) directly into physical memory by iBoot.&lt;/p&gt;
    &lt;p&gt;The Register State at Entry:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;CurrentEL&lt;/code&gt;: Indicates EL2 (on standard macOS Tahoe configurations).&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;x0&lt;/code&gt;: Physical address of the&lt;code&gt;boot_args&lt;/code&gt;structure (version 2).&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;x1&lt;/code&gt;: Physical address of the Device Tree base (if not inside&lt;code&gt;boot_args&lt;/code&gt;).&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;x2&lt;/code&gt;: 0 (Reserved/Empirically observed).&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;x3&lt;/code&gt;: 0 (Reserved/Empirically observed).&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;sp&lt;/code&gt;: Invalid/Temporary.&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h4"&gt;5.1.1 Deriving the Kernel Slide: The Decoupled Address Space&lt;/head&gt;
    &lt;p&gt;Kernel Address Space Layout Randomization (KASLR) on Apple Silicon is a cooperative effort between iBoot and XNU. iBoot generates a high-entropy value from the TRNG, populates the &lt;code&gt;/chosen/kaslr-seed&lt;/code&gt; property in the Device Tree, and physically relocates the kernel text in DRAM to match this slide.&lt;/p&gt;
    &lt;p&gt;The &lt;code&gt;boot_args&lt;/code&gt; Structure:&lt;lb/&gt; Upon entry at &lt;code&gt;_start&lt;/code&gt;, the kernel immediately parses the &lt;code&gt;boot_args&lt;/code&gt; structure pointed to by &lt;code&gt;x0&lt;/code&gt;. This structure acts as the handover manifest, containing:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;virtBase&lt;/code&gt;: The runtime virtual base address where the kernel is mapped (i.e., the static base plus the slide).&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;physBase&lt;/code&gt;: The actual physical load address in DRAM.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The Slide Calculation:&lt;lb/&gt; The kernel calculates its own slide by comparing the runtime virtual base provided by iBoot against its compile-time static base:&lt;/p&gt;
    &lt;p&gt;$$ \texttt{vm\_kernel\_slide} = \texttt{boot\_args.virtBase} - \texttt{STATIC\_KERNEL\_BASE} $$&lt;/p&gt;
    &lt;p&gt;The Tahoe Constraint: Address Space Decoupling:&lt;lb/&gt; In the Tahoe architecture, the system operates under a paradigm of Address Space Decoupling. The SPTM (GL2) and the Kernel (EL2) reside in the same physical DRAM but operate in distinct translation regimes.&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Kernel View: The kernel runs under &lt;code&gt;TTBR1_EL2&lt;/code&gt;(or&lt;code&gt;TTBR1_EL1&lt;/code&gt;with VHE), with a virtual layout randomized by&lt;code&gt;kaslr-seed&lt;/code&gt;.&lt;/item&gt;
      &lt;item&gt;SPTM View: The SPTM runs under the GL2 translation regime with its own independent set of translation table base registers.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Security Implication:&lt;lb/&gt; This separation is critical. A kernel-level memory leak (e.g., an &lt;code&gt;infoleak&lt;/code&gt; revealing a kernel pointer) allows an attacker to calculate &lt;code&gt;vm_kernel_slide&lt;/code&gt;. In previous architectures, if the monitor (PPL) was mapped at a fixed offset relative to the kernel, a kernel leak would instantly reveal the monitor's location.&lt;/p&gt;
    &lt;p&gt;In Tahoe, knowing &lt;code&gt;vm_kernel_slide&lt;/code&gt; yields zero information about the virtual address of the SPTM. The SPTM's virtual mapping is established by iBoot in the GL2 context before the kernel executes. While the kernel is aware of the SPTM's physical pages (marked as "Reserved" in the memory map), it is architecturally blind to the SPTM's virtual location.&lt;/p&gt;
    &lt;p&gt;RE Focus: Finding the Slide:&lt;lb/&gt; For a reverse engineer with a kernel panic log or a JTAG connection, identifying these slides requires inspecting distinct registers:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Kernel Slide: Inspect &lt;code&gt;TTBR1_EL2&lt;/code&gt;(or&lt;code&gt;TTBR1_EL1&lt;/code&gt;if VHE is active). The translation table base points to the physical location of the kernel's L1 table. The high bits of the PC (Program Counter) at the exception vector reveal the virtual slide.&lt;/item&gt;
      &lt;item&gt;SPTM Slide: This is invisible from EL2. To find it, one must inspect the GL2-specific TTBRs via JTAG while the core is halted in the GL2 context.&lt;/item&gt;
      &lt;item&gt;Static Analysis: The &lt;code&gt;vm_kernel_slide&lt;/code&gt;global variable in XNU is one of the first initialized. In a raw memory dump, locating the&lt;code&gt;boot_args&lt;/code&gt;struct (often at the start of a physical page aligned to 16KB) will reveal the&lt;code&gt;virtBase&lt;/code&gt;directly.&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h4"&gt;5.1.2 Initializing the MMU: &lt;code&gt;TCR_EL2&lt;/code&gt; and the SPTM Handshake&lt;/head&gt;
    &lt;p&gt;Before the kernel can execute C code safely, it must enable the Memory Management Unit (MMU). On standard ARMv8, this involves populating translation tables and writing to &lt;code&gt;TTBR0&lt;/code&gt; and &lt;code&gt;TTBR1&lt;/code&gt;, then setting &lt;code&gt;SCTLR.M&lt;/code&gt;.&lt;/p&gt;
    &lt;p&gt;On Tahoe, this process is fundamentally altered because the kernel cannot write to its own page tables.&lt;/p&gt;
    &lt;p&gt;The Bootstrap Problem:&lt;lb/&gt; How does the kernel build its initial page tables if it requires the SPTM to map pages, but the SPTM requires the kernel to make hypercalls?&lt;/p&gt;
    &lt;p&gt;The Solution: The Bootstrap Tables:&lt;lb/&gt; iBoot installs a minimal set of Bootstrap Page Tables before handing off control. These tables typically contain identity mappings for the PC and stack, allowing the kernel to execute the initialization code required to bring up the SPTM interface.&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;TCR_EL2 Setup: The kernel configures the Translation Control Register (&lt;code&gt;TCR_EL2&lt;/code&gt;).&lt;list rend="ul"&gt;&lt;item&gt;&lt;code&gt;T1SZ&lt;/code&gt;/&lt;code&gt;T0SZ&lt;/code&gt;: Defines the size of the virtual address space (typically 48-bit on macOS).&lt;/item&gt;&lt;item&gt;&lt;code&gt;TG1&lt;/code&gt;: Granule size (16KB is standard for Apple Silicon).&lt;/item&gt;&lt;item&gt;&lt;code&gt;IPS&lt;/code&gt;: Intermediate Physical Address Size (matches the SoC capability, e.g., 40 bits).&lt;/item&gt;&lt;item&gt;&lt;code&gt;TBI&lt;/code&gt;(Top Byte Ignore): Typically configured to allow the top byte (bits 63-56) to carry metadata (such as PAC signatures or tags) without affecting address translation.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The SPTM Handshake (The First &lt;code&gt;GENTER&lt;/code&gt;):&lt;lb/&gt; Once &lt;code&gt;TCR_EL2&lt;/code&gt; is configured, the kernel must transition from the iBoot-provided bootstrap tables to its own managed tables.&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Allocation: The kernel allocates physical pages for the new L1/L2/L3 translation tables from the &lt;code&gt;XNU_DATA&lt;/code&gt;pool.&lt;/item&gt;
      &lt;item&gt;Sanitization: The kernel zeroes these pages.&lt;/item&gt;
      &lt;item&gt;Retype: The kernel executes &lt;code&gt;GENTER&lt;/code&gt;(Selector&lt;code&gt;0x01&lt;/code&gt;-&lt;code&gt;sptm_retype&lt;/code&gt;) to convert these pages from&lt;code&gt;XNU_DATA&lt;/code&gt;to&lt;code&gt;PAGE_TABLE&lt;/code&gt;.&lt;/item&gt;
      &lt;item&gt;Mapping: The kernel executes &lt;code&gt;GENTER&lt;/code&gt;(Selector&lt;code&gt;0x02&lt;/code&gt;-&lt;code&gt;sptm_map&lt;/code&gt;) to populate the entries, replicating the kernel text and static data mappings.&lt;/item&gt;
      &lt;item&gt;Activation: Finally, the kernel programs the appropriate &lt;code&gt;TTBR1&lt;/code&gt;(EL1 or EL2 depending on configuration) to point to the new L1 table. The SPTM constrains the actual effect via SPRR/GXF.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The &lt;code&gt;SCTLR_EL2&lt;/code&gt; Lockdown:&lt;lb/&gt; The final step of &lt;code&gt;start&lt;/code&gt; is writing to the System Control Register (&lt;code&gt;SCTLR_EL2&lt;/code&gt;).&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;M&lt;/code&gt;(MMU Enable): Set to 1.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;C&lt;/code&gt;(Cache Enable): Set to 1.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;WXN&lt;/code&gt;(Write-XOR-Execute): Set to 1.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;In Tahoe, writes to &lt;code&gt;SCTLR_EL2&lt;/code&gt; are mediated by GL2/SPTM (via GXF’s control over system registers). GL2 enforces that configurations keep &lt;code&gt;WXN&lt;/code&gt; set, preventing EL2 from creating writable-executable mappings even if compromised. If the kernel attempts to disable &lt;code&gt;WXN&lt;/code&gt;, the SPTM rejects the configuration and panics the device.&lt;/p&gt;
    &lt;p&gt;Once the MMU is active and the kernel is running on its own page tables (managed by SPTM), the &lt;code&gt;start&lt;/code&gt; routine branches to &lt;code&gt;arm_init&lt;/code&gt;, beginning the high-level initialization of the BSD subsystem and IOKit.&lt;/p&gt;
    &lt;head rend="h3"&gt;5.2 Hardware Security Enforcements (The "Kill Switch" Registers)&lt;/head&gt;
    &lt;p&gt;As the kernel initialization sequence progresses through &lt;code&gt;start&lt;/code&gt;, it reaches a critical inflection point. The memory management structures are initialized, and the kernel is about to transition from a setup phase to a runtime phase. To prevent a compromised runtime kernel from modifying its own logic, the initialization routine must engage the hardware "Kill Switches."&lt;/p&gt;
    &lt;p&gt;In the Tahoe architecture, this protection is layered: KTRR provides the physical baseline, KIP defines the boot-time immutable regions, and the SPTM virtualizes and extends these concepts to enforce dynamic immutability.&lt;/p&gt;
    &lt;head rend="h4"&gt;5.2.1 KTRR (Kernel Text Read-Only Region): The Physical Lock&lt;/head&gt;
    &lt;p&gt;Kernel Text Read-Only Region (KTRR) is Apple’s hardware solution to the "W^X" (Write XOR Execute) problem at the physical memory controller level. While the MMU (via page tables) controls virtual access permissions, page tables are mutable data structures. KTRR enforces read-only permissions for a physical range corresponding to kernel text, below the level of page tables. Even if an attacker can mutate PTEs, writes into the KTRR physical region are blocked or faulted.&lt;/p&gt;
    &lt;p&gt;The Register Interface:&lt;lb/&gt; KTRR is controlled via a set of proprietary system registers, typically accessible via &lt;code&gt;MSR&lt;/code&gt; instructions.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;KTRR_LOWER_EL1&lt;/code&gt;(&lt;code&gt;S3_4_c15_c2_3&lt;/code&gt;): Defines the physical start address of the protected range.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;KTRR_UPPER_EL1&lt;/code&gt;(&lt;code&gt;S3_4_c15_c2_4&lt;/code&gt;): Defines the physical end address.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;KTRR_LOCK_EL1&lt;/code&gt;(&lt;code&gt;S3_4_c15_c2_2&lt;/code&gt;): The kill switch. Writing&lt;code&gt;1&lt;/code&gt;to the lock bit enables the protection.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The Tahoe Evolution (Virtualization of KTRR):&lt;lb/&gt; On M3/M4 chips running the SPTM, the kernel's interaction with KTRR changes. It is highly probable that the SPTM virtualizes these registers using GXF traps. When XNU executes the legacy instructions to write to &lt;code&gt;KTRR_LOWER/UPPER&lt;/code&gt; in &lt;code&gt;start&lt;/code&gt;, the hardware traps these accesses to GL2. The SPTM validates that the kernel is attempting to cover the correct physical range and enforces its own policy, effectively mocking the success of the operation to the kernel while ensuring the hardware is locked down.&lt;/p&gt;
    &lt;quote&gt;&lt;p&gt;RE Focus: The KTRR Slide Alignment&lt;/p&gt;&lt;lb/&gt;Because KTRR operates on physical ranges with large granularity (e.g., 1MB or L2 cache line boundaries), the KASLR slide is forced to align to this granularity. If you are brute-forcing the KASLR slide, knowing the KTRR alignment constraint significantly reduces the entropy search space.&lt;/quote&gt;
    &lt;head rend="h4"&gt;5.2.2 Kernel Integrity Protection (KIP) and SPTM Sealing&lt;/head&gt;
    &lt;p&gt;KTRR protects the static kernel binary (&lt;code&gt;kernelcache&lt;/code&gt;). However, modern macOS relies heavily on the Boot Kernel Collection (BKC) and Auxiliary Kernel Collection (AKC)—large caches of drivers and extensions loaded during boot.&lt;/p&gt;
    &lt;p&gt;Hardware KIP:&lt;lb/&gt; Apple documentation refers to Kernel Integrity Protection (KIP) as a hardware feature where the memory controller defines a protected region into which iBoot loads the kernel and kernel extensions, then denies writes after boot. This serves as the static anchor for the BKC.&lt;/p&gt;
    &lt;p&gt;SPTM Dynamic Sealing (&lt;code&gt;XNU_TEXT&lt;/code&gt;):&lt;lb/&gt; The SPTM generalizes this concept to support dynamic loading. Unlike static KTRR/KIP regions, the SPTM maintains a Frame Table where pages can be typed.&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Registration: During &lt;code&gt;start&lt;/code&gt;, the kernel links and relocates extensions.&lt;/item&gt;
      &lt;item&gt;Sealing: The kernel issues a &lt;code&gt;GENTER&lt;/code&gt;call (Selector&lt;code&gt;sptm_retype&lt;/code&gt;or&lt;code&gt;sptm_protect&lt;/code&gt;) to "seal" the region.&lt;/item&gt;
      &lt;item&gt;Retyping: The SPTM updates the Frame Table Entries (FTE) for the physical pages backing the drivers, transitioning them from &lt;code&gt;XNU_DATA&lt;/code&gt;(Writable) to&lt;code&gt;XNU_TEXT&lt;/code&gt;(Executable/Read-Only).&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The "One-Way" Door:&lt;lb/&gt; The security invariant enforced here is that memory typed as &lt;code&gt;XNU_TEXT&lt;/code&gt; is never writable by EL2. If the kernel attempts to write to a sealed page, the SPRR configuration for EL2 triggers a permission fault. This effectively turns the kernel extensions into ROM, mitigating rootkits that historically operated by patching IOKit vtables in memory.&lt;/p&gt;
    &lt;head rend="h4"&gt;5.2.3 The System Control Register (&lt;code&gt;SCTLR_EL2&lt;/code&gt;) Lockdown&lt;/head&gt;
    &lt;p&gt;The final "Kill Switch" is the configuration of the ARM processor itself. The &lt;code&gt;SCTLR_EL2&lt;/code&gt; register controls the MMU, caches, and alignment checks.&lt;/p&gt;
    &lt;p&gt;Critical Bits:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;WXN&lt;/code&gt;(Write-XOR-Execute): Bit 19. When set, any memory region mapped as Writable is implicitly treated as Non-Executable (&lt;code&gt;XN&lt;/code&gt;).&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;M&lt;/code&gt;(MMU Enable): Bit 0.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The Trap-and-Emulate Policy:&lt;lb/&gt; In a standard ARM system, EL2 can modify &lt;code&gt;SCTLR_EL2&lt;/code&gt; at will. In the Tahoe architecture, writes to &lt;code&gt;SCTLR_EL2&lt;/code&gt; are mediated by GL2/SPTM via GXF’s control over system registers. The effective policy under normal operation is that &lt;code&gt;WXN&lt;/code&gt; remains set: GL2/SPTM will not accept configurations that clear &lt;code&gt;WXN&lt;/code&gt; to create writable–executable regions. If the kernel attempts to program &lt;code&gt;SCTLR_EL2&lt;/code&gt; with &lt;code&gt;WXN&lt;/code&gt; cleared, the requested configuration is rejected by the monitor and, in current implementations, this manifests as a system panic rather than a silent relaxation of protections. This ensures that the fundamental security properties of the execution environment (in particular W^X) cannot be disabled, even by a compromised kernel.&lt;/p&gt;
    &lt;head rend="h3"&gt;5.3 Exclaves: The Microkernel within the Monolith&lt;/head&gt;
    &lt;p&gt;The introduction of Exclaves in the Tahoe architecture represents the most profound structural change to the Apple OS ecosystem since the transition from Mac OS 9 to OS X. It is an admission that the monolithic kernel architecture (XNU) has become too large, too complex, and too mutable to serve as the ultimate Trusted Computing Base (TCB) for high-value assets.&lt;/p&gt;
    &lt;p&gt;Exclaves introduce a Microkernel architecture running side-by-side with the monolithic XNU kernel on the same Application Processor cores. Unlike the Secure Enclave (which is a separate coprocessor), Exclaves harness the full performance of the M-series cores while maintaining cryptographic isolation enforced by the SPTM.&lt;/p&gt;
    &lt;head rend="h4"&gt;5.3.1 The L4 Influence: Domains, Conclaves, and IPC&lt;/head&gt;
    &lt;p&gt;The architecture of the Exclave system is heavily indebted to the L4 microkernel family. It prioritizes minimalism, capability-based security, and strict isolation.&lt;/p&gt;
    &lt;p&gt;The Hierarchy of Isolation:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;The Secure Kernel (&lt;code&gt;ExclaveOS&lt;/code&gt;): A tiny, formally verifiable kernel that manages scheduling and IPC within the secure world. It runs at GL1.&lt;/item&gt;
      &lt;item&gt;Domains: The highest level of separation. The "Insecure Domain" hosts XNU and userland (EL2/EL0). The "Secure Domain" hosts Exclave workloads.&lt;/item&gt;
      &lt;item&gt;Conclaves: Within the Secure Domain (GL0), workloads are siloed into Conclaves. A Conclave is a lightweight container consisting of an address space, a set of capabilities (handles to resources), and threads.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Memory Management via SPTM:&lt;lb/&gt; The isolation is enforced by the SPTM's Frame Table. Physical pages assigned to an Exclave are typed in the FTE (likely as &lt;code&gt;EXCLAVE_DATA&lt;/code&gt; or &lt;code&gt;SK_DATA&lt;/code&gt;). The kernel sees these physical pages as "reserved" in the device tree. Any attempt by XNU to map these pages via &lt;code&gt;sptm_map&lt;/code&gt; will result in a panic, as the SPTM forbids mapping Exclave-owned pages into the &lt;code&gt;XNU_DOMAIN&lt;/code&gt;.&lt;/p&gt;
    &lt;head rend="h4"&gt;5.3.2 RE Focus: The &lt;code&gt;RingGate&lt;/code&gt; Mechanism and &lt;code&gt;XNUProxy&lt;/code&gt;&lt;/head&gt;
    &lt;p&gt;For the reverse engineer, the critical question is: How does the Kernel talk to an Exclave? They share no virtual memory, run in different hardware contexts, and the SPTM actively prevents XNU from mapping Exclave physical pages. The bridge is a mechanism internally referred to by researchers as RingGate, facilitated by a component named &lt;code&gt;XNUProxy&lt;/code&gt;.&lt;/p&gt;
    &lt;p&gt;The Communication Stack:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;&lt;p&gt;Tightbeam (The IDL):&lt;/p&gt;&lt;lb/&gt;Apple has introduced a new Interface Definition Language (IDL) called Tightbeam. It replaces the legacy Mach Interface Generator (MIG) for secure world communication. Tightbeam is strongly typed and buffer-centric.&lt;list rend="ul"&gt;&lt;item&gt;Userland Analysis: The serialization logic is visible in &lt;code&gt;/usr/lib/libTightbeam.dylib&lt;/code&gt;.&lt;/item&gt;&lt;item&gt;Kernel Analysis: &lt;code&gt;XNUProxy&lt;/code&gt;appears both as an XNU-side component and as related services in the secure world, bridging Mach ports to Exclave endpoints.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;Userland Analysis: The serialization logic is visible in &lt;/item&gt;
      &lt;item&gt;&lt;p&gt;The Downcall (XNU → Exclave):&lt;/p&gt;&lt;lb/&gt;When XNU needs a service, it cannot call the function directly.&lt;list rend="ul"&gt;&lt;item&gt;Marshaling: &lt;code&gt;XNUProxy&lt;/code&gt;serializes the request using Tightbeam into a shared memory ring buffer.&lt;/item&gt;&lt;item&gt;The Gate: The kernel executes a specific instruction to trigger the world switch. This is a &lt;code&gt;GENTER&lt;/code&gt;instruction targeting a specific Dispatch ID reserved for the Secure Kernel.&lt;/item&gt;&lt;item&gt;Context Switch: The hardware (mediated by SPTM) saves the EL2 state, switches the SPRR configuration to the Exclave view, and jumps to the &lt;code&gt;ExclaveOS&lt;/code&gt;entry point (GL1).&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;Marshaling: &lt;/item&gt;
      &lt;item&gt;&lt;p&gt;The Upcall (Exclave → XNU):&lt;/p&gt;&lt;lb/&gt;Exclaves rely on XNU for file system I/O or networking.&lt;list rend="ul"&gt;&lt;item&gt;The Exclave writes a request to the outbound ring buffer.&lt;/item&gt;&lt;item&gt;It triggers an interrupt or executes a &lt;code&gt;GEXIT&lt;/code&gt;yield.&lt;/item&gt;&lt;item&gt;&lt;code&gt;XNUProxy&lt;/code&gt;receives the notification, reads the request, performs the operation via standard VFS calls, and returns the result via a Downcall.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Memory Loaning (The "DART" Window):&lt;lb/&gt; While control messages go through ring buffers, large data transfers occur via Memory Loaning. &lt;code&gt;XNUProxy&lt;/code&gt; pins a userland page and passes its physical address to the Exclave via Tightbeam. The Exclave requests the SPTM to map this specific PPN into its address space. This "Loaned Memory" mechanism is a prime target for TOCTOU (Time-of-Check to Time-of-Use) attacks, as the ownership transitions are complex and mediated by the SPTM state machine.&lt;/p&gt;
    &lt;head rend="h4"&gt;5.3.3 Use Case: Secure Control of Privacy Indicators and Passkeys&lt;/head&gt;
    &lt;p&gt;The "Killer App" for Exclaves in macOS Tahoe is the hardware-enforced privacy indicator (the green/orange dots).&lt;/p&gt;
    &lt;p&gt;Reverse engineering of current macOS Tahoe builds strongly suggests that these indicators are implemented using an Exclave-controlled overlay path along the following lines:&lt;/p&gt;
    &lt;p&gt;The Tahoe Solution:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Hardware Ownership: The physical framebuffer region corresponding to the status bar indicators is, in current implementations, not mapped in the XNU domain. It appears to be owned exclusively by a specific Privacy Conclave (GL0), so that only secure-world code can directly address the pixels used for the indicators.&lt;/item&gt;
      &lt;item&gt;The DART Lock: The Display Coprocessor's IOMMU (DART) is configured under SPTM control such that the main display pipe used by XNU and WindowServer cannot write to the indicator pixels. Only a secure overlay pipe, controlled by the Exclave domain, is allowed to source scanout data for that region.&lt;/item&gt;
      &lt;item&gt;Immutability: Under this design, XNU cannot map the physical memory backing the secure overlay, and it cannot reconfigure the relevant DART contexts without going through SPTM policy. As a result, a compromised kernel is effectively unable to erase or suppress the indicator once the secure pipeline has decided it should be visible.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Passkeys and FIDO:&lt;lb/&gt; Similarly, passkey operations are increasingly implemented inside Exclave-backed services.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Key Isolation: The key material for Passkeys is generated and stored in hardware-isolated domains (SEP plus, on newer platforms, Exclave-backed services), with XNU only ever handling opaque identifiers or tokens rather than raw private keys.&lt;/item&gt;
      &lt;item&gt;Isolation: Even if malware injects code into the &lt;code&gt;LocalAuthentication&lt;/code&gt;daemon or the kernel, it cannot extract the private key material, because it resides in a memory domain that the Normal World cannot directly address.&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h2"&gt;6.0 The Mach Subsystem: The Nervous System&lt;/head&gt;
    &lt;p&gt;While the SPTM and Exclaves represent the new fortress walls of the Apple Silicon architecture, the Mach subsystem remains the internal nervous system that coordinates activity within the XNU kernel. Originating from the NeXTSTEP era, Mach provides the fundamental primitives for Inter-Process Communication (IPC), thread scheduling, and virtual memory management.&lt;/p&gt;
    &lt;p&gt;For the reverse engineer, Mach is the primary vector for local privilege escalation (LPE). Despite decades of hardening, the complexity of state management in Mach messaging remains a fertile ground for logic bugs, race conditions, and reference counting errors. In the Tahoe era, Mach has been retrofitted with heavy PAC enforcement to protect its object graph.&lt;/p&gt;
    &lt;head rend="h3"&gt;6.1 Mach Ports &amp;amp; IPC Primitives&lt;/head&gt;
    &lt;p&gt;At the conceptual level, Mach is an object-oriented kernel. The fundamental unit of addressing is the Mach Port. To a userland process, a port is merely a 32-bit integer handle (&lt;code&gt;mach_port_name_t&lt;/code&gt;). To the kernel, it is a complex, reference-counted data structure (&lt;code&gt;ipc_port&lt;/code&gt;) that acts as a unidirectional communication channel.&lt;/p&gt;
    &lt;head rend="h4"&gt;6.1.1 Port Rights: Receive, Send, Send-Once, and Dead Names&lt;/head&gt;
    &lt;p&gt;The security model of Mach is capability-based. Possessing a port name is meaningless without the associated Port Right. The kernel tracks these rights in the process's IPC space.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;MACH_PORT_RIGHT_RECEIVE&lt;/code&gt;: The ownership right. Only one task can hold the Receive right for a specific port at any given time. This task is the destination for messages sent to the port.&lt;list rend="ul"&gt;&lt;item&gt;Kernel Structure: The &lt;code&gt;ipc_port&lt;/code&gt;struct contains a pointer (&lt;code&gt;ip_receiver&lt;/code&gt;) to the&lt;code&gt;ipc_space&lt;/code&gt;of the task holding this right.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;Kernel Structure: The &lt;/item&gt;
      &lt;item&gt;&lt;code&gt;MACH_PORT_RIGHT_SEND&lt;/code&gt;: The ability to queue messages into the port. Multiple tasks can hold send rights to the same port. This is the standard "client" handle.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;MACH_PORT_RIGHT_SEND_ONCE&lt;/code&gt;: A "fire-and-forget" right that vanishes after a single message is sent. This is critical for the Request/Reply pattern (RPC). When a client sends a message, it typically includes a&lt;code&gt;MAKE_SEND_ONCE&lt;/code&gt;right to its own reply port. The server uses this to send exactly one reply, preventing the server from spamming the client later.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;MACH_PORT_RIGHT_DEAD_NAME&lt;/code&gt;: If the task holding the Receive right dies or destroys the port, all outstanding Send rights in other tasks are instantly transmuted into Dead Names. Any attempt to send a message to a dead name returns&lt;code&gt;MACH_SEND_INVALID_DEST&lt;/code&gt;.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;RE Focus: The &lt;code&gt;ipc_port&lt;/code&gt; Structure and PAC:&lt;lb/&gt; In previous generations, a common exploit technique involved "Fake Ports"—spraying the heap with crafted data that looked like an &lt;code&gt;ipc_port&lt;/code&gt; struct and then tricking the kernel into using it.&lt;/p&gt;
    &lt;p&gt;In the arm64e/Tahoe architecture, the &lt;code&gt;ipc_port&lt;/code&gt; structure is heavily fortified:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;&lt;code&gt;ip_object&lt;/code&gt;: The base header of the port.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;ip_kobject&lt;/code&gt;: A pointer to the underlying kernel object (e.g., a task, a thread, or a user-client). This pointer is PAC-signed.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;ip_context&lt;/code&gt;: A 64-bit context value, also PAC-signed.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;If an attacker attempts to forge a port, they must generate a valid signature for the &lt;code&gt;ip_kobject&lt;/code&gt; pointer. Without the &lt;code&gt;APDAKey&lt;/code&gt; (Data Key A), the kernel will panic upon &lt;code&gt;AUT&lt;/code&gt; execution during message delivery.&lt;/p&gt;
    &lt;head rend="h4"&gt;6.1.2 The IPC Space (&lt;code&gt;ipc_space&lt;/code&gt;) and the Global Name Server&lt;/head&gt;
    &lt;p&gt;Every task (process) in macOS has an associated IPC Space (&lt;code&gt;ipc_space&lt;/code&gt;). This structure acts as the translation layer between userland integer handles (&lt;code&gt;mach_port_name_t&lt;/code&gt;) and kernel objects (&lt;code&gt;ipc_port *&lt;/code&gt;, &lt;code&gt;ipc_pset *&lt;/code&gt;, etc.).&lt;/p&gt;
    &lt;p&gt;The Translation Table (&lt;code&gt;is_table&lt;/code&gt;):&lt;lb/&gt; Each IPC space is backed by a dynamically sized array of IPC Entries (&lt;code&gt;ipc_entry&lt;/code&gt;), commonly referred to as the &lt;code&gt;is_table&lt;/code&gt; / &lt;code&gt;ipc_entry_table&lt;/code&gt;.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;p&gt;Index:&lt;/p&gt;&lt;lb/&gt;The userland handle (e.g.&lt;code&gt;0x103&lt;/code&gt;) encodes:&lt;list rend="ul"&gt;&lt;item&gt;A low-order index into the &lt;code&gt;is_table&lt;/code&gt;, and&lt;/item&gt;&lt;item&gt;High-order generation bits used to detect stale handles.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;A low-order index into the &lt;/item&gt;
      &lt;item&gt;&lt;p&gt;Entry (&lt;/p&gt;&lt;code&gt;ipc_entry&lt;/code&gt;):&lt;lb/&gt;Each entry contains (simplified):&lt;list rend="ul"&gt;&lt;item&gt;&lt;code&gt;ie_object&lt;/code&gt;: A pointer to the underlying&lt;code&gt;ipc_port&lt;/code&gt;or&lt;code&gt;ipc_pset&lt;/code&gt;. On arm64e/Tahoe, this pointer is protected with pointer authentication (PAC) so that corruption of the raw bits does not yield a usable kernel pointer.&lt;/item&gt;&lt;item&gt;&lt;code&gt;ie_bits&lt;/code&gt;: A bitfield encoding:&lt;list rend="ul"&gt;&lt;item&gt;Rights (send, receive, send-once, etc.).&lt;/item&gt;&lt;item&gt;The generation count for that slot.&lt;/item&gt;&lt;item&gt;Additional flags (e.g. dead-name state).&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The Lookup Process (&lt;code&gt;ipc_right_lookup_write&lt;/code&gt;):&lt;lb/&gt; When a thread executes &lt;code&gt;mach_msg()&lt;/code&gt; to send to some &lt;code&gt;msgh_remote_port&lt;/code&gt;:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;
        &lt;p&gt;The kernel retrieves the current task’s IPC space:&lt;/p&gt;
        &lt;code&gt;ipc_space_t space = current_task()-&amp;gt;itk_space;&lt;/code&gt;
      &lt;/item&gt;
      &lt;item&gt;&lt;p&gt;It decodes the&lt;/p&gt;&lt;code&gt;mach_port_name_t&lt;/code&gt;to obtain the index and generation and indexes into&lt;code&gt;space-&amp;gt;is_table&lt;/code&gt;.&lt;/item&gt;
      &lt;item&gt;&lt;p&gt;It checks&lt;/p&gt;&lt;code&gt;ie_bits&lt;/code&gt;:&lt;list rend="ul"&gt;&lt;item&gt;Generation matches the high bits of the name?&lt;/item&gt;&lt;item&gt;Required right present (e.g. &lt;code&gt;MACH_PORT_RIGHT_SEND&lt;/code&gt;for a send).&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;&lt;p&gt;On arm64e, it authenticates the&lt;/p&gt;&lt;code&gt;ie_object&lt;/code&gt;pointer using the appropriate kernel PAC key and context.&lt;/item&gt;
      &lt;item&gt;&lt;p&gt;If all checks succeed, it obtains the&lt;/p&gt;&lt;code&gt;ipc_port&lt;/code&gt;and proceeds with message delivery.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;This indirection is what allows the kernel to revoke or recycle ports while making stale userland handles harmless: the generation mismatch will cause lookups to fail instead of returning the wrong object.&lt;/p&gt;
    &lt;p&gt;The Global Name Server:&lt;lb/&gt; Mach itself does not implement a string-based global namespace in the kernel. The kernel only knows about ports and rights; it does not know what &lt;code&gt;"com.apple.windowserver"&lt;/code&gt; means.&lt;/p&gt;
    &lt;p&gt;The mapping from string service names → &lt;code&gt;mach_port_t&lt;/code&gt; is implemented entirely in userland by the bootstrap server, which on macOS is &lt;code&gt;launchd&lt;/code&gt;.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;p&gt;Special ports:&lt;/p&gt;&lt;lb/&gt;The kernel does maintain a small set of “special ports” on host and task objects. Relevant here:&lt;list rend="ul"&gt;&lt;item&gt;&lt;code&gt;HOST_PORT&lt;/code&gt;: A send right representing the host (&lt;code&gt;realhost&lt;/code&gt;).&lt;/item&gt;&lt;item&gt;&lt;code&gt;HOST_PRIV_PORT&lt;/code&gt;: The privileged host port (see Section 6.2).&lt;/item&gt;&lt;item&gt;&lt;code&gt;TASK_BOOTSTRAP_PORT&lt;/code&gt;: The task’s handle to the bootstrap server (typically a port managed by&lt;code&gt;launchd&lt;/code&gt;for that task’s domain).&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;When a process calls:&lt;/p&gt;
    &lt;code&gt;bootstrap_look_up(bootstrap_port, "com.apple.foo", &amp;amp;service_port);
&lt;/code&gt;
    &lt;p&gt;or uses the XPC equivalent, it is really sending a Mach message to whatever port is stored in its &lt;code&gt;TASK_BOOTSTRAP_PORT&lt;/code&gt; slot. &lt;code&gt;launchd&lt;/code&gt; receives that message and resolves &lt;code&gt;"com.apple.foo"&lt;/code&gt; into a Mach port according to its internal job graph and policy.&lt;/p&gt;
    &lt;head rend="h4"&gt;6.1.3 Copy-on-Write (CoW) optimizations in Out-of-Line (OOL) message passing&lt;/head&gt;
    &lt;p&gt;Mach messages are not limited to small scalars. They can transfer massive amounts of data using Out-of-Line (OOL) descriptors. This mechanism relies on Virtual Memory (VM) tricks rather than data copying, making it highly efficient but historically dangerous.&lt;/p&gt;
    &lt;p&gt;The Mechanism:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Sender: Includes a &lt;code&gt;mach_msg_ool_descriptor_t&lt;/code&gt;in the message, pointing to a buffer in its address space (e.g., 100MB of data).&lt;/item&gt;
      &lt;item&gt;Kernel Processing: The kernel does not copy the 100MB. Instead, it walks the sender's VM map.&lt;/item&gt;
      &lt;item&gt;Copy-on-Write (CoW): The kernel marks the physical pages backing that buffer as Read-Only in the sender's map.&lt;/item&gt;
      &lt;item&gt;Receiver: The kernel maps those same physical pages into the receiver's address space, also as Read-Only.&lt;/item&gt;
      &lt;item&gt;Faulting: If either the sender or receiver tries to write to the buffer, the MMU triggers a fault. The kernel catches this, allocates a new physical page, copies the data, and updates the mapping for the writer. This preserves the illusion of a copy.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The Tahoe/SPTM Intersection:&lt;lb/&gt; In the Tahoe architecture, this VM manipulation is complicated by the SPTM.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Permission Downgrade: When the kernel marks the pages as CoW (Read-Only), it cannot simply update the PTEs. It must issue a &lt;code&gt;GENTER&lt;/code&gt;call (&lt;code&gt;sptm_protect&lt;/code&gt;or&lt;code&gt;sptm_map&lt;/code&gt;) to the SPTM to downgrade the permissions of the physical pages in the sender's address space.&lt;/item&gt;
      &lt;item&gt;The Vulnerability Class: This complexity introduces a race window. If the kernel logic fails to correctly lock the VM map object before requesting the SPTM update, or if the SPTM state machine has a logic flaw regarding shared pages (&lt;code&gt;refcount &amp;gt; 1&lt;/code&gt;), it might be possible to modify the physical page after the message has been "sent" but before the receiver reads it. This is known as a Double Fetch or Physically-Backed-Virtually-Disjoint attack.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;RE Focus:&lt;lb/&gt; Analyze &lt;code&gt;vm_map_copyin&lt;/code&gt; and &lt;code&gt;vm_map_copyout&lt;/code&gt; in the XNU source (or binary). Look for how &lt;code&gt;vm_map_entry&lt;/code&gt; structures are flagged with &lt;code&gt;needs_copy&lt;/code&gt; and how these flags translate into SPTM calls. The interaction between Mach IPC (which assumes it controls VM) and the SPTM (which actually controls VM) is the friction point where new bugs will likely emerge.&lt;/p&gt;
    &lt;head rend="h3"&gt;6.2 The &lt;code&gt;host_priv&lt;/code&gt; Port&lt;/head&gt;
    &lt;p&gt;In the lexicon of XNU exploitation, the Host Privilege Port (&lt;code&gt;host_priv&lt;/code&gt;) has historically been synonymous with “Game Over.” It is not the kernel task port itself; rather, it is a privileged Mach port on the global host object (&lt;code&gt;realhost&lt;/code&gt;) that unlocks host-level operations and special ports. In older exploitation chains, &lt;code&gt;host_priv&lt;/code&gt; was often the stepping stone to obtain a send right to &lt;code&gt;kernel_task&lt;/code&gt; (TFP0) via interfaces such as &lt;code&gt;host_get_special_port&lt;/code&gt; or &lt;code&gt;task_for_pid(0, …)&lt;/code&gt;.&lt;/p&gt;
    &lt;head rend="h4"&gt;6.2.1 The “God Mode” Handle: Generation and Restriction&lt;/head&gt;
    &lt;p&gt;The &lt;code&gt;host_priv&lt;/code&gt; port is backed by the kernel’s global host object (&lt;code&gt;realhost&lt;/code&gt;). Unlike a task port, which maps to a &lt;code&gt;task_t&lt;/code&gt;, the &lt;code&gt;host_priv&lt;/code&gt; port is a privileged view of the host object that unlocks host-level operations (for example, access to special ports and certain system configuration controls).&lt;/p&gt;
    &lt;p&gt;Generation at boot&lt;/p&gt;
    &lt;p&gt;During early bootstrap in &lt;code&gt;osfmk/kern/host.c&lt;/code&gt;, XNU initializes the host subsystem:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;&lt;code&gt;host_init()&lt;/code&gt;:&lt;lb/&gt;Allocates and initializes the&lt;code&gt;realhost&lt;/code&gt;structure.&lt;/item&gt;
      &lt;item&gt;&lt;p&gt;Port allocation:&lt;/p&gt;&lt;lb/&gt;Calls&lt;code&gt;ipc_port_alloc_kernel()&lt;/code&gt;(or equivalent helpers) to create the Mach port for the host.&lt;/item&gt;
      &lt;item&gt;&lt;p&gt;Kobject association:&lt;/p&gt;&lt;lb/&gt;Associates the&lt;code&gt;realhost&lt;/code&gt;pointer with the port’s&lt;code&gt;ip_kobject&lt;/code&gt;/ context fields.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;On arm64e/Tahoe:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;The &lt;code&gt;ip_kobject&lt;/code&gt;(or related kobject pointer) is stored as a PAC-signed kernel pointer, using one of the kernel’s data-pointer keys with the port address (or similar) as context.&lt;/item&gt;
      &lt;item&gt;This prevents simple “write some other kernel address into &lt;code&gt;ip_kobject&lt;/code&gt;” attacks, even given a raw kernel read/write primitive: tampered pointers will not authenticate when used.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Distribution&lt;/p&gt;
    &lt;p&gt;The system is conservative about who gets &lt;code&gt;host_priv&lt;/code&gt;. Typical holders are:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;kernel_task&lt;/code&gt;:&lt;lb/&gt;Owns the receive right for the host-privileged port.&lt;/item&gt;
      &lt;item&gt;&lt;p&gt;Privileged daemons (for example,&lt;/p&gt;&lt;code&gt;launchd&lt;/code&gt;,&lt;code&gt;kernelmanagerd&lt;/code&gt;):&lt;lb/&gt;Obtain send rights to&lt;code&gt;host_priv&lt;/code&gt;via&lt;code&gt;host_get_host_priv_port()&lt;/code&gt;or the special-port mechanism, so they can:&lt;list rend="ul"&gt;&lt;item&gt;manage special ports (&lt;code&gt;host_get_special_port&lt;/code&gt;,&lt;code&gt;host_set_special_port&lt;/code&gt;), and&lt;/item&gt;&lt;item&gt;perform host-level operations on behalf of the rest of the system.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;manage special ports (&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The exact set of daemons that receive &lt;code&gt;host_priv&lt;/code&gt; can vary by OS release, but it is a very small, explicitly entitled group.&lt;/p&gt;
    &lt;p&gt;The “TFP0” chain in Tahoe&lt;/p&gt;
    &lt;p&gt;Historically, a common pattern was:&lt;/p&gt;
    &lt;code&gt;host_get_host_priv_port(mach_host_self(), &amp;amp;host_priv);
task_for_pid(mach_task_self(), 0, &amp;amp;kernel_task_port);
&lt;/code&gt;
    &lt;p&gt;On modern macOS / Tahoe, several layers weaken this chain:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;&lt;code&gt;task_conversion_eval&lt;/code&gt;and SIP:&lt;lb/&gt;Even if a caller presents&lt;code&gt;host_priv&lt;/code&gt;,&lt;code&gt;task_for_pid(0, …)&lt;/code&gt;is gated by System Integrity Protection (SIP) and related policy hooks. With SIP enabled, conversion to&lt;code&gt;kernel_task&lt;/code&gt;is denied for untrusted callers.&lt;/item&gt;
      &lt;item&gt;&lt;p&gt;Immutable kernel regions via KIP/SPTM:&lt;/p&gt;&lt;lb/&gt;Even if an attacker somehow:&lt;list rend="ul"&gt;&lt;item&gt;bypasses SIP/task conversion checks, and&lt;/item&gt;&lt;item&gt;obtains a &lt;code&gt;kernel_task&lt;/code&gt;port,&lt;/item&gt;&lt;/list&gt;&lt;p&gt;the system’s integrity protections still constrain what that port can do safely:&lt;/p&gt;&lt;list rend="ul"&gt;&lt;item&gt;code pages in the Kernel Integrity Protection (KIP) region are loaded and marked read-only by iBoot/SPTM,&lt;/item&gt;&lt;item&gt;page tables and “data-const” regions are protected by SPTM frame typing,&lt;/item&gt;&lt;item&gt;attempts to use &lt;code&gt;vm_write&lt;/code&gt;/&lt;code&gt;mach_vm_write&lt;/code&gt;to modify such protected regions can trigger integrity violations and system panic rather than giving persistent arbitrary code execution.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;In effect, on Tahoe-era systems, &lt;code&gt;host_priv&lt;/code&gt; is a high-leverage control primitive and a prerequisite for a number of powerful operations, but it is no longer, by itself, a trivial “write-anywhere in kernel text” primitive once KIP/SPTM and SIP are taken into account.&lt;/p&gt;
    &lt;head rend="h4"&gt;6.2.2 Task Special Ports: The Privileged Directory&lt;/head&gt;
    &lt;p&gt;While &lt;code&gt;host_priv&lt;/code&gt; itself is restricted, it is also the gateway into a table of host special ports that act as privileged entry points for various subsystems. These ports are accessed via &lt;code&gt;host_get_special_port()&lt;/code&gt; and &lt;code&gt;host_set_special_port()&lt;/code&gt;.&lt;/p&gt;
    &lt;p&gt;Internally, the &lt;code&gt;realhost&lt;/code&gt; structure maintains an array such as:&lt;/p&gt;
    &lt;code&gt;ipc_port_t special[HOST_MAX_SPECIAL_PORT + 1];
&lt;/code&gt;
    &lt;p&gt;where specific indices are reserved for particular subsystems.&lt;/p&gt;
    &lt;p&gt;Critical special ports (by name)&lt;/p&gt;
    &lt;p&gt;A non-exhaustive set of important host special ports:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;HOST_AUTOMOUNTD_PORT&lt;/code&gt;:&lt;lb/&gt;Port used by the kernel to talk to the automounter (&lt;code&gt;automountd&lt;/code&gt;) to initiate filesystem mounts.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;HOST_SEATBELT_PORT&lt;/code&gt;:&lt;lb/&gt;Control port for the sandbox subsystem (&lt;code&gt;seatbelt&lt;/code&gt;/&lt;code&gt;sandbox.kext&lt;/code&gt;). Possession of this port gives a daemon the ability to receive sandbox configuration and policy messages.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;HOST_KEXTD_PORT&lt;/code&gt;:&lt;lb/&gt;Port used for communicating with the kernel extension manager (&lt;code&gt;kextd&lt;/code&gt;/&lt;code&gt;kernelmanagerd&lt;/code&gt;). Historically has been involved in flows that could be abused to force loading of kexts; on Tahoe, these flows are constrained by driver signing, KCs, and TXM/LocalPolicy.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;HOST_AMFID_PORT&lt;/code&gt;:&lt;lb/&gt;Port used to talk to the Apple Mobile File Integrity daemon (&lt;code&gt;amfid&lt;/code&gt;) for code-signing validation requests.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The actual numeric IDs (indices into &lt;code&gt;special[]&lt;/code&gt;) for these ports are defined in headers like &lt;code&gt;host_special_ports.h&lt;/code&gt; and are not simple small integers like 1 or 7; they are offsets from &lt;code&gt;HOST_MAX_SPECIAL_KERNEL_PORT&lt;/code&gt;. For most reverse-engineering and exploitation work, the symbolic names and behaviors matter more than the concrete index values.&lt;/p&gt;
    &lt;p&gt;RE Focus: The &lt;code&gt;host_set_special_port&lt;/code&gt; trap&lt;/p&gt;
    &lt;p&gt;A classic post-exploitation idea is:&lt;/p&gt;
    &lt;quote&gt;
      &lt;p&gt;Overwrite a host special port (e.g. the KEXTD port) with a port you control, so you can intercept kernel upcalls intended for that subsystem.&lt;/p&gt;
    &lt;/quote&gt;
    &lt;p&gt;In principle:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;p&gt;If an attacker can get&lt;/p&gt;&lt;code&gt;host_priv&lt;/code&gt;and then call:&lt;code&gt;host_set_special_port(host_priv, HOST_KEXTD_PORT, attacker_port);&lt;/code&gt;&lt;p&gt;the kernel will now send all “kextd” notifications to&lt;/p&gt;&lt;code&gt;attacker_port&lt;/code&gt;instead.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Mitigations in modern macOS include:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;p&gt;Entitlement and policy gating:&lt;/p&gt;&lt;code&gt;host_set_special_port&lt;/code&gt;is restricted:&lt;list rend="ul"&gt;&lt;item&gt;It requires a host-privileged port.&lt;/item&gt;&lt;item&gt;It is further gated by entitlements and code-signing checks; in practice, only &lt;code&gt;launchd&lt;/code&gt;and a very small number of highly privileged system daemons are allowed to call it successfully.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;&lt;p&gt;Confused-deputy / race hardening:&lt;/p&gt;&lt;lb/&gt;Attackers therefore look for:&lt;list rend="ul"&gt;&lt;item&gt;Bugs that allow racing or bypassing entitlement checks.&lt;/item&gt;&lt;item&gt;Confused-deputy situations where a daemon that does have the entitlement can be coerced into calling &lt;code&gt;host_set_special_port&lt;/code&gt;with an attacker-controlled port name.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;From a reversing perspective, mapping which daemons hold both &lt;code&gt;host_priv&lt;/code&gt; and the relevant private entitlements is a critical part of understanding the real attack surface around &lt;code&gt;host_set_special_port&lt;/code&gt;.&lt;/p&gt;
    &lt;head rend="h4"&gt;6.2.3 RE Focus: Fuzzing Mach Message Parsing (MIG)&lt;/head&gt;
    &lt;p&gt;Since &lt;code&gt;host_priv&lt;/code&gt; exposes a wide attack surface via the Mach IPC interface, it is a primary target for fuzzing. The kernel handles these messages using the Mach Interface Generator (MIG).&lt;/p&gt;
    &lt;p&gt;The &lt;code&gt;host_priv_server&lt;/code&gt; Routine:&lt;lb/&gt; When a message is sent to &lt;code&gt;host_priv&lt;/code&gt;, the kernel's IPC dispatcher calls &lt;code&gt;host_priv_server&lt;/code&gt;. This is an auto-generated function that deserializes the Mach message and dispatches it to the implementation (e.g., &lt;code&gt;kern_host.c&lt;/code&gt;).&lt;/p&gt;
    &lt;p&gt;Vulnerability Classes in MIG:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Type Confusion: MIG relies on the message header to define the size and type of arguments. If the userland client sends a malformed message (e.g., claiming a descriptor is OOL memory when it is actually inline data), the kernel's unmarshaling logic might misinterpret the data, leading to heap corruption.&lt;/item&gt;
      &lt;item&gt;Reference Counting Leaks: If a MIG routine returns an error (e.g., &lt;code&gt;KERN_INVALID_ARGUMENT&lt;/code&gt;) after it has incremented the reference count on a port or VM object but before it consumes it, the object leaks. In the kernel, this can lead to a refcount overflow (though 64-bit refcounts make this hard) or a Use-After-Free if the cleanup logic is flawed.&lt;/item&gt;
      &lt;item&gt;TOCTOU on OOL Memory: As discussed in Section 6.1.3, if the message includes Out-of-Line memory, the kernel maps it Copy-on-Write. If the MIG handler verifies the content of the memory and then uses it later, the userland process might be able to race the kernel and modify the physical page (via a side-channel or SPTM state confusion) between the check and the use.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The Tahoe Hardening:&lt;lb/&gt; In the Tahoe kernel, MIG-generated code has been hardened with PAC.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Function Pointers: The dispatch tables used by &lt;code&gt;host_priv_server&lt;/code&gt;are signed.&lt;/item&gt;
      &lt;item&gt;Context: The &lt;code&gt;ipc_kmsg&lt;/code&gt;structure (representing the message in flight) is heavily protected to prevent modification of the message contents after validation but before processing.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;However, logic bugs in the implementation of the host calls (the C functions called by MIG) remain reachable. For example, &lt;code&gt;host_processor_set_priv&lt;/code&gt; allows manipulating CPU sets. If the logic fails to account for a processor being in a low-power state or being managed by an Exclave, it could trigger an inconsistent state in the scheduler.&lt;/p&gt;
    &lt;head rend="h2"&gt;7.0 IOKit &amp;amp; Driver Architecture&lt;/head&gt;
    &lt;p&gt;While the Mach subsystem provides the primitives for IPC and scheduling, IOKit provides the object-oriented framework for device drivers. Historically, IOKit has been the "soft underbelly" of the XNU kernel. Written in a restricted subset of C++, it relies heavily on virtual function dispatch, complex inheritance hierarchies, and manual reference counting (&lt;code&gt;OSObject::retain&lt;/code&gt;/&lt;code&gt;release&lt;/code&gt;).&lt;/p&gt;
    &lt;p&gt;In the Tahoe architecture, IOKit has undergone a radical hardening process. The transition to Apple Silicon has allowed Apple to enforce strict Control Flow Integrity (CFI) on C++ objects using PAC, while Kernel Integrity Protection (KIP) enforces the immutability of the driver code itself, with the SPTM protecting the page tables that describe those regions.&lt;/p&gt;
    &lt;head rend="h3"&gt;7.1 IOKit Initialization&lt;/head&gt;
    &lt;p&gt;The initialization of IOKit is the bridge between the static hardware description provided by iBoot (the Device Tree) and the dynamic, runtime object graph that constitutes the macOS driver environment.&lt;/p&gt;
    &lt;head rend="h4"&gt;7.1.1 The IORegistry: Populating the Device Tree into C++ Objects&lt;/head&gt;
    &lt;p&gt;When the kernel boots, the hardware topology is described by the Flattened Device Tree (FDT). Unlike previous architectures where the FDT pointer might have been passed in a raw register, in the current XNU ABI, the FDT pointer is stored in the &lt;code&gt;deviceTreeP&lt;/code&gt; field of the &lt;code&gt;boot_args&lt;/code&gt; structure, which is passed in &lt;code&gt;x0&lt;/code&gt; to the kernel entry point &lt;code&gt;_start&lt;/code&gt;. IOKit's first major task is to hydrate this binary blob into a live graph of &lt;code&gt;IORegistryEntry&lt;/code&gt; objects.&lt;/p&gt;
    &lt;p&gt;The &lt;code&gt;IOPlatformExpert&lt;/code&gt;:&lt;lb/&gt; The bootstrap process is driven by the &lt;code&gt;IOPlatformExpert&lt;/code&gt; class (specifically &lt;code&gt;IOPlatformExpertDevice&lt;/code&gt; on Apple Silicon).&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Unflattening: The kernel parses the FDT. For every node in the tree (e.g., &lt;code&gt;arm-io&lt;/code&gt;,&lt;code&gt;uart0&lt;/code&gt;,&lt;code&gt;aic&lt;/code&gt;), it instantiates an&lt;code&gt;IORegistryEntry&lt;/code&gt;.&lt;/item&gt;
      &lt;item&gt;The &lt;code&gt;IODeviceTree&lt;/code&gt;Plane: These objects are attached to the&lt;code&gt;IODeviceTree&lt;/code&gt;plane of the Registry. This plane represents the physical topology as reported by iBoot.&lt;/item&gt;
      &lt;item&gt;Property Mapping: Properties from the FDT (like &lt;code&gt;reg&lt;/code&gt;,&lt;code&gt;interrupts&lt;/code&gt;,&lt;code&gt;compatible&lt;/code&gt;) are converted into&lt;code&gt;OSData&lt;/code&gt;,&lt;code&gt;OSString&lt;/code&gt;, or&lt;code&gt;OSNumber&lt;/code&gt;objects and attached to the registry entries.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Matching and Driver Loading:&lt;lb/&gt; Once the Registry is populated, IOKit begins the Matching phase (&lt;code&gt;IOService::startMatching&lt;/code&gt;).&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;The &lt;code&gt;compatible&lt;/code&gt;String: IOKit iterates over the registry entries. It compares the&lt;code&gt;compatible&lt;/code&gt;property (e.g.,&lt;code&gt;apple,s5l8960x-uart&lt;/code&gt;) against the&lt;code&gt;IOKitPersonalities&lt;/code&gt;dictionary defined in the&lt;code&gt;Info.plist&lt;/code&gt;of every loaded driver.&lt;/item&gt;
      &lt;item&gt;The Probe/Start Lifecycle: When a match is found, the driver's C++ class is instantiated. &lt;list rend="ul"&gt;&lt;item&gt;&lt;code&gt;init()&lt;/code&gt;: Constructor.&lt;/item&gt;&lt;item&gt;&lt;code&gt;probe()&lt;/code&gt;: The driver verifies the hardware is actually present (rarely used on SoCs where hardware is static).&lt;/item&gt;&lt;item&gt;&lt;code&gt;start()&lt;/code&gt;: The driver initializes the hardware, maps MMIO regions, and registers interrupts.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;RE Focus: The "Missing" Hardware:&lt;lb/&gt; On Tahoe systems, empirical observation reveals gaps in the IORegistry compared to the raw Device Tree.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Reserved Regions: The SPTM and TXM reserve specific hardware blocks (e.g., the Secure Storage controller or specific GPIO banks for privacy LEDs).&lt;/item&gt;
      &lt;item&gt;Filtering: While not explicitly documented as an SPTM feature, reverse engineering suggests that during the unflattening process, nodes corresponding to physical ranges reserved by the SPTM are omitted from the &lt;code&gt;IODeviceTree&lt;/code&gt;. This effectively makes secure hardware invisible to the OS, preventing the kernel from even attempting to map the MMIO registers for these protected blocks.&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h4"&gt;7.1.2 Boot, System, and Auxiliary Kernel Collections&lt;/head&gt;
    &lt;p&gt;Gone are the days of loading individual &lt;code&gt;.kext&lt;/code&gt; bundles directly from &lt;code&gt;/System/Library/Extensions&lt;/code&gt; at boot. To optimize startup and enforce stronger integrity guarantees, macOS now uses Kernel Collections.&lt;/p&gt;
    &lt;p&gt;Boot Kernel Collection (BKC)&lt;/p&gt;
    &lt;p&gt;The BootKC is a large, prelinked Mach-O, delivered as an Image4 payload (commonly labeled &lt;code&gt;Ap,BootKernelCollection&lt;/code&gt;):&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;p&gt;Content:&lt;/p&gt;&lt;lb/&gt;The BKC bundles:&lt;list rend="ul"&gt;&lt;item&gt;&lt;p&gt;The XNU kernel.&lt;/p&gt;&lt;/item&gt;&lt;item&gt;&lt;p&gt;All “essential” drivers required to:&lt;/p&gt;&lt;list rend="ul"&gt;&lt;item&gt;Initialize low-level hardware.&lt;/item&gt;&lt;item&gt;Mount the root filesystem.&lt;/item&gt;&lt;item&gt;Bring up enough of the graphics/console stack to start userland and show the boot UI.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;&lt;p&gt;Linkage:&lt;/p&gt;&lt;lb/&gt;All included kexts are prelinked against the kernel:&lt;list rend="ul"&gt;&lt;item&gt;Symbol resolution is performed at build-time.&lt;/item&gt;&lt;item&gt;No relocations or link-edit work is needed in the early boot path.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;&lt;p&gt;Protection (KIP/SPTM):&lt;/p&gt;&lt;lb/&gt;The BKC is loaded by iBoot into a region managed by Kernel Integrity Protection (KIP) and the Secure Page Table Monitor (SPTM):&lt;list rend="ul"&gt;&lt;item&gt;The physical pages backing BKC code are tracked and locked down before XNU runs.&lt;/item&gt;&lt;item&gt;Page-table entries mapping these frames are subject to SPTM policy: kernel attempts to make them writable or executable in unexpected ways can be blocked or cause a panic.&lt;/item&gt;&lt;item&gt;This makes kernel text and core boot drivers effectively immutable from EL1, even if an attacker gains &lt;code&gt;kernel_task&lt;/code&gt;.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;System Kernel Collection (SystemKC)&lt;/p&gt;
    &lt;p&gt;The SystemKC holds additional Apple-provided drivers that are not strictly required to mount root or start &lt;code&gt;launchd&lt;/code&gt;:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;
        &lt;p&gt;Examples include Wi-Fi, Bluetooth, audio, and other device drivers.&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Like the BKC, SystemKC contents are:&lt;/p&gt;
        &lt;list rend="ul"&gt;
          &lt;item&gt;Prelinked.&lt;/item&gt;
          &lt;item&gt;Signed by Apple and loaded from the immutable System volume.&lt;/item&gt;
          &lt;item&gt;Covered by the same KIP/SPTM enforcement model once mapped.&lt;/item&gt;
        &lt;/list&gt;
      &lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Auxiliary Kernel Collection (AuxKC)&lt;/p&gt;
    &lt;p&gt;The AuxKC is the “expansion slot”:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;
        &lt;p&gt;It contains:&lt;/p&gt;
        &lt;list rend="ul"&gt;
          &lt;item&gt;Third-party kexts.&lt;/item&gt;
          &lt;item&gt;Apple-signed kexts that are treated as auxiliary (e.g. optional features, development-only drivers).&lt;/item&gt;
        &lt;/list&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Loading path:&lt;/p&gt;
        &lt;list rend="ul"&gt;
          &lt;item&gt;&lt;code&gt;kernelmanagerd&lt;/code&gt;(userland) is responsible for assembling and signing an Auxiliary KC based on currently-installed third-party drivers.&lt;/item&gt;
          &lt;item&gt;It then asks the kernel to load this collection at runtime once the system is up enough to trust userland decisions.&lt;/item&gt;
        &lt;/list&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Verification and sealing:&lt;/p&gt;
        &lt;list rend="ul"&gt;
          &lt;item&gt;
            &lt;p&gt;The kernel verifies the AuxKC’s signature.&lt;/p&gt;
          &lt;/item&gt;
          &lt;item&gt;
            &lt;p&gt;On Tahoe-era systems, this verification is tied into TXM / LocalPolicy:&lt;/p&gt;
            &lt;list rend="ul"&gt;
              &lt;item&gt;Policy must allow third-party kexts in the current boot configuration.&lt;/item&gt;
              &lt;item&gt;The AuxKC’s provenance and contents must satisfy platform rules.&lt;/item&gt;
            &lt;/list&gt;
          &lt;/item&gt;
          &lt;item&gt;
            &lt;p&gt;Once accepted, the pages for the AuxKC are mapped and then “sealed”:&lt;/p&gt;
            &lt;list rend="ul"&gt;
              &lt;item&gt;Their mappings transition to code-like protections under SPTM.&lt;/item&gt;
              &lt;item&gt;After sealing, they are enforced similarly to BKC/SystemKC code (immutable from the kernel’s own point of view).&lt;/item&gt;
            &lt;/list&gt;
          &lt;/item&gt;
        &lt;/list&gt;
      &lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;RE implication&lt;/p&gt;
    &lt;p&gt;For reverse engineering and exploitation:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;
        &lt;p&gt;BKC/SystemKC drivers:&lt;/p&gt;
        &lt;list rend="ul"&gt;
          &lt;item&gt;Have stable offsets relative to the kernel slide once you know the collection layout.&lt;/item&gt;
          &lt;item&gt;Live in regions that are protected early and rarely change at runtime.&lt;/item&gt;
        &lt;/list&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;AuxKC drivers:&lt;/p&gt;
        &lt;list rend="ul"&gt;
          &lt;item&gt;
            &lt;p&gt;Are loaded later and can have randomized placement.&lt;/p&gt;
          &lt;/item&gt;
          &lt;item&gt;
            &lt;p&gt;You often need to:&lt;/p&gt;
            &lt;list rend="ul"&gt;
              &lt;item&gt;Traverse kernel data structures (&lt;code&gt;kmod_info&lt;/code&gt;, KC descriptors) at runtime to find their base addresses.&lt;/item&gt;
              &lt;item&gt;Account for the fact that their text regions are still covered by SPTM after sealing, even though they arrived late.&lt;/item&gt;
            &lt;/list&gt;
          &lt;/item&gt;
          &lt;item&gt;Traverse kernel data structures (&lt;/item&gt;
        &lt;/list&gt;
      &lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h4"&gt;7.1.3 RE Focus: PAC-signing of C++ Vtables (&lt;code&gt;OSObject&lt;/code&gt;) and &lt;code&gt;BLRAA&lt;/code&gt;&lt;/head&gt;
    &lt;p&gt;The &lt;code&gt;OSObject&lt;/code&gt; class is the root of the IOKit inheritance hierarchy. In C++, dynamic dispatch is handled via Virtual Tables (vtables)—arrays of function pointers. Historically, attackers would overwrite the vtable pointer in an object to point to a fake vtable controlled by the attacker (vtable hijacking).&lt;/p&gt;
    &lt;p&gt;In the arm64e architecture, Apple has fundamentally altered the C++ ABI for kernel code to mitigate this.&lt;/p&gt;
    &lt;p&gt;The Signed Vtable Pointer:&lt;lb/&gt; In a standard C++ object, the first 8 bytes are the pointer to the vtable. In XNU on arm64e, this pointer is signed.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Key: &lt;code&gt;APDAKey&lt;/code&gt;(Data Key A).&lt;/item&gt;
      &lt;item&gt;Context: Public Apple documentation states the salt is 0. However, implementations often use address-based salts to achieve diversity.&lt;lb/&gt;$$ \texttt{SignedPtr} = \texttt{PAC}(\texttt{VtableAddr}, \texttt{Key=APDA}, \texttt{Context}=0) $$&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The Signed Vtable Entries:&lt;lb/&gt; The function pointers inside the vtable are signed using the &lt;code&gt;APIAKey&lt;/code&gt; (Instruction Key A).&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Context: The salt incorporates the entry's storage address and a hash of the mangled method name. This prevents moving entries between vtables.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The &lt;code&gt;BLRAA&lt;/code&gt; Dispatch:&lt;lb/&gt; When the kernel calls a virtual function (e.g., &lt;code&gt;object-&amp;gt;release()&lt;/code&gt;), the compiler emits a specialized instruction sequence:&lt;/p&gt;
    &lt;code&gt;LDR     x0, [x20]       ; Load the object pointer
LDR     x16, [x0]       ; Load the signed vtable pointer
AUTDA   x16, xzr        ; Authenticate Data Key A, Context = 0 (per docs)
LDR     x10, [x16, #0x18] ; Load the target function pointer from the vtable
BLRAA   x10, x16        ; Branch with Link, Authenticating Key A, Context = Vtable Address
&lt;/code&gt;
    &lt;p&gt;Note the two-stage authentication:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;&lt;code&gt;AUTDA&lt;/code&gt;: Authenticates that the vtable pointer is valid. If the pointer was overwritten,&lt;code&gt;x16&lt;/code&gt;becomes a canonical non-valid pointer.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;BLRAA&lt;/code&gt;: The function pointers inside the vtable are also signed. The&lt;code&gt;BLRAA&lt;/code&gt;instruction authenticates the function pointer (using the vtable address as context) and branches.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The "Recursive" PAC:&lt;lb/&gt; This creates a chain of trust:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;The Object trusts the Vtable Pointer (via &lt;code&gt;APDAKey&lt;/code&gt;).&lt;/item&gt;
      &lt;item&gt;The Vtable trusts the Function Pointers (via &lt;code&gt;APIAKey&lt;/code&gt;).&lt;/item&gt;
      &lt;item&gt;KIP/SPTM trusts the Vtable Memory (via code immutability).&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;For a reverse engineer, this means that patching a vtable in memory is impossible (KIP/SPTM), and forging an object requires the ability to sign pointers with the &lt;code&gt;APDAKey&lt;/code&gt;—a capability that requires a "Signing Oracle" gadget, which BTI aims to eliminate.&lt;/p&gt;
    &lt;head rend="h3"&gt;7.2 DriverKit (dexts)&lt;/head&gt;
    &lt;p&gt;The introduction of DriverKit represents a strategic retreat for the XNU kernel. For decades, the kernel’s attack surface was effectively the sum of the core kernel plus every third-party driver loaded into the address space. A vulnerability in a Wacom tablet driver or a USB-to-Serial adapter was functionally identical to a vulnerability in the scheduler: both yielded &lt;code&gt;EL1&lt;/code&gt; code execution.&lt;/p&gt;
    &lt;p&gt;DriverKit bifurcates this model by moving hardware drivers into userland, executing as System Extensions (&lt;code&gt;.dext&lt;/code&gt;). While they look and feel like drivers to the developer (using a C++ subset similar to Embedded C++), architecturally they are unprivileged processes. In the Tahoe architecture, this isolation is not merely a sandbox; it is a hardware-enforced chasm guarded by the TXM and SPTM.&lt;/p&gt;
    &lt;head rend="h4"&gt;7.2.1 Moving drivers to userland: &lt;code&gt;IOUserClient&lt;/code&gt; and Entitlement Checks&lt;/head&gt;
    &lt;p&gt;A &lt;code&gt;dext&lt;/code&gt; is an ordinary userland process (usually running as root but confined by a dedicated sandbox and entitlements). It has no direct access to the kernel’s task port and can only exercise kernel functionality via &lt;code&gt;IOUserClient&lt;/code&gt; interfaces that the kernel explicitly exposes.&lt;/p&gt;
    &lt;p&gt;The &lt;code&gt;IOUserServer&lt;/code&gt; Proxy:&lt;lb/&gt; When a &lt;code&gt;dext&lt;/code&gt; is matched and loaded (managed by &lt;code&gt;kernelmanagerd&lt;/code&gt;), the kernel instantiates a shadow object known as &lt;code&gt;IOUserServer&lt;/code&gt;. This kernel-side object acts as the proxy for the userland driver.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;The Shim: When the kernel needs to call a function in the driver (e.g., &lt;code&gt;Start()&lt;/code&gt;), it calls a method on&lt;code&gt;IOUserServer&lt;/code&gt;.&lt;/item&gt;
      &lt;item&gt;Serialization: &lt;code&gt;IOUserServer&lt;/code&gt;serializes the arguments into a specialized Mach message format (distinct from standard MIG).&lt;/item&gt;
      &lt;item&gt;The Upcall: The message is sent to the &lt;code&gt;dext&lt;/code&gt;process. The DriverKit runtime (linked into the&lt;code&gt;dext&lt;/code&gt;) deserializes the message and invokes the implementation of the&lt;code&gt;IOService&lt;/code&gt;subclass in userland.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The &lt;code&gt;IOUserClient&lt;/code&gt; Interface:&lt;lb/&gt; Conversely, when the &lt;code&gt;dext&lt;/code&gt; needs to talk to the kernel (e.g., to register an interrupt handler or map memory), it cannot call kernel APIs directly. It uses &lt;code&gt;IOUserClient&lt;/code&gt;.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Restricted API Surface: The &lt;code&gt;dext&lt;/code&gt;can only invoke a specific subset of kernel functionality exposed via&lt;code&gt;IOUserClient&lt;/code&gt;traps. These traps are heavily scrutinized.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;OSAction&lt;/code&gt;: Interrupts are no longer handled via ISRs (Interrupt Service Routines) in the driver. Instead, the kernel handles the physical IRQ, masks it, and dispatches an&lt;code&gt;OSAction&lt;/code&gt;event to the&lt;code&gt;dext&lt;/code&gt;via a Mach notification. This eliminates the entire class of vulnerabilities related to interrupt context safety and spinlock deadlocks in third-party code.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Entitlements as the Gatekeeper (TXM Enforcement):&lt;lb/&gt; In Tahoe, the ability of a &lt;code&gt;dext&lt;/code&gt; to bind to specific hardware is governed by Entitlements.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Hardware Binding: A &lt;code&gt;dext&lt;/code&gt;cannot simply&lt;code&gt;mmap&lt;/code&gt;any MMIO region. It must possess specific entitlements (e.g.,&lt;code&gt;com.apple.developer.driverkit.transport.usb&lt;/code&gt;) to access specific device families.&lt;/item&gt;
      &lt;item&gt;TXM Verification: When &lt;code&gt;kernelmanagerd&lt;/code&gt;launches a&lt;code&gt;dext&lt;/code&gt;, the system verifies its signature and entitlements against LocalPolicy and trust caches. On SPTM/TXM-equipped systems, these checks are enforced below XNU, so a compromised&lt;code&gt;kernelmanagerd&lt;/code&gt;cannot bypass them. If the TXM returns a failure, the kernel refuses to establish the&lt;code&gt;IOUserServer&lt;/code&gt;link, and the driver fails to start.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;RE Focus: The &lt;code&gt;IOUserClass&lt;/code&gt; Metaclass:&lt;lb/&gt; Reverse engineering a &lt;code&gt;dext&lt;/code&gt; requires understanding the &lt;code&gt;OSMetaClass&lt;/code&gt; infrastructure in userland. The &lt;code&gt;dext&lt;/code&gt; binary contains &lt;code&gt;OSMetaClass&lt;/code&gt; information that describes the RPC interface. By parsing the &lt;code&gt;__DATA,__const&lt;/code&gt; sections, one can reconstruct the vtables and the mapping between the kernel-side dispatch IDs and the userland C++ methods.&lt;/p&gt;
    &lt;head rend="h4"&gt;7.2.2 Memory Mapping Constraints and IOMMU (DART) Protection&lt;/head&gt;
    &lt;p&gt;The most dangerous capability of a driver is Direct Memory Access (DMA). A malicious or buggy driver could program a peripheral (like a GPU or Network Card) to write data to physical address &lt;code&gt;0x0&lt;/code&gt; (or wherever the kernel text resides), bypassing CPU-enforced protections like KTRR.&lt;/p&gt;
    &lt;p&gt;To mitigate this, Apple Silicon employs a pervasive IOMMU architecture known as DART (Device Address Resolution Table).&lt;/p&gt;
    &lt;p&gt;The DART Architecture:&lt;lb/&gt; Every DMA-capable peripheral on the SoC sits behind a DART. The device does not see Physical Addresses (PA); it sees I/O Virtual Addresses (IOVA). The DART translates IOVA → PA, enforcing permissions (Read/Write) at the page level.&lt;/p&gt;
    &lt;p&gt;DriverKit Memory Model:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;&lt;code&gt;IOMemoryDescriptor&lt;/code&gt;: When a&lt;code&gt;dext&lt;/code&gt;allocates a buffer for DMA, it creates an&lt;code&gt;IOMemoryDescriptor&lt;/code&gt;.&lt;/item&gt;
      &lt;item&gt;Mapping: The &lt;code&gt;dext&lt;/code&gt;calls&lt;code&gt;IOMemoryDescriptor::CreateMapping&lt;/code&gt;. This triggers a call into the kernel.&lt;/item&gt;
      &lt;item&gt;The Kernel's Role: The kernel allocates physical pages (&lt;code&gt;XNU_DATA&lt;/code&gt;) and pins them.&lt;/item&gt;
      &lt;item&gt;DART Programming: The kernel programs the DART associated with the specific hardware device controlled by the &lt;code&gt;dext&lt;/code&gt;. It maps the physical pages to an IOVA range visible to that device.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The Tahoe/SPTM Enforcement:&lt;lb/&gt; In the Tahoe architecture, the kernel is no longer trusted to program the DARTs directly. If the kernel could write to DART registers, it could map the kernel's own text segment as writable to the GPU, then tell the GPU to overwrite it (a DMA attack).&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;SPTM Ownership: The physical pages containing the DART translation tables (or the MMIO registers controlling the DART) are typed as &lt;code&gt;SPTM_PRIVATE&lt;/code&gt;or a specific hardware-protected type in the Frame Table.&lt;/item&gt;
      &lt;item&gt;The &lt;code&gt;sptm_map_iommu&lt;/code&gt;Selector: When the kernel needs to map a buffer for a&lt;code&gt;dext&lt;/code&gt;, it issues a&lt;code&gt;GENTER&lt;/code&gt;call to the SPTM.&lt;/item&gt;
      &lt;item&gt;Validation: The SPTM verifies that the physical pages being mapped are owned by the &lt;code&gt;dext&lt;/code&gt;(or are valid shared memory). It strictly forbids mapping any page typed&lt;code&gt;XNU_TEXT&lt;/code&gt;,&lt;code&gt;PAGE_TABLE&lt;/code&gt;, or&lt;code&gt;SPTM_PRIVATE&lt;/code&gt;into a DART.&lt;/item&gt;
      &lt;item&gt;Execution: The SPTM performs the write to the DART hardware.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;MMIO Mapping Restrictions:&lt;lb/&gt; Similarly, when a &lt;code&gt;dext&lt;/code&gt; needs to control hardware registers (MMIO), it requests a mapping.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;The kernel cannot simply map physical device memory into the &lt;code&gt;dext&lt;/code&gt;'s address space.&lt;/item&gt;
      &lt;item&gt;SPTM Validation: The SPTM only honors MMIO mapping requests that target ranges it recognizes as device registers for the given driver or device; ranges associated with secure components (SEP, KTRR controller) are excluded.&lt;/item&gt;
      &lt;item&gt;This ensures that a USB driver can only map the USB controller's registers, and cannot map the registers for the Secure Enclave Mailbox or the KTRR controller.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;RE Implication:&lt;lb/&gt; Exploiting a &lt;code&gt;dext&lt;/code&gt; to gain kernel privileges is exponentially harder in Tahoe. Even if you gain code execution in the &lt;code&gt;dext&lt;/code&gt; (Userland), you cannot issue arbitrary syscalls (sandbox), you cannot map kernel memory (VM isolation), and you cannot use the hardware device to perform DMA attacks against the kernel (SPTM-enforced DART). The attacker is contained within a hardware-enforced cage, limited to the specific capabilities of that one peripheral.&lt;/p&gt;
    &lt;head rend="h3"&gt;7.3 The Graphics Stack (AGX)&lt;/head&gt;
    &lt;p&gt;If the XNU kernel is the central nervous system, the Apple Graphics (AGX) stack is a secondary, alien brain grafted onto the SoC. On M-series silicon, the GPU is not merely a peripheral; it is a massive, autonomous compute cluster running its own proprietary operating system, managing its own memory translation, and executing a command stream that is almost entirely opaque to the main OS.&lt;/p&gt;
    &lt;p&gt;For the reverse engineer, AGX represents the largest and most complex attack surface in the kernel. The driver (&lt;code&gt;AGX.kext&lt;/code&gt;) is enormous, the firmware is encrypted (until load), and the hardware interface is undocumented. In the Tahoe architecture, Apple has moved to aggressively sandbox this beast, wrapping the GPU's memory access in strict DART (Device Address Resolution Table) policies enforced by the SPTM to prevent DMA-based kernel compromises.&lt;/p&gt;
    &lt;head rend="h4"&gt;7.3.1 RTKit: The Proprietary RTOS running on the GPU Coprocessor (ASC)&lt;/head&gt;
    &lt;p&gt;The GPU does not execute driver commands directly. Instead, the M-series SoC includes a dedicated Apple Silicon Coprocessor (ASC)—typically a hardened ARMv8-R or Cortex-M class core—that manages the GPU hardware. This coprocessor runs RTKit, Apple’s proprietary Real-Time Operating System.&lt;/p&gt;
    &lt;p&gt;The Firmware Blob:&lt;lb/&gt; The kernel driver does not contain the logic to drive the GPU hardware registers directly. Instead, upon initialization (&lt;code&gt;AGX::start&lt;/code&gt;), it loads a firmware payload from a firmware bundle on disk or embedded in the kext.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Format: The firmware is a standard Mach-O binary, often multi-architecture.&lt;/item&gt;
      &lt;item&gt;Sections: It contains &lt;code&gt;__TEXT&lt;/code&gt;and&lt;code&gt;__DATA&lt;/code&gt;segments just like a userland program.&lt;/item&gt;
      &lt;item&gt;RTKit Structure: Reverse engineering the firmware reveals a microkernel architecture. It has a scheduler, an IPC mechanism, and a set of "Endpoints" (services).&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The RTKit IPC Protocol:&lt;lb/&gt; Communication between the XNU kernel (&lt;code&gt;AGX.kext&lt;/code&gt;) and the ASC (&lt;code&gt;RTKit&lt;/code&gt;) occurs via a shared memory mailbox protocol.&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Mailbox Registers: The AP writes to a specific MMIO register to ring the doorbell of the ASC.&lt;/item&gt;
      &lt;item&gt;Message Buffer: The message payload is placed in a shared memory ring buffer.&lt;/item&gt;
      &lt;item&gt;Endpoints: The protocol is endpoint-based. Reverse engineering identifies specific service IDs running on the ASC, such as: &lt;list rend="ul"&gt;&lt;item&gt;&lt;code&gt;EP_PM&lt;/code&gt;: Power Management (Voltage/Clock gating).&lt;/item&gt;&lt;item&gt;&lt;code&gt;EP_GR&lt;/code&gt;: Graphics Rendering (Command submission).&lt;/item&gt;&lt;item&gt;&lt;code&gt;EP_COMP&lt;/code&gt;: Compute (GPGPU/Metal).&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;RE Focus: The &lt;code&gt;RTKit&lt;/code&gt; State Machine:&lt;lb/&gt; The &lt;code&gt;AGX.kext&lt;/code&gt; contains extensive logging strings and state tracking for RTKit. By analyzing the &lt;code&gt;RTKit&lt;/code&gt; class in the kext, one can reconstruct the message structures.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Crash Logs: When the GPU hangs, RTKit writes a "Coredump" to a shared buffer. The kernel captures this. Analyzing these logs reveals the internal memory layout of the ASC and the state of the GPU pipeline at the time of the crash.&lt;/item&gt;
      &lt;item&gt;Filter Bypass: Historically, vulnerabilities existed where the kernel could send malformed IPC messages to the ASC, causing memory corruption inside the GPU firmware. While this doesn't directly yield Kernel R/W, compromising the ASC allows an attacker to use the GPU as a confused deputy for DMA attacks (see 7.3.3).&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h4"&gt;7.3.2 &lt;code&gt;IOMobileFramebuffer&lt;/code&gt; (IOMFB): Secure Framebuffers and Exclave Compositing&lt;/head&gt;
    &lt;p&gt;While &lt;code&gt;AGX.kext&lt;/code&gt; handles rendering, &lt;code&gt;IOMobileFramebuffer.kext&lt;/code&gt; (IOMFB) handles the display controller (DCP). This driver is responsible for the "Swap Chain"—taking the rendered frames and scanning them out to the display panel.&lt;/p&gt;
    &lt;p&gt;The Unified Memory Architecture (UMA):&lt;lb/&gt; On Apple Silicon, the Framebuffer is just a region of system DRAM. &lt;code&gt;WindowServer&lt;/code&gt; (userland) renders into an &lt;code&gt;IOSurface&lt;/code&gt;. The physical pages backing this surface are passed to IOMFB, which programs the Display Coprocessor (DCP) to read from them.&lt;/p&gt;
    &lt;p&gt;The Security Criticality:&lt;lb/&gt; IOMFB is a high-value target because it handles complex shared memory structures (&lt;code&gt;IOMFBSharedMemory&lt;/code&gt;) mapped into both the kernel and userland (&lt;code&gt;WindowServer&lt;/code&gt;).&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Fuzzing Surface: The &lt;code&gt;Connect&lt;/code&gt;method and external methods of&lt;code&gt;IOMobileFramebufferUserClient&lt;/code&gt;have historically been riddled with race conditions and bounds-checking errors.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Tahoe and the "Secure Overlay":&lt;lb/&gt; In the Tahoe architecture, IOMFB's control over the display is no longer absolute. To support the Hardware Privacy Indicators (Green/Orange dots), reverse engineering suggests the display pipeline has been bifurcated.&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Standard Pipe: Managed by IOMFB/WindowServer. Draws the desktop/apps.&lt;/item&gt;
      &lt;item&gt;Secure Pipe: Managed by an Exclave. Draws the privacy indicators.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Hardware Compositing:&lt;lb/&gt; The compositing of these two pipes happens in the display hardware, not in memory.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;The Exclave owns a small, reserved framebuffer region.&lt;/item&gt;
      &lt;item&gt;The Display Controller overlays this region on top of the standard framebuffer during scanout.&lt;/item&gt;
      &lt;item&gt;Immutability: Because the Secure Pipe's framebuffer memory is owned by the Exclave (and protected by the SPTM), neither the kernel nor the GPU can write to it. This guarantees that if the camera is on, the green dot will be visible, even if the kernel is compromised.&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h4"&gt;7.3.3 DART: The IOMMU Wall and DMA Containment&lt;/head&gt;
    &lt;p&gt;The GPU is effectively a DMA engine with the capability to read and write vast swathes of system memory. Without restriction, a compromised GPU firmware (or a malicious shader exploiting a GPU hardware bug) could overwrite kernel text or page tables.&lt;/p&gt;
    &lt;p&gt;To prevent this, the AGX hardware—and indeed every DMA-capable peripheral on the Apple Silicon SoC—sits behind a strict IOMMU known as the DART (Device Address Resolution Table).&lt;/p&gt;
    &lt;p&gt;DART Architecture and Stream IDs (SIDs):&lt;lb/&gt; The DART translates Device Virtual Addresses (DVA) used by the peripheral into Physical Addresses (PA) in DRAM. However, the translation is not monolithic; it is segmented by the source of the traffic.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Stream IDs (SIDs): Every transaction on the SoC's Network-on-Chip (NoC) carries a hardware-generated Stream ID identifying the initiator (e.g., GPU Firmware, Vertex Fetcher, Display Controller).&lt;/item&gt;
      &lt;item&gt;Context Banks: The DART maintains multiple translation contexts (similar to distinct &lt;code&gt;TTBR&lt;/code&gt;roots).&lt;/item&gt;
      &lt;item&gt;SID Matching: The DART hardware is configured to map specific SIDs to specific Context Banks. This allows isolation between different workloads on the same peripheral (e.g., isolating &lt;code&gt;WindowServer&lt;/code&gt;rendering commands from a background compute shader).&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The Tahoe Enforcement (SPTM):&lt;lb/&gt; In pre-Tahoe systems, the kernel (&lt;code&gt;AGX.kext&lt;/code&gt; or &lt;code&gt;IOMapper&lt;/code&gt;) managed the DART page tables and the SID configuration registers directly. This meant a kernel attacker could disable DART, remap SIDs to privileged contexts, or map kernel memory into the GPU's address space to bypass KTRR.&lt;/p&gt;
    &lt;p&gt;In Tahoe, DART management is privileged to the SPTM.&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Ownership: The physical pages containing the DART translation tables (L1/L2 TTEs) and the MMIO registers controlling SID configuration are typed as &lt;code&gt;SPTM_PRIVATE&lt;/code&gt;(or a specific IOMMU_TABLE type) in the Frame Table.&lt;/item&gt;
      &lt;item&gt;Mapping Requests: When &lt;code&gt;AGX.kext&lt;/code&gt;needs to map a user's&lt;code&gt;IOSurface&lt;/code&gt;for GPU access:&lt;list rend="ul"&gt;&lt;item&gt;It pins the user pages.&lt;/item&gt;&lt;item&gt;It issues a &lt;code&gt;GENTER&lt;/code&gt;call (Selector&lt;code&gt;sptm_map_iommu&lt;/code&gt;).&lt;/item&gt;&lt;item&gt;It passes the DART ID, the Context ID, the DVA, and the PA.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;Validation: The SPTM verifies: &lt;list rend="ul"&gt;&lt;item&gt;The PA is valid &lt;code&gt;USER_DATA&lt;/code&gt;(not Kernel Text, not Page Tables).&lt;/item&gt;&lt;item&gt;The DART ID corresponds to the GPU.&lt;/item&gt;&lt;item&gt;SID Integrity: Crucially, the SPTM enforces the immutable binding between SIDs and Contexts. It ensures that the kernel cannot reconfigure the DART to allow an untrusted SID (e.g., the Neural Engine) to write to a Context Bank reserved for the Secure Enclave or Display Pipe.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;The PA is valid &lt;/item&gt;
      &lt;item&gt;Execution: The SPTM writes the DART PTE.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;RE Focus: The "GART" Attack Surface:&lt;lb/&gt; Despite SPTM protection, the logic requesting the mapping still resides in the kernel.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Aliasing: Can the kernel trick the SPTM into mapping the same physical page to two different DART contexts with different permissions?&lt;/item&gt;
      &lt;item&gt;Stale TLBs: Does the SPTM correctly flush the DART TLB (&lt;code&gt;tlb_flush&lt;/code&gt;) immediately after unmapping? If not, the GPU might retain access to a page that has been freed and reallocated to the kernel, leading to a Use-After-Free via DMA.&lt;/item&gt;
      &lt;item&gt;Side Channels: The DART configuration registers (e.g., &lt;code&gt;TCR&lt;/code&gt;,&lt;code&gt;TTBR&lt;/code&gt;, and SID match registers) are trapped by the hardware to GL2. Attempting to write to the DART control base address from EL1 should trigger a synchronous exception. Reverse engineering the&lt;code&gt;IOMapper&lt;/code&gt;class in IOKit will reveal the specific&lt;code&gt;GENTER&lt;/code&gt;trampolines used to bridge these operations.&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h2"&gt;8.0 Userland Bootstrap: The Birth of PID 1&lt;/head&gt;
    &lt;p&gt;The initialization of the XNU kernel culminates in mounting the root filesystem (the Signed System Volume) and creating the first userland process. In traditional UNIX systems, this is &lt;code&gt;init&lt;/code&gt; (PID 1). On macOS, this role is fulfilled by &lt;code&gt;launchd&lt;/code&gt;.&lt;/p&gt;
    &lt;p&gt;&lt;code&gt;launchd&lt;/code&gt; is not just a SysV-style init. It is:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;The process supervisor that manages the lifecycle of daemons and agents.&lt;/item&gt;
      &lt;item&gt;The Mach bootstrap server, providing the string-to-port name service for most of userland.&lt;/item&gt;
      &lt;item&gt;A central policy enforcement point for IPC visibility and service availability.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;In the Tahoe architecture, &lt;code&gt;launchd&lt;/code&gt; is also the first long-lived user process to run under the full scrutiny of the Trusted Execution Monitor (TXM) and associated integrity mechanisms. Its successful launch marks the handoff from the measured, firmware-controlled boot world to the userland environment.&lt;/p&gt;
    &lt;head rend="h3"&gt;8.1 &lt;code&gt;launchd&lt;/code&gt;: The Mach Port Broker&lt;/head&gt;
    &lt;p&gt;The transition from kernel mode to user mode is effectively one-way for the thread that becomes PID 1: once it crosses into userland, it never returns to the kernel in its original identity.&lt;/p&gt;
    &lt;p&gt;After early initialization in &lt;code&gt;bsd_init()&lt;/code&gt; (mounting root, bringing up the BSD subsystem), the kernel:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;p&gt;Spawns a special kernel thread (often referred to conceptually as the&lt;/p&gt;&lt;code&gt;bsdinit_task&lt;/code&gt;).&lt;/item&gt;
      &lt;item&gt;&lt;p&gt;Uses&lt;/p&gt;&lt;code&gt;bsd_utaskbootstrap()&lt;/code&gt;to:&lt;list rend="ul"&gt;&lt;item&gt;Allocate &lt;code&gt;initproc&lt;/code&gt;(PID 1) and its backing&lt;code&gt;task_t&lt;/code&gt;.&lt;/item&gt;&lt;item&gt;Load the &lt;code&gt;launchd&lt;/code&gt;Mach-O binary into that task via&lt;code&gt;load_init_program()&lt;/code&gt;.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;Allocate &lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;From this point on:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;launchd&lt;/code&gt;becomes the root of the userland process tree.&lt;/item&gt;
      &lt;item&gt;All subsequent processes are, ultimately, descendants of PID 1.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;launchd&lt;/code&gt;’s management of Mach ports and bootstrap namespaces becomes the primary mechanism by which services discover each other and enforce IPC-based policy.&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h4"&gt;8.1.1 Transition from Kernel to Userland: The First &lt;code&gt;execve&lt;/code&gt;&lt;/head&gt;
    &lt;p&gt;The kernel routine &lt;code&gt;bsd_init()&lt;/code&gt; (in &lt;code&gt;bsd/kern/bsd_init.c&lt;/code&gt;) orchestrates the end of early boot:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;&lt;p&gt;Root filesystem mount:&lt;/p&gt;&lt;lb/&gt;It ensures the Signed System Volume is mounted and ready.&lt;/item&gt;
      &lt;item&gt;&lt;p&gt;PID 1 construction (&lt;/p&gt;&lt;code&gt;bsd_utaskbootstrap&lt;/code&gt;/&lt;code&gt;cloneproc&lt;/code&gt;):&lt;lb/&gt;The kernel:&lt;list rend="ul"&gt;&lt;item&gt;Creates &lt;code&gt;initproc&lt;/code&gt;as PID 1 by cloning from the kernel’s internal template process, with special flags (&lt;code&gt;CLONEPROC_INITPROC&lt;/code&gt;).&lt;/item&gt;&lt;item&gt;Allocates the corresponding &lt;code&gt;task_t&lt;/code&gt;and thread structures.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;Creates &lt;/item&gt;
      &lt;item&gt;&lt;code&gt;load_init_program()&lt;/code&gt;– kernel-side&lt;code&gt;execve&lt;/code&gt;of&lt;code&gt;/sbin/launchd&lt;/code&gt;:&lt;lb/&gt;Instead of a user process calling&lt;code&gt;execve("/sbin/launchd", ...)&lt;/code&gt;, the kernel:&lt;list rend="ul"&gt;&lt;item&gt;&lt;p&gt;Loads the Mach-O for&lt;/p&gt;&lt;code&gt;/sbin/launchd&lt;/code&gt;(backed in modern systems by the OS Cryptex, even though the path appears as&lt;code&gt;/sbin/launchd&lt;/code&gt;).&lt;/item&gt;&lt;item&gt;&lt;p&gt;Constructs the initial user address space:&lt;/p&gt;&lt;list rend="ul"&gt;&lt;item&gt;Maps &lt;code&gt;__TEXT&lt;/code&gt;read/execute.&lt;/item&gt;&lt;item&gt;Maps &lt;code&gt;__DATA&lt;/code&gt;read/write.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;&lt;item&gt;Maps &lt;/item&gt;&lt;item&gt;&lt;p&gt;Sets up the initial user thread state (PC, stack, registers) as if an&lt;/p&gt;&lt;code&gt;execve&lt;/code&gt;had just succeeded.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;&lt;p&gt;Trust and integrity checks (conceptual model):&lt;/p&gt;&lt;lb/&gt;On Tahoe systems:&lt;list rend="ul"&gt;&lt;item&gt;&lt;p&gt;The code signature and CDHash of&lt;/p&gt;&lt;code&gt;launchd&lt;/code&gt;are validated against the Static Trust Cache and platform policy.&lt;/item&gt;&lt;item&gt;&lt;p&gt;TXM/SPTM participate in ensuring that:&lt;/p&gt;&lt;list rend="ul"&gt;&lt;item&gt;Only a measured, signed &lt;code&gt;launchd&lt;/code&gt;binary becomes PID 1.&lt;/item&gt;&lt;item&gt;Its text pages are mapped in a way that respects kernel integrity protection (no ad-hoc remapping to writable/executable later without violating SPTM policy).&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;&lt;item&gt;Only a measured, signed &lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The exact firmware call sequence is implementation detail, but the net effect is: if &lt;code&gt;launchd&lt;/code&gt; is not exactly the expected, signed binary, the system does not proceed into userland.&lt;/p&gt;
    &lt;p&gt;The &lt;code&gt;host_priv&lt;/code&gt; handoff&lt;/p&gt;
    &lt;p&gt;As part of bringing up the userland environment:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;
        &lt;p&gt;The system needs a trusted process that can:&lt;/p&gt;
        &lt;list rend="ul"&gt;
          &lt;item&gt;Talk to host-level interfaces (&lt;code&gt;host_get_special_port&lt;/code&gt;, etc.).&lt;/item&gt;
          &lt;item&gt;Manage systemwide services and kext/kc configuration.&lt;/item&gt;
        &lt;/list&gt;
      &lt;/item&gt;
      &lt;item&gt;Talk to host-level interfaces (&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;&lt;code&gt;launchd&lt;/code&gt; is that process. During or shortly after PID 1 construction:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;p&gt;The kernel ensures that&lt;/p&gt;&lt;code&gt;launchd&lt;/code&gt;can obtain the host-privileged port (&lt;code&gt;host_priv&lt;/code&gt;) by:&lt;list rend="ul"&gt;&lt;item&gt;Providing a host send right via initial special ports, or&lt;/item&gt;&lt;item&gt;Allowing &lt;code&gt;launchd&lt;/code&gt;to call&lt;code&gt;host_get_host_priv_port()&lt;/code&gt;successfully.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;&lt;p&gt;Subsequent privileged daemons (e.g.&lt;/p&gt;&lt;code&gt;kernelmanagerd&lt;/code&gt;) obtain their own host-level capabilities via&lt;code&gt;launchd&lt;/code&gt;-mediated configuration or direct&lt;code&gt;host_get_special_port&lt;/code&gt;calls, subject to entitlements.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;&lt;code&gt;launchd&lt;/code&gt; is therefore the first userland holder of host-level control needed to configure the rest of the system, but it is not necessarily the only holder for the entire lifetime of the OS.&lt;/p&gt;
    &lt;head rend="h4"&gt;8.1.2 Initializing the Bootstrap Port (Subset of the Name Service)&lt;/head&gt;
    &lt;p&gt;Mach does not provide any built-in string-based name service. Name→port mappings are implemented in userland by the bootstrap server, which on macOS is &lt;code&gt;launchd&lt;/code&gt;.&lt;/p&gt;
    &lt;p&gt;Bootstrap port assignment&lt;/p&gt;
    &lt;p&gt;Every task in XNU has a special port slot, &lt;code&gt;TASK_BOOTSTRAP_PORT&lt;/code&gt;. For PID 1:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;p&gt;When&lt;/p&gt;&lt;code&gt;launchd&lt;/code&gt;is created, the kernel associates a bootstrap server port with&lt;code&gt;launchd&lt;/code&gt;’s&lt;code&gt;TASK_BOOTSTRAP_PORT&lt;/code&gt;.&lt;/item&gt;
      &lt;item&gt;&lt;p&gt;For child processes spawned by&lt;/p&gt;&lt;code&gt;launchd&lt;/code&gt;, this slot is:&lt;list rend="ul"&gt;&lt;item&gt;Inherited from the parent, or&lt;/item&gt;&lt;item&gt;Replaced with a more restricted bootstrap port representing a subset namespace (e.g. per-user or per-session domain).&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;From userland’s perspective:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;bootstrap_port&lt;/code&gt;in the&lt;code&gt;bootstrap_*&lt;/code&gt;APIs (and the default XPC bootstrap connection) is whatever send right is stored in&lt;code&gt;TASK_BOOTSTRAP_PORT&lt;/code&gt;.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Namespace hierarchy (domains)&lt;/p&gt;
    &lt;p&gt;Modern &lt;code&gt;launchd&lt;/code&gt; organizes the bootstrap namespace into domains, which correspond roughly to what &lt;code&gt;launchctl&lt;/code&gt; exposes as specifiers:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;system/&lt;/code&gt;– The system-wide daemon domain (LaunchDaemons, root services).&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;user/&amp;lt;uid&amp;gt;/&lt;/code&gt;– Per-UID domains for LaunchAgents.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;gui/&amp;lt;uid&amp;gt;/&lt;/code&gt;– GUI domains for interactive sessions per user.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;login/&amp;lt;asid&amp;gt;/&lt;/code&gt;or&lt;code&gt;session/&amp;lt;asid&amp;gt;/&lt;/code&gt;– Per-login/per-ASID domains for specific authenticated sessions.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Each domain has:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Its own subset of registered service names.&lt;/item&gt;
      &lt;item&gt;Its own set of policies controlling access and visibility.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;All of these domains ultimately terminate in the same PID-1 &lt;code&gt;launchd&lt;/code&gt; process, but they appear as distinct bootstrap ports and namespaces from the point of view of tasks.&lt;/p&gt;
    &lt;p&gt;The bootstrap port in practice&lt;/p&gt;
    &lt;p&gt;When a daemon is launched, it typically:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;p&gt;Receives a bootstrap port (for its domain) in its&lt;/p&gt;&lt;code&gt;TASK_BOOTSTRAP_PORT&lt;/code&gt;.&lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Calls:&lt;/p&gt;
        &lt;code&gt;bootstrap_check_in(bootstrap_port, "com.apple.locationd", &amp;amp;service_port);&lt;/code&gt;
      &lt;/item&gt;
      &lt;item&gt;&lt;code&gt;launchd&lt;/code&gt;receives this message on the appropriate domain’s bootstrap port and:&lt;list rend="ul"&gt;&lt;item&gt;Verifies, via the audit token, that the caller is the process associated with the job for &lt;code&gt;"com.apple.locationd"&lt;/code&gt;.&lt;/item&gt;&lt;item&gt;Transfers the receive right for the pre-allocated service port into the daemon’s IPC space.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;Verifies, via the audit token, that the caller is the process associated with the job for &lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Client processes:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;p&gt;Use&lt;/p&gt;&lt;code&gt;bootstrap_look_up()&lt;/code&gt;or&lt;code&gt;xpc_connection_create_mach_service()&lt;/code&gt;on their bootstrap port.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;launchd&lt;/code&gt;resolves the name in the caller’s domain and either:&lt;list rend="ul"&gt;&lt;item&gt;Returns a send right to the service port, or&lt;/item&gt;&lt;item&gt;Fails with an error if the service does not exist or is not visible in that domain.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;This mechanism:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Implements the lazy, on-demand launch of services.&lt;/item&gt;
      &lt;item&gt;Enforces which names exist and are reachable in each domain, with &lt;code&gt;launchd&lt;/code&gt;as the central broker.&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h4"&gt;8.1.3 Parsing &lt;code&gt;launchd.plist&lt;/code&gt; and the Binary Protocol for XPC Service Lookups&lt;/head&gt;
    &lt;p&gt;&lt;code&gt;launchd&lt;/code&gt;’s configuration is driven by property lists (&lt;code&gt;.plist&lt;/code&gt;) describing jobs, located under:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;
        &lt;code&gt;/System/Library/LaunchDaemons&lt;/code&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;code&gt;/Library/LaunchDaemons&lt;/code&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;code&gt;/System/Library/LaunchAgents&lt;/code&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;code&gt;/Library/LaunchAgents&lt;/code&gt;
      &lt;/item&gt;
      &lt;item&gt;Per-user equivalents under &lt;code&gt;~/Library/LaunchAgents&lt;/code&gt;&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;At startup (and when configuration changes), &lt;code&gt;launchd&lt;/code&gt; parses these plists once and compiles them into an internal data structure representing:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Jobs (labels, binaries, arguments, environments).&lt;/item&gt;
      &lt;item&gt;Their MachServices.&lt;/item&gt;
      &lt;item&gt;Their target domain (system/user/gui/login).&lt;/item&gt;
      &lt;item&gt;Policy metadata (KeepAlive, RunAtLoad, sockets, etc.).&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The &lt;code&gt;MachServices&lt;/code&gt; dictionary&lt;/p&gt;
    &lt;p&gt;A typical job might include:&lt;/p&gt;
    &lt;code&gt;&amp;lt;key&amp;gt;MachServices&amp;lt;/key&amp;gt;
&amp;lt;dict&amp;gt;
    &amp;lt;key&amp;gt;com.apple.securityd&amp;lt;/key&amp;gt;
    &amp;lt;true/&amp;gt;
&amp;lt;/dict&amp;gt;
&lt;/code&gt;
    &lt;p&gt;This instructs &lt;code&gt;launchd&lt;/code&gt; to:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;p&gt;Allocate a Mach receive right for&lt;/p&gt;&lt;code&gt;"com.apple.securityd"&lt;/code&gt;when loading the job.&lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Hold that right until:&lt;/p&gt;
        &lt;list rend="ul"&gt;
          &lt;item&gt;A client first looks up &lt;code&gt;"com.apple.securityd"&lt;/code&gt;, and&lt;/item&gt;
          &lt;item&gt;The job has started and checked in.&lt;/item&gt;
        &lt;/list&gt;
      &lt;/item&gt;
      &lt;item&gt;A client first looks up &lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;&lt;code&gt;launchd&lt;/code&gt; remembers:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;The mapping &lt;code&gt;"com.apple.securityd" → (job, receive-right)&lt;/code&gt;.&lt;/item&gt;
      &lt;item&gt;Which domain that name belongs to.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Demand launching (lazy activation)&lt;/p&gt;
    &lt;p&gt;The common path for a client is:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;
        &lt;p&gt;The client calls:&lt;/p&gt;
        &lt;code&gt;xpc_connection_t conn = xpc_connection_create_mach_service("com.apple.securityd", dispatch_get_main_queue(), 0);&lt;/code&gt;
      &lt;/item&gt;
      &lt;item&gt;&lt;code&gt;libxpc&lt;/code&gt;sends a message to the caller’s bootstrap port asking for&lt;code&gt;"com.apple.securityd"&lt;/code&gt;.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;launchd&lt;/code&gt;:&lt;list rend="ul"&gt;&lt;item&gt;&lt;p&gt;Looks up&lt;/p&gt;&lt;code&gt;"com.apple.securityd"&lt;/code&gt;in the caller’s domain.&lt;/item&gt;&lt;item&gt;&lt;p&gt;If the job is not running:&lt;/p&gt;&lt;list rend="ul"&gt;&lt;item&gt;Spawns the configured binary via &lt;code&gt;posix_spawn&lt;/code&gt;.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;&lt;item&gt;Spawns the configured binary via &lt;/item&gt;&lt;item&gt;&lt;p&gt;Waits for the daemon to call&lt;/p&gt;&lt;code&gt;bootstrap_check_in()&lt;/code&gt;.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;&lt;p&gt;When the daemon calls&lt;/p&gt;&lt;code&gt;bootstrap_check_in()&lt;/code&gt;:&lt;list rend="ul"&gt;&lt;item&gt;&lt;code&gt;launchd&lt;/code&gt;confirms the caller matches the job.&lt;/item&gt;&lt;item&gt;Transfers the receive right for the service port into the daemon’s IPC space.&lt;/item&gt;&lt;item&gt;Returns a send right to the client.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;From the client’s perspective, the detail is hidden: it just sees an XPC connection that becomes ready.&lt;/p&gt;
    &lt;p&gt;Binary protocols: MIG vs XPC&lt;/p&gt;
    &lt;p&gt;Historically:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;launchd&lt;/code&gt;exposed a MIG-based API defined in&lt;code&gt;bootstrap.defs&lt;/code&gt;, including:&lt;list rend="ul"&gt;&lt;item&gt;&lt;code&gt;bootstrap_look_up&lt;/code&gt;&lt;/item&gt;&lt;item&gt;&lt;code&gt;bootstrap_check_in&lt;/code&gt;&lt;/item&gt;&lt;item&gt;&lt;code&gt;bootstrap_create_server&lt;/code&gt;&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;These are still present and supported.&lt;/p&gt;
      &lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Modern userland prefers XPC, which:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Packages requests into binary dictionaries and sends them over Mach ports.&lt;/item&gt;
      &lt;item&gt;Allows richer types (arrays, dictionaries, file descriptors, additional Mach ports) to be transported in a structured way.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Inside &lt;code&gt;launchd&lt;/code&gt;:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;
        &lt;p&gt;A central Mach receive loop demultiplexes incoming messages:&lt;/p&gt;
        &lt;list rend="ul"&gt;
          &lt;item&gt;MIG messages (identified by the Mach message ID) are routed to autogenerated handlers from &lt;code&gt;bootstrap.defs&lt;/code&gt;.&lt;/item&gt;
          &lt;item&gt;XPC messages (identified by XPC magic/version fields in the payload) are parsed into XPC objects and dispatched to XPC-specific handlers (job control, service lookup, status queries).&lt;/item&gt;
        &lt;/list&gt;
      &lt;/item&gt;
      &lt;item&gt;MIG messages (identified by the Mach message ID) are routed to autogenerated handlers from &lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Domain-aware policy&lt;/p&gt;
    &lt;p&gt;On Tahoe-era systems, the bootstrap namespace is also used as a policy boundary:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;
        &lt;p&gt;The kernel attaches an audit token to each Mach message, including:&lt;/p&gt;
        &lt;list rend="ul"&gt;
          &lt;item&gt;PID, UID, GID, ASID, and other identity information.&lt;/item&gt;
        &lt;/list&gt;
      &lt;/item&gt;
      &lt;item&gt;&lt;code&gt;launchd&lt;/code&gt;inspects:&lt;list rend="ul"&gt;&lt;item&gt;The audit token.&lt;/item&gt;&lt;item&gt;The caller’s entitlements and sandbox profile (when available).&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;It enforces constraints such as:&lt;/p&gt;
        &lt;list rend="ul"&gt;
          &lt;item&gt;Only processes with appropriate &lt;code&gt;mach-lookup&lt;/code&gt;entitlements can resolve certain global services.&lt;/item&gt;
          &lt;item&gt;Sandboxed apps see only a restricted subset of services in their effective bootstrap domain.&lt;/item&gt;
        &lt;/list&gt;
      &lt;/item&gt;
      &lt;item&gt;Only processes with appropriate &lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;In other words:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;The bootstrap namespace is not just a map from string to port.&lt;/item&gt;
      &lt;item&gt;It is also a filter, with &lt;code&gt;launchd&lt;/code&gt;acting as the enforcement point that decides which ports a given client is even allowed to know exist.&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h3"&gt;8.2 The Dynamic Linker (&lt;code&gt;dyld&lt;/code&gt;)&lt;/head&gt;
    &lt;p&gt;If &lt;code&gt;launchd&lt;/code&gt; is the architect of the userland process hierarchy, &lt;code&gt;dyld&lt;/code&gt; (the dynamic linker) is the component that materializes each process image. In the macOS ecosystem, &lt;code&gt;dyld&lt;/code&gt; is not merely a library loader; it is a privileged extension of the kernel’s execution model, responsible for:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Loading the main executable and its dependent images.&lt;/item&gt;
      &lt;item&gt;Enforcing Library Validation policies.&lt;/item&gt;
      &lt;item&gt;Applying Address Space Layout Randomization (ASLR).&lt;/item&gt;
      &lt;item&gt;On arm64e, integrating with Pointer Authentication (PAC).&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;On Apple Silicon and in the Tahoe architecture, &lt;code&gt;dyld&lt;/code&gt; has been heavily reworked. Legacy rebasing mechanisms have been replaced with Chained Fixups to enable page-in linking, and &lt;code&gt;dyld&lt;/code&gt;’s decisions are tightly coupled with the kernel’s memory management, which itself is constrained by the Secure Page Table Monitor (SPTM).&lt;/p&gt;
    &lt;head rend="h4"&gt;8.2.1 Mapping the Dyld Shared Cache (DSC)&lt;/head&gt;
    &lt;p&gt;The Dyld Shared Cache (DSC) is a defining feature of the macOS userland memory layout. It is a massive, pre-linked binary (often &amp;gt;4 GiB) that merges the text and data segments of most system frameworks (&lt;code&gt;CoreFoundation&lt;/code&gt;, &lt;code&gt;libSystem&lt;/code&gt;, &lt;code&gt;Foundation&lt;/code&gt;, etc.).&lt;/p&gt;
    &lt;p&gt;The Shared Region:&lt;/p&gt;
    &lt;p&gt;To optimize memory and TLB usage, the kernel reserves a Shared Region in every process:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;On arm64, this region typically begins at a high canonical address (e.g., around &lt;code&gt;0x180000000&lt;/code&gt;in current releases).&lt;/item&gt;
      &lt;item&gt;The DSC is mapped into this region, and the backing physical pages are shared across all processes.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;To satisfy &lt;code&gt;W^X&lt;/code&gt; and fine-grained data protection, the DSC is split into multiple mappings:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;&lt;code&gt;__TEXT&lt;/code&gt;(RX):&lt;lb/&gt;Immutable code and constant data that must never be written at runtime.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;__DATA_CONST&lt;/code&gt;(RO):&lt;lb/&gt;Read-only data that can be pre-relocated at build time and never changes at runtime (e.g., constant pointers, vtables).&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;__DATA_DIRTY&lt;/code&gt;(RW):&lt;lb/&gt;Data that must diverge per process (e.g., Objective-C class realization state, global variables).&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The Tahoe/SPTM Constraint:&lt;/p&gt;
    &lt;p&gt;On Tahoe systems, the mapping of the DSC is mediated by SPTM:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;&lt;p&gt;Source from Cryptex:&lt;/p&gt;&lt;lb/&gt;The DSC binaries and associated metadata reside in the OS Cryptex, typically under:&lt;code&gt;/System/Cryptexes/OS/System/Library/dyld/&lt;/code&gt;&lt;/item&gt;
      &lt;item&gt;&lt;p&gt;SPTM-Supervised Mapping:&lt;/p&gt;&lt;lb/&gt;When XNU initializes the shared region, it installs page tables for the DSC segments in each process’s address space. On SPTM-enabled systems:&lt;list rend="ul"&gt;&lt;item&gt;Each PTE change for DSC pages is vetted by SPTM.&lt;/item&gt;&lt;item&gt;The physical frames backing &lt;code&gt;__TEXT&lt;/code&gt;are associated with a “immutable code” state; once mapped, they are not permitted to transition to writable mappings under EL1 control alone.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;&lt;p&gt;Immutable Code under a Compromised Kernel:&lt;/p&gt;&lt;lb/&gt;Because SPTM operates at a higher privilege level than the kernel:&lt;list rend="ul"&gt;&lt;item&gt;Arbitrary EL1 writes cannot simply flip the DSC &lt;code&gt;__TEXT&lt;/code&gt;pages to&lt;code&gt;RWX&lt;/code&gt;.&lt;/item&gt;&lt;item&gt;Any attempt to create new executable mappings for code that has not been validated by TXM can be blocked by SPTM when the Execute bit is requested.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;Arbitrary EL1 writes cannot simply flip the DSC &lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Practically, this means traditional techniques that patch system libraries in-place from a kernel exploit are structurally constrained. Attackers must rely on indirection (e.g., hooks via &lt;code&gt;__DATA_DIRTY&lt;/code&gt;, PLT-style trampolines, or userland injecting new, separately validated images) rather than overwriting shared-cache code directly.&lt;/p&gt;
    &lt;head rend="h4"&gt;8.2.2 RE Focus: Code Signature Validation (&lt;code&gt;fcntl(F_ADDFILESIGS)&lt;/code&gt;) and the Call to TXM&lt;/head&gt;
    &lt;p&gt;&lt;code&gt;dyld&lt;/code&gt; is the primary enforcer of Library Validation for userland. The OS policy is:&lt;/p&gt;
    &lt;quote&gt;
      &lt;p&gt;A process can only execute code that has been validated by the platform’s code-signing machinery, and for hardened processes, only from binaries signed by Apple or by the same Team ID as the main executable.&lt;/p&gt;
    &lt;/quote&gt;
    &lt;p&gt;When &lt;code&gt;dyld&lt;/code&gt; loads a Mach-O image, either during initial process launch or via &lt;code&gt;dlopen&lt;/code&gt;, the high-level flow is:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;&lt;code&gt;mmap&lt;/code&gt;of the file:&lt;lb/&gt;The file is mapped into the address space with appropriate protections (typically at least readable, but not yet executable).&lt;/item&gt;
      &lt;item&gt;&lt;p&gt;Signature Registration via&lt;/p&gt;&lt;code&gt;F_ADDFILESIGS_RETURN&lt;/code&gt;:&lt;code&gt;dyld&lt;/code&gt;calls:&lt;code&gt;struct fsignatures fs; fcntl(fd, F_ADDFILESIGS_RETURN, &amp;amp;fs);&lt;/code&gt;&lt;p&gt;The&lt;/p&gt;&lt;code&gt;fsignatures_t&lt;/code&gt;structure informs the kernel where the code-signature blob (CMS) resides in the file and requests that this file be authorized for executable mappings.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;On older architectures, the kernel (plus AMFI) parsed and validated the CMS blob in EL1. On Tahoe systems, validation is mediated by TXM, and enforcement by SPTM.&lt;/p&gt;
    &lt;p&gt;Conceptual Kernel → TXM Flow:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;&lt;p&gt;Marshalling:&lt;/p&gt;&lt;lb/&gt;The kernel identifies the physical frames that contain:&lt;list rend="ul"&gt;&lt;item&gt;The Mach-O Code Directory.&lt;/item&gt;&lt;item&gt;The CMS code-signature blob.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;&lt;p&gt;Secure Monitor Invocation:&lt;/p&gt;&lt;lb/&gt;The kernel issues a secure call into TXM (e.g., via a&lt;code&gt;GENTER&lt;/code&gt;-style transition), passing:&lt;list rend="ul"&gt;&lt;item&gt;References to those frames.&lt;/item&gt;&lt;item&gt;Metadata for the code-signing request (team identifier, flags, platform binary vs third-party, etc.).&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;&lt;p&gt;TXM Verification:&lt;/p&gt;&lt;lb/&gt;Inside TXM:&lt;list rend="ul"&gt;&lt;item&gt;&lt;p&gt;The CMS blob is parsed and the signature chain is validated against:&lt;/p&gt;&lt;list rend="ul"&gt;&lt;item&gt;The Static Trust Cache (for platform binaries shipped with the OS/Cryptexes), or&lt;/item&gt;&lt;item&gt;Apple’s CA hierarchy (for third-party code).&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;&lt;item&gt;&lt;p&gt;Policy constraints are applied (e.g., hardened runtime flags, entitlements, revocation status).&lt;/p&gt;&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;&lt;p&gt;Verdict and SPTM Tagging:&lt;/p&gt;&lt;lb/&gt;TXM returns a verdict to the kernel. If the code is accepted:&lt;list rend="ul"&gt;&lt;item&gt;SPTM is updated with metadata that associates the relevant CDHash and physical frames with a “blessed for execution” state.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;&lt;p&gt;Page-Fault-Time Enforcement:&lt;/p&gt;&lt;lb/&gt;When the process later executes into that image:&lt;list rend="ul"&gt;&lt;item&gt;&lt;p&gt;The first access to a given code page triggers a page fault.&lt;/p&gt;&lt;/item&gt;&lt;item&gt;&lt;p&gt;The kernel attempts to install an executable PTE for that frame.&lt;/p&gt;&lt;/item&gt;&lt;item&gt;&lt;p&gt;SPTM intercepts the attempt and checks:&lt;/p&gt;&lt;list rend="ul"&gt;&lt;item&gt;Whether the frame was previously “blessed” by TXM for this CDHash.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;&lt;item&gt;&lt;p&gt;If the check fails, the mapping is refused and the process is terminated (e.g., with&lt;/p&gt;&lt;code&gt;SIGKILL | Code Signature Invalid&lt;/code&gt;).&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The exact internal data structures and opcodes used between kernel, TXM, and SPTM are firmware implementation details. From the perspective of &lt;code&gt;dyld&lt;/code&gt;, the observable behaviour is that &lt;code&gt;F_ADDFILESIGS_RETURN&lt;/code&gt; can succeed or fail, and that executing unblessed code results in immediate termination, independent of kernel cooperation.&lt;/p&gt;
    &lt;p&gt;RE Tip:&lt;lb/&gt; When a process dies immediately after &lt;code&gt;dlopen&lt;/code&gt; or after loading a plugin/framework, and &lt;code&gt;dyld&lt;/code&gt; reports code-signature errors, the proximate userland symptom is often a failed &lt;code&gt;fcntl(F_ADDFILESIGS_RETURN)&lt;/code&gt; or an immediate crash on first execution into the library. The authoritative reason (revoked certificate, missing trust-cache entry, policy violation) lives in TXM/SPTM logs and kernel log events, which may be partially redacted on production builds.&lt;/p&gt;
    &lt;head rend="h4"&gt;8.2.3 ASLR in Userland: Chained Fixups and the Death of &lt;code&gt;dyld_info&lt;/code&gt;&lt;/head&gt;
    &lt;p&gt;Modern &lt;code&gt;dyld&lt;/code&gt; (dyld 4.x and later) on Apple Silicon has effectively deprecated the legacy &lt;code&gt;LC_DYLD_INFO&lt;/code&gt; rebasing/binding opcodes in favour of Chained Fixups (&lt;code&gt;LC_DYLD_CHAINED_FIXUPS&lt;/code&gt;). This transition is not just a performance optimization; it is a fundamental change to how relocation metadata is encoded, tightly integrating ASLR and, on arm64e, PAC.&lt;/p&gt;
    &lt;p&gt;Limitations of Legacy Rebasing:&lt;/p&gt;
    &lt;p&gt;The previous model stored relocation metadata as a stream of opcodes (&lt;code&gt;REBASE_OPCODE_DO_*&lt;/code&gt;, &lt;code&gt;BIND_OPCODE_*&lt;/code&gt;) that described where in &lt;code&gt;__DATA&lt;/code&gt; to add the ASLR slide and how to bind imports. At launch, &lt;code&gt;dyld&lt;/code&gt; walked these opcode streams and:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Touched every page that contained a relocatable pointer.&lt;/item&gt;
      &lt;item&gt;Dirtying pages that might never be read, impacting both memory footprint and cache behaviour.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Chained Fixups: On-Disk Representation:&lt;/p&gt;
    &lt;p&gt;In the chained fixup model, on-disk “pointers” in the &lt;code&gt;__DATA&lt;/code&gt; segments are actually encoded metadata. For each image:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;LC_DYLD_CHAINED_FIXUPS&lt;/code&gt;points to a&lt;code&gt;dyld_chained_fixups_header&lt;/code&gt;.&lt;/item&gt;
      &lt;item&gt;&lt;p&gt;This header references a&lt;/p&gt;&lt;code&gt;dyld_chained_starts_in_image&lt;/code&gt;structure, which contains:&lt;list rend="ul"&gt;&lt;item&gt;Per-segment start tables (&lt;code&gt;dyld_chained_starts_in_segment&lt;/code&gt;), and&lt;/item&gt;&lt;item&gt;For each participating segment, an array giving the offset of the first fixup in each 16 KiB page (or &lt;code&gt;0xFFFF&lt;/code&gt;if the page has none).&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;Per-segment start tables (&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;At each fixup location, the file contains a 64-bit encoded value such as &lt;code&gt;dyld_chained_ptr_64_rebase&lt;/code&gt; or &lt;code&gt;dyld_chained_ptr_arm64e&lt;/code&gt;:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;
        &lt;p&gt;A subset of bits encode:&lt;/p&gt;
        &lt;list rend="ul"&gt;
          &lt;item&gt;The &lt;code&gt;next&lt;/code&gt;delta (in 4-byte units) to the next fixup in the same page.&lt;/item&gt;
          &lt;item&gt;The &lt;code&gt;target&lt;/code&gt;(either an offset into&lt;code&gt;__TEXT&lt;/code&gt;for rebasing or an ordinal into the import table for binding).&lt;/item&gt;
          &lt;item&gt;For arm64e, authentication flags and diversity bits.&lt;/item&gt;
        &lt;/list&gt;
      &lt;/item&gt;
      &lt;item&gt;The &lt;/item&gt;
      &lt;item&gt;&lt;p&gt;A&lt;/p&gt;&lt;code&gt;next&lt;/code&gt;value of&lt;code&gt;0&lt;/code&gt;terminates the chain for that page.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Page-In Linking (Lazy Fixups):&lt;/p&gt;
    &lt;p&gt;With chained fixups, &lt;code&gt;dyld&lt;/code&gt; no longer performs a global sweep at launch:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;&lt;p&gt;Initial Mapping:&lt;/p&gt;&lt;lb/&gt;The image is mapped into memory with its&lt;code&gt;__TEXT&lt;/code&gt;and&lt;code&gt;__DATA&lt;/code&gt;segments, but most&lt;code&gt;__DATA&lt;/code&gt;pages have not yet been faulted in.&lt;/item&gt;
      &lt;item&gt;&lt;p&gt;First Access / Page Fault:&lt;/p&gt;&lt;lb/&gt;When the process first reads or writes through a pointer in&lt;code&gt;__DATA&lt;/code&gt;that resides on a page with chained fixups:&lt;list rend="ul"&gt;&lt;item&gt;A page fault is triggered.&lt;/item&gt;&lt;item&gt;The kernel or a user-mode handler notes that this page has pending fixups.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;&lt;p&gt;Chain Walk:&lt;/p&gt;&lt;lb/&gt;The fixup logic:&lt;list rend="ul"&gt;&lt;item&gt;Consults the per-page start offset from &lt;code&gt;dyld_chained_starts_in_image&lt;/code&gt;.&lt;/item&gt;&lt;item&gt;Walks the chain by following &lt;code&gt;next&lt;/code&gt;deltas until the chain terminates.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;Consults the per-page start offset from &lt;/item&gt;
      &lt;item&gt;&lt;p&gt;Applying Fixups:&lt;/p&gt;&lt;lb/&gt;For each encoded “pointer”:&lt;list rend="ul"&gt;&lt;item&gt;&lt;p&gt;The&lt;/p&gt;&lt;code&gt;target&lt;/code&gt;is interpreted as:&lt;list rend="ul"&gt;&lt;item&gt;A &lt;code&gt;__TEXT&lt;/code&gt;offset to be combined with the ASLR slide (for rebasing), or&lt;/item&gt;&lt;item&gt;An import ordinal resolved to a symbol address (for binding).&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;&lt;item&gt;A &lt;/item&gt;&lt;item&gt;&lt;p&gt;On arm64e, the final pointer is authenticated:&lt;/p&gt;&lt;list rend="ul"&gt;&lt;item&gt;&lt;code&gt;PAC( Base + Offset, Key, Context/Discriminator )&lt;/code&gt;is computed using process-specific PAC keys.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;&lt;item&gt;&lt;p&gt;The 64-bit metadata word on the page is overwritten with the final, signed, slid pointer.&lt;/p&gt;&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;&lt;p&gt;After Fixup:&lt;/p&gt;&lt;lb/&gt;The page is now dirty (because the encoded metadata was overwritten), but only the pages that are actually accessed incur this cost.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;PAC Integration (&lt;code&gt;DYLD_CHAINED_PTR_ARM64E&lt;/code&gt;):&lt;/p&gt;
    &lt;p&gt;On arm64e, fixup entries use formats like &lt;code&gt;DYLD_CHAINED_PTR_ARM64E&lt;/code&gt; and &lt;code&gt;DYLD_CHAINED_PTR_ARM64E_AUTH_*&lt;/code&gt;:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;
        &lt;p&gt;Fields encode:&lt;/p&gt;
        &lt;list rend="ul"&gt;
          &lt;item&gt;Key selection (instruction/data key).&lt;/item&gt;
          &lt;item&gt;Diversity bits (salt).&lt;/item&gt;
          &lt;item&gt;Discriminator/context.&lt;/item&gt;
        &lt;/list&gt;
      &lt;/item&gt;
      &lt;item&gt;&lt;code&gt;dyld&lt;/code&gt;computes PAC for each pointer at fixup time:&lt;list rend="ul"&gt;&lt;item&gt;&lt;p&gt;Ensuring that:&lt;/p&gt;&lt;list rend="ul"&gt;&lt;item&gt;The pointer is valid only under the current process’s PAC keys.&lt;/item&gt;&lt;item&gt;Attempts to transplant the pointer into another process or mutate the context bits will cause PAC failures at use.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;ASLR and PAC are therefore coupled at the moment a page is faulted in and its fixups applied.&lt;/p&gt;
    &lt;p&gt;Reverse-Engineering Implications:&lt;/p&gt;
    &lt;p&gt;For reverse engineers, chained fixups fundamentally alter the static picture of binaries:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Raw on-disk &lt;code&gt;__DATA&lt;/code&gt;segments no longer contain meaningful absolute pointers; they contain encoded metadata words.&lt;/item&gt;
      &lt;item&gt;Naive disassembly or CFG reconstruction that ignores chained fixups will see “garbage” addresses and broken callgraphs.&lt;/item&gt;
      &lt;item&gt;Correct analysis requires simulating &lt;code&gt;dyld&lt;/code&gt;’s fixup engine to compute the final pointers.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Tooling must therefore:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Parse &lt;code&gt;LC_DYLD_CHAINED_FIXUPS&lt;/code&gt;and the associated structs.&lt;/item&gt;
      &lt;item&gt;Walk chains on a per-page basis.&lt;/item&gt;
      &lt;item&gt;Optionally write a “de-chained” view of the file for analysis.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Examples:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;ipsw dyld fixup&lt;/code&gt;and related tooling can emit a fixed-up view of Mach-O binaries extracted from DSCs.&lt;/item&gt;
      &lt;item&gt;Apple’s &lt;code&gt;dyld_shared_cache_util&lt;/code&gt;(and its open-source analogues) can extract and apply fixups to DSC residents.&lt;/item&gt;
      &lt;item&gt;Recent versions of IDA Pro and Ghidra detect &lt;code&gt;LC_DYLD_CHAINED_FIXUPS&lt;/code&gt;and apply fixups within the analysis database, even though the on-disk file remains in its chained form.&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h3"&gt;8.3 Cryptexes (Cryptographic Extensions)&lt;/head&gt;
    &lt;p&gt;The introduction of the Signed System Volume (SSV) in macOS Big Sur solved the problem of persistence: by anchoring the root filesystem in a cryptographic hash verified by iBoot, Apple ensured that the core OS partition is immutable. However, this immutability created an operational problem: patching a single high-level component (for example, &lt;code&gt;dyld&lt;/code&gt; or WebKit) would require resealing and redistributing the entire SSV.&lt;/p&gt;
    &lt;p&gt;To resolve the tension between immutability and agility, Apple introduced Cryptexes (Cryptographic Extensions). A Cryptex is a cryptographically sealed, versioned filesystem image that can be mounted and “grafted” into the system hierarchy at boot or runtime. In the Tahoe architecture, Cryptexes are the primary mechanism for the Split OS design, decoupling the kernel/BSD and low-level system from rapidly evolving userland components.&lt;/p&gt;
    &lt;head rend="h4"&gt;8.3.1 The “Split OS” Architecture: &lt;code&gt;/System/Cryptexes/OS&lt;/code&gt;&lt;/head&gt;
    &lt;p&gt;In modern macOS, the logical root filesystem (&lt;code&gt;/&lt;/code&gt;) is effectively a skeleton:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;it contains the sealed snapshot of the kernel and core boot artifacts on the SSV, and&lt;/item&gt;
      &lt;item&gt;it carries just enough structure to support bootstrapping.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The bulk of high-level userland—&lt;code&gt;dyld&lt;/code&gt;, &lt;code&gt;libSystem&lt;/code&gt;, system frameworks, many daemons—resides in the OS Cryptex.&lt;/p&gt;
    &lt;p&gt;The Image4 Container&lt;/p&gt;
    &lt;p&gt;A Cryptex is distributed as an Image4 (&lt;code&gt;img4&lt;/code&gt;) container:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;p&gt;Payload (&lt;/p&gt;&lt;code&gt;IM4P&lt;/code&gt;):&lt;lb/&gt;A disk image (typically APFS) containing a filesystem hierarchy.&lt;/item&gt;
      &lt;item&gt;&lt;p&gt;Manifest (&lt;/p&gt;&lt;code&gt;IM4M&lt;/code&gt;):&lt;lb/&gt;A signed metadata blob that binds the payload to Apple’s root keys. For some Cryptexes, the manifest can be personalized (tied to ECID, board, and security domain), preventing naive replay of mismatched OS components onto other devices.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Mounting and Grafting&lt;/p&gt;
    &lt;p&gt;Cryptexes are not mounted via a user-visible &lt;code&gt;mount(2)&lt;/code&gt; call. They are integrated into the system by early boot code and the APFS driver:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;&lt;p&gt;iBoot handoff:&lt;/p&gt;&lt;lb/&gt;iBoot locates the OS Cryptex image (commonly on the Preboot volume), validates the&lt;code&gt;IM4M&lt;/code&gt;signature against hardware-anchored keys, and arranges for the payload to be visible to the kernel.&lt;/item&gt;
      &lt;item&gt;&lt;p&gt;Trust cache extraction:&lt;/p&gt;&lt;lb/&gt;Inside the Cryptex, a binary trust cache (for example,&lt;code&gt;wrapper/trustcache&lt;/code&gt;) lists CDHashes for all executable content in that Cryptex.&lt;/item&gt;
      &lt;item&gt;&lt;p&gt;TXM ingestion:&lt;/p&gt;&lt;lb/&gt;Before the filesystem is grafted, this trust cache is provided to TXM. TXM verifies its signature and, on success, merges the hashes into the platform’s Static Trust Cache for that boot.&lt;/item&gt;
      &lt;item&gt;&lt;p&gt;APFS grafting / firmlinks:&lt;/p&gt;&lt;lb/&gt;The APFS driver performs a graft operation that logically attaches the Cryptex under:&lt;code&gt;/System/Cryptexes/OS&lt;/code&gt;&lt;p&gt;and uses firmlinks or equivalent redirections so that paths like:&lt;/p&gt;&lt;code&gt;/usr/lib/libSystem.B.dylib /System/Library/Frameworks/CoreFoundation.framework/...&lt;/code&gt;&lt;p&gt;are transparently resolved into the OS Cryptex, even though the SSV copy of&lt;/p&gt;&lt;code&gt;/usr&lt;/code&gt;and&lt;code&gt;/System/Library&lt;/code&gt;is skeletal.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;From a reverse-engineering perspective, the “real” binaries of interest (current &lt;code&gt;dyld&lt;/code&gt;, system frameworks, many daemons) live under &lt;code&gt;/System/Cryptexes/OS/...&lt;/code&gt;. Paths under &lt;code&gt;/System/Library&lt;/code&gt; or &lt;code&gt;/usr/lib&lt;/code&gt; may be firmlinked views pointing back into this Cryptex.&lt;/p&gt;
    &lt;head rend="h4"&gt;8.3.2 Rapid Security Response (RSR): Patching via Overlay Cryptexes&lt;/head&gt;
    &lt;p&gt;The Cryptex mechanism enables Rapid Security Response (RSR): security updates that patch critical components without requiring a full OS update or resealing of the SSV.&lt;/p&gt;
    &lt;p&gt;Patch Cryptexes&lt;/p&gt;
    &lt;p&gt;An RSR is delivered as an additional Cryptex:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;it usually contains only the components that changed (for example, updated dyld shared caches or WebKit frameworks),&lt;/item&gt;
      &lt;item&gt;it ships with its own Image4 manifest and trust cache, validated similarly to the base OS Cryptex.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Overlay / Union Mounting&lt;/p&gt;
    &lt;p&gt;When an RSR is applied:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;&lt;p&gt;Staging (&lt;/p&gt;&lt;code&gt;cryptexd&lt;/code&gt;):&lt;lb/&gt;The&lt;code&gt;cryptexd&lt;/code&gt;daemon orchestrates download, local verification, and placement of the new Cryptex image (typically onto the Preboot volume), and updates boot policy so early boot components know it exists.&lt;/item&gt;
      &lt;item&gt;&lt;p&gt;Verification and trust cache update:&lt;/p&gt;&lt;lb/&gt;During boot, the RSR Cryptex’s manifest is verified. Its embedded trust cache is ingested by TXM so that binaries from the RSR are eligible for execution.&lt;/item&gt;
      &lt;item&gt;&lt;p&gt;Overlaying the OS Cryptex:&lt;/p&gt;&lt;lb/&gt;The kernel overlays the RSR Cryptex on top of the base OS Cryptex using a union-style strategy:&lt;list rend="ul"&gt;&lt;item&gt;if a path exists in the RSR Cryptex, that version takes precedence;&lt;/item&gt;&lt;item&gt;otherwise, the VFS falls back to the underlying base OS Cryptex content.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The effective runtime view is:&lt;/p&gt;
    &lt;code&gt;SSV  +  OS Cryptex  +  (optional) RSR Cryptex overlay
&lt;/code&gt;
    &lt;p&gt;with VFS and firmlink logic ensuring a coherent &lt;code&gt;/System&lt;/code&gt; and &lt;code&gt;/usr&lt;/code&gt; layout.&lt;/p&gt;
    &lt;p&gt;Reversibility and Failure Handling&lt;/p&gt;
    &lt;p&gt;RSRs are designed to be reversible:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;p&gt;Atomicity:&lt;/p&gt;&lt;lb/&gt;Boot policy ensures the system is either fully in “base OS” state or in “base OS + specific RSR overlay” state. Partial application is not supported.&lt;/item&gt;
      &lt;item&gt;&lt;p&gt;Rollback:&lt;/p&gt;&lt;lb/&gt;If repeated boots under a given RSR Cryptex fail (for example, due to a regression), the boot chain can mark that RSR as inactive and revert to the base OS Cryptex on subsequent boots, without modifying the SSV.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Security and RE Implications&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;p&gt;Replay resistance:&lt;/p&gt;&lt;lb/&gt;Because Cryptexes and their trust caches are verified via Image4 and TXM, replaying older Cryptexes or RSRs is constrained by the same personalization and policy rules as the base OS.&lt;/item&gt;
      &lt;item&gt;&lt;p&gt;Persistence model:&lt;/p&gt;&lt;lb/&gt;RSRs live outside the SSV (typically on Preboot), but they remain in the verified boot chain via their manifests and trust caches.&lt;/item&gt;
      &lt;item&gt;&lt;p&gt;Analysis workflow:&lt;/p&gt;&lt;lb/&gt;To understand an RSR, you extract the RSR Cryptex image from the update payload, mount it, and diff its contents against the base OS Cryptex. The semantic delta is “what the RSR changed.” The live system view is the union of SSV + base OS Cryptex + any active RSR overlays, subject to SPTM/TXM integrity constraints.&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h2"&gt;9.0 The Security Daemon Hierarchy&lt;/head&gt;
    &lt;p&gt;While the kernel and the hardware monitors (SPTM/TXM) enforce the immutable laws of the system physics (memory protections, page table integrity, executable mappings), the complex, mutable business logic of macOS security is delegated to a hierarchy of userland daemons. These daemons operate with high privileges, often holding special ports or entitlements that allow them to influence kernel policy. For the reverse engineer, these daemons represent the “Policy Engine” of the OS—and historically, the most fertile ground for logic bugs and sandbox escapes.&lt;/p&gt;
    &lt;head rend="h3"&gt;9.1 &lt;code&gt;amfid&lt;/code&gt; (Apple Mobile File Integrity Daemon)&lt;/head&gt;
    &lt;p&gt;The Apple Mobile File Integrity Daemon (&lt;code&gt;amfid&lt;/code&gt;) is the userland arbiter of code execution policy. While the TXM enforces code-execution policy and manages trust caches for platform binaries in the guarded world, it lacks the context to evaluate the complex web of third-party provisioning profiles, developer certificates, notarization state, and MDM constraints.&lt;/p&gt;
    &lt;p&gt;In the Tahoe architecture, &lt;code&gt;amfid&lt;/code&gt; functions as the Policy Decision Point (PDP) for non-platform code, while the kernel and TXM act as the Policy Enforcement Points (PEP) that ultimately decide whether pages become executable.&lt;/p&gt;
    &lt;head rend="h4"&gt;9.1.1 The Interaction between &lt;code&gt;launchd&lt;/code&gt;, the Kernel (MACF), and &lt;code&gt;amfid&lt;/code&gt;&lt;/head&gt;
    &lt;p&gt;&lt;code&gt;amfid&lt;/code&gt; does not poll for binaries; it is driven by the kernel via the Mandatory Access Control Framework (MACF) hooks in the AMFI/AppleMobileFileIntegrity path.&lt;/p&gt;
    &lt;p&gt;The Bootstrap Race&lt;/p&gt;
    &lt;p&gt;&lt;code&gt;amfid&lt;/code&gt; is a critical system daemon launched by &lt;code&gt;launchd&lt;/code&gt; early in the boot process. Because &lt;code&gt;amfid&lt;/code&gt; is responsible for verifying signatures, it presents a bootstrap paradox: Who verifies &lt;code&gt;amfid&lt;/code&gt;?&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;The Solution: &lt;code&gt;amfid&lt;/code&gt;is a platform binary shipped as part of the system OS (delivered via the Signed System Volume and associated cryptexes). Its CDHash is included in the Static Trust Cache that iBoot hands to the kernel during early boot.&lt;/item&gt;
      &lt;item&gt;TXM / AMFI Verification: When &lt;code&gt;launchd&lt;/code&gt;spawns&lt;code&gt;amfid&lt;/code&gt;, the kernel’s AMFI path consults TXM against the static trust cache. The CDHash is present, so the secure-world policy engine blesses the mapping immediately. No userland upcall is required for&lt;code&gt;amfid&lt;/code&gt;itself.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;From this point onward, &lt;code&gt;amfid&lt;/code&gt; becomes part of the trusted computing base: it is the userland process that encodes code-execution policy for everything that is not already covered by immutable trust caches.&lt;/p&gt;
    &lt;p&gt;The Verification Upcall (The “Slow Path”)&lt;/p&gt;
    &lt;p&gt;When a user launches a third-party application (for example, &lt;code&gt;/Applications/Calculator.app&lt;/code&gt;), the flow traverses the boundary between kernel and userland multiple times.&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;&lt;p&gt;The Hook&lt;/p&gt;&lt;p&gt;The kernel executes&lt;/p&gt;&lt;code&gt;execve&lt;/code&gt;. Along the AMFI path, the MACF hook&lt;code&gt;mpo_vnode_check_signature&lt;/code&gt;in&lt;code&gt;AppleMobileFileIntegrity&lt;/code&gt;is triggered. This hook is the choke point where the system decides whether the binary’s code signature is acceptable.&lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;TXM / Trust Cache Miss&lt;/p&gt;
        &lt;p&gt;The kernel (via AMFI) queries TXM in the guarded world (conceptually via an internal “GENTER”-style call). TXM consults the Static Trust Cache and the Dynamic Trust Cache.&lt;/p&gt;
        &lt;p&gt;For a newly launched, third-party app whose CDHash has never been seen before, this lookup fails: there is no matching entry in either cache.&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;&lt;p&gt;The Upcall&lt;/p&gt;&lt;p&gt;On a trust-cache miss, the kernel must delegate policy to userland. It constructs a Mach message targeting the&lt;/p&gt;&lt;code&gt;HOST_AMFID_PORT&lt;/code&gt;(host special port 18), which is bound to&lt;code&gt;amfid&lt;/code&gt;.&lt;p&gt;The message carries:&lt;/p&gt;&lt;list rend="ul"&gt;&lt;item&gt;A send right to a &lt;code&gt;fileport&lt;/code&gt;for the executable.&lt;/item&gt;&lt;item&gt;Metadata describing offsets and sizes (location of the code signature blob, file length, etc.).&lt;/item&gt;&lt;item&gt;The CDHash or code directory parameters needed for verification.&lt;/item&gt;&lt;/list&gt;&lt;p&gt;Exact field layouts vary by OS release, but the kernel avoids trusting raw string paths where possible and instead relies on fileports and offsets.&lt;/p&gt;&lt;/item&gt;
      &lt;item&gt;A send right to a &lt;/item&gt;
      &lt;item&gt;&lt;code&gt;amfid&lt;/code&gt;Processing&lt;code&gt;amfid&lt;/code&gt;receives the MACH IPC and performs the heavy lifting:&lt;list rend="ul"&gt;&lt;item&gt;Parses the CMS / code signature blob from the file.&lt;/item&gt;&lt;item&gt;Validates the certificate chain via &lt;code&gt;libmis.dylib&lt;/code&gt;(Mobile Installation Service) and often IPC to&lt;code&gt;trustd&lt;/code&gt;.&lt;/item&gt;&lt;item&gt;Extracts entitlements and, if present, an embedded provisioning profile (&lt;code&gt;embedded.mobileprovision&lt;/code&gt;).&lt;/item&gt;&lt;item&gt;Applies policy derived from Developer Mode, MDM profiles, and local configuration.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;&lt;p&gt;The Verdict&lt;/p&gt;&lt;code&gt;amfid&lt;/code&gt;responds to the kernel with a MIG reply corresponding to the&lt;code&gt;verify_code_directory&lt;/code&gt;routine. For the kernel, this effectively collapses to:&lt;list rend="ul"&gt;&lt;item&gt;A status code (success, profile mismatch, expired certificate, etc.).&lt;/item&gt;&lt;item&gt;Derived flags (e.g. whether &lt;code&gt;get-task-allow&lt;/code&gt;is permitted).&lt;/item&gt;&lt;item&gt;Optionally, additional hints for AMFI.&lt;/item&gt;&lt;/list&gt;&lt;p&gt;At this stage, the kernel updates the process’s&lt;/p&gt;&lt;code&gt;cs_flags&lt;/code&gt;(Code Signing Flags), including bits such as&lt;code&gt;CS_GET_TASK_ALLOW&lt;/code&gt;and&lt;code&gt;CS_HARD&lt;/code&gt;, based on&lt;code&gt;amfid&lt;/code&gt;’s verdict.&lt;/item&gt;
      &lt;item&gt;&lt;p&gt;TXM Update&lt;/p&gt;&lt;p&gt;If&lt;/p&gt;&lt;code&gt;amfid&lt;/code&gt;approves the binary, the kernel performs a second secure-world interaction: the CDHash and relevant metadata are added to the Dynamic Trust Cache managed under TXM’s control. Future launches of the same, unchanged binary can now be satisfied entirely in TXM and AMFI without repeating the upcall.&lt;list rend="ul"&gt;&lt;item&gt;Security Note: In Tahoe, the architecture is such that TXM remains the final authority on cryptographic validity. Even if the kernel or &lt;code&gt;amfid&lt;/code&gt;were compromised, adding a CDHash to the dynamic trust cache requires passing TXM’s guardrails.&lt;code&gt;amfid&lt;/code&gt;supplies the policy decision (“this developer identity / profile is acceptable here”), while TXM ensures that the code bytes actually match the identity being whitelisted.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;Security Note: In Tahoe, the architecture is such that TXM remains the final authority on cryptographic validity. Even if the kernel or &lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;RE Focus: The MIG Interface&lt;/p&gt;
    &lt;p&gt;The communication interface is defined in the (reverse-engineered) MIG definition usually referred to as &lt;code&gt;mfi_server.defs&lt;/code&gt;. The key routine is often named &lt;code&gt;verify_code_directory&lt;/code&gt;.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Input (conceptual): &lt;code&gt;audit_token_t&lt;/code&gt;for the caller (kernel),&lt;code&gt;mach_port_t file_port&lt;/code&gt;, offset and size parameters for the code signature, and flags controlling the verification mode.&lt;/item&gt;
      &lt;item&gt;Attack Surface: Historically, malformed Mach messages to &lt;code&gt;amfid&lt;/code&gt;’s service port produced classic parsing bugs. Modern macOS hardens this by:&lt;list rend="ul"&gt;&lt;item&gt;Validating the audit token to ensure calls originate from &lt;code&gt;kernel_task&lt;/code&gt;, not arbitrary userland.&lt;/item&gt;&lt;item&gt;Tightening the MIG server and argument validation paths.&lt;/item&gt;&lt;item&gt;Relying increasingly on fileports rather than untrusted string paths.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;Validating the audit token to ensure calls originate from &lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;For reverse engineers, the MIG stubs and their error-handling paths remain prime targets for logic bugs and subtle policy bypasses.&lt;/p&gt;
    &lt;head rend="h4"&gt;9.1.2 Validating Code Directories (CDHash), Entitlements, and Provisioning Profiles&lt;/head&gt;
    &lt;p&gt;The core logic of &lt;code&gt;amfid&lt;/code&gt; resides in its ability to connect a binary’s Code Directory (CD) to a valid certificate chain and, when applicable, a Provisioning Profile. This mechanism enforces both the iOS-style “Walled Garden” and the macOS notarization regime.&lt;/p&gt;
    &lt;p&gt;The Validation Logic (&lt;code&gt;MISValidateSignatureAndCopyInfo&lt;/code&gt;)&lt;/p&gt;
    &lt;p&gt;&lt;code&gt;amfid&lt;/code&gt; links against &lt;code&gt;libmis.dylib&lt;/code&gt;, which exports the symbol &lt;code&gt;MISValidateSignatureAndCopyInfo&lt;/code&gt;. This function encapsulates most of the signature and profile evaluation:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;&lt;p&gt;CDHash Extraction&lt;/p&gt;&lt;code&gt;amfid&lt;/code&gt;reads the&lt;code&gt;LC_CODE_SIGNATURE&lt;/code&gt;load command, locates the Code Directory, and computes the CDHash by hashing the slots specified by the Code Directory (typically a truncated SHA-256 or SHA-1, depending on platform and epoch).&lt;/item&gt;
      &lt;item&gt;&lt;p&gt;Entitlement Extraction&lt;/p&gt;&lt;p&gt;It parses the embedded entitlements plist from the signature blob. These entitlements express requested capabilities (e.g.&lt;/p&gt;&lt;code&gt;com.apple.security.network.client&lt;/code&gt;,&lt;code&gt;com.apple.security.get-task-allow&lt;/code&gt;, private IOKit entitlements).&lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Profile Correlation (Developer-Signed Binaries)&lt;/p&gt;
        &lt;p&gt;When the binary is signed by a non-Apple certificate:&lt;/p&gt;
        &lt;list rend="ul"&gt;
          &lt;item&gt;It looks for an embedded provisioning profile (&lt;code&gt;embedded.mobileprovision&lt;/code&gt;).&lt;/item&gt;
          &lt;item&gt;It verifies the PKCS#7 signature of the profile, ensuring it is issued by Apple.&lt;/item&gt;
          &lt;item&gt;It compares the entitlements in the binary against the &lt;code&gt;Entitlements&lt;/code&gt;dictionary in the profile, enforcing that the binary does not claim more than the profile grants.&lt;/item&gt;
          &lt;item&gt;For development profiles, it verifies that the device’s identifier (UDID / platform identifier) is present in the &lt;code&gt;ProvisionedDevices&lt;/code&gt;array (or matches the profile’s “All Devices” semantics, depending on platform).&lt;/item&gt;
        &lt;/list&gt;
      &lt;/item&gt;
      &lt;item&gt;It looks for an embedded provisioning profile (&lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Constraint Enforcement&lt;/p&gt;
        &lt;list rend="ul"&gt;
          &lt;item&gt;Restricted Entitlements: Certain entitlements (for example, &lt;code&gt;com.apple.private.security.no-sandbox&lt;/code&gt;, low-level IOKit and CSR overrides) are “restricted” and only grantable when the signature chain terminates in specific Apple internal CAs or special program certificates.&lt;/item&gt;
          &lt;item&gt;&lt;code&gt;amfid&lt;/code&gt;enforces this hierarchy by refusing binaries whose entitlements exceed what the provisioning profile and certificate chain permit.&lt;/item&gt;
        &lt;/list&gt;
      &lt;/item&gt;
      &lt;item&gt;Restricted Entitlements: Certain entitlements (for example, &lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The “Union” of Trust: Notarization and Gatekeeper&lt;/p&gt;
    &lt;p&gt;On macOS, this signature evaluation interacts with the notarization system, primarily implemented in &lt;code&gt;syspolicyd&lt;/code&gt;:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;At download or first execution, Gatekeeper and &lt;code&gt;syspolicyd&lt;/code&gt;evaluate notarization tickets (stapled to the binary or stored under&lt;code&gt;/var/db/SystemPolicy*&lt;/code&gt;) and decide whether the binary is admissible under current policy.&lt;/item&gt;
      &lt;item&gt;Once a binary is admitted, subsequent executions still traverse AMFI/&lt;code&gt;amfid&lt;/code&gt;:&lt;list rend="ul"&gt;&lt;item&gt;&lt;code&gt;amfid&lt;/code&gt;ensures that the running code’s signature and entitlements still match what was originally notarized.&lt;/item&gt;&lt;item&gt;It can treat notarized binaries as belonging to a higher trust tier compared to purely ad-hoc signatures (for example, relaxing some heuristics or additional scanning).&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The effective trust decision is thus the intersection of:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Static trust caches and TXM policy (platform code).&lt;/item&gt;
      &lt;item&gt;Gatekeeper / notarization (admission control for untrusted downloads).&lt;/item&gt;
      &lt;item&gt;AMFI + &lt;code&gt;amfid&lt;/code&gt;(per-execution verification and entitlement policy).&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;RE Focus: &lt;code&gt;libmis.dylib&lt;/code&gt; Reversing&lt;/p&gt;
    &lt;p&gt;&lt;code&gt;libmis.dylib&lt;/code&gt; is heavily stripped and obfuscated, but it has a simple, observable contract:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;MISValidateSignatureAndCopyInfo&lt;/code&gt;returns an integer status, where&lt;code&gt;0&lt;/code&gt;indicates success and non-zero error codes map to specific failures (profile expired, certificate invalid, entitlements mismatch, etc.).&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;amfid&lt;/code&gt;logs detailed failure reasons via&lt;code&gt;os_log&lt;/code&gt;and friends. Many of these logs are visible only with specific boot arguments or developer configurations (for example, AMFI developer mode toggles).&lt;/item&gt;
      &lt;item&gt;Instrumenting the call sites and enumerating non-zero return codes is often the most efficient way to understand why a given binary is being killed or stripped of capabilities.&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h4"&gt;9.1.3 Exception Handling: How &lt;code&gt;get-task-allow&lt;/code&gt; and Debugging Entitlements are Processed&lt;/head&gt;
    &lt;p&gt;One of &lt;code&gt;amfid&lt;/code&gt;’s most security-sensitive roles is gating access to process debugging. The ability to attach a debugger (&lt;code&gt;task_for_pid&lt;/code&gt;) is effectively a full compromise of the target process.&lt;/p&gt;
    &lt;p&gt;The &lt;code&gt;get-task-allow&lt;/code&gt; Entitlement&lt;/p&gt;
    &lt;p&gt;In a standard production configuration, a process cannot be debugged unless either:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;The system is in a special developer or recovery mode, or&lt;/item&gt;
      &lt;item&gt;The target process possesses the &lt;code&gt;com.apple.security.get-task-allow&lt;/code&gt;entitlement and other policy conditions are satisfied.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Typical paths:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Xcode Builds: When an app is built and run from Xcode, the build system signs it with a development certificate and injects &lt;code&gt;get-task-allow&lt;/code&gt;, allowing&lt;code&gt;debugserver&lt;/code&gt;/&lt;code&gt;lldb&lt;/code&gt;to obtain a task port.&lt;/item&gt;
      &lt;item&gt;App Store Builds: The App Store distribution pipeline strips &lt;code&gt;get-task-allow&lt;/code&gt;before submission; resulting binaries are non-debuggable under normal policy.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The &lt;code&gt;amfid&lt;/code&gt; Decision Matrix&lt;/p&gt;
    &lt;p&gt;During &lt;code&gt;execve&lt;/code&gt;, the kernel extracts entitlements and passes them (directly or indirectly) into the AMFI/&lt;code&gt;amfid&lt;/code&gt; path:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;amfid&lt;/code&gt;validates that&lt;code&gt;get-task-allow&lt;/code&gt;appears in both:&lt;list rend="ul"&gt;&lt;item&gt;The entitlements blob in the code signature.&lt;/item&gt;&lt;item&gt;The entitlements and capabilities granted by the provisioning profile / certificate chain.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;If the request is:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Valid: &lt;code&gt;amfid&lt;/code&gt;indicates that&lt;code&gt;CS_GET_TASK_ALLOW&lt;/code&gt;may be set in the process’s&lt;code&gt;cs_flags&lt;/code&gt;. Subsequent&lt;code&gt;task_for_pid&lt;/code&gt;checks can succeed (subject to further checks like caller UID, SIP bits, and TCC state).&lt;/item&gt;
      &lt;item&gt;Invalid or Over-Privileged: &lt;code&gt;amfid&lt;/code&gt;can cause the entitlement to be ignored or the entire signature to be rejected, leading to kill-on-launch or a process without debug permissions.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The &lt;code&gt;task_for_pid&lt;/code&gt; Check&lt;/p&gt;
    &lt;p&gt;When &lt;code&gt;debugserver&lt;/code&gt; or &lt;code&gt;lldb&lt;/code&gt; calls &lt;code&gt;task_for_pid(target_pid)&lt;/code&gt;:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;The kernel checks the target’s &lt;code&gt;cs_flags&lt;/code&gt;(including&lt;code&gt;CS_GET_TASK_ALLOW&lt;/code&gt;) and applies additional policy (root privileges, SIP bits such as&lt;code&gt;CSR_ALLOW_TASK_FOR_PID&lt;/code&gt;, and TCC automations).&lt;/item&gt;
      &lt;item&gt;If the flags and policy allow it, the caller receives a send right to the target’s task port; otherwise, the call fails (e.g. &lt;code&gt;KERN_PROTECTION_FAILURE&lt;/code&gt;/&lt;code&gt;KERN_FAILURE&lt;/code&gt;).&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Developer Mode (The Tahoe Shift)&lt;/p&gt;
    &lt;p&gt;In the Tahoe architecture, the presence of &lt;code&gt;get-task-allow&lt;/code&gt; and a development certificate is no longer sufficient by itself. Debuggability is additionally gated by Developer Mode:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;&lt;p&gt;State Check&lt;/p&gt;&lt;p&gt;Developer Mode state is maintained by LocalPolicy and enforced via SPTM/TXM. The AMFI/&lt;/p&gt;&lt;code&gt;amfid&lt;/code&gt;path consults this state (via private interfaces and entitlements) when evaluating signatures.&lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Enforcement&lt;/p&gt;
        &lt;p&gt;If Developer Mode is disabled:&lt;/p&gt;
        &lt;list rend="ul"&gt;
          &lt;item&gt;Binaries signed solely with development certificates are generally treated as untrusted for execution and debugging on end-user systems.&lt;/item&gt;
          &lt;item&gt;Even if the provisioning profile is otherwise valid, &lt;code&gt;amfid&lt;/code&gt;and associated policy may refuse to honour&lt;code&gt;get-task-allow&lt;/code&gt;, resulting in&lt;code&gt;cs_flags&lt;/code&gt;that do not permit&lt;code&gt;task_for_pid&lt;/code&gt;.&lt;/item&gt;
        &lt;/list&gt;
      &lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;This prevents the trivial side-loading of a “debuggable” app to inspect memory on a locked-down device; enabling Developer Mode requires an explicit, TXM-mediated ceremony that materially lowers the device’s security posture.&lt;/p&gt;
    &lt;p&gt;Unrestricted Debugging, SIP, and AMFI&lt;/p&gt;
    &lt;p&gt;On macOS, System Integrity Protection (SIP) and AMFI are distinct but interacting mechanisms:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;SIP (CSR Bits): SIP is configured via &lt;code&gt;csrutil&lt;/code&gt;and boot arguments, setting bits such as&lt;code&gt;CSR_ALLOW_TASK_FOR_PID&lt;/code&gt;(relaxing debugging restrictions),&lt;code&gt;CSR_ALLOW_UNRESTRICTED_FS&lt;/code&gt;, and others.&lt;/item&gt;
      &lt;item&gt;AMFI / &lt;code&gt;amfi_get_out_of_my_way&lt;/code&gt;: On internal or development builds, AMFI can be disabled or relaxed via boot-args (e.g.&lt;code&gt;amfi_get_out_of_my_way=1&lt;/code&gt;), effectively causing the kernel to bypass code-signing enforcement.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Historically:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Setting debug CSR bits like &lt;code&gt;CSR_ALLOW_TASK_FOR_PID&lt;/code&gt;allowed broader debugging of system processes, but did not by itself disable AMFI’s signature checks.&lt;/item&gt;
      &lt;item&gt;Disabling AMFI (&lt;code&gt;amfi_get_out_of_my_way&lt;/code&gt;) is what effectively causes the kernel to treat code signatures as trivially acceptable.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;In Tahoe:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;SIP state is one of the inputs into LocalPolicy, with TXM enforcing the resulting policy at the page-table and executable-mapping level.&lt;/item&gt;
      &lt;item&gt;AMFI and &lt;code&gt;amfid&lt;/code&gt;still perform signature and entitlement checks, but some CSR bits continue to relax specific restrictions (for example, attaching a debugger to processes that would otherwise be non-debuggable).&lt;/item&gt;
      &lt;item&gt;Fully “everything is valid” behaviour is reserved for tightly controlled developer or internal configurations and is not reachable on production systems without both SIP and AMFI being simultaneously subverted.&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h3"&gt;9.2 &lt;code&gt;sandboxd&lt;/code&gt; &amp;amp; The Seatbelt Policy&lt;/head&gt;
    &lt;p&gt;If &lt;code&gt;amfid&lt;/code&gt; is the bouncer checking identities at the door, the Seatbelt subsystem (marketed as App Sandbox) is the straightjacket applied once code is inside. Originating from TrustedBSD, the macOS sandbox is a Mandatory Access Control (MAC) mechanism that restricts a process’s access to resources—files, sockets, Mach ports, IOKit drivers—regardless of the user’s UID.&lt;/p&gt;
    &lt;p&gt;In the Tahoe architecture, the sandbox has evolved from a predominantly path-based filter into a semantic, metadata-driven enforcement layer, tightly coupled with the kernel’s VFS and process credential machinery and integrated with new Data Vault primitives.&lt;/p&gt;
    &lt;head rend="h4"&gt;9.2.1 Compiling SBPL (Sandbox Policy Language) to Bytecode&lt;/head&gt;
    &lt;p&gt;Sandbox profiles are expressed in SBPL (Sandbox Policy Language), a Scheme-like (LISP) dialect. The kernel does not interpret SBPL directly. Instead, policy is compiled into a compact bytecode format that the kernel executes.&lt;/p&gt;
    &lt;p&gt;The SBPL compiler lives primarily in &lt;code&gt;libsandbox.dylib&lt;/code&gt; (and its libsystem glue), not in &lt;code&gt;sandboxd&lt;/code&gt;.&lt;/p&gt;
    &lt;p&gt;The Compilation Pipeline&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;
        &lt;p&gt;Profile Selection&lt;/p&gt;
        &lt;p&gt;Depending on the process, different profiles are selected:&lt;/p&gt;
        &lt;list rend="ul"&gt;
          &lt;item&gt;App Store Apps: The system applies a generic &lt;code&gt;container&lt;/code&gt;profile that implements the standard app sandbox.&lt;/item&gt;
          &lt;item&gt;System Daemons: Daemons specify their profile name in their &lt;code&gt;launchd.plist&lt;/code&gt;(for example,&lt;code&gt;com.apple.syslogd.sb&lt;/code&gt;), which is resolved to an SBPL specification.&lt;/item&gt;
          &lt;item&gt;Platform Profile: In modern macOS, many core policies are consolidated into a Platform Profile bundled with &lt;code&gt;Sandbox.kext&lt;/code&gt;/ the Boot Kernel Collection. Individual SBPL files for system services still exist, but the trend is toward more policy being pre-compiled into the kernel cache to reduce runtime parsing and external configuration surface.&lt;/item&gt;
        &lt;/list&gt;
      &lt;/item&gt;
      &lt;item&gt;App Store Apps: The system applies a generic &lt;/item&gt;
      &lt;item&gt;&lt;p&gt;The Compiler (&lt;/p&gt;&lt;code&gt;libsandbox&lt;/code&gt;/&lt;code&gt;libsystem_sandbox&lt;/code&gt;)&lt;p&gt;When a process initializes the sandbox (for example, via&lt;/p&gt;&lt;code&gt;sandbox_init_with_parameters&lt;/code&gt;):&lt;list rend="ul"&gt;&lt;item&gt;The call enters &lt;code&gt;libsandbox.dylib&lt;/code&gt;in the process address space.&lt;/item&gt;&lt;item&gt;&lt;code&gt;libsandbox&lt;/code&gt;parses the SBPL (often using an embedded TinyScheme derivative).&lt;/item&gt;&lt;item&gt;It resolves variable expansions such as &lt;code&gt;${HOME}&lt;/code&gt;,&lt;code&gt;${TemporaryDirectory}&lt;/code&gt;, and environment-dependent paths.&lt;/item&gt;&lt;item&gt;It compiles the SBPL rules into a proprietary bytecode representation.&lt;/item&gt;&lt;/list&gt;&lt;code&gt;sandboxd&lt;/code&gt;is not on this critical path. Its primary role is to receive violation reports and log denied operations; it is not the SBPL compiler.&lt;/item&gt;
      &lt;item&gt;The call enters &lt;/item&gt;
      &lt;item&gt;&lt;p&gt;The Bytecode Structure&lt;/p&gt;&lt;p&gt;The compiled blob is a serialized decision machine:&lt;/p&gt;&lt;list rend="ul"&gt;&lt;item&gt;Opcodes: Operations such as “match path”, “match pattern”, “check entitlement”, “allow”, “deny”, and conditional branching.&lt;/item&gt;&lt;item&gt;Filters: Rules are arranged into decision trees or tries keyed by operation class and path prefix (for example, file operations grouped under &lt;code&gt;/System&lt;/code&gt;,&lt;code&gt;/Users&lt;/code&gt;).&lt;/item&gt;&lt;/list&gt;&lt;p&gt;This bytecode is opaque to userland: it is handed to the kernel via the&lt;/p&gt;&lt;code&gt;__mac_syscall&lt;/code&gt;/ sandbox-specific syscalls, where&lt;code&gt;Sandbox.kext&lt;/code&gt;attaches it to the process’s MAC label.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;RE Focus: Reversing the Binary Blob&lt;/p&gt;
    &lt;p&gt;The kernel receives the compiled profile via a MACF-specific syscall (e.g. &lt;code&gt;__mac_syscall&lt;/code&gt; with &lt;code&gt;SANDBOX_SET_PROFILE&lt;/code&gt;):&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Extraction: The blob can be captured by: &lt;list rend="ul"&gt;&lt;item&gt;Hooking &lt;code&gt;sandbox_init*&lt;/code&gt;/&lt;code&gt;sandbox_compile_*&lt;/code&gt;inside&lt;code&gt;libsandbox&lt;/code&gt;.&lt;/item&gt;&lt;item&gt;Hooking &lt;code&gt;sandbox_set_profile&lt;/code&gt;/&lt;code&gt;__mac_syscall&lt;/code&gt;at the userland boundary.&lt;/item&gt;&lt;item&gt;Extracting the label attached to the process in the kernel (&lt;code&gt;kauth_cred_t&lt;/code&gt;→ sandbox label).&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;Hooking &lt;/item&gt;
      &lt;item&gt;Decompilation: Tools such as &lt;code&gt;sbs&lt;/code&gt;(Sandbox Scrutinizer) or custom disassemblers lift the bytecode back into an SBPL-like intermediate representation.&lt;/item&gt;
      &lt;item&gt;Profile Validation: In Tahoe, the kernel performs sanity checks on the bytecode (bounds checks, instruction validity, loop constraints) before attaching it to a process. This reduces the risk that a malformed profile can hang or crash kernel threads.&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h4"&gt;9.2.2 The Sandbox Kernel Extension: Hooking Syscalls via the MAC Framework&lt;/head&gt;
    &lt;p&gt;The enforcement engine is &lt;code&gt;Sandbox.kext&lt;/code&gt;, which hooks into the XNU kernel via the Mandatory Access Control Framework (MACF).&lt;/p&gt;
    &lt;p&gt;MACF Hooks&lt;/p&gt;
    &lt;p&gt;XNU is instrumented with a large set of &lt;code&gt;mac_&lt;/code&gt; hooks placed at security-critical bottlenecks:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Filesystem: &lt;code&gt;mac_vnode_check_open&lt;/code&gt;,&lt;code&gt;mac_vnode_check_rename&lt;/code&gt;,&lt;code&gt;mac_vnode_check_unlink&lt;/code&gt;, etc.&lt;/item&gt;
      &lt;item&gt;IPC: &lt;code&gt;mac_mach_port_check_send&lt;/code&gt;,&lt;code&gt;mac_mach_port_check_receive&lt;/code&gt;.&lt;/item&gt;
      &lt;item&gt;IOKit: &lt;code&gt;mac_iokit_check_open&lt;/code&gt;,&lt;code&gt;mac_iokit_check_get_property&lt;/code&gt;.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;&lt;code&gt;Sandbox.kext&lt;/code&gt; registers a MAC policy via a &lt;code&gt;mac_policy_conf&lt;/code&gt; structure whose function pointers implement these hooks.&lt;/p&gt;
    &lt;p&gt;The Evaluation Flow&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;
        &lt;p&gt;Trigger&lt;/p&gt;
        &lt;p&gt;A sandboxed process issues a syscall, for example:&lt;/p&gt;
        &lt;code&gt;open("/etc/passwd", O_RDONLY);&lt;/code&gt;
      &lt;/item&gt;
      &lt;item&gt;&lt;p&gt;MACF Hook&lt;/p&gt;&lt;p&gt;The kernel executes&lt;/p&gt;&lt;code&gt;mac_vnode_check_open&lt;/code&gt;. MACF dispatches this call to all registered policies, including&lt;code&gt;Sandbox.kext&lt;/code&gt;.&lt;/item&gt;
      &lt;item&gt;&lt;p&gt;Policy Dispatch&lt;/p&gt;&lt;code&gt;Sandbox.kext&lt;/code&gt;:&lt;list rend="ul"&gt;&lt;item&gt;Looks up the process’s &lt;code&gt;kauth_cred_t&lt;/code&gt;.&lt;/item&gt;&lt;item&gt;Retrieves the sandbox label, which includes a pointer to the compiled profile bytecode.&lt;/item&gt;&lt;item&gt;Normalizes arguments (operation kind, path, vnode type, etc.) into a canonical form.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;Looks up the process’s &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Bytecode Evaluation&lt;/p&gt;
        &lt;p&gt;The sandbox engine executes the profile bytecode:&lt;/p&gt;
        &lt;list rend="ul"&gt;
          &lt;item&gt;Input: Operation (for example, &lt;code&gt;file-read&lt;/code&gt;), resource (path&lt;code&gt;/etc/passwd&lt;/code&gt;), additional attributes (file type, vnode flags).&lt;/item&gt;
          &lt;item&gt;Logic: Traverses the pre-compiled decision tree, checking path prefixes, patterns, and entitlements.&lt;/item&gt;
        &lt;/list&gt;
      &lt;/item&gt;
      &lt;item&gt;Input: Operation (for example, &lt;/item&gt;
      &lt;item&gt;&lt;p&gt;Caching (Performance Critical Path)&lt;/p&gt;&lt;p&gt;Evaluating bytecode on every syscall would be prohibitively expensive, so&lt;/p&gt;&lt;code&gt;Sandbox.kext&lt;/code&gt;maintains caches:&lt;list rend="ul"&gt;&lt;item&gt;Per-vnode caches: Attach allow/deny decisions to vnode labels once a decision has been made.&lt;/item&gt;&lt;item&gt;Per-process caches: Cache repeated deny decisions for patterns known to be disallowed.&lt;/item&gt;&lt;/list&gt;&lt;p&gt;Subsequent accesses to the same file or resource often bypass the full bytecode interpreter and reuse cached verdicts.&lt;/p&gt;&lt;list rend="ul"&gt;&lt;item&gt;RE Vulnerability: Bugs in cache invalidation (for example, renames, mount points, or attribute changes that fail to invalidate cached decisions) can lead to enforcement bypasses where the sandbox decision no longer reflects reality.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The Tahoe / SPTM Intersection&lt;/p&gt;
    &lt;p&gt;While sandbox policy is defined in software, the integrity of the enforcement hooks is backed by hardware:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;The &lt;code&gt;mac_policy_conf&lt;/code&gt;structures and many related function pointer tables reside in const segments (&lt;code&gt;__DATA_CONST&lt;/code&gt;/&lt;code&gt;__CONST&lt;/code&gt;) in the Boot Kernel Collection.&lt;/item&gt;
      &lt;item&gt;SPTM/TXM enforce invariants on the kernel’s page tables, preventing EL1 code from remapping those const segments as writable, even under a kernel write primitive.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;This has two consequences:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Classical rootkits that “unhook” sandbox enforcement by overwriting function pointers in &lt;code&gt;mac_policy_conf&lt;/code&gt;are blocked at the page-table level: the attempted store either faults or writes to a non-effective alias.&lt;/item&gt;
      &lt;item&gt;The sandbox policy can still be subverted through more subtle means (policy loading, profile compilation, credential forgery), but transparent pointer overwrites of core hooks are no longer a viable attack on Tahoe-class hardware.&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h4"&gt;9.2.3 Containerization: Data Vaults and Group Containers&lt;/head&gt;
    &lt;p&gt;In the Tahoe era, Apple has moved beyond simple path-based rules (fragile and prone to symlink and mountpoint attacks) toward semantic containerization of data.&lt;/p&gt;
    &lt;p&gt;Data Vaults&lt;/p&gt;
    &lt;p&gt;Data Vaults are used to protect the most sensitive data at rest—for example, Messages, Photos, and certain system databases.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;
        &lt;p&gt;Implementation: A Data Vault is typically a directory or volume flagged with specific VFS attributes (for example, the “datavault” flag and associated extended attributes).&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Enforcement:&lt;/p&gt;
        &lt;list rend="ul"&gt;
          &lt;item&gt;Access decisions are made in MAC hooks before classic Discretionary Access Control (DAC). Even &lt;code&gt;root&lt;/code&gt;(UID 0) cannot trivially&lt;code&gt;ls&lt;/code&gt;or&lt;code&gt;cat&lt;/code&gt;a Data Vault.&lt;/item&gt;
          &lt;item&gt;Access is granted only if the calling process holds specific, private entitlements (for example, &lt;code&gt;com.apple.private.security.storage.AppDataVault&lt;/code&gt;or service-specific variants).&lt;/item&gt;
        &lt;/list&gt;
      &lt;/item&gt;
      &lt;item&gt;Access decisions are made in MAC hooks before classic Discretionary Access Control (DAC). Even &lt;/item&gt;
      &lt;item&gt;&lt;p&gt;The “Root” Fallacy: Running as&lt;/p&gt;&lt;code&gt;root&lt;/code&gt;with&lt;code&gt;host_priv&lt;/code&gt;is no longer sufficient. Data Vault checks are keyed off entitlements and sandbox state, not UID.&lt;/item&gt;
      &lt;item&gt;&lt;p&gt;RE Focus: Kernel symbols such as&lt;/p&gt;&lt;code&gt;rootless_check_datavault_flag&lt;/code&gt;and related helpers encode these checks. Reversing them reveals:&lt;list rend="ul"&gt;&lt;item&gt;How Data Vault flags are stored in the vnode and mount structures.&lt;/item&gt;&lt;item&gt;Which entitlements are accepted for a given vault class.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Group Containers&lt;/p&gt;
    &lt;p&gt;To support IPC and data sharing between apps and their extensions (for example, a Widget and its host app), the sandbox introduces Group Containers.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;p&gt;The&lt;/p&gt;&lt;code&gt;application-group&lt;/code&gt;Entitlement: Declares group IDs such as&lt;code&gt;group.com.example.app&lt;/code&gt;. These IDs define shared container namespaces.&lt;/item&gt;
      &lt;item&gt;&lt;p&gt;Container Manager: The system daemon&lt;/p&gt;&lt;code&gt;containermanagerd&lt;/code&gt;manages the lifecycle and filesystem layout of these group directories (typically under&lt;code&gt;~/Library/Group Containers/&lt;/code&gt;).&lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Sandbox Logic:&lt;/p&gt;
        &lt;list rend="ul"&gt;
          &lt;item&gt;When compiling the app’s sandbox profile, &lt;code&gt;libsandbox&lt;/code&gt;inspects entitlements.&lt;/item&gt;
          &lt;item&gt;For each &lt;code&gt;application-group&lt;/code&gt;identifier, it injects rules that allow controlled read/write access to&lt;code&gt;${HOME}/Library/Group Containers/&amp;lt;group-id&amp;gt;&lt;/code&gt;.&lt;/item&gt;
          &lt;item&gt;This binds filesystem access directly to the cryptographic identity of the executable: only code signed with a matching App Group entitlement can enter that directory.&lt;/item&gt;
        &lt;/list&gt;
      &lt;/item&gt;
      &lt;item&gt;When compiling the app’s sandbox profile, &lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;For the reverse engineer, group containers provide a clear mapping from entitlements → filesystem layout; group container IDs found in entitlements can be used to locate shared state and attack surfaces.&lt;/p&gt;
    &lt;head rend="h3"&gt;9.3 &lt;code&gt;tccd&lt;/code&gt; (Transparency, Consent, and Control)&lt;/head&gt;
    &lt;p&gt;If &lt;code&gt;amfid&lt;/code&gt; validates code identity and &lt;code&gt;sandboxd&lt;/code&gt;/Seatbelt constrain code reach, &lt;code&gt;tccd&lt;/code&gt; governs the most volatile part of the security model: user consent.&lt;/p&gt;
    &lt;p&gt;The Transparency, Consent, and Control (TCC) subsystem is effectively a “User Intent Oracle”. It governs access to privacy-sensitive sensors (Camera, Microphone), personal data (Contacts, Calendars, Photos), and privileged capabilities (Full Disk Access, Screen Recording). In the Tahoe architecture, &lt;code&gt;tccd&lt;/code&gt; has evolved from a simple “prompt and remember” component into a complex attribution engine that must defend against consent hijacking and attribution spoofing.&lt;/p&gt;
    &lt;head rend="h4"&gt;9.3.1 The TCC Database: Schema, Integrity, and SIP&lt;/head&gt;
    &lt;p&gt;TCC persists user consent state in SQLite databases. There is a split between system-wide and per-user state:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;System TCC: &lt;code&gt;/Library/Application Support/com.apple.TCC/TCC.db&lt;/code&gt;— root-owned, stores system-wide decisions such as Full Disk Access.&lt;/item&gt;
      &lt;item&gt;User TCC: &lt;code&gt;~/Library/Application Support/com.apple.TCC/TCC.db&lt;/code&gt;— user-owned, stores per-user decisions such as Camera/Microphone access.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The Schema&lt;/p&gt;
    &lt;p&gt;The core table is &lt;code&gt;access&lt;/code&gt;. For reverse engineering, key columns include:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;service&lt;/code&gt;: Identifies the privilege (e.g.&lt;code&gt;kTCCServiceSystemPolicyAllFiles&lt;/code&gt;,&lt;code&gt;kTCCServiceMicrophone&lt;/code&gt;,&lt;code&gt;kTCCServiceScreenCapture&lt;/code&gt;).&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;client&lt;/code&gt;: The bundle identifier or absolute path of the client.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;client_type&lt;/code&gt;: Indicates whether&lt;code&gt;client&lt;/code&gt;is interpreted as a bundle ID (&lt;code&gt;0&lt;/code&gt;) or path (&lt;code&gt;1&lt;/code&gt;).&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;auth_value&lt;/code&gt;: Encodes the decision (e.g.&lt;code&gt;0&lt;/code&gt;= Denied,&lt;code&gt;1&lt;/code&gt;= Unknown / Prompt,&lt;code&gt;2&lt;/code&gt;= Allowed,&lt;code&gt;3&lt;/code&gt;= Limited).&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;csreq&lt;/code&gt;: A compiled Code Signing Requirement (CSReq) used to bind the decision to a particular identity, not just a path string.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Additional columns (timestamps, indirect attribution fields, categories) vary by OS release, but these fields form the stable core.&lt;/p&gt;
    &lt;p&gt;The &lt;code&gt;csreq&lt;/code&gt; Blob: Cryptographic Anchor&lt;/p&gt;
    &lt;p&gt;TCC does not trust filesystem paths alone. Instead:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;&lt;p&gt;When a request arrives,&lt;/p&gt;&lt;code&gt;tccd&lt;/code&gt;obtains the process’s code signing information (via&lt;code&gt;csops&lt;/code&gt;or similar APIs).&lt;/item&gt;
      &lt;item&gt;&lt;p&gt;It evaluates whether the current code signature satisfies the stored&lt;/p&gt;&lt;code&gt;csreq&lt;/code&gt;expression from the database row:&lt;code&gt;(Current_Code_Signature) satisfies (Stored_CSReq)&lt;/code&gt;&lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;If the check fails (for example, the app was re-signed with a different certificate), existing permissions do not apply, and a new prompt may be triggered or access denied.&lt;/p&gt;
      &lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;This prevents an attacker from overwriting &lt;code&gt;/Applications/TrustedApp.app&lt;/code&gt; with malware and inheriting its camera or disk permissions.&lt;/p&gt;
    &lt;p&gt;Protection Mechanisms&lt;/p&gt;
    &lt;p&gt;Although the TCC databases are ordinary SQLite files, access to them is tightly controlled:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;p&gt;SIP Protection: The system TCC database is protected by SIP; direct modifications are blocked for all but a handful of Apple-signed components with special entitlements (including&lt;/p&gt;&lt;code&gt;tccd&lt;/code&gt;itself).&lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;MAC / Data Vaults: On newer macOS versions, the directory containing TCC databases can be part of a Data Vault, requiring specific entitlements just to traverse or open the directory and files.&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;&lt;p&gt;Exclusive Control by&lt;/p&gt;&lt;code&gt;tccd&lt;/code&gt;:&lt;list rend="ul"&gt;&lt;item&gt;&lt;code&gt;tccd&lt;/code&gt;maintains long-lived connections and can hold locks on the database.&lt;/item&gt;&lt;item&gt;Attempts to modify the file on disk directly (for example, via &lt;code&gt;sqlite3&lt;/code&gt;under a disabled SIP configuration) often lead to integrity check failures, after which&lt;code&gt;tccd&lt;/code&gt;may restore the database from a backup or recover via WAL semantics.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;RE Focus: The &lt;code&gt;tccutil&lt;/code&gt; Fallacy&lt;/p&gt;
    &lt;p&gt;The &lt;code&gt;tccutil&lt;/code&gt; command-line utility behaves as a client of TCC, not a raw database editor:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;It communicates with &lt;code&gt;tccd&lt;/code&gt;via XPC to request resets or clears.&lt;/item&gt;
      &lt;item&gt;It does not write to &lt;code&gt;TCC.db&lt;/code&gt;directly.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;For reverse engineering:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Observing XPC traffic between &lt;code&gt;tccutil&lt;/code&gt;and&lt;code&gt;tccd&lt;/code&gt;yields the supported operations and their internal names.&lt;/item&gt;
      &lt;item&gt;Direct tampering with &lt;code&gt;TCC.db&lt;/code&gt;is fragile and often counterproductive; intercepting or simulating&lt;code&gt;tccd&lt;/code&gt;’s own XPC interfaces is more robust.&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h4"&gt;9.3.2 The Attribution Chain: Determining Who Is Asking&lt;/head&gt;
    &lt;p&gt;The hardest problem TCC solves is Attribution. When an action flows through multiple processes, which one should be considered the “client” for consent purposes?&lt;/p&gt;
    &lt;p&gt;Examples:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;A GUI app that launches a helper tool to touch the camera.&lt;/item&gt;
      &lt;item&gt;A terminal running a shell script that launches &lt;code&gt;curl&lt;/code&gt;or a Python interpreter.&lt;/item&gt;
      &lt;item&gt;A background agent performing work on behalf of a signed, user-facing app.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The XPC Audit Token&lt;/p&gt;
    &lt;p&gt;When a message arrives at &lt;code&gt;tccd&lt;/code&gt; (for example, over &lt;code&gt;com.apple.tccd.system&lt;/code&gt; or &lt;code&gt;com.apple.tccd&lt;/code&gt;):&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;The Mach message carries an audit token in its trailer.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;tccd&lt;/code&gt;extracts PID, UID, GID, and audit attributes from this token.&lt;/item&gt;
      &lt;item&gt;It uses the kernel’s code-signing interfaces (&lt;code&gt;csops&lt;/code&gt;,&lt;code&gt;CS_VALID&lt;/code&gt;flags) to resolve the token to an actual, signed binary on disk.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The audit token is provided by the kernel and cannot be forged by userland, making it the primary identity anchor.&lt;/p&gt;
    &lt;p&gt;The “Responsible Process” Problem&lt;/p&gt;
    &lt;p&gt;Attribution is not always identical to the immediate caller:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;For &lt;code&gt;Terminal.app&lt;/code&gt;running&lt;code&gt;curl&lt;/code&gt;, the responsible entity for a network or disk access may be considered&lt;code&gt;Terminal.app&lt;/code&gt;, not&lt;code&gt;curl&lt;/code&gt;.&lt;/item&gt;
      &lt;item&gt;For automation or helper tools, a background daemon might act on behalf of a user-facing app.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;To handle this, TCC models an Attribution Chain:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;&lt;code&gt;responsible_pid&lt;/code&gt;and Relationship Tracking&lt;list rend="ul"&gt;&lt;item&gt;Launch services, XPC, and higher-level frameworks can mark another process as the “responsible” one (for example, via launch configuration or XPC flags).&lt;/item&gt;&lt;item&gt;&lt;code&gt;tccd&lt;/code&gt;verifies that the relationship between caller and responsible process is legitimate (parent–child, session, or entitlement-based).&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;&lt;p&gt;Access Object Construction&lt;/p&gt;&lt;p&gt;Internally,&lt;/p&gt;&lt;code&gt;tccd&lt;/code&gt;constructs a conceptual&lt;code&gt;TCCAccessRequest&lt;/code&gt;:&lt;list rend="ul"&gt;&lt;item&gt;Subject: The process issuing the request (the immediate caller).&lt;/item&gt;&lt;item&gt;Accessor: The process that will actually interact with the resource (often equal to the subject).&lt;/item&gt;&lt;item&gt;Attributor: The process that should be presented to the user in UI and used as the key in the database.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Decision Logic&lt;/p&gt;
        &lt;p&gt;Roughly:&lt;/p&gt;
        &lt;list rend="ul"&gt;
          &lt;item&gt;If the caller has a private entitlement such as &lt;code&gt;com.apple.private.tcc.allow&lt;/code&gt;for the requested service, access is granted without user interaction.&lt;/item&gt;
          &lt;item&gt;Otherwise, TCC looks for an existing row in &lt;code&gt;TCC.db&lt;/code&gt;for the attributor and service (using&lt;code&gt;csreq&lt;/code&gt;matching).&lt;/item&gt;
          &lt;item&gt;If no row exists, &lt;code&gt;tccd&lt;/code&gt;triggers a user prompt.&lt;/item&gt;
        &lt;/list&gt;
      &lt;/item&gt;
      &lt;item&gt;If the caller has a private entitlement such as &lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Secure UI&lt;/p&gt;
    &lt;p&gt;TCC prompts are not drawn by the requesting client:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;tccd&lt;/code&gt;delegates UI to system agents such as&lt;code&gt;UserNotificationCenter&lt;/code&gt;/&lt;code&gt;CoreServicesUIAgent&lt;/code&gt;.&lt;/item&gt;
      &lt;item&gt;Prompts are shown in elevated WindowServer layers that the client cannot fully control or overlay, mitigating clickjacking and fake consent dialogs.&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h4"&gt;9.3.3 RE Focus: XPC Attacks against TCC Endpoint Validation&lt;/head&gt;
    &lt;p&gt;From a vulnerability research perspective, &lt;code&gt;tccd&lt;/code&gt; is a high-value target. Gaining the ability to impersonate a trusted client (such as &lt;code&gt;Finder.app&lt;/code&gt;) can yield Full Disk Access or other sensitive capabilities.&lt;/p&gt;
    &lt;p&gt;Attack Vector 1: XPC Injection into Trusted Clients&lt;/p&gt;
    &lt;p&gt;Many TCC-permitted apps are extensible:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;They load bundles or plugins via &lt;code&gt;dlopen&lt;/code&gt;.&lt;/item&gt;
      &lt;item&gt;They may allow scripting or untrusted content with code execution.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;If an attacker injects code into such a process:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;That code runs inside the trusted PID.&lt;/item&gt;
      &lt;item&gt;TCC continues to see the trusted app’s identity and grants access based on its existing permissions.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Mitigations:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Hardened Runtime and Library Validation (enforced by AMFI and &lt;code&gt;dyld&lt;/code&gt;in cooperation with TXM) prevent loading unsigned or unentitled libraries into hardened processes.&lt;/item&gt;
      &lt;item&gt;However, any app with &lt;code&gt;com.apple.security.cs.disable-library-validation&lt;/code&gt;or similar entitlements remains a potential carrier for this class of attack.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Attack Vector 2: Fake Attributors and XPC Payload Spoofing&lt;/p&gt;
    &lt;p&gt;Earlier macOS versions were more trusting of client-supplied metadata in XPC messages:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Some TCC code paths accepted an explicit “target token” or attribution fields from the client’s XPC dictionary.&lt;/item&gt;
      &lt;item&gt;Attackers could attempt to supply a forged &lt;code&gt;target_token&lt;/code&gt;that pointed to a more privileged app.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Modern TCC has hardened this:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;For most services, &lt;code&gt;tccd&lt;/code&gt;ignores user-provided tokens in XPC payloads.&lt;/item&gt;
      &lt;item&gt;It trusts only the kernel-supplied audit token from the Mach message trailer and reconstructs attribution from kernel state and entitlement checks.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Attack Vector 3: Semantic Confusion via Automation (AppleEvents, &lt;code&gt;open&lt;/code&gt;, etc.)&lt;/p&gt;
    &lt;p&gt;An attacker can attempt to coerce a privileged app into performing an action:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;For example, using AppleEvents or the &lt;code&gt;open&lt;/code&gt;command to cause&lt;code&gt;Terminal&lt;/code&gt;or another privileged app to run a script or open a sensitive file.&lt;/item&gt;
      &lt;item&gt;If the privileged app is the attributor in TCC’s view, its permissions are leveraged by the attacker’s payload.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Mitigations:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Automation permissions such as &lt;code&gt;kTCCServiceAppleEvents&lt;/code&gt;gate which apps can send AppleEvents to which targets.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;tccd&lt;/code&gt;tracks automation relationships and often requires separate consent for one app to control another.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The Tahoe Impact: Hardware-Anchored Identity&lt;/p&gt;
    &lt;p&gt;On Apple Silicon with Tahoe-class hardware:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;
        &lt;p&gt;TCC depends on code-signing identity and hardened runtime flags obtained from the kernel.&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Those, in turn, are anchored in TXM and SPTM:&lt;/p&gt;
        &lt;list rend="ul"&gt;
          &lt;item&gt;TXM controls executable mappings and trust caches.&lt;/item&gt;
          &lt;item&gt;SPTM enforces that the kernel’s view of code identity cannot be arbitrarily rewritten via page-table manipulation.&lt;/item&gt;
        &lt;/list&gt;
      &lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Consequences:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;p&gt;A kernel attacker who sets&lt;/p&gt;&lt;code&gt;CS_VALID&lt;/code&gt;bits in process credentials without correspondingly convincing TXM risks creating a state where pages will not be executable or are killed on use.&lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;TCC’s reliance on code identity is therefore backed by a hardware root of trust: subtly altering TCC decisions still requires either:&lt;/p&gt;
        &lt;list rend="ul"&gt;
          &lt;item&gt;Subverting &lt;code&gt;tccd&lt;/code&gt;’s logic (via XPC or parsing bugs), or&lt;/item&gt;
          &lt;item&gt;Subverting the TXM/SPTM path that defines which CDHashes are trustworthy.&lt;/item&gt;
        &lt;/list&gt;
      &lt;/item&gt;
      &lt;item&gt;Subverting &lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Even under kernel compromise, forging the identity of a high-value system binary that TCC trusts is significantly more complex than on pre-SPTM systems; the identity must be consistent from the userland view, the kernel’s credentials, and the secure-world trust caches.&lt;/p&gt;
    &lt;head rend="h2"&gt;10.0 User Session, Authentication &amp;amp; Data Protection&lt;/head&gt;
    &lt;p&gt;The transition from the system bootstrap phase to the interactive user session represents a critical boundary crossing. Up to this point, the system has operated primarily in the &lt;code&gt;Startup&lt;/code&gt; domain, managed by the root &lt;code&gt;launchd&lt;/code&gt; context. The instantiation of a user session requires the creation of a new security context—the Audit Session—and the decryption of user-specific cryptographic material anchored in the Secure Enclave.&lt;/p&gt;
    &lt;p&gt;In the Tahoe architecture, this process is no longer a simple comparison of a password hash against a file. It is a hardware-mediated ceremony involving:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Evaluation of the user’s credentials via Open Directory and the Shadow Hash store.&lt;/item&gt;
      &lt;item&gt;Unlocking of a SEP-protected per-user secret that underpins the Secure Token / FileVault authorization model.&lt;/item&gt;
      &lt;item&gt;Derivation or unwrapping of the User Keybag inside the SEP.&lt;/item&gt;
      &lt;item&gt;Establishment of a local Kerberos identity (via the Local KDC / LKDC) for those services that participate in single sign-on, with the initial credentials ultimately rooted in secrets that are only accessible after the SEP has accepted the login.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Biometrics (Touch ID, Face ID, Optic ID) do not replace the password; they conditionally authorize the Secure Enclave to perform cryptographic operations—such as unwrapping key material—that would otherwise require manual secret entry.&lt;/p&gt;
    &lt;head rend="h3"&gt;10.1 &lt;code&gt;loginwindow&lt;/code&gt; &amp;amp; &lt;code&gt;opendirectoryd&lt;/code&gt;&lt;/head&gt;
    &lt;p&gt;The graphical login experience is orchestrated by two primary userland components:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;loginwindow&lt;/code&gt;– Manages the session lifecycle and login UI, coordinates shield windows, and drives the state machine for login / logout / fast user switching.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;opendirectoryd&lt;/code&gt;– Provides the abstraction layer for authentication and identity services, loading plugins to speak to local, LDAP, and Active Directory nodes.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Both components have lineage back to NeXTSTEP, but their internals have been aggressively refactored to support the hardware-backed security model of Apple Silicon and the Tahoe boot chain.&lt;/p&gt;
    &lt;head rend="h4"&gt;10.1.1 The Audit Session ID (ASID) and Kernel Tracking&lt;/head&gt;
    &lt;p&gt;In XNU, the concept of a “User” in the sense of a login instance is tracked via the Audit Session ID (ASID). This is distinct from the UNIX UID/GID:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;UID/GID – Identify principals in the traditional POSIX sense.&lt;/item&gt;
      &lt;item&gt;ASID – Identifies a specific authenticated session (e.g. physical console login, fast user switch slot, SSH login, screen sharing session).&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Every process in the system carries an &lt;code&gt;audit_token_t&lt;/code&gt; which encodes, among other fields, the ASID of the session under which it is running.&lt;/p&gt;
    &lt;p&gt;The &lt;code&gt;setaudit_addr&lt;/code&gt; syscall&lt;/p&gt;
    &lt;p&gt;When &lt;code&gt;loginwindow&lt;/code&gt; successfully authenticates a user, it does not simply &lt;code&gt;setuid&lt;/code&gt;. It calls into the BSM audit stack via the &lt;code&gt;setaudit_addr&lt;/code&gt; syscall (typically through &lt;code&gt;libbsm&lt;/code&gt; wrappers):&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Kernel structure: The syscall populates the &lt;code&gt;auditinfo_addr&lt;/code&gt;state, from which&lt;code&gt;audit_token_t&lt;/code&gt;values are derived for that process.&lt;/item&gt;
      &lt;item&gt;Inheritance: Children inherit their parent’s ASID in much the same way they inherit UID/GID.&lt;/item&gt;
      &lt;item&gt;Mutability constraints: Changing an ASID after it has been established is tightly controlled. In practice, only a small set of privileged components (e.g. &lt;code&gt;loginwindow&lt;/code&gt;,&lt;code&gt;sshd&lt;/code&gt;) can create or reassign audit sessions, and they do so under private entitlements discovered via reverse engineering rather than public API.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;For almost all processes, the ASID behaves as a write-once attribute: it is set when the session is created and then propagated down the process tree.&lt;/p&gt;
    &lt;p&gt;ASID as a Console Ownership signal&lt;/p&gt;
    &lt;p&gt;The ASID acts as a primary signal for “Console Ownership” in several subsystems:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;p&gt;TCC /&lt;/p&gt;&lt;code&gt;tccd&lt;/code&gt;:&lt;lb/&gt;Access-control decisions for sensors such as Camera and Microphone are made in the context of an audit token. When a process requests, for example, Camera access,&lt;code&gt;tccd&lt;/code&gt;evaluates whether the request comes from the ASID associated with the active graphical console. Foreground sessions see prompts; non-console sessions (e.g. SSH) are generally denied or handled differently.&lt;/item&gt;
      &lt;item&gt;&lt;p&gt;WindowServer / SkyLight:&lt;/p&gt;&lt;lb/&gt;Only processes that belong to the active console ASID are permitted to establish the full, interactive connection to the WindowServer required to draw on the screen. Other ASIDs may be confined to offscreen rendering, remote sessions, or be blocked entirely.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;This makes the ASID a crucial anchor for reasoning about which processes are “actually in front of the user” in the Tahoe user-session model.&lt;/p&gt;
    &lt;p&gt;RE Focus: &lt;code&gt;security_authtrampoline&lt;/code&gt; and launchd domains&lt;/p&gt;
    &lt;p&gt;Historically, the transition from the &lt;code&gt;loginwindow&lt;/code&gt; context (running as root) to the user context involved a setuid helper binary, &lt;code&gt;security_authtrampoline&lt;/code&gt;, which mediated the handoff of credentials and environment to a per-user &lt;code&gt;/sbin/launchd&lt;/code&gt; process. That design existed in earlier OS X releases, where each logged-in user had their own &lt;code&gt;launchd&lt;/code&gt; instance.&lt;/p&gt;
    &lt;p&gt;Modern macOS (including Tahoe) uses a different model:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;p&gt;There is a single&lt;/p&gt;&lt;code&gt;launchd&lt;/code&gt;process (PID 1) for the entire system.&lt;/item&gt;
      &lt;item&gt;&lt;p&gt;Instead of spawning separate&lt;/p&gt;&lt;code&gt;launchd&lt;/code&gt;processes per user,&lt;code&gt;launchd&lt;/code&gt;manages multiple domains in its bootstrap namespace:&lt;list rend="ul"&gt;&lt;item&gt;A system domain for LaunchDaemons.&lt;/item&gt;&lt;item&gt;User domains keyed by UID (e.g. &lt;code&gt;user/501/&lt;/code&gt;).&lt;/item&gt;&lt;item&gt;Login/session domains keyed by ASID (e.g. &lt;code&gt;login/ASID/&lt;/code&gt;or&lt;code&gt;session/ASID/&lt;/code&gt;).&lt;/item&gt;&lt;item&gt;GUI domains (e.g. &lt;code&gt;gui/UID/&lt;/code&gt;) that correspond to interactive consoles.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;On successful authentication, &lt;code&gt;loginwindow&lt;/code&gt; now:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;&lt;p&gt;Uses private XPC/session APIs (e.g.&lt;/p&gt;&lt;code&gt;xpc_session_create&lt;/code&gt;and related calls, as observed via reverse engineering) to ask the system&lt;code&gt;launchd&lt;/code&gt;(PID 1) to create or activate:&lt;list rend="ul"&gt;&lt;item&gt;A user domain for the authenticated UID.&lt;/item&gt;&lt;item&gt;A login/session domain keyed by the newly established ASID.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Binds that login domain to the new Audit Session:&lt;/p&gt;
        &lt;list rend="ul"&gt;
          &lt;item&gt;New user processes launched for the session are started in this login domain.&lt;/item&gt;
          &lt;item&gt;Their &lt;code&gt;audit_token_t&lt;/code&gt;values reflect both the user’s UID and the new ASID.&lt;/item&gt;
        &lt;/list&gt;
      &lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;From this point of view:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;p&gt;The login domain in&lt;/p&gt;&lt;code&gt;launchd&lt;/code&gt;becomes the logical root of the user’s process tree for that session (services, agents, apps), but:&lt;list rend="ul"&gt;&lt;item&gt;All of these processes are still ultimately descendants of the single PID-1 &lt;code&gt;launchd&lt;/code&gt;.&lt;/item&gt;&lt;item&gt;There is no separate “User &lt;code&gt;launchd&lt;/code&gt;” process in modern macOS; only per-user/per-session domains inside the global&lt;code&gt;launchd&lt;/code&gt;.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;All of these processes are still ultimately descendants of the single PID-1 &lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;For reverse engineers, the key observation points are:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Tracking how &lt;code&gt;loginwindow&lt;/code&gt;transitions from “no session” to “new ASID + new login domain”.&lt;/item&gt;
      &lt;item&gt;Enumerating &lt;code&gt;launchd&lt;/code&gt;jobs in the relevant&lt;code&gt;user/&lt;/code&gt;and&lt;code&gt;login/&lt;/code&gt;namespaces to reconstruct the user’s process lattice for a given ASID.&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h4"&gt;10.1.2 &lt;code&gt;loginwindow&lt;/code&gt;: The Shield Window and Session State&lt;/head&gt;
    &lt;p&gt;&lt;code&gt;loginwindow&lt;/code&gt; (at &lt;code&gt;/System/Library/CoreServices/loginwindow.app/Contents/MacOS/loginwindow&lt;/code&gt;) is the session leader for the console. It:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Draws the login UI and lock screen.&lt;/item&gt;
      &lt;item&gt;Negotiates authentication with &lt;code&gt;opendirectoryd&lt;/code&gt;and Kerberos components.&lt;/item&gt;
      &lt;item&gt;Manages fast user switching and logout.&lt;/item&gt;
      &lt;item&gt;Maintains the “Shield Window” that sits above all userland UI during sensitive phases.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The Shield Window (anti-overlay)&lt;/p&gt;
    &lt;p&gt;To prevent “fake login” and clickjacking attacks in which a malicious application draws a visually perfect imitation of the login screen to steal credentials, &lt;code&gt;loginwindow&lt;/code&gt; uses a privileged connection to SkyLight (the WindowServer framework):&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Window level: The login UI is drawn at or near &lt;code&gt;kCGShieldingWindowLevel&lt;/code&gt;, a reserved Z-order used by the system for modalities like login, lock, and screen dimming overlays.&lt;/item&gt;
      &lt;item&gt;Exclusive event routing: While the Shield Window is active, the WindowServer routes all keyboard and pointer events exclusively to &lt;code&gt;loginwindow&lt;/code&gt;. Background applications may still be composited but do not receive input, even if their windows visually overlap or mimic the login UI.&lt;/item&gt;
      &lt;item&gt;Console focus: The Shield Window is tied to the active console ASID, so remote or background sessions cannot legitimately persist a shield that captures events intended for the physical user.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;For RE work, confirming input exclusivity via event taps is a good sanity check that the shielded state is active.&lt;/p&gt;
    &lt;p&gt;The State Machine&lt;/p&gt;
    &lt;p&gt;&lt;code&gt;loginwindow&lt;/code&gt; implements a substantial state machine driven by:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;AppleEvents: Legacy IPC paths that still orchestrate parts of the login / logout choreography and client notifications.&lt;/item&gt;
      &lt;item&gt;Darwin Notifications / XPC: Modern notification mechanisms for coordinating with &lt;code&gt;opendirectoryd&lt;/code&gt;,&lt;code&gt;launchd&lt;/code&gt;, and system services.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Relevant legacy hooks:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;LoginHook&lt;/code&gt;/&lt;code&gt;LogoutHook&lt;/code&gt;:&lt;lb/&gt;While officially deprecated, the underlying code paths remain. They are surrounded by modern sandboxing and hardened runtime checks, but they still provide observable transitions around session start / end.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Session state persistence:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;p&gt;Resume / Transparent App Lifecycle (TAL):&lt;/p&gt;&lt;code&gt;loginwindow&lt;/code&gt;participates in the “Resume” feature (re-opening windows after reboot or logout). State is persisted across:&lt;list rend="ul"&gt;&lt;item&gt;Per-host preferences such as &lt;code&gt;~/Library/Preferences/ByHost/com.apple.loginwindow.*.plist&lt;/code&gt;.&lt;/item&gt;&lt;item&gt;Per-application saved state under &lt;code&gt;~/Library/Saved Application State/&lt;/code&gt;.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;Per-host preferences such as &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;These artifacts are protected by the user’s Data Protection keys and provide a rich post-mortem surface for reconstructing session evolution.&lt;/p&gt;
      &lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h4"&gt;10.1.3 &lt;code&gt;opendirectoryd&lt;/code&gt;: The Authentication Broker&lt;/head&gt;
    &lt;p&gt;&lt;code&gt;opendirectoryd&lt;/code&gt; is the daemon responsible for answering the question: “Are these credentials valid for this identity?” It is a modular daemon that loads plugins (bundles) to handle different directory services: local, LDAP, Active Directory, and more.&lt;/p&gt;
    &lt;p&gt;The Local Node (&lt;code&gt;/Local/Default&lt;/code&gt;)&lt;/p&gt;
    &lt;p&gt;On a standalone Mac, authentication is handled by the Local Node, whose data store lives under:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;
        &lt;code&gt;/var/db/dslocal/nodes/Default/&lt;/code&gt;
      &lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Within this node:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Users are stored as individual property list (&lt;code&gt;.plist&lt;/code&gt;) files under&lt;code&gt;users/&lt;/code&gt;.&lt;/item&gt;
      &lt;item&gt;These plists contain metadata (name, UID, group memberships, secure token flags, etc.) but not directly the password hash.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Shadow Hash Data&lt;/p&gt;
    &lt;p&gt;The actual password verifier is stored as Shadow Hash data:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;p&gt;The user plist typically contains a&lt;/p&gt;&lt;code&gt;ShadowHashData&lt;/code&gt;key whose value is a binary blob.&lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Analysis of these blobs shows:&lt;/p&gt;
        &lt;list rend="ul"&gt;
          &lt;item&gt;A SALTED-SHA512-PBKDF2 representation of the password for compatibility with older flows and offline verification scenarios.&lt;/item&gt;
          &lt;item&gt;Additional structured fields used by Apple’s modern authentication path, including material that is only meaningful in combination with the Secure Enclave and device-specific secrets.&lt;/item&gt;
        &lt;/list&gt;
      &lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;In the Tahoe-era architecture, it is useful to conceptually treat part of this blob as a SEP-wrapped per-user secret that participates in FileVault and keybag unlock. Apple does not publish the internal structure of &lt;code&gt;ShadowHashData&lt;/code&gt;, but reverse engineering strongly indicates that the blob contains more than a conventional hash.&lt;/p&gt;
    &lt;p&gt;Verification Flow (&lt;code&gt;ODRecordVerifyPassword&lt;/code&gt;)&lt;/p&gt;
    &lt;p&gt;When &lt;code&gt;loginwindow&lt;/code&gt; submits a password to &lt;code&gt;opendirectoryd&lt;/code&gt; for a local account, the flow roughly looks like this:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;&lt;p&gt;Directory lookup:&lt;/p&gt;&lt;code&gt;opendirectoryd&lt;/code&gt;uses its Local Node plugin to locate the user record and retrieve the associated&lt;code&gt;ShadowHashData&lt;/code&gt;blob.&lt;/item&gt;
      &lt;item&gt;&lt;p&gt;Hash verification:&lt;/p&gt;&lt;lb/&gt;The SALTED-SHA512-PBKDF2 component can be verified locally to confidently reject obviously wrong passwords without involving the SEP.&lt;/item&gt;
      &lt;item&gt;&lt;p&gt;Secure Enclave mediation:&lt;/p&gt;&lt;lb/&gt;For FileVault-enabled accounts and for modern secure-token flows,&lt;code&gt;opendirectoryd&lt;/code&gt;(via lower layers in the stack) invokes the AppleSEPKeyStore interface in the kernel:&lt;list rend="ul"&gt;&lt;item&gt;&lt;p&gt;The candidate password and the relevant wrapped secret(s) derived from&lt;/p&gt;&lt;code&gt;ShadowHashData&lt;/code&gt;are marshalled to the kernel.&lt;/item&gt;&lt;item&gt;&lt;p&gt;The kernel forwards this to the SEP over the mailbox channel.&lt;/p&gt;&lt;/item&gt;&lt;item&gt;&lt;p&gt;The SEP combines:&lt;/p&gt;&lt;list rend="ul"&gt;&lt;item&gt;The device’s UID key (fused in hardware, never leaving the SEP).&lt;/item&gt;&lt;item&gt;A KDF over the password and salt.&lt;/item&gt;&lt;item&gt;Policy- and measurement-dependent state (e.g. SKP).&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;&lt;item&gt;&lt;p&gt;The SEP attempts to “unwrap” the per-user secret and, if successful, signals success and may derive additional keys for keybag and FileVault operations.&lt;/p&gt;&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;&lt;p&gt;Result propagation:&lt;/p&gt;&lt;code&gt;opendirectoryd&lt;/code&gt;treats SEP success as authoritative for those modern flows. A failure at this stage typically manifests as an authentication error even if the legacy PBKDF2 hash alone would have been satisfied.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;RE Implication&lt;/p&gt;
    &lt;p&gt;This architecture has two important consequences:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;p&gt;Password hashes vs. device-bound keys:&lt;/p&gt;&lt;lb/&gt;Extracting&lt;code&gt;ShadowHashData&lt;/code&gt;allows offline cracking of the PBKDF2-SHA512 password hash, but recovering the password does not by itself reconstruct the FileVault Volume Encryption Key (VEK) or class keys. Those require the SEP, UID key, and SKP-bound material.&lt;/item&gt;
      &lt;item&gt;&lt;p&gt;Device specificity:&lt;/p&gt;&lt;lb/&gt;The secrets that actually unlock user data are bound to the specific Secure Enclave instance that created them. Moving Shadow Hash material to another Mac does not make that user’s FileVault-protected data decryptable without further compromise.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;From a red-team perspective, this forces attacks toward live credential interception (before the password is sent into the verification pipeline) or SEP compromise, rather than traditional offline hash cracking for disk decryption.&lt;/p&gt;
    &lt;head rend="h4"&gt;10.1.4 Kerberos and the Local KDC (Heimdal)&lt;/head&gt;
    &lt;p&gt;Modern macOS systems ship with a Heimdal Kerberos stack and, by default, support a Local Key Distribution Center (LKDC). The LKDC provides Kerberized identities for local services and is integrated with Open Directory.&lt;/p&gt;
    &lt;p&gt;Why Kerberos on a standalone Mac?&lt;/p&gt;
    &lt;p&gt;Kerberos avoids passing plaintext passwords around systemwide. Instead:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;&lt;p&gt;Initial login (when Kerberos is configured):&lt;/p&gt;&lt;lb/&gt;Once the user’s credentials have been accepted (potentially via SEP-mediated verification), the system can obtain a Ticket Granting Ticket (TGT) from the LKDC corresponding to that account. This step is conditional: non-Kerberized setups or purely local workflows may omit it.&lt;/item&gt;
      &lt;item&gt;&lt;p&gt;Credential cache:&lt;/p&gt;&lt;lb/&gt;Kerberos tickets are stored in a credential cache managed by the system (kernel and userland helpers), typically accessed via the standard&lt;code&gt;KRB5CCNAME&lt;/code&gt;/ CCAPI plumbing.&lt;/item&gt;
      &lt;item&gt;&lt;p&gt;Service authentication:&lt;/p&gt;&lt;lb/&gt;When the user interacts with Kerberized services (e.g. Screen Sharing, some system preference panes, local file services, AD-backed services), the client obtains a service ticket from the LKDC and presents it to the target service instead of resending the password.&lt;/item&gt;
      &lt;item&gt;&lt;p&gt;Validation:&lt;/p&gt;&lt;lb/&gt;Services validate the Kerberos ticket and enforce their own authorization logic.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Smart Card and PKINIT&lt;/p&gt;
    &lt;p&gt;In higher-assurance environments:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;
        &lt;p&gt;Smart cards or platform PIV tokens (backed by the Secure Enclave) are used instead of passwords.&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Kerberos uses PKINIT to validate an X.509 certificate chain, mapping it to a Kerberos principal.&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Tahoe’s hardened boot and driver model ensures that:&lt;/p&gt;
        &lt;list rend="ul"&gt;
          &lt;item&gt;The smart card driver stack (often running as a driver extension, &lt;code&gt;dext&lt;/code&gt;) is validated and measured under TXM/LocalPolicy.&lt;/item&gt;
          &lt;item&gt;Certificates and private keys used for PKINIT are only accessible after SEP policy checks.&lt;/item&gt;
        &lt;/list&gt;
      &lt;/item&gt;
      &lt;item&gt;The smart card driver stack (often running as a driver extension, &lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;RE Focus: &lt;code&gt;Heimdal.framework&lt;/code&gt;&lt;/p&gt;
    &lt;p&gt;The private &lt;code&gt;Heimdal.framework&lt;/code&gt; contains the glue between &lt;code&gt;loginwindow&lt;/code&gt;, &lt;code&gt;opendirectoryd&lt;/code&gt;, and the Kerberos stack:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Functions like &lt;code&gt;krb5_get_init_creds_password&lt;/code&gt;remain useful RE chokepoints for observing when and how plaintext credentials are turned into Kerberos tickets.&lt;/item&gt;
      &lt;item&gt;Hooking these paths requires bypassing SIP and the hardened runtime and is therefore squarely in the “post-exploitation / lab” category rather than a practical on-disk modification target.&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h3"&gt;10.2 Biometric Unlock (Touch ID / Face ID / Optic ID)&lt;/head&gt;
    &lt;p&gt;Biometric authentication on Apple platforms is frequently misunderstood as a replacement for the passcode or password. Architecturally, it is a convenience mechanism:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Biometrics never replace the underlying secret; they authorize the Secure Enclave to perform a cryptographic operation that would otherwise require manual entry of that secret.&lt;/item&gt;
      &lt;item&gt;The SEP decides whether biometric factors are currently acceptable (policy, backoff, recent passcode use, secure intent).&lt;/item&gt;
      &lt;item&gt;On success, the SEP unlocks or derives specific keys and returns opaque handles or tokens to the OS.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;In the Tahoe architecture, the biometric stack is an interplay between:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Userland daemons (&lt;code&gt;coreauthd&lt;/code&gt;,&lt;code&gt;biometrickitd&lt;/code&gt;).&lt;/item&gt;
      &lt;item&gt;Kernel drivers (&lt;code&gt;AppleBiometricSensor&lt;/code&gt;, Local Authentication hooks).&lt;/item&gt;
      &lt;item&gt;The Secure Enclave.&lt;/item&gt;
      &lt;item&gt;For Face ID and Optic ID: the Secure Neural Engine (SNE).&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h4"&gt;10.2.1 The Daemon Hierarchy: &lt;code&gt;coreauthd&lt;/code&gt; → &lt;code&gt;biometrickitd&lt;/code&gt; → SEP&lt;/head&gt;
    &lt;p&gt;The implementation is split across two main daemons to enforce separation of concerns:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;coreauthd&lt;/code&gt;– Policy&lt;lb/&gt;Located at&lt;code&gt;/System/Library/Frameworks/LocalAuthentication.framework/Support/coreauthd&lt;/code&gt;,&lt;lb/&gt;it implements the system’s Local Authentication policy engine:&lt;list rend="ul"&gt;&lt;item&gt;Manages &lt;code&gt;LAContext&lt;/code&gt;instances and associates them with PIDs, ASIDs, and calling processes.&lt;/item&gt;&lt;item&gt;Parses Keychain Access Control Lists (ACLs), evaluating requirements such as “biometry OR passcode” vs “biometry AND device unlock”.&lt;/item&gt;&lt;item&gt;Implements the Access Control Module (ACM) logic that mirrors SEP-side decision structures: it constructs and validates the requests that will eventually be sent to the Secure Enclave.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;Manages &lt;/item&gt;
      &lt;item&gt;&lt;code&gt;biometrickitd&lt;/code&gt;– Mechanism&lt;lb/&gt;Located at&lt;code&gt;/usr/libexec/biometrickitd&lt;/code&gt;, it manages the physical biometric sensors:&lt;list rend="ul"&gt;&lt;item&gt;Sensor abstraction: Loads device-specific plugins (e.g. Mesa for Touch ID, Pearl for Face ID, Jade for Optic ID).&lt;/item&gt;&lt;item&gt;Power / state management: Controls sensor power, exposure, illumination hardware, and readiness.&lt;/item&gt;&lt;item&gt;Data relay: Sets up shared buffers or DMA configurations between the sensor hardware and the Secure Enclave via the kernel. It does not perform high-level biometric matching; it shuttles encrypted sensor output toward the SEP.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The Handshake&lt;/p&gt;
    &lt;p&gt;A typical biometric request flows as follows:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;&lt;p&gt;An app invokes&lt;/p&gt;&lt;code&gt;-[LAContext evaluatePolicy:localizedReason:reply:]&lt;/code&gt;.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;coreauthd&lt;/code&gt;:&lt;list rend="ul"&gt;&lt;item&gt;Validates the caller’s code signature, entitlements, and audit token (including ASID).&lt;/item&gt;&lt;item&gt;Checks Keychain or system ACLs to decide whether biometry is acceptable for this operation.&lt;/item&gt;&lt;item&gt;Creates an &lt;code&gt;ACMContext&lt;/code&gt;structure representing this auth attempt.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;coreauthd&lt;/code&gt;sends an XPC request to&lt;code&gt;biometrickitd&lt;/code&gt;to arm the appropriate sensor.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;biometrickitd&lt;/code&gt;:&lt;list rend="ul"&gt;&lt;item&gt;Issues &lt;code&gt;IOConnectCall*&lt;/code&gt;requests into the biometric kernel driver (&lt;code&gt;AppleBiometricSensor&lt;/code&gt;and relatives).&lt;/item&gt;&lt;item&gt;The driver configures the sensor and a buffer that is shared with or visible to the Secure Enclave.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;Issues &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;The kernel signals the SEP via the mailbox that a biometric capture session is ready and provides the buffer references.&lt;/p&gt;
      &lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;At that point, the SEP takes over capture, matching, and decision logic; userland daemons observe state transitions and present UI, but never see raw biometric templates.&lt;/p&gt;
    &lt;head rend="h4"&gt;10.2.2 The Hardware Path: Sensor-to-SEP Pairing&lt;/head&gt;
    &lt;p&gt;A critical security property of the biometric stack is hardware pairing between the sensor module and the Secure Enclave.&lt;/p&gt;
    &lt;p&gt;Factory pairing&lt;/p&gt;
    &lt;p&gt;During manufacturing and repair-authorization procedures:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;
        &lt;p&gt;The biometric sensor module (Touch ID button, TrueDepth camera system, Optic ID array) and the SEP perform a pairing protocol.&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;A shared secret is established and stored:&lt;/p&gt;
        &lt;list rend="ul"&gt;
          &lt;item&gt;In the sensor’s controller.&lt;/item&gt;
          &lt;item&gt;In SEP-managed internal storage (e.g. xART).&lt;/item&gt;
        &lt;/list&gt;
      &lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Encrypted channel&lt;/p&gt;
    &lt;p&gt;When a biometric capture occurs:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;The sensor acquires raw data (fingerprint ridge map, IR depth map, iris texture).&lt;/item&gt;
      &lt;item&gt;The sensor hardware encrypts this data using keys derived from the pairing secret before putting it on the bus.&lt;/item&gt;
      &lt;item&gt;The encrypted payload travels over SPI/MIPI to the Application Processor.&lt;/item&gt;
      &lt;item&gt;The biometric kernel driver writes the encrypted blob into a region of memory that is readable by the SEP.&lt;/item&gt;
      &lt;item&gt;The SEP reads the blob, decrypts it using the pairing key, and performs all further processing internally.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;From the AP’s perspective, these buffers contain high-entropy ciphertext. Dumping them from the kernel or an I/O trace yields no usable biometric image data.&lt;/p&gt;
    &lt;p&gt;RE Implication&lt;/p&gt;
    &lt;p&gt;Two empirically observable consequences:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Swapping a Touch ID or Face ID module between devices without running Apple’s pairing tools causes biometric functions to fail: the SEP can no longer decrypt sensor output.&lt;/item&gt;
      &lt;item&gt;Hooking the biometric driver stack and dumping in-flight data shows encrypted blobs rather than structured images, confirming that matching happens exclusively inside the SEP / SNE domain.&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h4"&gt;10.2.3 The Secure Neural Engine (SNE) &amp;amp; Optic ID&lt;/head&gt;
    &lt;p&gt;Face ID and Optic ID push biometric matching beyond the capabilities of the general-purpose SEP core. To handle these workloads, Apple partitions the Neural Engine (ANE) into:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;A standard mode – accessible to userland via Core ML.&lt;/item&gt;
      &lt;item&gt;A secure mode – a slice reserved for the Secure Enclave, sometimes referred to as the Secure Neural Engine (SNE).&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Optic ID Flow (Tahoe / Vision Pro)&lt;/p&gt;
    &lt;p&gt;At a high level, an Optic ID authentication proceeds as follows:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;&lt;p&gt;Capture:&lt;/p&gt;&lt;lb/&gt;The dedicated Optic ID cameras capture spatiotemporally modulated IR images of the user’s eyes.&lt;/item&gt;
      &lt;item&gt;&lt;p&gt;Encrypted transfer:&lt;/p&gt;&lt;lb/&gt;As with Touch ID and Face ID, the raw frames are encrypted at the sensor and written as ciphertext into memory visible to the SEP.&lt;/item&gt;
      &lt;item&gt;&lt;p&gt;SNE setup:&lt;/p&gt;&lt;lb/&gt;The SEP:&lt;list rend="ul"&gt;&lt;item&gt;Ensures that the portion of the Neural Engine allocated for secure use is scrubbed and placed under the control of its memory protection regime.&lt;/item&gt;&lt;item&gt;Loads the Optic ID neural network model and associated parameters.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;&lt;p&gt;Feature extraction:&lt;/p&gt;&lt;lb/&gt;The SEP feeds the encrypted image data through the secure ANE slice:&lt;list rend="ul"&gt;&lt;item&gt;The SNE produces feature vectors representing the iris and surrounding structures.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;&lt;p&gt;Template matching:&lt;/p&gt;&lt;lb/&gt;The SEP compares the feature vector against stored templates in its Secure Storage Component (xART-backed), applying thresholds, quality checks, and policy (user presence, recent activity, etc.).&lt;/item&gt;
      &lt;item&gt;&lt;p&gt;Liveness detection:&lt;/p&gt;&lt;lb/&gt;In parallel, the SEP uses the spatiotemporal pattern of IR illumination and pupil response to distinguish live tissue from static imagery or contact-lens attacks.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Memory protection&lt;/p&gt;
    &lt;p&gt;On recent Apple Silicon generations:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;
        &lt;p&gt;The memory used for SEP-private and SEP–SNE-shared computations is protected by the Secure Enclave’s Memory Protection Engine.&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Observers outside the SEP domain (including the AP and hypervisors) see encrypted and authenticated data when they attempt to read those regions.&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;This ensures that:&lt;/p&gt;
        &lt;list rend="ul"&gt;
          &lt;item&gt;Biometric templates and intermediate neural activations never appear in plaintext outside the Secure Enclave trust boundary.&lt;/item&gt;
          &lt;item&gt;Dumping DRAM does not expose Optic ID templates or models in a directly usable form.&lt;/item&gt;
        &lt;/list&gt;
      &lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h4"&gt;10.2.4 Secure Intent: The GPIO Hardline&lt;/head&gt;
    &lt;p&gt;For high-value transactions (Apple Pay, high-assurance key operations), Apple requires more than “biometric match.” Malware could, in principle, trick the user into satisfying a biometric prompt while a hidden transaction is in flight.&lt;/p&gt;
    &lt;p&gt;To address this, Apple implements Secure Intent as a physical side channel into the SEP.&lt;/p&gt;
    &lt;p&gt;The physical control&lt;/p&gt;
    &lt;p&gt;On supported devices:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;The side/top/power button is wired not only to the Application Processor and Always-On Processor (AOP), but also via a dedicated signal path to the Secure Enclave.&lt;/item&gt;
      &lt;item&gt;This signal path allows the SEP to independently observe specific button gestures (e.g. double-click).&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The logic&lt;/p&gt;
    &lt;p&gt;When a transaction is marked as requiring secure intent (via LocalAuthentication / Apple Pay policy):&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;
        &lt;p&gt;The SEP performs the biometric match as usual.&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;On success, instead of immediately unwrapping or signing with the relevant key, the SEP:&lt;/p&gt;
        &lt;list rend="ul"&gt;
          &lt;item&gt;Records that a biometric match is pending for a secure-intent operation.&lt;/item&gt;
          &lt;item&gt;Starts a short internal timer window.&lt;/item&gt;
        &lt;/list&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;The SEP monitors its dedicated button line for the required gesture (e.g. double-click within a given time bound).&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Only if both conditions are satisfied:&lt;/p&gt;
        &lt;list rend="ul"&gt;
          &lt;item&gt;Recent acceptable biometric match.&lt;/item&gt;
          &lt;item&gt;Correct physical button gesture within the window.&lt;lb/&gt;does the SEP:&lt;/item&gt;
          &lt;item&gt;Release the Apple Pay token.&lt;/item&gt;
          &lt;item&gt;Unwrap or use the key required for the operation.&lt;/item&gt;
        &lt;/list&gt;
      &lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;RE Focus&lt;/p&gt;
    &lt;p&gt;From an attacker’s perspective:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;p&gt;UI spoofing (e.g. drawing a fake “Double Click to Pay” overlay via&lt;/p&gt;&lt;code&gt;WindowServer&lt;/code&gt;) cannot produce the electrical signal on the SEP’s dedicated line.&lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Even full compromise of the AP and WindowServer stack cannot bypass secure intent without either:&lt;/p&gt;
        &lt;list rend="ul"&gt;
          &lt;item&gt;Inducing the user to perform the real physical gesture at the right time, or&lt;/item&gt;
          &lt;item&gt;Compromising the SEP itself.&lt;/item&gt;
        &lt;/list&gt;
      &lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h4"&gt;10.2.5 The Local Authentication Context (LAC) and Token Binding&lt;/head&gt;
    &lt;p&gt;When authentication succeeds, the SEP does not simply return &lt;code&gt;true&lt;/code&gt; / &lt;code&gt;false&lt;/code&gt;. It returns or maintains cryptographic context that is later used to authorize specific operations.&lt;/p&gt;
    &lt;p&gt;&lt;code&gt;ACMHandle&lt;/code&gt; and context&lt;/p&gt;
    &lt;p&gt;Internally, &lt;code&gt;coreauthd&lt;/code&gt; and related components track an opaque handle (often modeled as an &lt;code&gt;ACMHandle&lt;/code&gt;) associated with:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;
        &lt;p&gt;The LAContext created for the app.&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;The SEP’s record of:&lt;/p&gt;
        &lt;list rend="ul"&gt;
          &lt;item&gt;The factor that succeeded (passcode vs. biometry).&lt;/item&gt;
          &lt;item&gt;The time of the auth.&lt;/item&gt;
          &lt;item&gt;Relevant policy state (device lock state, secure intent, etc.).&lt;/item&gt;
        &lt;/list&gt;
      &lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;This handle is then passed to other system components that need to prove “recent successful user presence” without re-prompting.&lt;/p&gt;
    &lt;p&gt;Keychain and token binding&lt;/p&gt;
    &lt;p&gt;For a Keychain item protected by &lt;code&gt;kSecAccessControlUserPresence&lt;/code&gt; or a similar policy:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;
        &lt;p&gt;The client invokes a Keychain operation.&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;&lt;code&gt;securityd&lt;/code&gt;(the Keychain daemon) verifies that it has a suitable&lt;code&gt;ACMHandle&lt;/code&gt;or triggers&lt;code&gt;coreauthd&lt;/code&gt;to obtain one.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;securityd&lt;/code&gt;sends:&lt;list rend="ul"&gt;&lt;item&gt;The encrypted keyblob (wrapped key).&lt;/item&gt;&lt;item&gt;The &lt;code&gt;ACMHandle&lt;/code&gt;or equivalent context.&lt;lb/&gt;to the SEP.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Inside the SEP:&lt;/p&gt;
        &lt;list rend="ul"&gt;
          &lt;item&gt;The handle is checked for validity and freshness (time bounds, lock state, backoff).&lt;/item&gt;
          &lt;item&gt;If valid, the SEP uses its internal keys to unwrap the keyblob.&lt;/item&gt;
        &lt;/list&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Depending on the item’s protection:&lt;/p&gt;
        &lt;list rend="ul"&gt;
          &lt;item&gt;The unwrapped key may be returned to &lt;code&gt;securityd&lt;/code&gt;(for extractable keys).&lt;/item&gt;
          &lt;item&gt;Or the SEP may perform the cryptographic operation internally (for non-extractable keys).&lt;/item&gt;
        &lt;/list&gt;
      &lt;/item&gt;
      &lt;item&gt;The unwrapped key may be returned to &lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;In all cases, the AP never gains the ability to “forge” recent user presence; it can only present handles that the SEP previously issued.&lt;/p&gt;
    &lt;p&gt;Backoff and retry policy&lt;/p&gt;
    &lt;p&gt;The SEP enforces retry and lockout policy in hardware:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Failed biometric attempts increment counters stored in SEP-protected storage (e.g. xART).&lt;/item&gt;
      &lt;item&gt;After a small number of failures, delays are introduced between attempts.&lt;/item&gt;
      &lt;item&gt;After a bounded number of failures (e.g. five for Face ID / Touch ID), biometric authentication is disabled until the user enters the passcode or password.&lt;/item&gt;
      &lt;item&gt;Time-based rules (such as requiring a passcode after a certain period since last unlock or since last passcode entry) are also enforced by SEP logic rather than the AP.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The exact thresholds and timing are encoded in &lt;code&gt;sepOS&lt;/code&gt; and evolve across OS generations, but the important property is that they are not under kernel or userland control.&lt;/p&gt;
    &lt;head rend="h3"&gt;10.3 Data Protection &amp;amp; FileVault&lt;/head&gt;
    &lt;p&gt;On Intel Macs, FileVault was implemented as a distinct full-disk encryption layer (CoreStorage) that sat below the filesystem. On Apple Silicon, this layering has collapsed into a unified Data Protection model:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Every file on the APFS volume is encrypted with a per-file key.&lt;/item&gt;
      &lt;item&gt;Per-file keys are wrapped by class keys.&lt;/item&gt;
      &lt;item&gt;Class keys are stored in keybags that are managed by the Secure Enclave.&lt;/item&gt;
      &lt;item&gt;“Turning on FileVault” primarily changes how the Volume Encryption Key (VEK) is protected: from “effectively UID-only” to “UID plus user secret (password) and system measurement (SKP).”&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;In macOS Tahoe, the Data Protection model from iOS is carried over almost verbatim and extended with Mac-specific SKP and policy machinery.&lt;/p&gt;
    &lt;head rend="h4"&gt;10.3.1 Unwrapping the User Keybag: The Class Key Hierarchy&lt;/head&gt;
    &lt;p&gt;The central on-disk structure for Data Protection is the Keybag:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;A binary property list stored in system-managed locations (paths vary with OS releases and boot volume layout).&lt;/item&gt;
      &lt;item&gt;Contains wrapped class keys and metadata.&lt;/item&gt;
      &lt;item&gt;Is always consumed by the SEP; the kernel never sees cleartext class keys.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Hierarchy&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;&lt;p&gt;Hardware UID (UID key):&lt;/p&gt;&lt;lb/&gt;A device-unique AES key, fused into the Secure Enclave and never exposed outside it.&lt;/item&gt;
      &lt;item&gt;&lt;p&gt;User password / passcode:&lt;/p&gt;&lt;lb/&gt;The logical secret known to the user and entered at login or unlock time.&lt;/item&gt;
      &lt;item&gt;&lt;p&gt;Passcode-derived key (PDK):&lt;/p&gt;&lt;lb/&gt;The SEP mixes:&lt;list rend="ul"&gt;&lt;item&gt;A KDF over the password plus salt (PBKDF2-like).&lt;/item&gt;&lt;item&gt;The UID key.&lt;/item&gt;&lt;item&gt;Policy-dependent inputs (e.g. SKP measurement).&lt;lb/&gt;Conceptually:&lt;/item&gt;&lt;/list&gt;&lt;code&gt;PDK = Tangle( UID, PBKDF2(password, salt), measurement, policy )&lt;/code&gt;&lt;p&gt;The exact KDF and tangling function are implementation details, but the key property is: PDK cannot be derived off-device.&lt;/p&gt;&lt;/item&gt;
      &lt;item&gt;&lt;p&gt;Class Keys:&lt;/p&gt;&lt;lb/&gt;The keybag stores wrapped class keys corresponding to the Data Protection classes:&lt;list rend="ul"&gt;&lt;item&gt;Class A (“Complete Protection”):&lt;lb/&gt;Data only accessible while the device is unlocked. Keys are evicted from SEP memory when the device locks.&lt;/item&gt;&lt;item&gt;Class B (“Protected Unless Open”):&lt;lb/&gt;Similar to Class A, but open file handles may retain ephemeral context to allow certain operations to complete in the background.&lt;/item&gt;&lt;item&gt;Class C (“Protected Until First User Authentication” / “First Unlock”):&lt;lb/&gt;Keys are brought into SEP memory after the first successful unlock and persist (subject to policy) until reboot. FileVault’s VEK is conceptually associated with this class on Apple Silicon Macs.&lt;/item&gt;&lt;item&gt;Class D (“No User Secret” / “UID-only”):&lt;lb/&gt;Keys wrapped solely by the UID (and SKP where applicable). Used for data that must be accessible before user login (e.g. some system daemons and metadata). On Apple Silicon, user data is generally not assigned to Class D.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;Class A (“Complete Protection”):&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Unwrapping ceremony&lt;/p&gt;
    &lt;p&gt;When a user logs in on a FileVault-enabled Apple Silicon Mac:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;&lt;code&gt;loginwindow&lt;/code&gt;submits the password through the authentication pipeline; upon acceptance, the kernel passes:&lt;list rend="ul"&gt;&lt;item&gt;The user’s keybag blob.&lt;/item&gt;&lt;item&gt;The supplied password (or a derivative).&lt;lb/&gt;to the SEP via AppleSEPKeyStore.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Inside SEP:&lt;/p&gt;
        &lt;list rend="ul"&gt;
          &lt;item&gt;The password is run through the configured KDF.&lt;/item&gt;
          &lt;item&gt;The UID key and measurement inputs are combined via the tangling function to derive the PDK.&lt;/item&gt;
          &lt;item&gt;The keybag’s wrapped class keys are unwrapped using the PDK and UID.&lt;/item&gt;
        &lt;/list&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;The unwrapped class keys remain resident only inside SEP-protected memory.&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;The SEP returns handles (numeric identifiers or similar) for the class keys to the kernel rather than the keys themselves.&lt;/p&gt;
      &lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Subsequent file I/O and volume operations refer to class keys by these handles, never by raw key bits.&lt;/p&gt;
    &lt;head rend="h4"&gt;10.3.2 Sealed Key Protection (SKP): Binding Data to Measurement&lt;/head&gt;
    &lt;p&gt;Tahoe introduces and extends Sealed Key Protection (SKP) as a defense against “Evil Maid” scenarios where an attacker boots a compromised or downgraded OS to attack the disk encryption keys.&lt;/p&gt;
    &lt;p&gt;Measurement chain&lt;/p&gt;
    &lt;p&gt;During boot:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;&lt;p&gt;The Secure Enclave’s Boot Monitor verifies and measures&lt;/p&gt;&lt;code&gt;sepOS&lt;/code&gt;.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;sepOS&lt;/code&gt;in turn measures:&lt;list rend="ul"&gt;&lt;item&gt;The macOS kernelcache.&lt;/item&gt;&lt;item&gt;The LocalPolicy describing boot and security configuration (e.g. SIP, boot policy, secure boot level).&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;These measurements are accumulated into internal registers within the SEP (conceptually similar to TPM PCRs, but not exposed as such).&lt;/p&gt;
      &lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Sealed keys&lt;/p&gt;
    &lt;p&gt;When the Volume Encryption Key (VEK) and class keys are created (e.g. at install or FileVault enablement time), they are wrapped under a key derived from:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;The UID key.&lt;/item&gt;
      &lt;item&gt;The passcode-derived material (PDK).&lt;/item&gt;
      &lt;item&gt;The current boot-chain measurement.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Conceptually:&lt;/p&gt;
    &lt;code&gt;KEK = KDF( UID, PDK, Measurement )
WrappedVEK = Encrypt( VEK, KEK )
&lt;/code&gt;
    &lt;p&gt;At unlock time:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;The same derivation is repeated inside the SEP using the current Measurement.&lt;/item&gt;
      &lt;item&gt;If the OS, LocalPolicy, or relevant firmware has changed in a way that alters the Measurement beyond allowed ranges, the derived KEK will be different and the unwrap will fail—even if the correct password is supplied.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Security consequence&lt;/p&gt;
    &lt;p&gt;To successfully decrypt the data volume, an attacker must:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Possess the user’s secret (or otherwise satisfy SEP policy).&lt;/item&gt;
      &lt;item&gt;Boot into an OS configuration that produces an acceptable Measurement (signed, authorized kernel + LocalPolicy consistent with SKP policy).&lt;/item&gt;
      &lt;item&gt;Run on the original or equivalently provisioned hardware (UID key, SEP state).&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Downgrades to vulnerable kernels, custom kernels, or off-device keybag attacks are blocked at the SKP layer.&lt;/p&gt;
    &lt;head rend="h4"&gt;10.3.3 The Hardware AES Engine &amp;amp; the Wrapped-Key Path&lt;/head&gt;
    &lt;p&gt;A common misconception is that the macOS kernel decrypts file contents. On Apple Silicon, the encryption/decryption of user data is handled by a dedicated AES engine on the SoC, integrated with the memory and storage controllers.&lt;/p&gt;
    &lt;p&gt;Inline encryption path&lt;/p&gt;
    &lt;p&gt;When a user process performs a file read:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;&lt;p&gt;Metadata lookup:&lt;/p&gt;&lt;lb/&gt;The APFS driver consults file metadata to obtain:&lt;list rend="ul"&gt;&lt;item&gt;The identifier or handle for the per-file key (wrapped).&lt;/item&gt;&lt;item&gt;The relevant class key handle for this file.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;&lt;p&gt;Key request to SEP:&lt;/p&gt;&lt;lb/&gt;The kernel sends:&lt;list rend="ul"&gt;&lt;item&gt;The wrapped per-file key.&lt;/item&gt;&lt;item&gt;The class key handle.&lt;lb/&gt;to the SEP via AppleSEPKeyStore.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;&lt;p&gt;SEP translation:&lt;/p&gt;&lt;lb/&gt;The SEP:&lt;list rend="ul"&gt;&lt;item&gt;&lt;p&gt;Unwraps the per-file key using the class key resident in SEP memory.&lt;/p&gt;&lt;/item&gt;&lt;item&gt;&lt;p&gt;Either:&lt;/p&gt;&lt;list rend="ul"&gt;&lt;item&gt;Programs the SoC’s AES engine with the resulting key via an internal, non-CPU-addressable interface; or&lt;/item&gt;&lt;item&gt;Re-wraps the per-file key under an ephemeral engine-only key and passes that to the AES engine.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;&lt;p&gt;DMA from storage:&lt;/p&gt;&lt;lb/&gt;The kernel issues a read from the NAND-backed storage through the ANS/AGS storage controller, referencing the relevant blocks.&lt;/item&gt;
      &lt;item&gt;&lt;p&gt;On-the-fly decryption:&lt;/p&gt;&lt;lb/&gt;As data flows through the storage path into DRAM:&lt;list rend="ul"&gt;&lt;item&gt;The AES engine decrypts the ciphertext using the key material that was just programmed.&lt;/item&gt;&lt;item&gt;The decrypted plaintext is written into the page cache.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;&lt;p&gt;Key lifetime:&lt;/p&gt;&lt;lb/&gt;The AES engine’s key state is ephemeral and tightly scoped to the I/O operation. The AP never sees the cleartext per-file key; the SEP holds the root class keys and controls when engine keys exist.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;RE Implication&lt;/p&gt;
    &lt;p&gt;Forensics and offensive implications:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;
        &lt;p&gt;Dumping kernel memory will reveal plaintext file contents (resident in the page cache) but not the keys that decrypted them.&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Per-file and class keys exist only inside the SEP and (transiently) in engine-private state.&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Recovering those keys requires either:&lt;/p&gt;
        &lt;list rend="ul"&gt;
          &lt;item&gt;Compromising the SEP firmware and dumping its internal state (e.g., SRAM, xART).&lt;/item&gt;
          &lt;item&gt;Attacking the AES engine at the hardware level.&lt;/item&gt;
        &lt;/list&gt;
      &lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h4"&gt;10.3.4 RE Focus: Analyzing the &lt;code&gt;AppleSEPKeyStore&lt;/code&gt; Kernel Extension&lt;/head&gt;
    &lt;p&gt;The primary interface between the kernel and the SEP’s key-management logic is the &lt;code&gt;AppleSEPKeyStore&lt;/code&gt; kernel extension. For Tahoe and Apple Silicon, this binary is the focal point for understanding the proprietary AP ↔ SEP protocol.&lt;/p&gt;
    &lt;p&gt;Key responsibilities (RE-derived)&lt;/p&gt;
    &lt;p&gt;Typical symbols and responsibilities observed across releases include:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;aks_unwrap_key&lt;/code&gt;/ related functions:&lt;list rend="ul"&gt;&lt;item&gt;Accept wrapped keys (e.g. from keybags, per-file metadata).&lt;/item&gt;&lt;item&gt;Prepare and send unwrap requests to the SEP.&lt;/item&gt;&lt;item&gt;Return handles or status to callers in the kernel.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;aks_get_lock_state&lt;/code&gt;/ equivalents:&lt;list rend="ul"&gt;&lt;item&gt;Query the SEP for the current lock / unlock state and biometric backoff state.&lt;/item&gt;&lt;item&gt;Update kernel-side views of whether user data should be considered accessible.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;&lt;p&gt;Message demultiplexers (e.g.&lt;/p&gt;&lt;code&gt;sep_key_store_client_handle_message&lt;/code&gt;):&lt;list rend="ul"&gt;&lt;item&gt;Parse TLV-encoded responses from the SEP.&lt;/item&gt;&lt;item&gt;Dispatch them to the correct waiters in the kernel or userland.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Attack surface&lt;/p&gt;
    &lt;p&gt;From a reverse-engineering and exploitation perspective, several patterns emerge:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;p&gt;Handle confusion:&lt;/p&gt;&lt;lb/&gt;Keys are referred to by relatively small integer handles in the kernel. Bugs that cause handles to be mis-associated across security domains (system vs. user, different users, different contexts) could allow an attacker to induce the SEP to use a more privileged key than intended.&lt;/item&gt;
      &lt;item&gt;&lt;p&gt;State desynchronization:&lt;/p&gt;&lt;code&gt;AppleSEPKeyStore&lt;/code&gt;maintains shadow state about lock status, key availability, and pending operations. Any discrepancy between this state and the SEP’s internal view could create TOCTOU-style conditions where:&lt;list rend="ul"&gt;&lt;item&gt;The kernel believes an operation is permitted, but the SEP does not (and vice versa).&lt;/item&gt;&lt;item&gt;A key handle is assumed valid when the SEP has already invalidated it.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;&lt;p&gt;TLV parsing:&lt;/p&gt;&lt;lb/&gt;The AP-side parser for SEP messages handles complex TLV structures. Memory-safety bugs or logic errors here represent a classic attack surface, albeit one increasingly hardened by modern CFI, PAC, and mitigation layers.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Tahoe hardening (observed)&lt;/p&gt;
    &lt;p&gt;On Tahoe-era builds, interactions between &lt;code&gt;AppleSEPKeyStore&lt;/code&gt; and higher-privilege operations (e.g., enabling FileVault, changing recovery keys, altering LocalPolicy-bound state) show evidence of:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Additional checks that correlate key operations with TXM / GL1 policy decisions.&lt;/item&gt;
      &lt;item&gt;Stricter coupling between “is this operation permitted under the current Measurement and LocalPolicy?” and “should this unwrap / key creation be forwarded to the SEP?”&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Public documentation does not yet spell out this coupling, but runtime traces and binary analysis strongly suggest that Apple is moving more of the authorization logic below the kernel and into the measured, SEP-adjacent policy domain.&lt;/p&gt;
    &lt;head rend="h2"&gt;11.0 Conclusion: The Attack Surface Landscape&lt;/head&gt;
    &lt;p&gt;The architectural transformation introduced with macOS Tahoe and the M3/M4 silicon generation signifies the end of the "Kernel is King" era. We have moved from a monolithic trust model, where &lt;code&gt;uid=0&lt;/code&gt; and &lt;code&gt;tfp0&lt;/code&gt; were the ultimate objectives, to a federated security model where the kernel is merely a highly privileged, yet strictly supervised, tenant within a hardware-enforced hypervisor.&lt;/p&gt;
    &lt;p&gt;For the vulnerability researcher, this necessitates a shift in methodology. Fuzzing syscalls is no longer sufficient to compromise the system's root of trust. The new frontier lies in the Boundary Crossings—the specific, hardware-mediated bridges that allow data and execution flow to traverse the isolated domains.&lt;/p&gt;
    &lt;head rend="h3"&gt;11.1 Summary of Boundary Crossings&lt;/head&gt;
    &lt;p&gt;The following matrix details the architectural boundaries, the mechanisms used to traverse them, and the specific attack surface exposed at each junction.&lt;/p&gt;
    &lt;head rend="h4"&gt;11.1.1 Userland (EL0) ↔ Kernel (EL2/VHE)&lt;/head&gt;
    &lt;p&gt;The Traditional Boundary, Hardened by Silicon.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;
        &lt;p&gt;Transition Mechanism:&lt;/p&gt;
        &lt;list rend="ul"&gt;
          &lt;item&gt;Entry: &lt;code&gt;SVC&lt;/code&gt;(Supervisor Call) instruction triggering a synchronous exception to the kernel exception vector (&lt;code&gt;VBAR_EL1 + 0x400&lt;/code&gt;, or the EL2 alias under VHE on macOS).&lt;/item&gt;
          &lt;item&gt;Exit: &lt;code&gt;ERET&lt;/code&gt;(Exception Return) restoring&lt;code&gt;PC&lt;/code&gt;and&lt;code&gt;PSTATE&lt;/code&gt;from&lt;code&gt;ELR_EL1&lt;/code&gt;/&lt;code&gt;ELR_EL2&lt;/code&gt;and&lt;code&gt;SPSR_EL1&lt;/code&gt;/&lt;code&gt;SPSR_EL2&lt;/code&gt;(depending on the concrete VHE configuration).&lt;/item&gt;
        &lt;/list&gt;
      &lt;/item&gt;
      &lt;item&gt;Entry: &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Hardware Enforcement:&lt;/p&gt;
        &lt;list rend="ul"&gt;
          &lt;item&gt;PAC: Entry points are signed. The kernel verifies the thread state signature (&lt;code&gt;kauth_thread_state&lt;/code&gt;) on return, ensuring return-address and register integrity.&lt;/item&gt;
          &lt;item&gt;PPL/SPTM: The kernel cannot modify its own text or page tables to disable SMEP/SMAP equivalents (&lt;code&gt;PAN&lt;/code&gt;/&lt;code&gt;PXN&lt;/code&gt;). Page-table integrity and code immutability are ultimately enforced by the SPTM rather than by EL2 alone.&lt;/item&gt;
        &lt;/list&gt;
      &lt;/item&gt;
      &lt;item&gt;PAC: Entry points are signed. The kernel verifies the thread state signature (&lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;The Tahoe Shift:&lt;/p&gt;
        &lt;list rend="ul"&gt;
          &lt;item&gt;&lt;p&gt;The kernel is no longer the final arbiter of virtual memory. When a user process requests&lt;/p&gt;&lt;code&gt;mmap(RWX)&lt;/code&gt;, the kernel cannot simply write to the translation tables; it must request the SPTM to map the page.&lt;/item&gt;
          &lt;item&gt;
            &lt;p&gt;Attack Surface:&lt;/p&gt;
            &lt;list rend="ul"&gt;
              &lt;item&gt;Logic Bugs: Standard memory corruption (UAF, heap overflow) in kernel extensions still yields privileged kernel execution in the EL2/VHE context.&lt;/item&gt;
              &lt;item&gt;PAC Bypasses: Forging pointers to survive the &lt;code&gt;ERET&lt;/code&gt;path or function-pointer authentication (return addresses, vtables, dispatch tables).&lt;/item&gt;
              &lt;item&gt;Argument Sanitization: The kernel must sanitize user pointers and lengths before passing them to the SPTM. A "Confused Deputy" attack where the kernel is tricked into asking the SPTM to map a privileged page into user space is the new &lt;code&gt;tfp0&lt;/code&gt;.&lt;/item&gt;
            &lt;/list&gt;
          &lt;/item&gt;
        &lt;/list&gt;
      &lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h4"&gt;11.1.2 Kernel (EL2) ↔ Secure Page Table Monitor (GL2)&lt;/head&gt;
    &lt;p&gt;The "Mechanism" Boundary: The New Hypervisor.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;
        &lt;p&gt;Transition Mechanism:&lt;/p&gt;
        &lt;list rend="ul"&gt;
          &lt;item&gt;Entry: &lt;code&gt;GENTER&lt;/code&gt;(Opcode&lt;code&gt;0x00201420&lt;/code&gt;) with the&lt;code&gt;sptm_dispatch_target_t&lt;/code&gt;in&lt;code&gt;x16&lt;/code&gt;(encoding Domain + Dispatch Table ID + Endpoint). The 5-bit immediate in the&lt;code&gt;GENTER&lt;/code&gt;instruction selects the GXF entry stub and is recorded in&lt;code&gt;ESR_GLx&lt;/code&gt;.&lt;/item&gt;
          &lt;item&gt;Exit: &lt;code&gt;GEXIT&lt;/code&gt;(Opcode&lt;code&gt;0x00201400&lt;/code&gt;), returning from GL2 to the kernel’s EL2/VHE context.&lt;/item&gt;
        &lt;/list&gt;
      &lt;/item&gt;
      &lt;item&gt;Entry: &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Hardware Enforcement:&lt;/p&gt;
        &lt;list rend="ul"&gt;
          &lt;item&gt;GXF: Hardware context switch of &lt;code&gt;SP_EL2&lt;/code&gt;/&lt;code&gt;SP_EL1&lt;/code&gt;→&lt;code&gt;SP_GL2&lt;/code&gt;and the corresponding GL2 state (&lt;code&gt;SPSR_GL2&lt;/code&gt;,&lt;code&gt;ELR_GL2&lt;/code&gt;,&lt;code&gt;ESR_GL2&lt;/code&gt;).&lt;/item&gt;
          &lt;item&gt;SPRR: Atomic switch of permission views. Kernel text becomes RO/NX from the GL2 perspective; SPTM text/data become RX/RW as configured for GL2 and remain inaccessible from EL2.&lt;/item&gt;
        &lt;/list&gt;
      &lt;/item&gt;
      &lt;item&gt;GXF: Hardware context switch of &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Data Exchange:&lt;/p&gt;
        &lt;list rend="ul"&gt;
          &lt;item&gt;Registers: &lt;code&gt;x0&lt;/code&gt;–&lt;code&gt;x7&lt;/code&gt;carry arguments (physical page numbers, ASIDs, permission bitmasks, context IDs).&lt;code&gt;x16&lt;/code&gt;carries the dispatch target (&lt;code&gt;sptm_domain_t&lt;/code&gt;+ table + endpoint).&lt;/item&gt;
          &lt;item&gt;Shared Memory: None in the normal call path. The SPTM reads and writes physical memory directly via its own linear map and page-table view.&lt;/item&gt;
        &lt;/list&gt;
      &lt;/item&gt;
      &lt;item&gt;Registers: &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Attack Surface:&lt;/p&gt;
        &lt;list rend="ul"&gt;
          &lt;item&gt;State Machine Confusion: The SPTM enforces a Finite State Machine (FSM) on every physical page (Frame Table). The primary attack vector is finding a sequence of &lt;code&gt;retype&lt;/code&gt;/&lt;code&gt;map&lt;/code&gt;/&lt;code&gt;unmap&lt;/code&gt;calls that desynchronizes the SPTM’s view of a page from the hardware’s actual usage (e.g., aliasing a&lt;code&gt;PAGE_TABLE&lt;/code&gt;frame as&lt;code&gt;XNU_DATA&lt;/code&gt;).&lt;/item&gt;
          &lt;item&gt;Input Validation: Passing invalid physical addresses, truncated ranges, or edge-case permission combinations to &lt;code&gt;sptm_map&lt;/code&gt;/&lt;code&gt;sptm_unmap&lt;/code&gt;/&lt;code&gt;sptm_map_iommu&lt;/code&gt;, especially under high contention or refcounted/shared-frame scenarios.&lt;/item&gt;
          &lt;item&gt;Panic-as-Oracle: Because invalid or inconsistent requests cause the SPTM to return fatal errors that XNU treats as unrecoverable and converts into kernel panics, timing side-channels or fault-injection during the &lt;code&gt;GENTER&lt;/code&gt;window are potential vectors to infer GL2 layout and state (e.g., distinguishing “valid but denied” vs “structurally impossible” transitions via differing panic paths or latencies).&lt;/item&gt;
        &lt;/list&gt;
      &lt;/item&gt;
      &lt;item&gt;State Machine Confusion: The SPTM enforces a Finite State Machine (FSM) on every physical page (Frame Table). The primary attack vector is finding a sequence of &lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h4"&gt;11.1.3 Kernel (EL2) ↔ Trusted Execution Monitor (TXM)&lt;/head&gt;
    &lt;p&gt;The “Policy” Boundary: Code-Signing and Entitlement Authority.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;
        &lt;p&gt;Transition Mechanism:&lt;/p&gt;
        &lt;list rend="ul"&gt;
          &lt;item&gt;Entry: XNU invokes TXM through &lt;code&gt;txm_kernel_call()&lt;/code&gt;and related wrappers. These routines set up a dedicated TXM stack, marshal a call descriptor (selector, argument vector, return buffer), and then perform the CPU sequence required to enter the TXM context. On current iOS releases, reverse-engineering shows that TXM itself uses&lt;code&gt;SVC&lt;/code&gt;to perform in-monitor calls; on Tahoe, the interface exposed to XNU is via these&lt;code&gt;txm_*&lt;/code&gt;entry points rather than a raw&lt;code&gt;GENTER&lt;/code&gt;stub.&lt;/item&gt;
          &lt;item&gt;Exit: TXM writes its result into the call descriptor, updates a status field, and returns to XNU, which interprets the status. Depending on selector and flags, some TXM failures are converted into kernel panics.&lt;/item&gt;
        &lt;/list&gt;
      &lt;/item&gt;
      &lt;item&gt;Entry: XNU invokes TXM through &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Hardware Enforcement:&lt;/p&gt;
        &lt;list rend="ul"&gt;
          &lt;item&gt;SPTM-Supervised Domain: TXM resides in a region whose code and data are owned and typed by SPTM. XNU has no direct write access to TXM text or critical data; changes must go through SPTM retyping and mapping operations.&lt;/item&gt;
          &lt;item&gt;Privilege Ordering: Apple’s OS integrity documentation describes TXM as a lower-privilege component used by SPTM to enforce code-signing and integrity policy. Even if TXM were compromised, SPTM still mediates page-table updates and frame typing; memory integrity does not collapse automatically.&lt;/item&gt;
        &lt;/list&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Data Exchange:&lt;/p&gt;
        &lt;list rend="ul"&gt;
          &lt;item&gt;Pointers and Metadata: XNU passes pointers (or physical addresses) to Code Directories, CMS blobs, trust caches, and entitlement structures, along with lengths and flags. TXM interprets these structures and returns accept/deny decisions plus auxiliary metadata.&lt;/item&gt;
          &lt;item&gt;Dynamic Trust Cache Operations: TXM selectors cover registration and removal of trust-cache entries, enabling or disabling specific code-signing relaxations, and managing development/debug modes.&lt;/item&gt;
        &lt;/list&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Attack Surface:&lt;/p&gt;
        &lt;list rend="ul"&gt;
          &lt;item&gt;Parser Complexity: TXM must parse Mach-O headers, CodeDirectories, CMS/ASN.1, entitlements, and various policy structures. Bugs in these parsers can yield powerful policy-manipulation primitives (for example, arbitrary trust-cache entries or coerced acceptance of malformed signatures), but SPTM still constrains what memory mappings are possible.&lt;/item&gt;
          &lt;item&gt;Policy Downgrade and LocalPolicy Handling: Incorrect handling of boot arguments and LocalPolicy data can cause persistent relaxation of code-signing or integrity checks. Exploits here influence what code TXM authorizes, but do not directly grant the ability to arbitrarily rewrite protected frames without also influencing SPTM.&lt;/item&gt;
          &lt;item&gt;TOCTOU and Retyping: If the buffers that TXM inspects are not retyped or otherwise shielded by SPTM, there is a window where DMA or kernel code could mutate them between TXM’s checks and subsequent use. Correct integration of SPTM retyping with TXM’s parsing determines how exploitable such races are.&lt;/item&gt;
        &lt;/list&gt;
      &lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h4"&gt;11.1.4 Kernel (EL1) ↔ Secure Enclave (SEP)&lt;/head&gt;
    &lt;p&gt;The "Air Gap" Boundary: The Parallel Computer.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Transition Mechanism: &lt;list rend="ul"&gt;&lt;item&gt;Asynchronous IPC: Mailbox Registers (Doorbell) + Shared Memory Buffers (DART-mapped).&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;Hardware Enforcement: &lt;list rend="ul"&gt;&lt;item&gt;Physical Isolation: Distinct CPU core, distinct MMU.&lt;/item&gt;&lt;item&gt;Memory Protection Engine: SEP memory is encrypted/authenticated inline.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;Data Exchange: &lt;list rend="ul"&gt;&lt;item&gt;Serialized Messages: L4 IPC format (Endpoints, TLV payloads).&lt;/item&gt;&lt;item&gt;Wrapped Keys: Keys are passed as opaque blobs; raw key material never crosses this boundary.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;Attack Surface: &lt;list rend="ul"&gt;&lt;item&gt;Message Parsing: Fuzzing the &lt;code&gt;sepOS&lt;/code&gt;endpoint handlers (e.g.,&lt;code&gt;biometrickitd&lt;/code&gt;,&lt;code&gt;securekeyvault&lt;/code&gt;).&lt;/item&gt;&lt;item&gt;Shared Memory Races: Modifying the contents of a DART-mapped buffer after the SEP has validated the header but before it processes the payload.&lt;/item&gt;&lt;item&gt;Anti-Replay Logic: Attempting to rollback the &lt;code&gt;xART&lt;/code&gt;storage state to force the SEP to reuse old nonces or counters.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;Message Parsing: Fuzzing the &lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h4"&gt;11.1.5 Kernel (EL1) ↔ Exclaves (Secure Domain)&lt;/head&gt;
    &lt;p&gt;The "Microkernel" Boundary: The RingGate.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Transition Mechanism: &lt;list rend="ul"&gt;&lt;item&gt;RingGate: &lt;code&gt;XNUProxy&lt;/code&gt;kext marshals data →&lt;code&gt;GENTER&lt;/code&gt;(to Secure Kernel) → IPC to Conclave.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;RingGate: &lt;/item&gt;
      &lt;item&gt;Hardware Enforcement: &lt;list rend="ul"&gt;&lt;item&gt;SPTM: Enforces physical memory isolation between &lt;code&gt;XNU_DOMAIN&lt;/code&gt;and&lt;code&gt;SK_DOMAIN&lt;/code&gt;.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;SPTM: Enforces physical memory isolation between &lt;/item&gt;
      &lt;item&gt;Data Exchange: &lt;list rend="ul"&gt;&lt;item&gt;Tightbeam: A strongly-typed IDL serialization format.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;Attack Surface: &lt;list rend="ul"&gt;&lt;item&gt;Proxy Confusion: Exploiting &lt;code&gt;XNUProxy&lt;/code&gt;to route messages to the wrong Conclave.&lt;/item&gt;&lt;item&gt;IDL Deserialization: Bugs in the Tightbeam generated code within the Exclave.&lt;/item&gt;&lt;item&gt;Resource Exhaustion: Flooding the Secure Kernel with Downcalls to starve secure workloads (DoS).&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;Proxy Confusion: Exploiting &lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h3"&gt;11.2 The "Intel Gap": Security Disparities between x86 and Apple Silicon&lt;/head&gt;
    &lt;p&gt;While macOS Tahoe presents a unified user experience across architectures, the underlying security reality is a tale of two operating systems. On Apple Silicon, macOS is a hypervisor-managed, hardware-attested fortress. On Intel (x86_64), it remains a traditional monolithic kernel relying on legacy protection mechanisms. This divergence has created a massive "Intel Gap"—a disparity in exploit mitigation so severe that the same vulnerability often yields a trivial root shell on Intel while resulting in a harmless panic on Apple Silicon.&lt;/p&gt;
    &lt;p&gt;For the reverse engineer, understanding this gap is essential for targeting. The Intel architecture represents the "Soft Target," lacking the silicon-enforced boundaries of the SPTM, TXM, and PAC.&lt;/p&gt;
    &lt;head rend="h4"&gt;11.2.1 Lateral Privilege: GL2 vs Ring 0&lt;/head&gt;
    &lt;p&gt;The critical difference between Intel and Apple-silicon Tahoe systems is the existence, on Apple silicon, of a privilege layer above the kernel that continues to enforce memory-integrity invariants even after a kernel compromise.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;
        &lt;p&gt;Apple Silicon:&lt;/p&gt;
        &lt;list rend="ul"&gt;
          &lt;item&gt;
            &lt;p&gt;XNU runs at EL2 under the supervision of SPTM in GL2. SPTM is the sole authority for page-table retyping and for managing frame types that correspond to kernel text, page tables, IOMMU tables, and other critical regions.&lt;/p&gt;
          &lt;/item&gt;
          &lt;item&gt;
            &lt;p&gt;TXM executes in a lower-privilege domain than SPTM and provides code-signing and integrity policy decisions. SPTM calls into TXM to decide whether particular mappings or code images are acceptable, but SPTM remains the arbiter of what is actually mapped and how frames are typed.&lt;/p&gt;
          &lt;/item&gt;
          &lt;item&gt;
            &lt;p&gt;A kernel exploit that yields KRW in XNU provides strong influence over control flow and data within EL2 and allows attempts to mis-use SPTM/TXM as confused deputies. However, the attacker must still either:&lt;/p&gt;
            &lt;list rend="ul"&gt;
              &lt;item&gt;Drive SPTM through an illegal but accepted state transition (retyping or mapping), or&lt;/item&gt;
              &lt;item&gt;Gain sufficient influence over TXM and then exploit the TXM–SPTM interface,&lt;lb/&gt;to obtain equivalent authority over page tables and sealed code.&lt;/item&gt;
            &lt;/list&gt;
          &lt;/item&gt;
        &lt;/list&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Intel x86_64:&lt;/p&gt;
        &lt;list rend="ul"&gt;
          &lt;item&gt;The kernel runs in Ring 0 and directly controls page tables, VT-d configuration, and most integrity mechanisms below the T2’s secure boot checks.&lt;/item&gt;
          &lt;item&gt;There is no SPTM-equivalent hypervisor above Ring 0 enforcing frame typing or page-table integrity at runtime. Once KRW is obtained and static KTRR is bypassed or worked around, the attacker can patch kernel text, alter page tables, and reconfigure DMA mappings with no higher-privilege arbiter.&lt;/item&gt;
        &lt;/list&gt;
      &lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Under this model, KRW on Apple silicon is an intermediate privilege level situated below SPTM/TXM, whereas KRW on Intel is much closer to the maximum privilege available to macOS.&lt;/p&gt;
    &lt;head rend="h4"&gt;11.2.2 Static vs. Dynamic Kernel Integrity (KTRR vs. SPTM)&lt;/head&gt;
    &lt;p&gt;Both architectures attempt to enforce Kernel Text Read-Only Region (KTRR), but the implementation differs fundamentally in flexibility and robustness.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Intel (Hardware KTRR): On recent Intel Macs, KTRR is implemented via proprietary memory controller registers (configured via &lt;code&gt;MSR&lt;/code&gt;).&lt;list rend="ul"&gt;&lt;item&gt;Mechanism: The firmware locks a physical range of memory as Read-Only/Executable.&lt;/item&gt;&lt;item&gt;Limitation: This is Static. Once the range is locked at boot, it cannot change. This forces the kernel to fit all immutable code into a contiguous block. It cannot protect dynamically loaded drivers (KEXTs) with the same hardware rigor. KEXTs rely on software-managed page tables (&lt;code&gt;CR0.WP&lt;/code&gt;bit), which a compromised kernel can disable.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;Apple Silicon (SPTM): &lt;list rend="ul"&gt;&lt;item&gt;Mechanism: The SPTM manages the Frame Table.&lt;/item&gt;&lt;item&gt;Advantage: This is Dynamic. The kernel can load a new extension (AKC), link it, and then ask the SPTM to "Seal" it. The SPTM transitions those specific pages to &lt;code&gt;XNU_TEXT&lt;/code&gt;. This allows the "Immutable Kernel" coverage to extend to late-loaded drivers, a feat impossible on the static Intel KTRR implementation.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h4"&gt;11.2.3 The CFI Chasm: PAC vs. CET&lt;/head&gt;
    &lt;p&gt;Control Flow Integrity (CFI) is the primary defense against ROP/JOP.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Apple Silicon: Pointer Authentication (PAC) is ubiquitous. It protects return addresses (stack), function pointers (heap/data), and C++ vtables. It provides cryptographic diversity based on pointer context.&lt;/item&gt;
      &lt;item&gt;Intel x86: Intel Macs support Control-flow Enforcement Technology (CET), specifically Shadow Stacks (&lt;code&gt;IBT&lt;/code&gt;support is limited).&lt;list rend="ul"&gt;&lt;item&gt;The Gap: CET Shadow Stacks protect return addresses effectively, but they do not protect Forward-Edge transfers (function pointers) with the same granularity as PAC.&lt;/item&gt;&lt;item&gt;Data Pointers: Crucially, Intel has no equivalent to &lt;code&gt;APDAKey&lt;/code&gt;(Data Key). An attacker on Intel can still perform Data-Oriented Programming (DOP)—swapping valid object pointers or corrupting decision-making flags—without triggering a hardware fault. On Apple Silicon, these pointers are signed; forging them requires a signing gadget.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h4"&gt;11.2.4 The Root of Trust: T2 vs. On-Die Boot ROM&lt;/head&gt;
    &lt;p&gt;The boot chain trust anchor differs physically.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Intel: The Root of Trust is the Apple T2 Security Chip (on models 2018-2020). &lt;list rend="ul"&gt;&lt;item&gt;The Weakness: The T2 is a discrete bridge. It verifies the &lt;code&gt;boot.efi&lt;/code&gt;and kernelcache signature before the Intel CPU starts. However, once the Intel CPU is executing, the T2 is effectively a peripheral connected via USB/PCIe. It cannot introspect the Intel CPU's execution state. It cannot stop a runtime kernel exploit.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;The Weakness: The T2 is a discrete bridge. It verifies the &lt;/item&gt;
      &lt;item&gt;Apple Silicon: The Root of Trust is the AP Boot ROM. &lt;list rend="ul"&gt;&lt;item&gt;The Strength: The security logic (SEP, PKA, Boot Monitor) is on the same die. The Secure Enclave can monitor the power and clock lines of the AP. The SPTM (running on the AP) enforces the boot measurements continuously. The trust chain is not "handed off"; it is maintained throughout the runtime lifecycle.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h4"&gt;11.2.5 I/O Security: VT-d vs. DART&lt;/head&gt;
    &lt;p&gt;DMA attacks are a classic method to bypass CPU memory protections.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Intel: Uses VT-d (Intel Virtualization Technology for Directed I/O). &lt;list rend="ul"&gt;&lt;item&gt;Configuration: The kernel configures the IOMMU tables.&lt;/item&gt;&lt;item&gt;Vulnerability: If the kernel is compromised, it can reconfigure VT-d to allow a malicious Thunderbolt device to overwrite kernel memory (unless strict "DMA Protection" is enabled and locked, which relies on the kernel's integrity).&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;Apple Silicon: Uses DART (Device Address Resolution Table). &lt;list rend="ul"&gt;&lt;item&gt;Enforcement: As detailed in Section 7.2.2, the kernel cannot write to DART registers. Only the SPTM can map I/O memory.&lt;/item&gt;&lt;item&gt;Result: Even a compromised kernel cannot weaponize a peripheral to perform a DMA attack against the monitor or the kernel text, because the SPTM will reject the mapping request.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h4"&gt;11.2.6 Summary Table: Tahoe on Intel vs Apple Silicon&lt;/head&gt;
    &lt;table&gt;
      &lt;row span="3"&gt;
        &lt;cell role="head"&gt;Feature&lt;/cell&gt;
        &lt;cell role="head"&gt;Intel Mac (x86_64 + T2)&lt;/cell&gt;
        &lt;cell role="head"&gt;Apple Silicon (arm64e, Tahoe)&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;Highest effective privilege&lt;/cell&gt;
        &lt;cell&gt;Ring 0 kernel with static KIP/KTRR; no higher-privilege macOS component supervising runtime mappings&lt;/cell&gt;
        &lt;cell&gt;GL2 SPTM as top-level memory arbiter supervising EL2 XNU; TXM runs below SPTM and supplies code-signing and integrity policy that SPTM consumes for protected mappings&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;Page-table protection&lt;/cell&gt;
        &lt;cell&gt;Memory-controller KIP + software-managed page tables; VT-d tables configured by the kernel&lt;/cell&gt;
        &lt;cell&gt;SPRR + SPTM-mediated retyping and mapping for page tables and DART; kernel cannot directly repoint protected frames&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;Kernel code integrity&lt;/cell&gt;
        &lt;cell&gt;Static KTRR region for core kernel text; many KEXTs rely on page-table flags that the kernel can modify&lt;/cell&gt;
        &lt;cell&gt;Dynamic sealing of XNU text and AKCs via SPTM/KIP; additional code cannot be introduced as &lt;code&gt;XNU_TEXT&lt;/code&gt; after boot without passing SPTM’s frame-typing rules&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;CFI primitive&lt;/cell&gt;
        &lt;cell&gt;CET (Shadow Stack + IBT) available in hardware; extent of macOS use is not publicly documented&lt;/cell&gt;
        &lt;cell&gt;PAC on kernel and userland code, including return addresses and many vtables&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;Vtable / data-pointer protection&lt;/cell&gt;
        &lt;cell&gt;No hardware authentication for data pointers or vtables&lt;/cell&gt;
        &lt;cell&gt;PAC on vtables and selected data pointers (DA/GA keys) constrains many forward-edge and DOP-style attacks&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;Code-signing enforcement&lt;/cell&gt;
        &lt;cell&gt;AMFI / CoreTrust in the kernel enforce policy; T2 participates in secure boot but does not supervise runtime kernel mappings&lt;/cell&gt;
        &lt;cell&gt;TXM, running in a domain protected by SPTM, evaluates signatures and integrity policy. On iOS-class platforms, TXM/SPTM together enforce “only signed and trusted code executes”. On macOS, TXM/SPTM primarily protect page-tables and protected code regions while still allowing arbitrary user code execution in accordance with macOS policy.&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;DMA configuration&lt;/cell&gt;
        &lt;cell&gt;VT-d configured and updated by the kernel&lt;/cell&gt;
        &lt;cell&gt;DART configured via SPTM dispatch; IOMMU tables live behind SPTM’s frame-typing and mapping rules&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;Secure enclave / secure coprocessor&lt;/cell&gt;
        &lt;cell&gt;Discrete T2 SoC linked over internal buses; cannot introspect x86_64 execution after hand-off&lt;/cell&gt;
        &lt;cell&gt;SEP on-die with AP; Exclaves and other secure domains use the same silicon fabric and SPTM/TXM-supervised interfaces&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;cell&gt;Typical kernel-exploit consequence&lt;/cell&gt;
        &lt;cell&gt;KRW + KTRR bypass ⇒ direct and persistent kernel modification and DMA reconfiguration&lt;/cell&gt;
        &lt;cell&gt;KRW in XNU ⇒ strong EL2 foothold; additional steps against SPTM/TXM/Exclaves are required to influence sealed code or protected page tables, especially for persistence or for changing hardware-enforced invariants&lt;/cell&gt;
      &lt;/row&gt;
    &lt;/table&gt;
    &lt;p&gt;Conclusion for the Researcher:&lt;lb/&gt; The "Intel Gap" means that legacy Intel Macs are essentially running a different, far more vulnerable operating system, despite sharing the macOS version number. Exploits that require complex, multi-stage chains on M3 (e.g., bypassing PAC, confusing SPTM, racing TXM) can often be reduced to a single Use-After-Free and a ROP chain on Intel. As Apple phases out Intel support, the "easy mode" of macOS exploitation is rapidly vanishing.&lt;/p&gt;
    &lt;head rend="h3"&gt;11.3 Future Trends: The expansion of Exclaves and the death of Kernel Extensions&lt;/head&gt;
    &lt;p&gt;The trajectory of macOS security architecture is not asymptotic; it is directional. Apple is not merely patching vulnerabilities in XNU; they are actively architecting its obsolescence as a security boundary. The "Tahoe" architecture provides the silicon primitives (SPTM, TXM, GL2) required to execute a long-term strategy of Architectural Attrition.&lt;/p&gt;
    &lt;p&gt;The future of macOS exploitation lies in understanding two concurrent trends: the ossification of the XNU kernel into a static, immutable appliance, and the migration of high-value logic into the opaque, hardware-isolated world of Exclaves.&lt;/p&gt;
    &lt;head rend="h4"&gt;11.3.1 The Deprecation of &lt;code&gt;kmod_load&lt;/code&gt;: The Static Kernel&lt;/head&gt;
    &lt;p&gt;For decades, the ability to load Kernel Extensions (KEXTs) was a defining feature of macOS. It was also its Achilles' heel. KEXTs run at EL1, share the kernel's address space, and historically lacked the rigorous code review applied to the core kernel.&lt;/p&gt;
    &lt;p&gt;The mechanism for this—the &lt;code&gt;kmod_load&lt;/code&gt; syscall (and the associated &lt;code&gt;kmod_control&lt;/code&gt; traps)—represents a massive attack surface. It requires the kernel to possess a runtime linker (&lt;code&gt;kld&lt;/code&gt;), capable of resolving symbols, applying relocations, and modifying executable memory.&lt;/p&gt;
    &lt;p&gt;The DriverKit End-Game:&lt;lb/&gt; Apple has systematically introduced userland replacements for kernel drivers: &lt;code&gt;USBDriverKit&lt;/code&gt;, &lt;code&gt;HIDDriverKit&lt;/code&gt;, &lt;code&gt;AudioDriverKit&lt;/code&gt;, and &lt;code&gt;NetworkingDriverKit&lt;/code&gt;.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Current State: In Tahoe, third-party KEXTs are deprecated. The userland tool &lt;code&gt;kmutil&lt;/code&gt;manages the policy, but the actual loading still relies on the kernel's ability to link code. Loading a legacy KEXT now requires reducing system security (disabling SIP/Secure Boot) and interacting with the TXM via LocalPolicy to explicitly authorize the hash.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Future State: The Death of the Runtime Linker:&lt;lb/&gt; We are approaching a point where the kernel will effectively lose the ability to load dynamic code entirely in "Full Security" mode. The goal is to remove the &lt;code&gt;kmod_load&lt;/code&gt; logic from the kernel entirely.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;The "Sealed" Kernel: The Boot Kernel Collection (BKC) (loaded by iBoot) and the Auxiliary Kernel Collection (AKC) (loaded early by &lt;code&gt;kernelmanagerd&lt;/code&gt;) will be the only permitted executable kernel code.&lt;/item&gt;
      &lt;item&gt;Pre-Linked Immutability: By moving all linking to build-time (kernelcache generation) or boot-time (iBoot verification), Apple can strip the dynamic linker logic (&lt;code&gt;kld&lt;/code&gt;) from the runtime kernel. If the kernel doesn't know how to link a Mach-O, it cannot load a rootkit.&lt;/item&gt;
      &lt;item&gt;SPTM Enforcement: The SPTM already enforces that &lt;code&gt;XNU_TEXT&lt;/code&gt;is immutable. The logical next step is for the SPTM to reject any&lt;code&gt;sptm_retype&lt;/code&gt;request that attempts to create new&lt;code&gt;XNU_TEXT&lt;/code&gt;pages after the initial boot sealing phase is complete.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;RE Implication:&lt;lb/&gt; The era of the "Rootkit" is ending. If you cannot introduce new code into EL1 via &lt;code&gt;kmod_load&lt;/code&gt;, and you cannot modify existing code due to KTRR/SPTM, persistence in the kernel becomes impossible. Attackers will be forced to live entirely within data-only attacks (DOP) or move their persistence to userland (which is easier to detect) or firmware (which is harder to achieve).&lt;/p&gt;
    &lt;head rend="h4"&gt;11.3.2 Exclave Expansion: Eating the Monolith&lt;/head&gt;
    &lt;p&gt;If XNU is the "Insecure World," Exclaves are the "Secure World." Currently, Exclaves are used for high-sensitivity, low-complexity tasks (Privacy Indicators, Passkeys). However, the architecture is designed to scale. Apple is effectively strangling the monolithic kernel by slowly migrating critical subsystems out of EL1 and into Exclaves.&lt;/p&gt;
    &lt;p&gt;Candidates for Migration:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;The Network Stack (&lt;code&gt;skywalk&lt;/code&gt;):&lt;lb/&gt;Apple has already introduced&lt;code&gt;skywalk&lt;/code&gt;, a userland networking subsystem. The logical evolution is to move the TCP/IP stack and packet filtering logic into an Exclave.&lt;list rend="ul"&gt;&lt;item&gt;Benefit: A remote code execution vulnerability in the Wi-Fi firmware or the TCP stack would compromise an isolated Exclave, not the entire kernel. The SPTM would prevent the compromised network stack from touching system memory.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;Filesystem Encryption (APFS):&lt;lb/&gt;Currently,&lt;code&gt;AppleSEPKeyStore&lt;/code&gt;handles key wrapping, but the bulk encryption happens via the AES Engine managed by the kernel. Moving the filesystem driver's cryptographic logic to an Exclave would ensure that even a kernel compromise cannot exfiltrate file keys, as the keys would exist only within the Exclave's memory domain.&lt;/item&gt;
      &lt;item&gt;Audio and Media Processing:&lt;lb/&gt;To protect DRM content and prevent microphone eavesdropping, the entire CoreAudio engine could be moved to a "Media Conclave."&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The "Dark Matter" OS:&lt;lb/&gt; As more logic moves to Exclaves, a significant portion of the OS execution flow becomes invisible to standard introspection tools.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;No DTrace: You cannot DTrace an Exclave.&lt;/item&gt;
      &lt;item&gt;No kdebug: Kernel tracing will show a "black hole" where the request enters &lt;code&gt;XNUProxy&lt;/code&gt;and vanishes until the result returns.&lt;/item&gt;
      &lt;item&gt;Opaque State: The memory of an Exclave is physically unmappable by the kernel. A kernel memory dump (coredump) will contain gaps where the Exclave memory resides.&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h4"&gt;11.3.3 The "Hollow Kernel" Hypothesis&lt;/head&gt;
    &lt;p&gt;Extrapolating these trends leads to the Hollow Kernel Hypothesis.&lt;/p&gt;
    &lt;p&gt;In this future architecture, XNU (EL1) is demoted to a Compatibility Shim. Its primary role is to:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Provide POSIX system call semantics for legacy userland applications.&lt;/item&gt;
      &lt;item&gt;Manage coarse-grained scheduling of CPU resources.&lt;/item&gt;
      &lt;item&gt;Act as a message bus (via &lt;code&gt;XNUProxy&lt;/code&gt;) between userland applications and the real system logic running in Exclaves.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The Security Inversion:&lt;lb/&gt; In the traditional model, the Kernel protects the User. In the Hollow Kernel model, the Hardware (SPTM/TXM) protects the System from the Kernel.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;The kernel is treated as untrusted code.&lt;/item&gt;
      &lt;item&gt;The TCB (Trusted Computing Base) shrinks from "The entire Kernel" to "The SPTM, TXM, and specific Exclaves."&lt;/item&gt;
      &lt;item&gt;A kernel compromise becomes a "Local DoS" or "Privacy Violation" rather than a "System Compromise."&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h4"&gt;11.3.4 The Visibility Gap: The End of Passive Analysis&lt;/head&gt;
    &lt;p&gt;For the reverse engineer, this shift is catastrophic for visibility.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Tightbeam IDL: The interface between XNU and Exclaves is defined by Tightbeam. Unlike MIG, which was relatively static, Tightbeam protocols can evolve rapidly. Reverse engineering the system will require constantly reconstructing these serialization formats.&lt;/item&gt;
      &lt;item&gt;The "Intel Gap" Closure: As Apple phases out Intel support completely, they will likely remove the legacy code paths in XNU that supported the "un-isolated" model. This will make the kernel source code (if still released) increasingly divergent from the binary reality running on M-series chips.&lt;/item&gt;
      &lt;item&gt;Hardware-Locked Debugging: Debugging an Exclave likely requires "Red" (Development) fused silicon. Researchers working on retail "Green" (Production) hardware will be effectively locked out of analyzing the internal logic of these secure subsystems, forced to treat them as black boxes and fuzz their inputs via &lt;code&gt;XNUProxy&lt;/code&gt;.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Final Thought:&lt;lb/&gt; macOS is no longer just a Unix system. It is a distributed system running on a single die, governed by a hypervisor that doesn't exist in software. The kernel is dead; long live the Monitor.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://stack.int.mov/a-reverse-engineers-anatomy-of-the-macos-boot-chain-security-architecture/"/><published>2025-11-22T20:54:02+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=46018165</id><title>Show HN: Build the habit of writing meaningful commit messages</title><updated>2025-11-23T08:13:04.969046+00:00</updated><content>&lt;doc fingerprint="f45415cfb8b2bbdb"&gt;
  &lt;main&gt;
    &lt;p&gt;smartcommit is an intelligent, AI-powered CLI tool that helps you write semantic, Conventional Commits messages effortlessly. It analyzes your staged changes, asks clarifying questions to understand the "why" behind your code, and generates a structured commit message for you.&lt;/p&gt;
    &lt;p&gt;Future you will thank you for deciding to use &lt;code&gt;smartcommit&lt;/code&gt;!&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;AI-Powered Analysis: Automatically analyzes your staged &lt;code&gt;git diff&lt;/code&gt;to understand what changed.&lt;/item&gt;
      &lt;item&gt;Interactive Q&amp;amp;A: Asks you specific, relevant questions to gather context that isn't obvious from the code alone (the "why" and "intent").&lt;/item&gt;
      &lt;item&gt;Multi-Provider Support: &lt;list rend="ul"&gt;&lt;item&gt;OpenAI (GPT-4o): For top-tier accuracy and performance.&lt;/item&gt;&lt;item&gt;Ollama (Llama 3.1): Run locally and privately for free.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;Conventional Commits: strictly enforces the Conventional Commits specification (&lt;code&gt;feat&lt;/code&gt;,&lt;code&gt;fix&lt;/code&gt;,&lt;code&gt;chore&lt;/code&gt;, etc.).&lt;/item&gt;
      &lt;item&gt;Beautiful TUI: A responsive, easy-to-use Terminal User Interface built with Bubble Tea.&lt;/item&gt;
    &lt;/list&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Go (1.21 or later)&lt;/item&gt;
      &lt;item&gt;Git installed and available in your PATH.&lt;/item&gt;
      &lt;item&gt;(Optional) Ollama installed locally if you plan to use the local model.&lt;/item&gt;
    &lt;/list&gt;
    &lt;code&gt;go install github.com/arpxspace/smartcommit@latest&lt;/code&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;
        &lt;p&gt;Clone the repository:&lt;/p&gt;
        &lt;code&gt;git clone https://github.com/arpxspace/smartcommit.git cd smartcommit&lt;/code&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Build the binary:&lt;/p&gt;
        &lt;quote&gt;go build -o smartcommit&lt;/quote&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Move to your PATH (optional):&lt;/p&gt;
        &lt;quote&gt;mv smartcommit /usr/local/bin/&lt;/quote&gt;
      &lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;To use &lt;code&gt;smartcommit&lt;/code&gt; as your default &lt;code&gt;git commit&lt;/code&gt; command, run:&lt;/p&gt;
    &lt;code&gt;git config --global alias.ci '!smartcommit'&lt;/code&gt;
    &lt;p&gt;Or for this repository only:&lt;/p&gt;
    &lt;code&gt;git config alias.ci '!smartcommit'&lt;/code&gt;
    &lt;p&gt;Usage:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;To commit with smartcommit: &lt;code&gt;git ci&lt;/code&gt;&lt;/item&gt;
    &lt;/list&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;
        &lt;p&gt;Stage your changes:&lt;/p&gt;
        &lt;code&gt;git add .&lt;/code&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Run smartcommit:&lt;/p&gt;
        &lt;quote&gt;smartcommit&lt;/quote&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Follow the TUI:&lt;/p&gt;
        &lt;list rend="ul"&gt;
          &lt;item&gt;First Run: You'll be asked to choose your AI provider (OpenAI or Ollama) and configure it.&lt;/item&gt;
          &lt;item&gt;Analysis: The AI will analyze your changes.&lt;/item&gt;
          &lt;item&gt;Questions: Answer a few questions to provide context.&lt;/item&gt;
          &lt;item&gt;Review: The AI generates a commit message. You can edit it or confirm it to commit immediately.&lt;/item&gt;
        &lt;/list&gt;
      &lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;If you already know what you want to write, you can select "I already know what to write" from the main menu to open your default git editor.&lt;/p&gt;
    &lt;p&gt;smartcommit stores its configuration in a local file (usually &lt;code&gt;~/.smartcommit/config.json&lt;/code&gt;).&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;OPENAI_API_KEY&lt;/code&gt;: If set, smartcommit can detect this during setup and ask if you want to use it, saving you from pasting it manually.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Contributions are welcome! Please feel free to submit a Pull Request.&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Fork the project&lt;/item&gt;
      &lt;item&gt;Create your feature branch (&lt;code&gt;git checkout -b feature/AmazingFeature&lt;/code&gt;)&lt;/item&gt;
      &lt;item&gt;Commit your changes (&lt;code&gt;git commit -m 'feat: Add some AmazingFeature'&lt;/code&gt;)&lt;/item&gt;
      &lt;item&gt;Push to the branch (&lt;code&gt;git push origin feature/AmazingFeature&lt;/code&gt;)&lt;/item&gt;
      &lt;item&gt;Open a Pull Request&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Distributed under the MIT License. See &lt;code&gt;LICENSE&lt;/code&gt; for more information.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://github.com/arpxspace/smartcommit"/><published>2025-11-22T20:54:35+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=46018380</id><title>WorldGen – Text to Immersive 3D Worlds</title><updated>2025-11-23T08:13:04.461576+00:00</updated><content/><link href="https://www.meta.com/en-gb/blog/worldgen-3d-world-generation-reality-labs-generative-ai-research/"/><published>2025-11-22T21:20:24+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=46018664</id><title>Windows ARM64 Internals: Deconstructing Pointer Authentication</title><updated>2025-11-23T08:13:04.079089+00:00</updated><content>&lt;doc fingerprint="90909313a42a7241"&gt;
  &lt;main&gt;
    &lt;p&gt;Pointer Authentication Code, or PAC, is an anti-exploit/memory-corruption feature that signs pointers so their use (as code or data) can be validated at runtime. PAC is available on Armv8.3-A and Armv9.0-A (and later) ARM architectures and leverages virtual addressing in order to store a small cryptographic signature alongside the pointer value.&lt;/p&gt;
    &lt;p&gt;On a typical 64-bit processor a pointer is considered a "user-mode" pointer if bit 47 of a 64-bit address is set to 0 (meaning, then, bits 48-63 are also 0). This is known as a canonical user-mode address. If bit 47 is set to 1, bits 48-63 are also set to 1, with this being considered a canonical kernel-mode address. Additionally, LA57, ARM 52 or 56 bit, or similar processors extend the most significant bit out even further (and PAC can also be enabled in the ARM-specific scenarios). For our purposes, however, we will be looking at a typical 64-bit processor with the most significant bit being bit 47.&lt;/p&gt;
    &lt;p&gt;It has always been an "accepted" standard that the setting of the most significant bit denotes a user-mode or kernel-mode address â with even some hardware vendors, like Intel, formalizing this architecture in actual hardware with CPU features like Linear Address Space Separation (LASS). This means that bits 48-63 are unused on a current, standard 64-bit processor, as the OS typically ignores them. Because they are unused, this allows PAC to store the aforementioned signature in these unused bits alongside the pointer itself.&lt;/p&gt;
    &lt;p&gt;As mentioned, these âunusedâ bits are now used to store signing information about a particular pointer in order to validate and verify execution and/or data access to the target memory address. Special CPU instructions are used to both generate and validate cryptographic signatures associated with a particular pointer value. This blog post will examine the Windows implementation of PAC on ARM64 installations of Windows, which, as we will see, supports a very specific implementation of PAC in both user-mode and kernel-mode.&lt;/p&gt;
    &lt;head rend="h2"&gt;PAC Enablement on Windows&lt;/head&gt;
    &lt;p&gt;PAC enablement on Windows begins at the entry point of ntoskrnl.exe, KiSystemStartup. KiSystemStartup is responsible for determining if PAC is supported on Windows and also for initializing basic PAC support. KiSystemStartup receives the loader parameter block (LOADER_PARAMETER_BLOCK) from winload.efi, the Windows boot loader. The loader block denotes if PAC is supported. Specifically, the loader parameter block extension (LOADER_PARAMETER_EXTENSION) portion of the loader block defines a bitmask of various features which are present/supported, so say the boot loader. The PointerAuthKernelIpEnabled bit of this bitmask denotes if PAC is supported. If PAC is supported, the loader parameter block extension is also responsible for providing the initial PAC signing key (PointerAuthKernelIpKey) used to sign and authenticate all kernel-mode pointers (we will see later that the "current" signing key is updated many times). When execution is occurring in kernel-mode, this is the key used to sign kernel-mode pointers. The bootloader generates the key in OslPrepareTarget by calling the function SymCryptRngAesGenerate to generate the initial kernel pointer signing key passed via the loader parameter block.&lt;/p&gt;
    &lt;p&gt;The ARM architecture supports having multiple signing keys for different scenarios, like signing instruction pointers or data pointers with different keys. Typically, "key A" and "key B" (as they are referred to), which are stored in specific system registers, are used for signing pointers used in instruction executions (like return addresses). Windows currently only uses PAC for "instruction pointers" (more on this later) and it also it only uses "key B" for cryptographic signatures and, therefore, loads the target pointer signing value into the APIBKeyLo_EL1 and APIBKeyHi_EL AArch64 system registers. These "key registers" are specific system registers, which are special registers on ARM systems which control various behaviors/controls/statuses for the system, and are responsible for maintaining the current keys used for signing and authenticating pointers. These two registers ("lo" and hi") each hold a single 64-bit value, which results in a concatenated 128-bit key. EL1, in this case, refers to exception level â1â - which denotes the ARM-equivalent of âprivilege levelâ the CPU is running in (as ARM-based CPUs are âexception-oritentedâ, meaning system calls, interrupts, etc. are all treated as âexceptionsâ). Typically EL1 is associated with kernel-mode. User-mode and kernel-mode, for Windows, share EL1âs signing key register (although the "current" signing key in the register changes depending on if a processor is executing in kernel-mode or user-mode). It should be noted that although the signing key for user-mode is stored in an EL1 register, the register itself (e.g., reading/writing) is inaccessible from user-mode (EL 0).&lt;/p&gt;
    &lt;p&gt;It is possible to examine the current signing key values using WinDbg. Although WinDbg, on ARM systems, has no extension to read from these system registers, it was discovered through trial-and-error that it is possible to leverage the rdmsr command in WinDbg to read from ARM system registers using the encoding values provided by the ARM documentation. The two PAC key system registers used by Windows have the following encodings:&lt;/p&gt;
    &lt;p&gt;â&lt;/p&gt;
    &lt;p&gt;&lt;code&gt;1. APIBKeyLo_EL1&lt;/code&gt;&lt;lb/&gt;- op0: 0b11 (3)&lt;lb/&gt;- op1: 0b000 (0)&lt;lb/&gt;- CRn: 0b0010 (2)&lt;lb/&gt;- CRm: 0b0001 (1)&lt;lb/&gt;- op2: 0b010 (2)&lt;/p&gt;
    &lt;p&gt;&lt;code&gt;2. APIBKeyHigh_EL1&lt;/code&gt;&lt;lb/&gt;- op0: 0b11 (3)&lt;lb/&gt;- op1: 0b000 (0)&lt;lb/&gt;- CRn: 0b0010 (2)&lt;lb/&gt;- CRm: 0b0001 (1)&lt;lb/&gt;- op2: 0b011 (3)&lt;/p&gt;
    &lt;p&gt;â&lt;/p&gt;
    &lt;p&gt;Concatenating these binary values into their hexadecimal values, it is then possible to leverage the rdmsr command to view the current signing key values:&lt;/p&gt;
    &lt;p&gt;After the initial signing key value has been configured, the kernel continues executing its entry point in order to continue to fill out some of the basic functionality of the kernel (although the kernel is not done yet being fully initialized). Almost immediately after performing basic PAC initialization, the function KiInitializeBootStructures is called from the kernel entry point, which also receives the loader parameter block and initializes various items such as the feature settings bitmask, setting the proper stack sizes (especially for "special" stacks like ISR stacks and DPC stacks), etc. One of those crucial things that this function does is call into KiDetectPointerAuthSupport, which is responsible for the bulk of the PAC initialization. This function is responsible for reading from the appropriate PAC-related ARM system registers in order to determine what specific PAC features the current CPU is capable of supporting.&lt;/p&gt;
    &lt;p&gt;After the current CPU's supported options are configured, "phase 0" of the system initialization process (achieved via KeInitsystem) will fully enable PAC. Currently, on Windows 11 24H2 and 25H2 preview builds, enablement is gated through a feature flag called Feature_Pointer_Auth_User__private_featureState. If the feature flag is enabled, a secondary check is performed to determine if a registry override option to disable PAC was present. Additionally, if the PAC feature flag is disabled, a check is performed to see if a registry override to enable PAC is present. The applicable registry paths are:&lt;/p&gt;
    &lt;p&gt;
      &lt;code&gt;- HKLM\System\CurrentControlSet\Control\Session Manager\Kernel\PointerAuthUserIpEnabled&lt;/code&gt;
    &lt;/p&gt;
    &lt;p&gt;
      &lt;code&gt;- HKLM\System\CurrentControlSet\Control\Session Manager\Kernel\PointerAuthUserIpForceDisabled&lt;/code&gt;
    &lt;/p&gt;
    &lt;p&gt;Note that the "enablement" flags are not directly tied one-to-one to the "supported flags". As previously seen, KePointerAuthEnabled is masked with the value 4 in KiSystemStartup before the "supported" options are even evaluated. Additionally, note that the KePointerAuthEnabled variable is marked as read-only and is present in the CFGRO section, which is also read-only in the VTL 0 guest page tables (known in ARM as the âStage 2 tablesâ with âStage 2â tables being the final level of translation from guest memory to system memory) thanks to the services of Hypervisor-Protected Code Integrity (HVCI), along with KePointerAuthKernelIpKey and KePointerAuthMask. As seen below, even using WinDbg, it is impossible to overwrite these global variables as they are read-only in the âStage 2â page tables.&lt;/p&gt;
    &lt;p&gt;As an aside, the supported and enabled PAC features can be queried via NtQuerySystemInformation through the SystemPointerAuthInformation class.&lt;/p&gt;
    &lt;p&gt;â&lt;/p&gt;
    &lt;p&gt;&lt;code&gt;C:\&amp;gt;C:\WindowsPAC.exe&lt;/code&gt;&lt;lb/&gt;[+] System Pointer Authentication Control (PAC) settings:&lt;lb/&gt;Â Â [&amp;gt;] SupportedFlags: 0x1F&lt;lb/&gt;Â Â [&amp;gt;] EnabledFlags: 0x101&lt;lb/&gt;Â Â Â Â [*] AddressAuthFaulting: TRUE&lt;lb/&gt;Â Â Â Â [*] AddressAuthQarma: TRUE&lt;lb/&gt;Â Â Â Â [*] AddressAuthSupported: TRUE&lt;lb/&gt;Â Â Â Â [*] GenericAuthQarma: TRUE&lt;lb/&gt;Â Â Â Â [*] GenericAuthSupported: TRUE&lt;lb/&gt;Â Â Â Â [*] KernelIpAuthEnabled: TRUE&lt;lb/&gt;Â Â Â Â [*] UserGlobalIpAuthEnabled: FALSE&lt;lb/&gt;Â Â Â Â [*] UserPerProcessIpAuthEnabled: TRUE&lt;/p&gt;
    &lt;p&gt;â&lt;/p&gt;
    &lt;p&gt;Once the appropriate PAC-related initialization flags have been set, PAC is then enabled on a per-process basis (if per-process PAC is supported, which currently on Windows it is). For user-mode PAC, the enablement process begins at process creation, specifically during the allocation of the new process object. If PAC is enabled, each user-mode process (meaning EPROCESS-&amp;gt;Flags3.SystemProcess is not set) is unconditionally opted-in to PAC (as all kernel-mode code shares a global signing key).&lt;/p&gt;
    &lt;p&gt;Additionally, likely as a side effect of Intel CET enablement on x86-based installations of Windows, the mitigation value CetDynamicApisOutOfProcOnly is also set unconditionally for every process except for the Idle process on Windows.&lt;/p&gt;
    &lt;p&gt;For the sake of completeness, the CET dynamic address range feature is not actually supported as the PROCESSINFOCLASS enum value ProcessDynamicEnforcedCetCompatibleRanges, for the NtSetInformationProcess system service, always returns STATUS_NOT_SUPPORTED on Windows ARM systems.&lt;/p&gt;
    &lt;p&gt;Returning to user-mode PAC, Windows SDK contains two documented ways to enable/disable PAC for user-mode processes. For extended process creation parameters, the following parameters are available in the SDK:&lt;/p&gt;
    &lt;p&gt;â&lt;/p&gt;
    &lt;p&gt;&lt;code&gt;//&lt;/code&gt;&lt;lb/&gt;// Define the ARM64 user-mode per-process instruction pointer authentication&lt;lb/&gt;// mitigation policy options.&lt;lb/&gt;//&lt;/p&gt;
    &lt;p&gt;
      &lt;code&gt;â&lt;/code&gt;
    &lt;/p&gt;
    &lt;p&gt;
      &lt;code&gt;#define PROCESS_CREATION_MITIGATION_POLICY2_POINTER_AUTH_USER_IP_MASKÂ  Â  Â  (0x00000003ui64 &amp;lt;&amp;lt; 44)&lt;/code&gt;
    &lt;/p&gt;
    &lt;p&gt;
      &lt;code&gt;#define PROCESS_CREATION_MITIGATION_POLICY2_POINTER_AUTH_USER_IP_DEFER Â  Â  (0x00000000ui64 &amp;lt;&amp;lt; 44)&lt;/code&gt;
    &lt;/p&gt;
    &lt;p&gt;
      &lt;code&gt;#define PROCESS_CREATION_MITIGATION_POLICY2_POINTER_AUTH_USER_IP_ALWAYS_ON (0x00000001ui64 &amp;lt;&amp;lt; 44)&lt;/code&gt;
    &lt;/p&gt;
    &lt;p&gt;&lt;code&gt;#define PROCESS_CREATION_MITIGATION_POLICY2_POINTER_AUTH_USER_IP_ALWAYS_OFF&lt;/code&gt;&lt;lb/&gt;(0x00000002ui64 &amp;lt;&amp;lt; 44)&lt;/p&gt;
    &lt;p&gt;
      &lt;code&gt;#define PROCESS_CREATION_MITIGATION_POLICY2_POINTER_AUTH_USER_IP_RESERVEDÂ  (0x00000003ui64 &amp;lt;&amp;lt; 44)&lt;/code&gt;
    &lt;/p&gt;
    &lt;p&gt;â&lt;/p&gt;
    &lt;p&gt;Additionally, for runtime enablement/disablement, the following structure can be supplied with the ProcessUserPointerAuthPolicy:&lt;/p&gt;
    &lt;p&gt;â&lt;/p&gt;
    &lt;p&gt;&lt;code&gt;typedef struct _PROCESS_MITIGATION_USER_POINTER_AUTH_POLICY {&lt;/code&gt;&lt;lb/&gt;Â Â Â Â union {&lt;lb/&gt;Â Â Â Â Â Â Â Â DWORD Flags&lt;lb/&gt;Â Â Â Â Â Â Â Â struct {&lt;lb/&gt;Â Â Â Â Â Â Â Â Â Â Â Â DWORD EnablePointerAuthUserIp : 1;&lt;lb/&gt;Â Â Â Â Â Â Â Â Â Â Â Â DWORD ReservedFlags : 31;&lt;lb/&gt;Â Â Â Â Â Â Â Â } DUMMYSTRUCTNAME;&lt;lb/&gt;Â Â Â Â } DUMMYUNIONNAME;&lt;lb/&gt;} PROCESS_MITIGATION_USER_POINTER_AUTH_POLICY,&lt;lb/&gt;*PPROCESS_MITIGATION_USER_POINTER_AUTH_POLICY;&lt;/p&gt;
    &lt;p&gt;â&lt;/p&gt;
    &lt;p&gt;However, testing and reverse engineering revealed that PAC is unconditionally enabled on user-mode processes (as shown above) with no way to disable the mitigation either at process creation (e.g., creating a child process with extended parameters) or by calling SetProcessMitigationPolicy at runtime. The only other supported way to enable a process mitigation at process creation is to use the ImageFileExecutionOptions (IFEO) registry key. This functionality is wrapped by the "Exploit Protection" UI on Windows systems, but the registry value can be set manually. Unfortunately, there is no PAC Exploit Protection setting in the UI.&lt;/p&gt;
    &lt;p&gt;Outside of the exploit mitigation policy for PAC, there is also an audit-mode exploit mitigation policy option in the ImageFileExecutionOptions policy map. This can be confirmed through the presence of the mitigation flag values of AuditPointerAuthUserIp and AuditPointerAuthUserIpLogged in the MitigationFlags2Values field of a process object on Windows.&lt;/p&gt;
    &lt;p&gt;The IFEO registry key contains a list of processes that have IFEO values. One of the items encapsulated in the IFEO key, as mentioned, is both the mitigation policy settings and audit-mode mitigation policy settings (meaning that an ETW event is logged but the target operation is not blocked/process is not terminated by a mitigation violation) for a target process. These per-process mitigation values are used in making considerations about what mitigation policies will be applied to a particular target process at process creation time. On a default installation of Windows 11 24H2 running an ARM build of Windows, no processes have the audit-mode PAC flags set.&lt;/p&gt;
    &lt;p&gt;Further investigation reveals that this is because there is no way to set the PAC audit-mode exploit policy value on a per-process basis, even through the IFEO key. This is because if pointer authentication is enabled, for example, the slot in the map (represented by the 0x000000000000X000 nibble) in which audit-mode PAC may be enabled is explicitly overridden by PspAllocateProcess (and no ETW event exists in the manifest of the Microsoft-Windows-Security-Mitigations ETW provider for PAC violations).&lt;/p&gt;
    &lt;p&gt;Once PAC support has been instantiated for the process, the per-process signing key is configured. Yes, this means that each process has its own key it can use to sign pointers. This occurs in PspAllocateProcess and, if a process has not opted in to inheriting the signing key, a random key is generated with BCryptGenRandom.&lt;/p&gt;
    &lt;p&gt;The "per-process" signing key differs from the initial (kernel) signing key that was configured in KiSystemStartup. This is because, obviously, execution is in kernel mode when the initial signing key is instantiated. However, the implementation of PAC on Windows (as we can see above) instruments a per-process signing key (along with a single kernel key). When execution transitions into user mode, the signing key system register(s) are updated to the current process signing key (which is maintained through a process object). The example below outlines the current PAC signing key being updated to that of a user-mode process, specifically when a return into user-mode happens after a system call is handled by the kernel (KiSystemServiceExit).&lt;/p&gt;
    &lt;p&gt;This is how the necessary PAC infrastructure is updated for user-to-kernel and kernel-to-user transitions and how kernel-mode and user-mode PAC on Windows is set up. Let's now examine what Windows does when the proper infrastructure is in place.&lt;/p&gt;
    &lt;head rend="h2"&gt;Windows PAC As An Exploit Mitigation&lt;/head&gt;
    &lt;p&gt;Windows currently offers an implementation of PAC (with the ability to expand in the future). Windows currently supports PAC for signing and authenticating "instruction pointers". The way that this manifests itself, however, really results in the signing of return addresses. On Windows, for both user-mode and kernel-mode ARM64 code, one can specify the /guard:signret(-) compiler flag to either explicitly enable or disable the signing of return addresses. Enabling this flag instruments the pacibsp and autibsp instructions into the prologue and epilogue of each function, which are "PAC" instructions used to both sign and subsequently validate return addresses.&lt;/p&gt;
    &lt;p&gt;In the ARM64 architecture, the semantics of preserving return addresses across call boundaries slightly differ from Intel x86. On x86-based systems, a call instruction will also push the target return address onto the stack. Then, right before a return, the aforementioned return address is "popped" off of the stack and loaded into the instruction pointer. On ARM64 the bl (Branch with Link, similar to a call) instruction will instead place the current, in-scope return address an architectural register (lr, or "link register") with a typical operating system, like Windows, also storing this value on the stack to preserve the return address so the lr register can be used for the next call's return address (meaning the return addresses are still stored on the stack on ARM, even with the presence of lr).&lt;/p&gt;
    &lt;p&gt;The pacibsp instruction will use "key b" (APIBKeyLo_EL1 and APIBKeyHi_EL1) and the value of the in-scope stack pointer to sign the return address. The target return address will remain in this state, with the upper bits (non-canonical) being transformed through the signing.&lt;/p&gt;
    &lt;p&gt;This assumes, however, that there is already a return address to process. What if a user-mode thread, for example, is just entering its initial execution, and there is no return address? Windows has two functions (for user-mode and kernel-mode) that will generate the necessary "first" signed return address via KiGenerateSignedReturnAddressForStartUserThread. These functions accept the initial stack value as the value to use in the signing of the return address, using instead the pacib instruction, which is capable of using a general-purpose architectural register in the signing process instead of just defaulting to "the current stack pointer".&lt;/p&gt;
    &lt;p&gt;At this point, the return address (stored in lr, but also present on the stack) has been signed. The in-scope function performs its work and eventually the epilogue of a function is reached (which is responsible for returning to the caller for the current function). When the epilogue is reached, but before the ret has been executed, the autibsp instruction is used to authenticate the return address (in lr) before performing the return control-flow transfer. This will result in transforming the value in lr back to the "original" return address so that the return occurs back into a valid memory address.&lt;/p&gt;
    &lt;p&gt;The effectiveness of PAC, however, relies on what happens if a return address has been corrupted with a malicious return address, like a ROP gadget or the corruption of a return address through a stack-based buffer overflow. In the example below, this is outlined by corrupting a return address on the stack with another return address on the stack. Both of these addresses used in this memory corruption example are signed, but, as we can recall from earlier, return addresses are signed with the considerations of the current in-scope stack pointer (meaning they are tied to a stack frame). Because the corrupted return address does not correspond to an "in-scope" stack frame, the authentication of the in-scope return address (which has been corrupted) results in a fastfail with the code FAST_FAIL_POINTER_AUTH_INVALID_RETURN_ADDRESS - and the application crashes. One interesting note, as you can see, is that WinDbg can convert a signed return address on the stack to its actual unsigned value (and appropriate symbol name).Â&lt;/p&gt;
    &lt;p&gt;Shifting focus slightly, when a kernel-mode PAC violation, identical to the previous scenario, occurs, a KERNEL_SECURITY_CHECK_FAILURE ensues, with the type of memory safety violation being FAST_FAIL_POINTER_AUTH_INVALID_RETURN_ADDRESS.&lt;/p&gt;
    &lt;head rend="h2"&gt;Secure Kernel And PAC&lt;/head&gt;
    &lt;p&gt;The curious reader may notice that the kernel itself is responsible for managing the key values for PAC. Additionally, we already covered the fact that the in-memory variable which tracks the kernelâs PAC signing key (used to sign kernel pointers) is read-only in VTL 0 memory thanks to the services of HVCI. However, the in-memory representation is simply a reflection of the system register value(s) we have talked about before - the APIBKeyLo_EL1 and APIBKeyHi_EL AArch64 registers (specifically when execution is in kernel-mode, loading the per-boot kernel-mode PAC key). What is preventing an attacker, in kernel-mode, from modifying the contents of this system register at any given time? After all, the register is writable from kernel-mode because the configuration is not delegated to a higher security boundary? To help alleviate this problem, Secure Kernel Patch Guard, more commonly referred to as âHyperGuardâ - a security feature promulgated by the Secure Kernel - is used! HyperGuard achieves much of what PatchGuard attempts to defend against (modification of kernel data structures, MSRs on x86 systems, control registers, etc.) but it does so deterministically, as opposed to PatchGuard, because HyperGuard runs at a higher security boundary than the code it is attempting to defend (VTL 0âs kernel).&lt;/p&gt;
    &lt;p&gt;HyperGuard uses what is known as extents, which are definitions of what components/code/data/etc. should be protected by HyperGuard. On ARM64 installations of Windows, an ARM64-specific HyperGuard extent exists - the PAC system register extent. This extent is used by HyperGuard to ask the hypervisor to intercept certain items of interest - such as modifications to an MSR (or ARM64 system register), certain memory access operations, etc. Specifically for the ARM64 version of the Secure Kernel, an extent is registered for monitoring modifications to the PAC key system registers. This is done in securekernel!SkpgxInitializeInterceptMasks.&lt;/p&gt;
    &lt;p&gt;Although ARM-based hypervisors do not have âVirtual Machine Control Structureâ, or VMCS (in the âcanonicalâ sense that x86-based systems do, such as having dedicated instructions in the ISA for reading/writing to the VMCS), ARM hypervisors still must maintain the âstateâ of a guest. This, obviously, is used in situations like when a processor starts executing in context of the hypervisor software (due to a hypervisor call (HVC call), or other exceptions into the hypervisor), or when a guest starts resuming its execution. Part of this state - as is the case with x86-based systems - is the set of virtual registers (e.g., registers which are preserved across exception level changes into/out of the hypervisor and are specific to a guest). Among the virtual registers which are configurable by the hypervisor are, as you may have guessed, the âloâ and âhiâ PAC signing key registers! This is what the function from the screenshot above intends to achieve - securekernel!SkpgArm64ReadRegister64.&lt;/p&gt;
    &lt;p&gt;Microsoft documents many of the 64-bit virtualized-registers. Among the undocumented registers, however, are the ARM-based virtualized registers. However, we can see above that values 0x4002E and 0x4002F correspond to the virtual/private PAC signing registers. For completeness sake, 0x40002 corresponds to SCTLR_EL1. This was determined by examining the bit being processed (bit 30, via the 0x40000000 mask). This was previously seen, in the beginning of our analysis, by the toggling of SCTLR_EL1.EnIB bit (bit 30).&lt;/p&gt;
    &lt;p&gt;This entire configuration allows the Secure Kernel to intercept, via HyperGuard, any unauthorized modification of the PAC signing key register.&lt;/p&gt;
    &lt;head rend="h1"&gt;Conclusion&lt;/head&gt;
    &lt;p&gt;ARM-based processors, without the presence of backwards-edge control flow integrity (CFI) mitigations like CET, are able to effectively leverage PAC to defend against return address corruption. Windows, as we have seen, currently leverages PAC only in limited circumstances (like the protection of return addresses), which is standard on many mainstream implementations of PAC (with the ability in the future, if feasible, to expand into protection of data accesses). PAC provides a viable solution to protect non-x86-based processors from certain classes of memory corruption exploits. In addition, current-generation ARM64 Microsoft devices, like the Surface Pro, are not shipped with chips that can support the Memory Tagging Extension (MTE) feature. Although not implemented today on Windows systems, the implementation of both PAC and MTE in the future would serve to greatly increase the cost of memory corruption exploits. Given the protections afforded by the hypervisor, plus the current implementation of PAC, ARM-based Windows provides both user-mode and kernel-mode code with additional security against memory corruption exploits.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://www.preludesecurity.com/blog/windows-arm64-internals-deconstructing-pointer-authentication"/><published>2025-11-22T22:03:29+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=46019636</id><title>NTSB report: Decryption of images from the Titan submersible camera [pdf] (2024)</title><updated>2025-11-23T08:13:03.913137+00:00</updated><content/><link href="https://data.ntsb.gov/Docket/Document/docBLOB?ID=18741602&amp;FileExtension=pdf&amp;FileName=Underwater%20Camera%20-%20Specialist%27s%20Factual%20Report-Rel.pdf"/><published>2025-11-23T00:35:27+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=46019685</id><title>A monopoly ISP refuses to fix upstream infrastructure</title><updated>2025-11-23T08:13:03.624883+00:00</updated><content>&lt;doc fingerprint="e4f58d916a5c0f24"&gt;
  &lt;main&gt;
    &lt;p&gt;A documented case of infrastructure failure, failed escalation, and a company that refuses to investigate.&lt;/p&gt;
    &lt;head rend="h2"&gt;Here’s the situation: I have outages. My neighbor has the same outages. Xfinity won’t fix it.&lt;/head&gt;
    &lt;p&gt;I bought Xfinity internet in June 2024. Immediately, my connection started dropping. Multiple times a day. Every single day. After troubleshooting every piece of equipment I had and questioning my sanity my neighbor complained about the same thing which led me to understand this was not my equipment.&lt;/p&gt;
    &lt;p&gt;I set up an uptime monitor and found that these outages happen 6-7 times per day for 125 seconds.&lt;/p&gt;
    &lt;p&gt;Over 17 months of my service term that’s approximately 3,387 outage incidents totaling 117+ hours of cumulative downtime.&lt;/p&gt;
    &lt;p&gt;This outage pattern has recurred thousands of times. It is consistent, predictable, and it follows an automated schedule.&lt;/p&gt;
    &lt;p&gt;My neighbor has the same problem. Different house. Different line from a different junction box. Same 125-second outages happening at the same times of day.&lt;/p&gt;
    &lt;head class="mai-accordion-summary"&gt;PING Uptime Log&lt;/head&gt;
    &lt;code&gt;2025-11-21T14:42:31-08:00 Warning dpinger exiting on signal 15
2025-11-21T07:01:34-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: loss -&amp;gt; none RTT: 21.4 ms RTTd: 14.8 ms Loss: 10.0 %)
2025-11-21T07:01:28-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: down -&amp;gt; loss RTT: 21.7 ms RTTd: 15.8 ms Loss: 20.0 %)
2025-11-21T06:59:33-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: loss -&amp;gt; down RTT: 19.1 ms RTTd: 1.7 ms Loss: 21.0 %)
2025-11-21T06:59:28-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: none -&amp;gt; loss RTT: 19.1 ms RTTd: 1.6 ms Loss: 12.0 %)
2025-11-21T00:01:33-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: loss -&amp;gt; none RTT: 20.5 ms RTTd: 2.7 ms Loss: 10.0 %)
2025-11-21T00:01:28-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: down -&amp;gt; loss RTT: 20.6 ms RTTd: 2.8 ms Loss: 20.0 %)
2025-11-20T23:59:35-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: loss -&amp;gt; down RTT: 20.1 ms RTTd: 3.1 ms Loss: 21.0 %)
2025-11-20T23:59:30-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: none -&amp;gt; loss RTT: 20.0 ms RTTd: 3.0 ms Loss: 12.0 %)
2025-11-20T15:01:37-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: loss -&amp;gt; none RTT: 21.3 ms RTTd: 3.9 ms Loss: 10.0 %)
2025-11-20T15:01:31-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: down -&amp;gt; loss RTT: 21.4 ms RTTd: 4.1 ms Loss: 20.0 %)
2025-11-20T14:59:36-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: loss -&amp;gt; down RTT: 21.0 ms RTTd: 3.9 ms Loss: 21.0 %)
2025-11-20T14:59:31-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: none -&amp;gt; loss RTT: 21.3 ms RTTd: 4.3 ms Loss: 12.0 %)
2025-11-20T13:46:40-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: loss -&amp;gt; none RTT: 20.4 ms RTTd: 2.9 ms Loss: 10.0 %)
2025-11-20T13:46:34-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: down -&amp;gt; loss RTT: 20.2 ms RTTd: 3.0 ms Loss: 20.0 %)
2025-11-20T13:44:38-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: loss -&amp;gt; down RTT: 19.9 ms RTTd: 1.7 ms Loss: 21.0 %)
2025-11-20T13:44:33-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: none -&amp;gt; loss RTT: 19.7 ms RTTd: 1.7 ms Loss: 12.0 %)
2025-11-20T12:46:37-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: loss -&amp;gt; none RTT: 19.3 ms RTTd: 1.2 ms Loss: 10.0 %)
2025-11-20T12:46:32-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: down -&amp;gt; loss RTT: 19.2 ms RTTd: 1.2 ms Loss: 20.0 %)
2025-11-20T12:44:39-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: loss -&amp;gt; down RTT: 19.2 ms RTTd: 0.9 ms Loss: 21.0 %)
2025-11-20T12:44:34-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: none -&amp;gt; loss RTT: 19.3 ms RTTd: 1.0 ms Loss: 12.0 %)
2025-11-20T05:16:33-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: loss -&amp;gt; none RTT: 19.5 ms RTTd: 1.4 ms Loss: 10.0 %)
2025-11-20T05:16:27-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: down -&amp;gt; loss RTT: 19.5 ms RTTd: 1.4 ms Loss: 20.0 %)
2025-11-20T05:14:33-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: loss -&amp;gt; down RTT: 19.4 ms RTTd: 1.2 ms Loss: 21.0 %)
2025-11-20T05:14:28-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: none -&amp;gt; loss RTT: 19.3 ms RTTd: 1.2 ms Loss: 12.0 %)
2025-11-20T03:31:34-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: loss -&amp;gt; none RTT: 18.9 ms RTTd: 1.3 ms Loss: 10.0 %)
2025-11-20T03:31:28-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: down -&amp;gt; loss RTT: 18.8 ms RTTd: 1.1 ms Loss: 20.0 %)
2025-11-20T03:29:32-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: loss -&amp;gt; down RTT: 19.3 ms RTTd: 1.6 ms Loss: 21.0 %)
2025-11-20T03:29:28-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: none -&amp;gt; loss RTT: 19.4 ms RTTd: 1.6 ms Loss: 14.0 %)
2025-11-19T20:01:32-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: loss -&amp;gt; none RTT: 18.9 ms RTTd: 1.2 ms Loss: 10.0 %)
2025-11-19T20:01:26-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: down -&amp;gt; loss RTT: 18.8 ms RTTd: 1.2 ms Loss: 20.0 %)
2025-11-19T19:59:34-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: loss -&amp;gt; down RTT: 19.2 ms RTTd: 2.2 ms Loss: 21.0 %)
2025-11-19T19:59:29-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: none -&amp;gt; loss RTT: 19.1 ms RTTd: 2.1 ms Loss: 12.0 %)
2025-11-19T16:31:36-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: loss -&amp;gt; none RTT: 20.2 ms RTTd: 2.7 ms Loss: 10.0 %)
2025-11-19T16:31:29-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: down -&amp;gt; loss RTT: 20.2 ms RTTd: 2.8 ms Loss: 20.0 %)
2025-11-19T16:29:35-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: loss -&amp;gt; down RTT: 19.6 ms RTTd: 2.1 ms Loss: 21.0 %)
2025-11-19T16:29:30-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: none -&amp;gt; loss RTT: 19.8 ms RTTd: 2.3 ms Loss: 12.0 %)
2025-11-19T13:31:35-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: loss -&amp;gt; none RTT: 17.7 ms RTTd: 2.5 ms Loss: 10.0 %)
2025-11-19T13:31:29-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: down -&amp;gt; loss RTT: 17.9 ms RTTd: 2.6 ms Loss: 20.0 %)
2025-11-19T13:29:38-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: loss -&amp;gt; down RTT: 16.7 ms RTTd: 2.0 ms Loss: 21.0 %)
2025-11-19T13:29:32-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: none -&amp;gt; loss RTT: 16.6 ms RTTd: 2.0 ms Loss: 12.0 %)
2025-11-19T10:31:39-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: loss -&amp;gt; none RTT: 19.6 ms RTTd: 1.4 ms Loss: 10.0 %)
2025-11-19T10:31:33-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: down -&amp;gt; loss RTT: 19.5 ms RTTd: 1.3 ms Loss: 20.0 %)
2025-11-19T10:29:39-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: loss -&amp;gt; down RTT: 18.9 ms RTTd: 1.2 ms Loss: 21.0 %)
2025-11-19T10:29:33-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: none -&amp;gt; loss RTT: 19.1 ms RTTd: 1.3 ms Loss: 12.0 %)
2025-11-19T03:46:32-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: loss -&amp;gt; none RTT: 19.6 ms RTTd: 2.6 ms Loss: 10.0 %)
2025-11-19T03:46:25-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: down -&amp;gt; loss RTT: 19.6 ms RTTd: 2.7 ms Loss: 20.0 %)
2025-11-19T03:44:33-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: loss -&amp;gt; down RTT: 19.4 ms RTTd: 1.2 ms Loss: 21.0 %)
2025-11-19T03:44:28-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: none -&amp;gt; loss RTT: 19.4 ms RTTd: 1.2 ms Loss: 12.0 %)
2025-11-18T22:31:36-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: loss -&amp;gt; none RTT: 19.9 ms RTTd: 2.6 ms Loss: 10.0 %)
2025-11-18T22:31:29-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: down -&amp;gt; loss RTT: 19.8 ms RTTd: 2.5 ms Loss: 20.0 %)
2025-11-18T22:29:34-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: loss -&amp;gt; down RTT: 20.1 ms RTTd: 2.5 ms Loss: 21.0 %)
2025-11-18T22:29:29-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: none -&amp;gt; loss RTT: 20.0 ms RTTd: 2.4 ms Loss: 12.0 %)
2025-11-18T12:19:41-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: loss -&amp;gt; none RTT: 21.1 ms RTTd: 4.2 ms Loss: 10.0 %)
2025-11-18T12:19:35-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: down -&amp;gt; loss RTT: 21.1 ms RTTd: 4.3 ms Loss: 20.0 %)
2025-11-18T12:17:42-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: loss -&amp;gt; down RTT: 19.5 ms RTTd: 1.7 ms Loss: 21.0 %)
2025-11-18T12:17:37-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: none -&amp;gt; loss RTT: 19.8 ms RTTd: 1.8 ms Loss: 12.0 %)
2025-11-18T12:16:37-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: loss -&amp;gt; none RTT: 19.3 ms RTTd: 1.6 ms Loss: 10.0 %)
2025-11-18T12:16:31-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: down -&amp;gt; loss RTT: 19.2 ms RTTd: 1.7 ms Loss: 20.0 %)
2025-11-18T12:14:38-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: loss -&amp;gt; down RTT: 19.1 ms RTTd: 1.2 ms Loss: 21.0 %)
2025-11-18T12:14:32-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: none -&amp;gt; loss RTT: 19.1 ms RTTd: 1.1 ms Loss: 12.0 %)
2025-11-18T09:31:37-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: loss -&amp;gt; none RTT: 19.4 ms RTTd: 1.0 ms Loss: 10.0 %)
2025-11-18T09:31:32-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: down -&amp;gt; loss RTT: 19.4 ms RTTd: 1.0 ms Loss: 20.0 %)
2025-11-18T09:29:38-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: loss -&amp;gt; down RTT: 19.6 ms RTTd: 1.3 ms Loss: 21.0 %)
2025-11-18T09:29:33-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: none -&amp;gt; loss RTT: 19.6 ms RTTd: 1.2 ms Loss: 12.0 %)
2025-11-18T07:46:33-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: loss -&amp;gt; none RTT: 21.1 ms RTTd: 15.0 ms Loss: 10.0 %)
2025-11-18T07:46:26-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: down -&amp;gt; loss RTT: 21.4 ms RTTd: 15.9 ms Loss: 20.0 %)
2025-11-18T07:44:32-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: loss -&amp;gt; down RTT: 19.7 ms RTTd: 2.1 ms Loss: 21.0 %)
2025-11-18T07:44:27-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: none -&amp;gt; loss RTT: 19.6 ms RTTd: 2.0 ms Loss: 12.0 %)
2025-11-18T02:46:34-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: loss -&amp;gt; none RTT: 19.0 ms RTTd: 1.5 ms Loss: 10.0 %)
2025-11-18T02:46:28-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: down -&amp;gt; loss RTT: 19.1 ms RTTd: 1.6 ms Loss: 20.0 %)
2025-11-18T02:44:33-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: loss -&amp;gt; down RTT: 19.0 ms RTTd: 1.0 ms Loss: 21.0 %)
2025-11-18T02:44:28-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: none -&amp;gt; loss RTT: 19.0 ms RTTd: 1.0 ms Loss: 12.0 %)
2025-11-17T23:01:33-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: loss -&amp;gt; none RTT: 18.6 ms RTTd: 0.9 ms Loss: 10.0 %)
2025-11-17T23:01:28-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: down -&amp;gt; loss RTT: 18.7 ms RTTd: 0.9 ms Loss: 20.0 %)
2025-11-17T22:59:35-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: loss -&amp;gt; down RTT: 18.8 ms RTTd: 1.0 ms Loss: 21.0 %)
2025-11-17T22:59:29-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: none -&amp;gt; loss RTT: 18.9 ms RTTd: 1.0 ms Loss: 12.0 %)
2025-11-17T17:01:35-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: loss -&amp;gt; none RTT: 20.5 ms RTTd: 3.3 ms Loss: 10.0 %)
2025-11-17T17:01:29-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: down -&amp;gt; loss RTT: 20.4 ms RTTd: 3.0 ms Loss: 20.0 %)
2025-11-17T16:59:36-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: loss -&amp;gt; down RTT: 19.4 ms RTTd: 1.5 ms Loss: 21.0 %)
2025-11-17T16:59:31-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: none -&amp;gt; loss RTT: 19.4 ms RTTd: 1.6 ms Loss: 12.0 %)
2025-11-17T13:31:36-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: loss -&amp;gt; none RTT: 20.1 ms RTTd: 3.3 ms Loss: 10.0 %)
2025-11-17T13:31:30-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: down -&amp;gt; loss RTT: 20.2 ms RTTd: 3.4 ms Loss: 20.0 %)
2025-11-17T13:29:37-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: loss -&amp;gt; down RTT: 19.3 ms RTTd: 1.1 ms Loss: 21.0 %)
2025-11-17T13:29:32-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: none -&amp;gt; loss RTT: 19.5 ms RTTd: 1.5 ms Loss: 12.0 %)
2025-11-17T12:46:37-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: loss -&amp;gt; none RTT: 19.0 ms RTTd: 3.4 ms Loss: 10.0 %)
2025-11-17T12:46:31-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: down -&amp;gt; loss RTT: 19.3 ms RTTd: 3.5 ms Loss: 20.0 %)
2025-11-17T12:44:40-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: loss -&amp;gt; down RTT: 17.8 ms RTTd: 3.1 ms Loss: 22.0 %)
2025-11-17T12:44:34-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: none -&amp;gt; loss RTT: 17.8 ms RTTd: 3.0 ms Loss: 12.0 %)
2025-11-17T02:46:33-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: loss -&amp;gt; none RTT: 19.8 ms RTTd: 2.6 ms Loss: 10.0 %)
2025-11-17T02:46:27-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: down -&amp;gt; loss RTT: 19.8 ms RTTd: 2.7 ms Loss: 20.0 %)
2025-11-17T02:44:32-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: loss -&amp;gt; down RTT: 19.0 ms RTTd: 0.9 ms Loss: 21.0 %)
2025-11-17T02:44:28-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: none -&amp;gt; loss RTT: 19.2 ms RTTd: 1.5 ms Loss: 12.0 %)
2025-11-17T01:15:08-08:00 Notice dpinger MONITOR: WAN_GW (Addr: 8.8.8.8 Alarm: down -&amp;gt; none RTT: 19.0 ms RTTd: 1.1 ms Loss: 0.0 %)
2025-11-17T01:14:57-08:00 Warning dpinger send_interval 1000ms loss_interval 4000ms time_period 60000ms report_interval 0ms data_len 1 alert_interval 1000ms latency_alarm 0ms loss_alarm 0% alarm_hold 10000ms dest_addr 8.8.8.8 bind_addr 24.2.60.72 identifier "WAN_GW "&lt;/code&gt;
    &lt;head class="mai-accordion-summary"&gt;DOCSIS Event Log from MODEM (MAC Obfuscated)&lt;/head&gt;
    &lt;p&gt;00:00:36&lt;/p&gt;
    &lt;p&gt;Fri Nov 21 2025 Critical (3) UCD invalid or channel unusable;CM-MAC=00:XX:XX:XX:XX:ac;CMTS-MAC=00:XX:XX:XX:XX:00;CM-QOS=1.1;CM-VER=3.1;&lt;/p&gt;
    &lt;p&gt;Time Not Established&lt;/p&gt;
    &lt;p&gt;Critical (3) SYNC Timing Synchronization failure – Failed to acquire QAM/QPSK symbol timing;;CM-MAC=00:XX:XX:XX:XX:ac;CMTS-MAC=00:00:00:00:00:00;CM-QOS=1.1;CM-VER=3.1;&lt;/p&gt;
    &lt;p&gt;Time Not Established&lt;/p&gt;
    &lt;p&gt;Critical (3) UCD invalid or channel unusable;CM-MAC=00:XX:XX:XX:XX:ac;CMTS-MAC=00:XX:XX:XX:XX:00;CM-QOS=1.1;CM-VER=3.1;&lt;/p&gt;
    &lt;p&gt;07:00:37&lt;/p&gt;
    &lt;p&gt;Fri Nov 21 2025 Critical (3) UCD invalid or channel unusable;CM-MAC=00:XX:XX:XX:XX:ac;CMTS-MAC=00:XX:XX:XX:XX:00;CM-QOS=1.1;CM-VER=3.1;&lt;/p&gt;
    &lt;p&gt;Time Not Established&lt;/p&gt;
    &lt;p&gt;Critical (3) SYNC Timing Synchronization failure – Failed to acquire QAM/QPSK symbol timing;;CM-MAC=00:XX:XX:XX:XX:ac;CMTS-MAC=00:00:00:00:00:00;CM-QOS=1.1;CM-VER=3.1;&lt;/p&gt;
    &lt;p&gt;Time Not Established&lt;/p&gt;
    &lt;p&gt;Critical (3) UCD invalid or channel unusable;CM-MAC=00:XX:XX:XX:XX:ac;CMTS-MAC=00:XX:XX:XX:XX:00;CM-QOS=1.1;CM-VER=3.1;&lt;/p&gt;
    &lt;p&gt;14:48:44&lt;/p&gt;
    &lt;p&gt;Fri Nov 21 2025 Critical (3) UCD invalid or channel unusable;CM-MAC=00:XX:XX:XX:XX:ac;CMTS-MAC=00:XX:XX:XX:XX:00;CM-QOS=1.1;CM-VER=3.1;&lt;/p&gt;
    &lt;p&gt;Time Not Established&lt;/p&gt;
    &lt;p&gt;Critical (3) SYNC Timing Synchronization failure – Failed to acquire QAM/QPSK symbol timing;;CM-MAC=00:XX:XX:XX:XX:ac;CMTS-MAC=00:00:00:00:00:00;CM-QOS=1.1;CM-VER=3.1;&lt;/p&gt;
    &lt;p&gt;Time Not Established&lt;/p&gt;
    &lt;p&gt;Critical (3) UCD invalid or channel unusable;CM-MAC=00:XX:XX:XX:XX:ac;CMTS-MAC=00:XX:XX:XX:XX:00;CM-QOS=1.1;CM-VER=3.1;&lt;/p&gt;
    &lt;p&gt;15:30:40&lt;/p&gt;
    &lt;p&gt;Fri Nov 21 2025 Critical (3) UCD invalid or channel unusable;CM-MAC=00:XX:XX:XX:XX:ac;CMTS-MAC=00:XX:XX:XX:XX:00;CM-QOS=1.1;CM-VER=3.1;&lt;/p&gt;
    &lt;p&gt;Time Not Established&lt;/p&gt;
    &lt;p&gt;Critical (3) SYNC Timing Synchronization failure – Failed to acquire QAM/QPSK symbol timing;;CM-MAC=00:XX:XX:XX:XX:ac;CMTS-MAC=00:00:00:00:00:00;CM-QOS=1.1;CM-VER=3.1;&lt;/p&gt;
    &lt;p&gt;Time Not Established&lt;/p&gt;
    &lt;p&gt;Critical (3) UCD invalid or channel unusable;CM-MAC=00:XX:XX:XX:XX:ac;CMTS-MAC=00:XX:XX:XX:XX:00;CM-QOS=1.1;CM-VER=3.1;&lt;/p&gt;
    &lt;p&gt;03:00:36&lt;/p&gt;
    &lt;p&gt;Sat Nov 22 2025 Critical (3) UCD invalid or channel unusable;CM-MAC=00:XX:XX:XX:XX:ac;CMTS-MAC=00:XX:XX:XX:XX:00;CM-QOS=1.1;CM-VER=3.1;&lt;/p&gt;
    &lt;p&gt;Time Not Established&lt;/p&gt;
    &lt;p&gt;Critical (3) SYNC Timing Synchronization failure – Failed to acquire QAM/QPSK symbol timing;;CM-MAC=00:XX:XX:XX:XX:ac;CMTS-MAC=00:00:00:00:00:00;CM-QOS=1.1;CM-VER=3.1;&lt;/p&gt;
    &lt;p&gt;Time Not Established&lt;/p&gt;
    &lt;p&gt;Critical (3) UCD invalid or channel unusable;CM-MAC=00:XX:XX:XX:XX:ac;CMTS-MAC=00:XX:XX:XX:XX:00;CM-QOS=1.1;CM-VER=3.1;&lt;/p&gt;
    &lt;p&gt;04:00:39&lt;/p&gt;
    &lt;p&gt;Sat Nov 22 2025 Critical (3) UCD invalid or channel unusable;CM-MAC=00:XX:XX:XX:XX:ac;CMTS-MAC=00:XX:XX:XX:XX:00;CM-QOS=1.1;CM-VER=3.1;&lt;/p&gt;
    &lt;p&gt;Time Not Established&lt;/p&gt;
    &lt;p&gt;Critical (3) SYNC Timing Synchronization failure – Failed to acquire QAM/QPSK symbol timing;;CM-MAC=00:XX:XX:XX:XX:ac;CMTS-MAC=00:00:00:00:00:00;CM-QOS=1.1;CM-VER=3.1;&lt;/p&gt;
    &lt;p&gt;Time Not Established&lt;/p&gt;
    &lt;p&gt;Critical (3) UCD invalid or channel unusable;CM-MAC=00:XX:XX:XX:XX:ac;CMTS-MAC=00:XX:XX:XX:XX:00;CM-QOS=1.1;CM-VER=3.1;&lt;/p&gt;
    &lt;p&gt;11:00:30&lt;/p&gt;
    &lt;p&gt;Sat Nov 22 2025 Critical (3) UCD invalid or channel unusable;CM-MAC=00:XX:XX:XX:XX:ac;CMTS-MAC=00:XX:XX:XX:XX:00;CM-QOS=1.1;CM-VER=3.1;&lt;/p&gt;
    &lt;p&gt;11:00:30&lt;/p&gt;
    &lt;p&gt;Sat Nov 22 2025 Critical (3) Started Unicast Maintenance Ranging – No Response received – T3 time-out;CM-MAC=00:XX:XX:XX:XX:ac;CMTS-MAC=00:XX:XX:XX:XX:00;CM-QOS=1.1;CM-VER=3.1;&lt;/p&gt;
    &lt;p&gt;11:00:35&lt;/p&gt;
    &lt;p&gt;Sat Nov 22 2025 Critical (3) UCD invalid or channel unusable;CM-MAC=00:XX:XX:XX:XX:ac;CMTS-MAC=00:XX:XX:XX:XX:00;CM-QOS=1.1;CM-VER=3.1;&lt;/p&gt;
    &lt;p&gt;Time Not Established&lt;/p&gt;
    &lt;p&gt;Critical (3) SYNC Timing Synchronization failure – Failed to acquire QAM/QPSK symbol timing;;CM-MAC=00:XX:XX:XX:XX:ac;CMTS-MAC=00:00:00:00:00:00;CM-QOS=1.1;CM-VER=3.1;&lt;/p&gt;
    &lt;p&gt;Time Not Established&lt;/p&gt;
    &lt;p&gt;Critical (3) UCD invalid or channel unusable;CM-MAC=00:XX:XX:XX:XX:ac;CMTS-MAC=00:XX:XX:XX:XX:00;CM-QOS=1.1;CM-VER=3.1;&lt;/p&gt;
    &lt;p&gt;11:45:35&lt;/p&gt;
    &lt;p&gt;Sat Nov 22 2025 Critical (3) UCD invalid or channel unusable;CM-MAC=00:XX:XX:XX:XX:ac;CMTS-MAC=00:XX:XX:XX:XX:00;CM-QOS=1.1;CM-VER=3.1;&lt;/p&gt;
    &lt;p&gt;Time Not Established&lt;/p&gt;
    &lt;p&gt;Critical (3) SYNC Timing Synchronization failure – Failed to acquire QAM/QPSK symbol timing;;CM-MAC=00:XX:XX:XX:XX:ac;CMTS-MAC=00:00:00:00:00:00;CM-QOS=1.1;CM-VER=3.1;&lt;/p&gt;
    &lt;p&gt;Time Not Established&lt;/p&gt;
    &lt;p&gt;Critical (3) UCD invalid or channel unusable;CM-MAC=00:XX:XX:XX:XX:ac;CMTS-MAC=00:XX:XX:XX:XX:00;CM-QOS=1.1;CM-VER=3.1;&lt;/p&gt;
    &lt;p&gt;13:15:31&lt;/p&gt;
    &lt;p&gt;Sat Nov 22 2025 Critical (3) UCD invalid or channel unusable;CM-MAC=00:XX:XX:XX:XX:ac;CMTS-MAC=00:XX:XX:XX:XX:00;CM-QOS=1.1;CM-VER=3.1;&lt;/p&gt;
    &lt;p&gt;Time Not Established&lt;/p&gt;
    &lt;p&gt;Critical (3) SYNC Timing Synchronization failure – Failed to acquire QAM/QPSK symbol timing;;CM-MAC=00:XX:XX:XX:XX:ac;CMTS-MAC=00:00:00:00:00:00;CM-QOS=1.1;CM-VER=3.1;&lt;/p&gt;
    &lt;p&gt;Time Not Established&lt;/p&gt;
    &lt;p&gt;Critical (3) UCD invalid or channel unusable;CM-MAC=00:XX:XX:XX:XX:ac;CMTS-MAC=00:XX:XX:XX:XX:00;CM-QOS=1.1;CM-VER=3.1;&lt;/p&gt;
    &lt;p&gt;Time Not Established&lt;/p&gt;
    &lt;p&gt;Notice (6) Honoring MDD; IP provisioning mode = IPv6&lt;/p&gt;
    &lt;p&gt;18:15:32&lt;/p&gt;
    &lt;p&gt;Sat Nov 22 2025 Notice (6) DS profile assignment change. DS Chan ID: 32; Previous Profile: ; New Profile: 1 2 3.;CM-MAC=00:XX:XX:XX:XX:ac;CMTS-MAC=00:XX:XX:XX:XX:00;CM-QOS=1.1;CM-VER=3.1;&lt;/p&gt;
    &lt;p&gt;18:15:39&lt;/p&gt;
    &lt;p&gt;Sat Nov 22 2025 Critical (3) UCD invalid or channel unusable;CM-MAC=00:XX:XX:XX:XX:ac;CMTS-MAC=00:XX:XX:XX:XX:00;CM-QOS=1.1;CM-VER=3.1;&lt;/p&gt;
    &lt;head rend="h2"&gt;My Attempts to Fix It&lt;/head&gt;
    &lt;p&gt;I called support. Multiple times. They blamed my WiFi (I’m hardwired). They blamed my modem (an Xfinity Approved MB8611 that worked without fault on Wave Broadband and Spectrum). They blamed my router (I tested with multiple devices). They sent a subcontracted technician. Then another subcontracted technician. Then a subcontracted crew. The crew ran a new coax line and grounded it to a water pipe that turns into PVC when it enters the ground (this doesn’t ground anything). Then they sent an Xfinity technician to look at the line.&lt;/p&gt;
    &lt;p&gt;The problem never changed. The only thing that changed is my download speed dropped from advertised 1200Mbps to &amp;lt;500Mbps.&lt;/p&gt;
    &lt;p&gt;I escalated to retention. They offered me nothing. I provided detailed technical documentation showing the exact pattern of the outages, the minute markers they occur at, the exact duration every single time. They didn’t understand it. They couldn’t escalate it.&lt;/p&gt;
    &lt;p&gt;I was transferred to technical support. The person did not care and put me on speaker phone with so much background noise I couldn’t hear myself think. I imagine he was rolling his eyes while trying his utmost to care less.&lt;/p&gt;
    &lt;head rend="h2"&gt;My Neighbor’s Attempts to Fix It&lt;/head&gt;
    &lt;p&gt;He called Xfinity about his TV cutting out repeatedly. The technician told him his UPS grounding his coax cable was causing the problem. So he ungrounded the cable, pocketed the spare cable, and my neighbor kept having the same issues.&lt;/p&gt;
    &lt;head rend="h2"&gt;What I Found&lt;/head&gt;
    &lt;p&gt;Just in the last 72 hours I have documented 20 consecutive outages using OPNSense’s built in gateway uptime monitor. Here’s what they show:&lt;/p&gt;
    &lt;p&gt;Every single outage lasted 124.8 ± 1.3 seconds. That’s not random hardware failure. That’s a timeout value hardcoded into something in Xfinity’s infrastructure.&lt;/p&gt;
    &lt;p&gt;The outages cluster at specific minute markers. 35% start at minute :44. 35% start at minute :29. This is scheduled automation. This is likely a cron job or automated task running at those exact times every hour.&lt;/p&gt;
    &lt;p&gt;The outages peak at specific hours. Most happen between noon and 1 PM. Others cluster in early morning around 2-3 AM. This is not random.&lt;/p&gt;
    &lt;p&gt;This is an infrastructure problem on Xfinity’s network. Not on my end. Not on my neighbor’s end. Upstream. Somewhere on their equipment something is failing for exactly 125 seconds multiple times per day.&lt;/p&gt;
    &lt;p&gt;I have the data. I have the patterns. I have another customer (my neighbor) on a different line experiencing the exact same thing.&lt;/p&gt;
    &lt;p&gt;Xfinity has all this information. They know about the problem. They just won’t investigate it.&lt;/p&gt;
    &lt;head rend="h2"&gt;Why They Won’t Fix It&lt;/head&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Support can’t understand technical data. They follow scripts. When I attempted to explain monitoring logs they had no framework for discussing it. They blamed my equipment because that’s what they’re trained to do.&lt;/item&gt;
      &lt;item&gt;Nobody has authority to escalate. Retention transferred me to tech support. Tech support couldn’t care nor help. They dug up my yard and placed a new line which did nothing to solve the problem. Nobody would actually order an investigation into the upstream infrastructure.&lt;/item&gt;
      &lt;item&gt;There’s no pressure to fix it. Xfinity is the only gigabit provider in this area. No competition. No alternatives. I can’t leave. So they don’t have to care.&lt;/item&gt;
      &lt;item&gt;A 2-minute outage every few hours is “tolerable.” It’s annoying enough to frustrate customers but not enough to make them quit (since they have nowhere else to go). It’s cheap to ignore compared to actually investigating and fixing it.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;There’s Also a Security Problem&lt;/p&gt;
    &lt;p&gt;About half of the Xfinity junction boxes in my neighborhood are unlocked or broken. Anyone can walk up and disconnect whomever they want.&lt;/p&gt;
    &lt;p&gt;If your home security system is on Xfinity with no wireless backup, someone can just walk to the street and physically disconnect your internet, rob your house, and your security system won’t notify you.&lt;/p&gt;
    &lt;head rend="h2"&gt;I’m Out of Options&lt;/head&gt;
    &lt;p&gt;I’ve done everything I can do as a customer:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Documented the problem professionally&lt;/item&gt;
      &lt;item&gt;Escalated through all available channels&lt;/item&gt;
      &lt;item&gt;Provided technical evidence&lt;/item&gt;
      &lt;item&gt;Been ignored at every level&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The problem is real. My neighbor confirms it. Everyone downstream of whatever is broken on their infrastructure probably has it too.&lt;/p&gt;
    &lt;p&gt;I can’t fix this. Only Xfinity can. And they won’t.&lt;/p&gt;
    &lt;p&gt;So I’m publishing this hoping someone with actual authority, perhaps someone at a regulatory agency, someone at a news outlet, someone who has power over Xfinity sees this and decides to actually investigate.&lt;/p&gt;
    &lt;p&gt;Because I’m out of options. My neighbors are out of options. And Xfinity’s counting on us staying out of options. Because this is the reality of my neighborhood (source):&lt;/p&gt;
    &lt;p&gt;If you’re in Sacramento County and have Xfinity internet, check two things:&lt;/p&gt;
    &lt;p&gt;1. Walk to your junction box. Is it locked? If not, you have a physical security problem.&lt;/p&gt;
    &lt;p&gt;2. Look at where your cable grounds. Does it go to your electrical panel? Or to a water pipe? If it’s a water pipe or PVC, that’s wrong.&lt;/p&gt;
    &lt;p&gt;3. Have you noticed your connection drop briefly multiple times a day? Same times of day? If you see a pattern, document it. You might have the same problem.&lt;/p&gt;
    &lt;p&gt;If you want to report this:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;FCC: https://consumercomplaints.fcc.gov/&lt;/item&gt;
      &lt;item&gt;California PUC: https://www.cpuc.ca.gov/&lt;/item&gt;
    &lt;/list&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://sacbear.com/xfinity-wont-fix-internet/"/><published>2025-11-23T00:46:53+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=46019817</id><title>Meta buried 'causal' evidence of social media harm, US court filings allege</title><updated>2025-11-23T08:13:03.210431+00:00</updated><content>&lt;doc fingerprint="3cb290da3823dec9"&gt;
  &lt;main&gt;
    &lt;p&gt;Nov 22 (Reuters) - Meta shut down internal research into the mental health effects of Facebook and Instagram after finding causal evidence that its products harmed users’ mental health, according to unredacted filings in a class action by U.S. school districts against Meta and other social media platforms.&lt;/p&gt;
    &lt;p&gt;In a 2020 research project code-named “Project Mercury,” Meta (META.O) scientists worked with survey firm Nielsen to gauge the effect of “deactivating” Facebook and Instagram, according to Meta documents obtained via discovery. To the company’s disappointment, “people who stopped using Facebook for a week reported lower feelings of depression, anxiety, loneliness and social comparison,” internal documents said.&lt;/p&gt;
    &lt;p&gt;Sign up here.&lt;/p&gt;
    &lt;p&gt;Rather than publishing those findings or pursuing additional research, the filing states, Meta called off further work and internally declared that the negative study findings were tainted by the “existing media narrative” around the company.&lt;/p&gt;
    &lt;p&gt;Privately, however, staff assured Nick Clegg, Meta’s then-head of global public policy, that the conclusions of the research were valid.&lt;/p&gt;
    &lt;p&gt;“The Nielsen study does show causal impact on social comparison,” (unhappy face emoji), an unnamed staff researcher allegedly wrote. Another staffer worried that keeping quiet about negative findings would be akin to the tobacco industry “doing research and knowing cigs were bad and then keeping that info to themselves.”&lt;/p&gt;
    &lt;p&gt;Despite Meta’s own work documenting a causal link between its products and negative mental health effects, the filing alleges, Meta told Congress that it had no ability to quantify whether its products were harmful to teenage girls.&lt;/p&gt;
    &lt;p&gt;In a statement Saturday, Meta spokesman Andy Stone said the study was stopped because its methodology was flawed and that it worked diligently to improve the safety of its products.&lt;/p&gt;
    &lt;p&gt;“The full record will show that for over a decade, we have listened to parents, researched issues that matter most, and made real changes to protect teens,” he said.&lt;/p&gt;
    &lt;head rend="h2"&gt;PLAINTIFFS ALLEGE PRODUCT RISKS WERE HIDDEN&lt;/head&gt;
    &lt;p&gt;The allegation of Meta burying evidence of social media harms is just one of many in a late Friday filing by Motley Rice, a law firm suing Meta, Google (GOOGL.O), TikTok and Snapchat (SNAP.N) on behalf of school districts around the country. Broadly, the plaintiffs argue the companies have intentionally hidden the internally recognized risks of their products from users, parents and teachers.&lt;/p&gt;
    &lt;p&gt;TikTok, Google and Snapchat did not immediately respond to a request for comment.&lt;/p&gt;
    &lt;p&gt;Allegations against Meta and its rivals include tacitly encouraging children below the age of 13 to use their platforms, failing to address child sexual abuse content and seeking to expand the use of social media products by teenagers while they were at school. The plaintiffs also allege that the platforms attempted to pay child-focused organizations to defend the safety of their products in public.&lt;/p&gt;
    &lt;p&gt;In one instance, TikTok sponsored the National PTA and then internally boasted about its ability to influence the child-focused organization. Per the filing, TikTok officials said the PTA would “do whatever we want going forward in the fall… (t)hey’ll announce things publicly(,), (t)heir CEO will do press statements for us.”&lt;/p&gt;
    &lt;p&gt;By and large, however, the allegations against the other social media platforms are less detailed than those against Meta. The internal documents cited by the plaintiffs allege:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Meta intentionally designed its youth safety features to be ineffective and rarely used, and blocked testing of safety features that it feared might be harmful to growth.&lt;/item&gt;
      &lt;item&gt;Meta required users to be caught 17 times attempting to traffic people for sex before it would remove them from its platform, which a document described as “a very, very, very high strike threshold."&lt;/item&gt;
      &lt;item&gt;Meta recognized that optimizing its products to increase teen engagement resulted in serving them more harmful content, but did so anyway.&lt;/item&gt;
      &lt;item&gt;Meta stalled internal efforts to prevent child predators from contacting minors for years due to growth concerns, and pressured safety staff to circulate arguments justifying its decision not to act.&lt;/item&gt;
      &lt;item&gt;In a text message in 2021, Mark Zuckerberg said that he wouldn’t say that child safety was his top concern “when I have a number of other areas I’m more focused on like building the metaverse.” Zuckerberg also shot down or ignored requests by Clegg to better fund child safety work.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Meta’s Stone disputed these allegations, saying the company’s teen safety measures are effective and that the company’s current policy is to remove accounts as soon as they are flagged for sex trafficking.&lt;/p&gt;
    &lt;p&gt;He said the suit misrepresents its efforts to build safety features for teens and parents, and called its safety work “broadly effective.”&lt;/p&gt;
    &lt;p&gt;"We strongly disagree with these allegations, which rely on cherry-picked quotes and misinformed opinions,” Stone said.&lt;/p&gt;
    &lt;p&gt;The underlying Meta documents cited in the filing are not public, and Meta has filed a motion to strike the documents. Stone said the objection was to the over-broad nature of what plaintiffs are seeking to unseal, not unsealing in its entirety.&lt;/p&gt;
    &lt;p&gt;A hearing regarding the filing is set for January 26 in Northern California District Court.&lt;/p&gt;
    &lt;p&gt;Reporting by Jeff Horwitz in San Francisco; Editing by Nick Zieminski and David Gregorio&lt;/p&gt;
    &lt;p&gt;Our Standards: The Thomson Reuters Trust Principles.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://www.reuters.com/sustainability/boards-policy-regulation/meta-buried-causal-evidence-social-media-harm-us-court-filings-allege-2025-11-23/"/><published>2025-11-23T01:09:47+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=46020096</id><title>An Economy of AI Agents</title><updated>2025-11-23T08:13:02.962519+00:00</updated><content>&lt;doc fingerprint="8c9c2e0accd3808d"&gt;
  &lt;main&gt;&lt;head rend="h1"&gt;Economics &amp;gt; General Economics&lt;/head&gt;&lt;p&gt; [Submitted on 1 Sep 2025]&lt;/p&gt;&lt;head rend="h1"&gt;Title:An Economy of AI Agents&lt;/head&gt;View PDF HTML (experimental)&lt;quote&gt;Abstract:In the coming decade, artificially intelligent agents with the ability to plan and execute complex tasks over long time horizons with little direct oversight from humans may be deployed across the economy. This chapter surveys recent developments and highlights open questions for economists around how AI agents might interact with humans and with each other, shape markets and organizations, and what institutions might be required for well-functioning markets.&lt;/quote&gt;&lt;p&gt; Current browse context: &lt;/p&gt;&lt;p&gt;econ.GN&lt;/p&gt;&lt;head rend="h3"&gt;References &amp;amp; Citations&lt;/head&gt;&lt;p&gt; export BibTeX citation Loading... &lt;/p&gt;&lt;head rend="h1"&gt;Bibliographic and Citation Tools&lt;/head&gt;&lt;p&gt; Bibliographic Explorer (What is the Explorer?) &lt;/p&gt;&lt;p&gt; Connected Papers (What is Connected Papers?) &lt;/p&gt;&lt;p&gt; Litmaps (What is Litmaps?) &lt;/p&gt;&lt;p&gt; scite Smart Citations (What are Smart Citations?) &lt;/p&gt;&lt;head rend="h1"&gt;Code, Data and Media Associated with this Article&lt;/head&gt;&lt;p&gt; alphaXiv (What is alphaXiv?) &lt;/p&gt;&lt;p&gt; CatalyzeX Code Finder for Papers (What is CatalyzeX?) &lt;/p&gt;&lt;p&gt; DagsHub (What is DagsHub?) &lt;/p&gt;&lt;p&gt; Gotit.pub (What is GotitPub?) &lt;/p&gt;&lt;p&gt; Hugging Face (What is Huggingface?) &lt;/p&gt;&lt;p&gt; Papers with Code (What is Papers with Code?) &lt;/p&gt;&lt;p&gt; ScienceCast (What is ScienceCast?) &lt;/p&gt;&lt;head rend="h1"&gt;Demos&lt;/head&gt;&lt;head rend="h1"&gt;Recommenders and Search Tools&lt;/head&gt;&lt;p&gt; Influence Flower (What are Influence Flowers?) &lt;/p&gt;&lt;p&gt; CORE Recommender (What is CORE?) &lt;/p&gt;&lt;head rend="h1"&gt;arXivLabs: experimental projects with community collaborators&lt;/head&gt;&lt;p&gt;arXivLabs is a framework that allows collaborators to develop and share new arXiv features directly on our website.&lt;/p&gt;&lt;p&gt;Both individuals and organizations that work with arXivLabs have embraced and accepted our values of openness, community, excellence, and user data privacy. arXiv is committed to these values and only works with partners that adhere to them.&lt;/p&gt;&lt;p&gt;Have an idea for a project that will add value for arXiv's community? Learn more about arXivLabs.&lt;/p&gt;&lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://arxiv.org/abs/2509.01063"/><published>2025-11-23T02:08:00+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=46020151</id><title>GCC SC approves inclusion of Algol 68 Front End</title><updated>2025-11-23T08:13:02.525866+00:00</updated><content>&lt;doc fingerprint="de8b4576095db9f5"&gt;
  &lt;main&gt;&lt;head rend="h1"&gt;Algol 68 Front End&lt;/head&gt; David Edelsohn dje.gcc@gmail.com &lt;lb/&gt;Sat Nov 22 20:38:25 GMT 2025&lt;quote&gt;The GCC Steering Committee has agreed to include the Algol 68 Front End in trunk designated as experimental with stipulations: 1. Algol 68 is not part of all languages built by default. 2. Algol 68 is not part of the GCC release criteria. 3. All GCC developers who are not responsible for the Algol 68 Front End may decline to work on issues related to the Algol 68 Front End. 4. If the Algol 68 Front End bit rots or is not maintained, it will be removed. To permit Algol 68 development to continue, Jose E. Marchesi is appointed as Algol 68 front end maintainer. If maintaining a Front End outside of trunk is difficult, the Algol 68 developers are invited to propose concrete changes to make it easier to maintain front ends in a branch of the GCC repository outside of trunk. Happy Hacking! David &lt;/quote&gt;&lt;lb/&gt;More information about the Gcc
mailing list&lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://gcc.gnu.org/pipermail/gcc/2025-November/247020.html"/><published>2025-11-23T02:18:03+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=46020543</id><title>Unusual circuits in the Intel 386's standard cell logic</title><updated>2025-11-23T08:13:02.244597+00:00</updated><content>&lt;doc fingerprint="771d431011a60802"&gt;
  &lt;main&gt;
    &lt;p&gt;I've been studying the standard cell circuitry in the Intel 386 processor recently. The 386, introduced in 1985, was Intel's most complex processor at the time, containing 285,000 transistors. Intel's existing design techniques couldn't handle this complexity and the chip began to fall behind schedule. To meet the schedule, the 386 team started using a technique called standard cell logic. Instead of laying out each transistor manually, the layout process was performed by a computer.&lt;/p&gt;
    &lt;p&gt;The idea behind standard cell logic is to create standardized circuits (standard cells) for each type of logic element, such as an inverter, NAND gate, or latch. You feed your circuit description into software that selects the necessary cells, positions these cells into columns, and then routes the wiring between the cells. This "automatic place and route" process creates the chip layout much faster than manual layout. However, switching to standard cells was a risky decision since if the software couldn't create a dense enough layout, the chip couldn't be manufactured. But in the end, the 386 finished ahead of schedule, an almost unheard-of accomplishment.1&lt;/p&gt;
    &lt;p&gt;The 386's standard cell circuitry contains a few circuits that I didn't expect. In this blog post, I'll take a quick look at some of these circuits: surprisingly large multiplexers, a transistor that doesn't fit into the standard cell layout, and inverters that turned out not to be inverters. (If you want more background on standard cells in the 386, see my earlier post, "Reverse engineering standard cell logic in the Intel 386 processor".)&lt;/p&gt;
    &lt;p&gt;The photo below shows the 386 die with the automatic-place-and-route regions highlighted; I'm focusing on the red region in the lower right. These blocks of logic have cells arranged in rows, giving them a characteristic striped appearance. The dark stripes are the transistors that make up the logic gates, while the lighter regions between the stripes are the "routing channels" that hold the wiring that connects the cells. In comparison, functional blocks such as the datapath on the left and the microcode ROM in the lower right were designed manually to optimize density and performance, giving them a more solid appearance.&lt;/p&gt;
    &lt;p&gt;As for other features on the chip, the black circles around the border are bond wire connections that go to the chip's external pins. The chip has two metal layers, a small number by modern standards, but a jump from the single metal layer of earlier processors such as the 286. (Providing two layers of metal made automated routing practical: one layer can hold horizontal wires while the other layer can hold vertical wires.) The metal appears white in larger areas, but purplish where circuitry underneath roughens its surface. The underlying silicon and the polysilicon wiring are obscured by the metal layers.&lt;/p&gt;
    &lt;head rend="h2"&gt;The giant multiplexers&lt;/head&gt;
    &lt;p&gt;The standard cell circuitry that I'm examining (red box above) is part of the control logic that selects registers while executing an instruction. You might think that it is easy to select which registers take part in an instruction, but due to the complexity of the x86 architecture, it is more difficult. One problem is that a 32-bit register such as EAX can also be treated as the 16-bit register AX, or two 8-bit registers AH and AL. A second problem is that some instructions include a "direction" bit that switches the source and destination registers. Moreover, sometimes the register is specified by bits in the instruction, but in other cases, the register is specified by the microcode. Due to these factors, selecting the registers for an operation is a complicated process with many cases, using control bits from the instruction, from the microcode, and from other sources.&lt;/p&gt;
    &lt;p&gt;Three registers need to be selected for an operation—two source registers and a destination register—and there are about 17 cases that need to be handled. Registers are specified with 7-bit control signals that select one of the 30 registers and control which part of the register is accessed. With three control signals, each 7 bits wide, and about 17 cases for each, you can see that the register control logic is large and complicated. (I wrote more about the 386's registers here.)&lt;/p&gt;
    &lt;p&gt;I'm still reverse engineering the register control logic, so I won't go into details. Instead, I'll discuss how the register control circuit uses multiplexers, implemented with standard cells. A multiplexer is a circuit that combines multiple input signals into a single output by selecting one of the inputs.2 A multiplexer can be implemented with logic gates, for instance, by ANDing each input with the corresponding control line, and then ORing the results together. However, the 386 uses a different approach—CMOS switches—that avoids a large AND/OR gate.&lt;/p&gt;
    &lt;p&gt;The schematic above shows how a CMOS switch is constructed from two MOS transistors. When the two transistors are on, the output is connected to the input, but when the two transistors are off, the output is isolated. An NMOS transistor is turned on when its input is high, but a PMOS transistor is turned on when its input is low. Thus, the switch uses two control inputs, one inverted. The motivation for using two transistors is that an NMOS transistor is better at pulling the output low, while a PMOS transistor is better at pulling the output high, so combining them yields the best performance.3 Unlike a logic gate, the CMOS switch has no amplification, so a signal is weakened as it passes through the switch. As will be seen below, inverters can be used to amplify the signal.&lt;/p&gt;
    &lt;p&gt;The image below shows how CMOS switches appear under the microscope. This image is very hard to interpret because the two layers of metal on the 386 are packed together densely, but you can see that some wires run horizontally and others run vertically. The bottom layer of metal (called M1) runs vertically in the routing area, as well as providing internal wiring for a cell. The top layer of metal (M2) runs horizontally; unlike M1, the M2 wires can cross a cell. The large circles are vias that connect the M1 and M2 layers, while the small circles are connections between M1 and polysilicon or M1 and silicon. The central third of the image is a column of standard cells with two CMOS switches outlined in green. The cells are bordered by the vertical ground rail and +5V rail that power the cells. The routing areas are on either side of the cells, holding the wiring that connects the cells.&lt;/p&gt;
    &lt;p&gt;Removing the metal layers reveals the underlying silicon with a layer of polysilicon wiring on top. The doped silicon regions show up as dark outlines. I've drawn the polysilicon in green; it forms a transistor (brighter green) when it crosses doped silicon. The metal ground and power lines are shown in blue and red, respectively, with other metal wiring in purple. The black dots are vias between layers. Note how metal wiring (purple) and polysilicon wiring (green) are combined to route signals within the cell. Although this standard cell is complicated, the important thing is that it only needs to be designed once. The standard cells for different functions are all designed to have the same width, so the cells can be arranged in columns, snapped together like Lego bricks.&lt;/p&gt;
    &lt;p&gt;To summarize, this switch circuit allows the input to be connected to the output or disconnected, controlled by the select signal. This switch is more complicated than the earlier schematic because it includes two inverters to amplify the signal. The data input and the two select lines are connected to the polysilicon (green); the cell is designed so these connections can be made on either side. At the top, the input goes through a standard two-transistor inverter. The lower left has two transistors, combining the NMOS half of an inverter with the NMOS half of the switch. A similar circuit on the right combines the PMOS part of an inverter and switch. However, because PMOS transistors are weaker, this part of the circuit is duplicated.&lt;/p&gt;
    &lt;p&gt;A multiplexer is constructed by combining multiple switches, one for each input. Turning on one switch will select the corresponding input. For instance, a four-to-one multiplexer has four switches, so it can select one of the four inputs.&lt;/p&gt;
    &lt;p&gt;The schematic above shows a hypothetical multiplexer with four inputs. One optimization is that if an input is always 0, the PMOS transistor can be omitted. Likewise, if an input is always 1, the NMOS transistor can be omitted. One set of select lines is activated at a time to select the corresponding input. The pink circuit selects 1, green selects input A, yellow selects input B, and blue selects 0. The multiplexers in the 386 are similar, but have more inputs.&lt;/p&gt;
    &lt;p&gt;The diagram below shows how much circuitry is devoted to multiplexers in this block of standard cells. The green, purple, and red cells correspond to the multiplexers driving the three register control outputs. The yellow cells are inverters that generate the inverted control signals for the CMOS switches. This diagram also shows how the automatic layout of cells results in a layout that appears random.&lt;/p&gt;
    &lt;head rend="h2"&gt;The misplaced transistor&lt;/head&gt;
    &lt;p&gt;The idea of standard-cell logic is that standardized cells are arranged in columns. The space between the cells is the "routing channel", holding the wiring that links the cells. The 386 circuitry follows this layout, except for one single transistor, sitting between two columns of cells.&lt;/p&gt;
    &lt;p&gt;I wrote some software tools to help me analyze the standard cells. Unfortunately, my tools assumed that all the cells were in columns, so this one wayward transistor caused me considerable inconvenience.&lt;/p&gt;
    &lt;p&gt;The transistor turns out to be a PMOS transistor, pulling a signal high as part of a multiplexer. But why is this transistor out of place? My hypothesis is that the transistor is a bug fix. Regenerating the cell layout was very costly, taking many hours on an IBM mainframe computer. Presumably, someone found that they could just stick the necessary transistor into an unused spot in the routing channel, manually add the necessary wiring, and avoid the delay of regenerating all the cells.&lt;/p&gt;
    &lt;head rend="h2"&gt;The fake inverter&lt;/head&gt;
    &lt;p&gt;The simplest CMOS gate is the inverter, with an NMOS transistor to pull the output low and a PMOS transistor to pull the output high. The standard cell circuitry that I examined contains over a hundred inverters of various sizes. (Performance is improved by using inverters that aren't too small but also aren't larger than necessary for a particular circuit. Thus, the standard cell library includes inverters of multiple sizes.)&lt;/p&gt;
    &lt;p&gt;The image below shows a medium-sized standard-cell inverter under the microscope. For this image, I removed the two metal layers with acid to show the underlying polysilicon (bright green) and silicon (gray). The quality of this image is poor—it is difficult to remove the metal without destroying the polysilicon—but the diagram below should clarify the circuit. The inverter has two transistors: a PMOS transistor connected to +5 volts to pull the output high when the input is 0, and an NMOS transistor connected to ground to pull the output low when the input is 1. (The PMOS transistor needs to be larger because PMOS transistors don't function as well as NMOS transistors due to silicon physics.)&lt;/p&gt;
    &lt;p&gt;The polysilicon input line plays a key role: where it crosses the doped silicon, a transistor gate is formed. To make the standard cell more flexible, the input to the inverter can be connected on either the left or the right; in this case, the input is connected on the right and there is no connection on the left. The inverter's output can be taken from the polysilicon on the upper left or the right, but in this case, it is taken from the upper metal layer (not shown). The power, ground, and output lines are in the lower metal layer, which I have represented by the thin red, blue, and yellow lines. The black circles are connections between the metal layer and the underlying silicon.&lt;/p&gt;
    &lt;p&gt;This inverter appears dozens of times in the circuitry. However, I came across a few inverters that didn't make sense. The problem was that the inverter's output was connected to the output of a multiplexer. Since an inverter is either on or off, its value would clobber the output of the multiplexer.4 This didn't make any sense. I double- and triple-checked the wiring to make sure I hadn't messed up. After more investigation, I found another problem: the input to a "bad" inverter didn't make sense either. The input consisted of two signals shorted together, which doesn't work.&lt;/p&gt;
    &lt;p&gt;Finally, I realized what was going on. A "bad inverter" has the exact silicon layout of an inverter, but it wasn't an inverter: it was independent NMOS and PMOS transistors with separate inputs. Now it all made sense. With two inputs, the input signals were independent, not shorted together. And since the transistors were controlled separately, the NMOS transistor could pull the output low in some circumstances, the PMOS transistor could pull the output high in other circumstances, or both transistors could be off, allowing the multiplexer's output to be used undisturbed. In other words, the "inverter" was just two more cases for the multiplexer.&lt;/p&gt;
    &lt;p&gt;If you compare the "bad inverter" cell below with the previous cell, they look almost the same, but there are subtle differences. First, the gates of the two transistors are connected in the real inverter, but disconnected by a small gap in the transistor pair. I've indicated this gap in the photo above; it is hard to tell if the gap is real or just an imaging artifact, so I didn't spot it. The second difference is that the "fake" inverter has two input connections, one to each transistor, while the inverter has a single input connection. Unfortunately, I assumed that the two connections were just a trick to route the signal across the inverter without requiring an extra wire. In total, this cell was used 32 times as a real inverter and 9 times as independent transistors.&lt;/p&gt;
    &lt;head rend="h2"&gt;Conclusions&lt;/head&gt;
    &lt;p&gt;Standard cell logic and automatic place and route have a long history before the 386, back to the early 1970s, so this isn't an Intel invention.5 Nonetheless, the 386 team deserves the credit for deciding to use this technology at a time when it was a risky decision. They needed to develop custom software for their placing and routing needs, so this wasn't a trivial undertaking. This choice paid off and they completed the 386 ahead of schedule. The 386 ended up being a huge success for Intel, moving the x86 architecture to 32 bits and defining the dominant computer architecture for the rest of the 20th century.&lt;/p&gt;
    &lt;p&gt;If you're interested in standard cell logic, I also wrote about standard cell logic in an IBM chip. I plan to write more about the 386, so follow me on Mastodon, Bluesky, or RSS for updates. Thanks to Pat Gelsinger and Roxanne Koester for providing helpful papers.&lt;/p&gt;
    &lt;p&gt;For more on the 386 and other chips, follow me on Mastodon (@[email protected]), Bluesky (@righto.com), or RSS. (I've given up on Twitter.) If you want to read more about the 386, I've written about the clock pin, prefetch queue, die versions, packaging, and I/O circuits.&lt;/p&gt;
    &lt;head rend="h2"&gt;Notes and references&lt;/head&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;
        &lt;p&gt;The decision to use automatic place and route is described on page 13 of the Intel 386 Microprocessor Design and Development Oral History Panel, a very interesting document on the 386 with discussion from some of the people involved in its development. ↩&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Multiplexers often take a binary control signal to select the desired input. For instance, an 8-to-1 multiplexer selects one of 8 inputs, so a 3-bit control signal can specify the desired input. The 386's multiplexers use a different approach with one control signal per input. One of the 8 control signals is activated to select the desired input. This approach is called a "one-hot encoding" since one control line is activated (hot) at a time. ↩&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Some chips, such as the MOS Technology 6502 processor, are built with NMOS technology, without PMOS transistors. Multiplexers in the 6502 use a single NMOS transistor, rather than the two transistors in the CMOS switch. However, the performance of the switch is worse. ↩&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;One very common circuit in the 386 is a latch constructed from an inverter loop and a switch/multiplexer. The inverter's output and the switch's output are connected together. The trick, however, is that the inverter is constructed from special weak transistors. When the switch is disabled, the inverter's weak output is sufficient to drive the loop. But to write a value into the latch, the switch is enabled and its output overpowers the weak inverter.&lt;/p&gt;
        &lt;p&gt;The point of this is that there are circuits where an inverter and a multiplexer have their outputs connected. However, the inverter must be constructed with special weak transistors, which is not the situation that I'm discussing. ↩&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;I'll provide more history on standard cells in this footnote. RCA patented a bipolar standard cell in 1971, but this was a fixed arrangement of transistors and resistors, more of a gate array than a modern standard cell. Bell Labs researched standard cell layout techniques in the early 1970s, calling them Polycells, including a 1973 paper by Brian Kernighan. By 1979, A Guide to LSI Implementation discussed the standard cell approach and it was described as well-known in this patent application. Even so, Electronics called these design methods "futuristic" in 1980.&lt;/p&gt;
        &lt;p&gt;Standard cells became popular in the mid-1980s as faster computers and improved design software made it practical to produce semi-custom designs that used standard cells. Standard cells made it to the cover of Digital Design in August 1985, and the article inside described numerous vendors and products. Companies like Zymos and VLSI Technology (VTI) focused on standard cells. Traditional companies such as Texas Instruments, NCR, GE/RCA, Fairchild, Harris, ITT, and Thomson introduced lines of standard cell products in the mid-1980s. ↩&lt;/p&gt;
      &lt;/item&gt;
    &lt;/list&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://www.righto.com/2025/11/unusual-386-standard-cell-circuits.html"/><published>2025-11-23T03:33:42+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=46020596</id><title>A cryptography research body held an election and they can't decrypt the results</title><updated>2025-11-23T08:13:02.027510+00:00</updated><content/><link href="https://www.nytimes.com/2025/11/21/world/cryptography-group-lost-election-results.html"/><published>2025-11-23T03:47:17+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=46021179</id><title>Google Revisits JPEG XL in Chromium After Earlier Removal</title><updated>2025-11-23T08:13:01.872471+00:00</updated><content>&lt;doc fingerprint="74d2b5f131b651ba"&gt;
  &lt;main&gt;
    &lt;head rend="h1"&gt;Google Revisits JPEG XL in Chromium After Earlier Removal&lt;/head&gt;
    &lt;p&gt;Google has resumed work on JPEG XL in Chromium, but there is no timeline for Chrome release&lt;/p&gt;
    &lt;p&gt;Three years ago, Google removed JPEG XL support from Chrome, stating there wasn’t enough interest at the time. That position has now changed.&lt;/p&gt;
    &lt;p&gt;In a recent note to developers, a Chrome team representative confirmed that work has restarted to bring JPEG XL to Chromium and said Google “would ship it in Chrome” once long-term maintenance and the usual launch requirements are met.&lt;/p&gt;
    &lt;p&gt;The team explained that other platforms moved ahead. Safari supports JPEG XL, and Windows 11 users can add native support through an image extension from Microsoft Store. The format is also confirmed for use in PDF documents. There has been continuous demand from developers and users who ask for its return.&lt;/p&gt;
    &lt;p&gt;Before Google ships the feature in Chrome, the company wants the integration to be secure and supported over time.&lt;/p&gt;
    &lt;head rend="h2"&gt;Chrome JPEG XL implementation adds animation support&lt;/head&gt;
    &lt;p&gt;A developer has submitted new code that reintroduces JPEG XL to Chromium. This version is marked as feature complete. The developer said it also “includes animation support,” which earlier implementations did not offer. The code passes most of Chrome’s automated testing, but it remains under review and is not available to users.&lt;/p&gt;
    &lt;p&gt;The featured image is taken from an unlisted developer demo created for testing purposes.&lt;/p&gt;
    &lt;p&gt;JPEG XL is a newer image format intended as a replacement for traditional JPEG files. It can reduce file size without loss in visual quality. This may help web pages load faster and reduce data usage. More details are available on the official JPEG XL website.&lt;/p&gt;
    &lt;p&gt;Google has not provided a timeline for JPEG XL support in Chrome. Users cannot enable the format today, but development has restarted after years without progress.&lt;/p&gt;
    &lt;p&gt;Read our disclosure page to find out how can you help Windows Report sustain the editorial team. Read more&lt;/p&gt;
    &lt;p&gt;User forum&lt;/p&gt;
    &lt;p&gt;0 messages&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://windowsreport.com/google-revisits-jpeg-xl-in-chromium-after-earlier-removal/"/><published>2025-11-23T06:05:51+00:00</published></entry></feed>