<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><id>hnrss.org/frontpage</id><title>Hacker News: Front Page</title><updated>2025-10-04T15:08:24.749017+00:00</updated><link href="https://news.ycombinator.com/" rel="alternate"/><link href="https://raw.githubusercontent.com/Prabesh01/hnrss-content-extract/refs/heads/main/out/rss.xml" rel="self"/><generator uri="https://lkiesow.github.io/python-feedgen" version="1.0.0">python-feedgen</generator><subtitle>Hacker News RSS</subtitle><entry><id>https://news.ycombinator.com/item?id=45447057</id><title>Old Stockholm Telephone Tower</title><updated>2025-10-04T15:08:37.095321+00:00</updated><content>&lt;doc fingerprint="2fca64de273c623d"&gt;
  &lt;main&gt;&lt;head rend="h1"&gt;Old Stockholm telephone tower&lt;/head&gt;&lt;table&gt;&lt;row span="2"&gt;&lt;cell role="head"&gt;Old Stockholm telephone tower&lt;/cell&gt;&lt;/row&gt;&lt;row span="2"&gt;&lt;cell&gt;&lt;p&gt;Telefontornet&lt;/p&gt;&lt;/cell&gt;&lt;/row&gt;&lt;row span="2"&gt;&lt;cell&gt;General information&lt;/cell&gt;&lt;/row&gt;&lt;row span="2"&gt;&lt;cell&gt;Status&lt;/cell&gt;&lt;cell&gt;Demolished&lt;/cell&gt;&lt;/row&gt;&lt;row span="2"&gt;&lt;cell&gt;Location&lt;/cell&gt;&lt;cell&gt;Malmskillnadsgatan 32, Stockholm, Sweden, Sweden&lt;/cell&gt;&lt;/row&gt;&lt;row span="2"&gt;&lt;cell&gt;Coordinates&lt;/cell&gt;&lt;cell&gt;59°19′54″N 18°03′58″E / 59.331657°N 18.066029°E&lt;/cell&gt;&lt;/row&gt;&lt;row span="2"&gt;&lt;cell&gt;Completed&lt;/cell&gt;&lt;cell&gt;1887&lt;/cell&gt;&lt;/row&gt;&lt;row span="2"&gt;&lt;cell&gt;Renovated&lt;/cell&gt;&lt;cell&gt;1890&lt;p&gt;1913&lt;/p&gt;&lt;p&gt;1939&lt;/p&gt;&lt;/cell&gt;&lt;/row&gt;&lt;row span="2"&gt;&lt;cell&gt;Demolished&lt;/cell&gt;&lt;cell&gt;1953&lt;/cell&gt;&lt;/row&gt;&lt;row span="2"&gt;&lt;cell&gt;Landlord&lt;/cell&gt;&lt;cell&gt;Stockholms Allmänna Telefon AB&lt;/cell&gt;&lt;/row&gt;&lt;row span="2"&gt;&lt;cell&gt;Height&lt;/cell&gt;&lt;/row&gt;&lt;row&gt;&lt;cell&gt;Antenna spire&lt;/cell&gt;&lt;cell&gt;80 metres (260 ft)&lt;/cell&gt;&lt;/row&gt;&lt;/table&gt;&lt;p&gt;The Old Stockholm telephone tower (Swedish: Telefontornet) was a metallic structure built to connect approximately 5,500 telephone lines in the Swedish capital of Stockholm. Constructed in 1887, the tower was used until 1913. It was damaged by a fire in 1952 and demolished the following year.&lt;/p&gt;&lt;head rend="h2"&gt;History&lt;/head&gt;[edit]&lt;p&gt;In 1887, Stockholms Allmänna Telefon AB ordered the construction of a tower allowing the connection of about 5,500 overhead telephone lines. The quadrangular metallic structure was 80 metres tall and soon fell out of favour with the local population. The company requested the architect Fritz Eckert to carry out embellishment work, which was when the four turrets were added.&lt;/p&gt;&lt;p&gt;The tower was quickly made obsolete as telephone companies began using underground cables in urban areas. In 1913, underground cabling for telephones was fully completed and the tower no longer served its original purpose. After 1939 it carried advertising for Nordiska Kompaniet. On 23 July 1952 a fire weakened the structure, resulting in its demolition in 1953 on safety grounds.[1]&lt;/p&gt;&lt;head rend="h2"&gt;Gallery&lt;/head&gt;[edit]&lt;list rend="ul"&gt;&lt;item&gt; The telephone tower in 1891&lt;/item&gt;&lt;item&gt; Tower seen from up close&lt;/item&gt;&lt;item&gt; The telephone tower in 1952&lt;/item&gt;&lt;item&gt; Tower from far away in 1952&lt;/item&gt;&lt;/list&gt;&lt;head rend="h2"&gt;References&lt;/head&gt;[edit]&lt;list rend="ol"&gt;&lt;item&gt;^ ""Telefontornet brinner!"". Svenska Dagbladet. 25 November 2012. Retrieved 20 September 2014.&lt;/item&gt;&lt;/list&gt;&lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://en.wikipedia.org/wiki/Old_Stockholm_telephone_tower"/><published>2025-10-02T07:12:18+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45447536</id><title>Asked to do something illegal at work? Here's what these software engineers did</title><updated>2025-10-04T15:08:36.924794+00:00</updated><content>&lt;doc fingerprint="2c57d065f8a373cc"&gt;
  &lt;main&gt;
    &lt;head rend="h1"&gt;Asked to do something illegal at work? Here’s what these software engineers did&lt;/head&gt;
    &lt;p&gt;Update on 2 Oct 2025: back in 2021, Charlie Javice, CEO of student loan startup Frank pressured a software engineer to inflate customer numbers. She told the engineer that she did not believe that anyone would end up in an ‘orange jumpsuit’ just for this. Still, the engineer refused – and was proven right. Javice, in fact, did end up in an orange jumpsuit, sentenced to 7 years of prison in 2025 for fraud.&lt;/p&gt;
    &lt;p&gt;The below topic was sent out to full subscribers of The Pragmatic Engineer, three weeks ago, in The Pulse #66. I have received several messages from people asking if they can pay to “unlock” this information for others, given how vital it is for software engineers. It is vital, and so I’m sharing this with all readers, without a paywall. In the unlikely case that you are asked to do something fishy or illegal: I hope the below will help decide how to do the right thing.&lt;/p&gt;
    &lt;p&gt;Sign up to The Pragmatic Engineer to get articles like this earlier in your inbox. It's a pretty good read, and the #1 tech publication on Substack.&lt;/p&gt;
    &lt;p&gt;What would you do if you learned your company is up to something illegal like stealing customer funds, or you’re asked to make code changes that will enable something illegal to happen, like misleading investors, or defrauding customers? Here are three real-life cases, where what engineers and engineering managers did had serious consequences.&lt;/p&gt;
    &lt;head rend="h4"&gt;FTX: an engineering director went along with the fraud&lt;/head&gt;
    &lt;p&gt;A trial related to FTX, the cryptocurrency exchange which allegedly defrauded investors of $9B, is ongoing. Day 9 of the trial of former FTX CEO Sam Bankman-Fried trial, heard testimony from Nishad Singh, who joined the business as a software engineer, and later became an engineering director. Here is software engineer and writer Molly White summarizes of his evidence:&lt;/p&gt;
    &lt;p&gt;“To hear Singh tell it, he didn’t even really realize what was going on at FTX and Alameda Research until September 2022 — only a month or two before everything came crashing down. (...) Several times throughout various testimonies, we’ve seen a document written by Sam Bankman-Fried, in which he describes his thinking that Alameda Research should be shut down. That document was, ultimately, how Singh learned in September 2022 that Alameda Research had taken billions of dollars of customer funds from FTX. &lt;lb/&gt;This was when Gary Wang told Singh that Alameda was borrowing massive amounts of customer money from FTX — at the time, around $13 billion of it. Singh testified that he felt ‘really afraid’, and called an in-person meeting immediately. Bankman-Fried, who was sitting next to Singh at the time, ‘seemed unsurprised and made up what I understood to be a false excuse for dodging the meeting.’ Singh, Ellison, and Wang met without him, and Singh confirmed his fears: that he had not misunderstood Wang, and that Alameda had actually taken customer funds to that extent.”&lt;/p&gt;
    &lt;p&gt;Okay, so in September 2022, Singh had confirmation that something illegal was happening at the company, which he had no direct knowledge of, until then. At that point, if he wanted to avoid being an accomplice to potentially illegal activity, his options were:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Talk to a lawyer on how to avoid assisting a crime&lt;/item&gt;
      &lt;item&gt;Turn whistleblower. See the tech whistleblower guide&lt;/item&gt;
      &lt;item&gt;Quit the company, ensuring he did not further aid this activity&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The smart thing would have been to do #1. The profitable thing could have been to do #2 because in the US, a whistleblower may receive a whistleblower reward of between 10-30% of what the government recovers from fraudulent activities. The final choice #3 is hard, but could have meant Singh would not have had to plead guilty as he did.&lt;/p&gt;
    &lt;p&gt;Here’s what Singh did instead: he asked for a personal meeting with Bankman-Fried and confronted him about the missing funds. However, Bankman-Fried replied there not much to worry about, and that they’d repay the funds by raising more money from investors (!!) This should have been the point at which Singh quit. Instead:&lt;/p&gt;
    &lt;quote&gt;“He thought about leaving the company then, he testified, but worried that his departure could cause everything to fall apart. He felt that if he stayed, maybe he could help the companies make back what they owed.”&lt;/quote&gt;
    &lt;p&gt;For the next two months, Singh tried to make things better, but it was fruitless. FTX collapsed in November 2022.&lt;/p&gt;
    &lt;p&gt;Lesson #1: when you discover fraud may be happening, do not “stay around to fix it.” Any other approach would have been better for Singh; seeking legal advice, turning whistleblower, or quitting on the spot.&lt;/p&gt;
    &lt;p&gt;To be fair, Singh didn’t seen totally clueless, and it seems he decided to profit on the developments. Days after he found about this fraud, he took a $3.7M loan from FTX (!!) to buy a house, The Verge pointed out. It’s exactly the type of thing you don’t want to do after you discover fraud.&lt;/p&gt;
    &lt;p&gt;Now, Singh is facing up to 75 years in jail thanks to his decision to aid the company after discovering the fraud. His sentence will most likely be reduced due to his plea deal, but any course of action which leads to a criminal conviction is surely a grave error of judgment.&lt;/p&gt;
    &lt;p&gt;Update in Oct 2025: in the end, Nishad Singh was spared from prison, and received 3 years of supervised release. The judge was persuaded that Singh’s involvement with the fraud was far more limited than that of FTX founder Sam Bankman-Fried or Caroline Ellison, the former CEO of sister hedge fund Alameda Research.&lt;/p&gt;
    &lt;head rend="h4"&gt;Frank: a software engineer refuses to fake customer data&lt;/head&gt;
    &lt;p&gt;Frank was a student loan startup founded by Charlie Javice in 2016. In 2019, Javice was featured on the Forbes “30 under 30” finance list, suggesting she was a high-flying founder:&lt;/p&gt;
    &lt;p&gt;It certainly seemed like Charlie Javice was a standout founder; in 2021, JP Morgan purchased Frank for $175M. However, things turned sour quickly. JP Morgan thought it bought a startup with 5 million customers, which worked with 6,000 schools. But after the purchase, this data was found to be mostly fake.&lt;/p&gt;
    &lt;p&gt;Let’s get to a software engineer’s involvement. This April, founder Charlie Javice was arrested, and a lawsuit is ongoing between her, former Chief Growth Officer Olivier Amar, and JP Morgan. From to this lawsuit, we get an inside look at how events unfolded inside Frank.&lt;/p&gt;
    &lt;p&gt;In 2021, an engineer was asked to produce fake data for 4.2M non-existent customers. As acquisition talks were ongoing, JP Morgan wanted to validate that Frank had the nearly 5M customers it claimed. In reality, Frank had 293,000 customers, so the CEO asked an engineer to fake the data and turn this list into 4.2M members. Here’s what happened next – from the lawsuit:&lt;/p&gt;
    &lt;p&gt;“[In 2021] Javice [CEO], Amar [Chief Growth Officer] and the Director of Engineering then had a Zoom meeting during which Javice and Amar asked the Director of Engineering to help them create a synthetic list of customer data. She asked the Director of Engineering if he could help take a known set of FAFSA application data and use it to artificially augment a much larger set of anonymous data tht her systems had collected over time.&lt;lb/&gt;The Director of Engineering questioned whether creating and using such a data set was legal, but Javice tried to assure the engineer by claiming that this was perfectly acceptable in an investment situation and she did not believe that anyone would end up in an ‘orange jumpsuit’ over this project.”&lt;/p&gt;
    &lt;p&gt;Lesson #2: when your manager claims they don’t believe anyone would end up in an “orange jumpsuit,” assume that someone definitely could. The engineering director’s next step? They refused:&lt;/p&gt;
    &lt;p&gt;“The Director of Engineering was not persuaded and told Javice and Amar that he would not perform the task, and only would send them the file containing Frank’s actual users, which amounted to approximately 293,000 individuals at the time.”&lt;/p&gt;
    &lt;p&gt;And this engineering director played it right, as the people who are likely to go to jail and end up in orange jumpsuits are the other two people on the call, who knowingly went along with the illegal.&lt;/p&gt;
    &lt;head rend="h4"&gt;Pollen: an engineer told to double charge customers by the CEO&lt;/head&gt;
    &lt;p&gt;Last year, I published my first – and to date only– investigative article on how events tech startup Pollen raised $200M and then collapsed, owing months of wages to staff. In the investigation, I focused on an unusual detail: $3.2M worth of funds taken months early from customers. The incident was described internally by Pollen as a mistake, and an incident review should have followed. Even more confusing, the company blamed the payments processor Stripe for the incident.&lt;/p&gt;
    &lt;p&gt;The reality was that this was a very deliberate double charge. I could not share this fact at the time – as the company threatened me with libel after I informed them of this detail – but the BBC has now produced a documentary revealing details about this deliberate double charge that was covered up as an outage. From the documentary:&lt;/p&gt;
    &lt;p&gt;[Narrator] “Pollen initially told some customers that the problem was with their payments provider. Later, Callum [the CEO] addressed his staff who were demanding to know what happened.”&lt;/p&gt;
    &lt;p&gt;[CEO of Pollen talking] “All that happened was that a couple millions of dollars of payment plans that were due to be paid at a later month were then paid earlier. It’s being investigated. We’ve committed already that once that investigation is done, it will be shared with the company so that people understand what happened.”&lt;/p&gt;
    &lt;p&gt;[Narrator] “With over 1,500 customers impacted, rumors began to circulate about the causes of the incident.”&lt;/p&gt;
    &lt;p&gt;[Dan Taylor, managing editor at Tech.eu] “From my understanding, there was a creative code ‘malfunction’ that all of the sudden, double charged customers. But that double charge magically happened to meet Pollen’s payroll, that month. Hmm! Odd, don’t you think?”&lt;/p&gt;
    &lt;p&gt;[Narrator] “The internal investigation due to be shared with the company was never completed, but a group of Pollen staff did their own, unofficial digging. (...) The code contained in the report confirms that the customer's monthly payment plans had been manually altered, which meant that double or triple charges will take place on a single day, without the customer’s authorization.”&lt;/p&gt;
    &lt;p&gt;The engineer making this change even did a test run the day before, to ensure that this code change “correctly” double charges customers! A former Pollen software engineer appearing in the documentary also makes the point that any code changing production code in payments needs to go through code review, so whoever made this change could have not been acting alone.&lt;/p&gt;
    &lt;p&gt;Two days after the incident, a senior engineering team member sent an internal chat message to 3 colleagues, where they admit that they had run the script at the request of the CEO. Here is what this message said:&lt;/p&gt;
    &lt;quote&gt;“Also want to come clean that it was me who ran a bad script - in hindsight I wasn’t knowledgeable enough to alter a subset of payment plans for Balvin [one of the events organized by Pollen]. I did this as a special request from Callum and didn’t want to raise on call to handle. It’s been a long week and I displayed a very poor form of judgement.”&lt;/quote&gt;
    &lt;p&gt;In the video, a Pollen software engineer is shown the message, and he says: “I’m not sure I buy this. It seems a bit fishy.”&lt;/p&gt;
    &lt;p&gt;Lesson #3: if the CEO asks you to do something potentially illegal – document it, and consider not doing it. We don’t know what happened with the senior engineering member who carried out the code changes, following a request from the CEO. This person could have said no, like the engineering director at Frank did. The message sent a few days ago already said that this person regretted doing so, and it’s unlikely that this action was worth the risk it carried.&lt;/p&gt;
    &lt;p&gt;Update in Oct 2025: no criminal charges that I am aware of have been made related to this double charging at Pollen.&lt;/p&gt;
    &lt;p&gt;If you take one lesson from this, it’s that you can always say no. In these three stories, the only engineer who’s legally safe is the former engineering director at Frank who point blank refused to assist what could be an illegal request. The engineering director at FTX who stayed after he confirmed fraud was occurring is now facing jail time, while the senior engineering member at Pollen is at the mercy of the UK police, and how they deal with what could be a potential wire fraud case.&lt;/p&gt;
    &lt;p&gt;Subscribe to my weekly newsletter to get articles like this in your inbox. It's a pretty good read - and the #1 tech newsletter on Substack.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://blog.pragmaticengineer.com/asked-to-do-something-illegal-at-work/"/><published>2025-10-02T08:51:49+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45455164</id><title>Where it's at://</title><updated>2025-10-04T15:08:36.596248+00:00</updated><content>&lt;doc fingerprint="9e199d86dcdee5d6"&gt;
  &lt;main&gt;
    &lt;head rend="h1"&gt;Where It's at://&lt;/head&gt;
    &lt;p&gt;October 2, 2025&lt;/p&gt;
    &lt;p&gt;You might have heard about the AT protocol (if not, read this!)&lt;/p&gt;
    &lt;p&gt;Together, all servers speaking the AT protocol comprise the atmosphere—a web of hyperlinked JSON. Each piece of JSON on the atmosphere has its own &lt;code&gt;at://&lt;/code&gt; URI:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;
        &lt;code&gt;at://ruuuuu.de/app.bsky.feed.post/3lzy2ji4nms2z&lt;/code&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;code&gt;at://danabra.mov/sh.tangled.feed.star/3m23ddgjpgn22&lt;/code&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;code&gt;at://tessa.germnetwork.com/pub.leaflet.publication/3lzz6juivnc2d&lt;/code&gt;
      &lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;But where do they point, exactly?&lt;/p&gt;
    &lt;p&gt;Given an &lt;code&gt;at://&lt;/code&gt; URI, how do you locate the corresponding JSON?&lt;/p&gt;
    &lt;p&gt;In this post, I’ll show you the exact process of resolving an &lt;code&gt;at://&lt;/code&gt; URI step by step. Turns out, this is also a great way to learn the details of how &lt;code&gt;at://&lt;/code&gt; works.&lt;/p&gt;
    &lt;p&gt;Let’s start with the structure of a URI itself.&lt;/p&gt;
    &lt;head rend="h3"&gt;The User as the Authority&lt;/head&gt;
    &lt;p&gt;As you might know, a URI often contains a scheme (for example, &lt;code&gt;https://&lt;/code&gt;), an authority (like &lt;code&gt;wikipedia.com&lt;/code&gt;), a path (like &lt;code&gt;/Main_Page&lt;/code&gt;), and maybe a query.&lt;/p&gt;
    &lt;p&gt;In most protocols, including &lt;code&gt;https://&lt;/code&gt;, the authority part points at whoever’s hosting the data. Whoever created this data is either not present, or is in the path:&lt;/p&gt;
    &lt;p&gt;The &lt;code&gt;at://&lt;/code&gt; protocol flips that around.&lt;/p&gt;
    &lt;p&gt;In &lt;code&gt;at://&lt;/code&gt; URIs, whoever created the data is the authority, in the most literal sense:&lt;/p&gt;
    &lt;p&gt;The user is the authority for their own data. Whoever’s hosting the data could change over time, and is not directly included in an &lt;code&gt;at://&lt;/code&gt; URI. To find out the actual physical server hosting that JSON, you’re gonna need to take a few steps.&lt;/p&gt;
    &lt;head rend="h3"&gt;A Post in the Atmosphere&lt;/head&gt;
    &lt;p&gt;Let’s try to resolve this &lt;code&gt;at://&lt;/code&gt; URI to the piece of JSON it represents:&lt;/p&gt;
    &lt;p&gt;An easy way to resolve an &lt;code&gt;at://&lt;/code&gt; URI is to use an SDK or a client app. Let’s try an online client, for example, pdsls or Taproot or atproto-browser. They’ll figure out the physical server where its JSON is currently hosted, and show that JSON for you.&lt;/p&gt;
    &lt;p&gt;The above &lt;code&gt;at://&lt;/code&gt; URI points at this JSON, wherever it is currently being hosted:&lt;/p&gt;
    &lt;p&gt;You can guess by the &lt;code&gt;$type&lt;/code&gt; field being &lt;code&gt;"app.bsky.feed.post"&lt;/code&gt; that this is some kind of a post (which might explain why it has fields like &lt;code&gt;text&lt;/code&gt; and &lt;code&gt;langs&lt;/code&gt;).&lt;/p&gt;
    &lt;p&gt;However, note that this piece of JSON represents a certain social media post itself, not a web page or a piece of some app. It’s pure data as a piece of JSON, not a piece of UI. You may think of the &lt;code&gt;$type&lt;/code&gt; stating the data format; the &lt;code&gt;app.bsky.*&lt;/code&gt; prefix tells us that the &lt;code&gt;bsky.app&lt;/code&gt; application might know something about what to do with it. Other applications may also consume and produce data in this format.&lt;/p&gt;
    &lt;p&gt;A careful reader might notice that the &lt;code&gt;uri&lt;/code&gt; in the JSON block is also an &lt;code&gt;at://&lt;/code&gt; URI but it’s slightly different from the original &lt;code&gt;at://&lt;/code&gt; URI we requested:&lt;/p&gt;
    &lt;p&gt;In particular, the short &lt;code&gt;ruuuuu.de&lt;/code&gt; authority has expanded into a longer &lt;code&gt;did:web:iam.ruuuuu.de&lt;/code&gt; authority. Maybe that’s the physical host?&lt;/p&gt;
    &lt;p&gt;Actually, no, that’s not the physical host either—it’s something called an identity. Turns out, resolving an &lt;code&gt;at://&lt;/code&gt; URI is done in three distinct steps:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Resolve the handle to an identity (“who are you?”)&lt;/item&gt;
      &lt;item&gt;Resolve that identity to a hosting (“who holds your data?”)&lt;/item&gt;
      &lt;item&gt;Request the JSON from that hosting (“what is the data?”)&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Let’s go through each of these steps and see how they work.&lt;/p&gt;
    &lt;head rend="h3"&gt;From Handles to Identities&lt;/head&gt;
    &lt;p&gt;The &lt;code&gt;at://&lt;/code&gt; URIs you’ve seen earlier are fragile because they use handles.&lt;/p&gt;
    &lt;p&gt;Here, &lt;code&gt;ruuuuu.de&lt;/code&gt;, &lt;code&gt;danabra.mov&lt;/code&gt;, and &lt;code&gt;tessa.germnetwork.com&lt;/code&gt; are handles:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;
        &lt;code&gt;at://ruuuuu.de/app.bsky.feed.post/3lzy2ji4nms2z&lt;/code&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;code&gt;at://danabra.mov/sh.tangled.feed.star/3m23ddgjpgn22&lt;/code&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;code&gt;at://tessa.germnetwork.com/pub.leaflet.publication/3lzz6juivnc2d&lt;/code&gt;
      &lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;(Read more about domains as “internet handles” here.)&lt;/p&gt;
    &lt;p&gt;The user may choose to change their &lt;code&gt;at://&lt;/code&gt; handle later, and it is important for that not to break any links between pieces of JSON already on the network.&lt;/p&gt;
    &lt;p&gt;This is why, before you store an &lt;code&gt;at://&lt;/code&gt; URI, you should turn it into a canonical form by resolving the handle to something that never changes—an identity. An identity is like an account ID, but global and meant for the entire web. There are two mechanisms to resolve a handle to an identity (also known as a “DID”):&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Query the DNS TXT record at &lt;code&gt;_atproto.&amp;lt;handle&amp;gt;&lt;/code&gt;looking for&lt;code&gt;did=???&lt;/code&gt;&lt;/item&gt;
      &lt;item&gt;Make an HTTPS GET to &lt;code&gt;https://&amp;lt;handle&amp;gt;/.well-known/atproto-did&lt;/code&gt;&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The thing you’re looking for, the DID, is going to have a shape like &lt;code&gt;did:something:whatever&lt;/code&gt;. (We’ll revisit what that means later.)&lt;/p&gt;
    &lt;p&gt;For example, let’s try to resolve &lt;code&gt;ruuuuu.de&lt;/code&gt; via the DNS mechanism:&lt;/p&gt;
    &lt;p&gt;Found it!&lt;/p&gt;
    &lt;p&gt;The &lt;code&gt;ruuuuu.de&lt;/code&gt; handle claims to be owned by &lt;code&gt;did:web:iam.ruuuuu.de&lt;/code&gt;, whoever that may be. That’s all that we wanted to know at this point:&lt;/p&gt;
    &lt;p&gt;Note this doesn’t prove their association yet. We’ll need to verify that whoever controls the &lt;code&gt;did:web:iam.ruuuuu.de&lt;/code&gt; identity “agrees” with &lt;code&gt;ruuuuu.de&lt;/code&gt; being their handle. The mapping is bidirectional. But we’ll confirm that in a later step.&lt;/p&gt;
    &lt;p&gt;Now let’s try to resolve &lt;code&gt;danabra.mov&lt;/code&gt; using the DNS route:&lt;/p&gt;
    &lt;p&gt;That also worked! The &lt;code&gt;danabra.mov&lt;/code&gt; handle claims to be owned by the &lt;code&gt;did:plc:fpruhuo22xkm5o7ttr2ktxdo&lt;/code&gt; identity, whoever that may be:&lt;/p&gt;
    &lt;p&gt;This DID looks a bit different than what you saw earlier but it’s also a valid DID. Again, it’s important to emphasize we’ve not confirmed the association yet.&lt;/p&gt;
    &lt;p&gt;Subdomains like &lt;code&gt;barackobama.bsky.social&lt;/code&gt; can also be handles.&lt;/p&gt;
    &lt;p&gt;Let’s try to resolve it:&lt;/p&gt;
    &lt;p&gt;The DNS mechanism didn’t work, so let’s try with HTTPS:&lt;/p&gt;
    &lt;p&gt;That worked! This means that &lt;code&gt;barackobama.bsky.social&lt;/code&gt; handle claims to be owned by the &lt;code&gt;did:plc:5c6cw3veuqruljoy5ahzerfx&lt;/code&gt; identity, whoever that is:&lt;/p&gt;
    &lt;p&gt;So you get the idea. When you see a handle, you can probe it with DNS and HTTPS to see if it claims to be owned by some identity (a DID). If you found a DID, you’ll then be able to (1) verify it actually owns that handle, and (2) locate the server that hosts the data for that DID. And that will be the server you’ll ask for the JSON.&lt;/p&gt;
    &lt;p&gt;In practice, if you’re building with AT, you’ll likely want to either deploy your own handle/did resolution cache or hit an existing one. (Here’s one implementation.)&lt;/p&gt;
    &lt;head rend="h3"&gt;AT Permalinks&lt;/head&gt;
    &lt;p&gt;Now you know how handles resolve to identities, also known as DIDs. Unlike handles, which change over time, DIDs never change—they’re immutable.&lt;/p&gt;
    &lt;p&gt;These &lt;code&gt;at://&lt;/code&gt; links, which use handles, are human-readable but fragile:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;
        &lt;code&gt;at://ruuuuu.de/app.bsky.feed.post/3lzy2ji4nms2z&lt;/code&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;code&gt;at://danabra.mov/sh.tangled.feed.star/3m23ddgjpgn22&lt;/code&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;code&gt;at://tessa.germnetwork.com/pub.leaflet.publication/3lzz6juivnc2d&lt;/code&gt;
      &lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;They will break if one of us changes a handle again.&lt;/p&gt;
    &lt;p&gt;In contrast, the &lt;code&gt;at://&lt;/code&gt; links below, which use DIDs, will not break until we either delete our accounts, delete these records, or permanently take down our hosting:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;
        &lt;code&gt;at://did:web:iam.ruuuuu.de/app.bsky.feed.post/3lzy2ji4nms2z&lt;/code&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;code&gt;at://did:plc:fpruhuo22xkm5o7ttr2ktxdo/sh.tangled.feed.star/3m23ddgjpgn22&lt;/code&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;code&gt;at://did:plc:ad4m72ykh2evfdqen3qowxmg/pub.leaflet.publication/3lzz6juivnc2d&lt;/code&gt;
      &lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;So, really, this is the “true form” of an &lt;code&gt;at://&lt;/code&gt; URI:&lt;/p&gt;
    &lt;p&gt;Think of &lt;code&gt;at://&lt;/code&gt; links with DIDs as “permalinks”. Any application storing &lt;code&gt;at://&lt;/code&gt; URIs should store them in this canonical form so that logical links between our pieces of JSON don’t break when we change our handles or change our hosting.&lt;/p&gt;
    &lt;p&gt;Now that you know how to resolve a handle to a DID, you want to do two things:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Verify that whoever owns this DID actually goes by that handle.&lt;/item&gt;
      &lt;item&gt;Find the server that hosts all the data for this DID.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;You can do both of these things by fetching a piece of JSON called the DID Document. You can think of it as sort of a “passport” for a given DID.&lt;/p&gt;
    &lt;p&gt;How you do that depends on what kind of DID it is.&lt;/p&gt;
    &lt;head rend="h3"&gt;From Identities to Hosting&lt;/head&gt;
    &lt;p&gt;Currently, there are two kinds of DIDs, known as DID methods, supported by the AT protocol: &lt;code&gt;did:web&lt;/code&gt; (a W3C draft) and &lt;code&gt;did:plc&lt;/code&gt; (specified by Bluesky).&lt;/p&gt;
    &lt;p&gt;Let’s compare them.&lt;/p&gt;
    &lt;head rend="h4"&gt;
      &lt;code&gt;did:web&lt;/code&gt;
    &lt;/head&gt;
    &lt;p&gt;The &lt;code&gt;ruuuuu.de&lt;/code&gt; handle claims to be owned by &lt;code&gt;did:web:iam.ruuuuu.de&lt;/code&gt;:&lt;/p&gt;
    &lt;p&gt;To check this claim, let’s find the DID Document for &lt;code&gt;did:web:iam.ruuuuu.de&lt;/code&gt;. The &lt;code&gt;did:web&lt;/code&gt; method is a specification that specifies an algorithm for that.&lt;/p&gt;
    &lt;p&gt;In short, you cut off the &lt;code&gt;did:web:&lt;/code&gt; from the DID, append &lt;code&gt;/.well-known/did.json&lt;/code&gt; to the end, and run an HTTPS GET request:&lt;/p&gt;
    &lt;p&gt;This DID Document looks sleep-inducing but it tells us three important things:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;How to refer to them. The &lt;code&gt;alsoKnownAs&lt;/code&gt;field confirms that whoever controls&lt;code&gt;did:web:iam.ruuuuu.de&lt;/code&gt;indeed wants to use&lt;code&gt;@ruuuuu.de&lt;/code&gt;as a handle. ✅&lt;/item&gt;
      &lt;item&gt;How to verify the integrity of their data. The &lt;code&gt;publicKeyMultibase&lt;/code&gt;field tells us the public key with which all changes to their data are signed.&lt;/item&gt;
      &lt;item&gt;Where their data is stored. The &lt;code&gt;serviceEndpoint&lt;/code&gt;field tells us the actual server with their data. Rudy’s data is currently hosted at&lt;code&gt;https://blacksky.app&lt;/code&gt;.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;A DID Document really is like an internet passport for an identity: here’s their handle, here’s their signature, and here’s their location. It connects a handle to a hosting while letting the identity owner change either the handle or the hosting.&lt;/p&gt;
    &lt;p&gt;Users who interact with &lt;code&gt;@ruuuuu.de&lt;/code&gt; on different apps in the atmosphere don’t need to know or care about his DID or about his current hosting (and whether it moves). From their perspective, his current handle is the only relevant identifier. As for developers, they’ll refer to him by DID, which conveniently never changes.&lt;/p&gt;
    &lt;p&gt;All of this sounds great, but there is one big downside to the &lt;code&gt;did:web&lt;/code&gt; identity. If &lt;code&gt;did:web:iam.ruuuuu.de&lt;/code&gt; ever loses control of the &lt;code&gt;iam.ruuuuu.de&lt;/code&gt; domain, he will lose control over his DID Document, and thus over his entire identity.&lt;/p&gt;
    &lt;p&gt;Let’s have a look at an alternative to &lt;code&gt;did:web&lt;/code&gt; that avoids this problem.&lt;/p&gt;
    &lt;head rend="h4"&gt;
      &lt;code&gt;did:plc&lt;/code&gt;
    &lt;/head&gt;
    &lt;p&gt;We already know the &lt;code&gt;danabra.mov&lt;/code&gt; handle claims to be owned by the &lt;code&gt;did:plc:fpruhuo22xkm5o7ttr2ktxdo&lt;/code&gt; identity (actually, that’s me!)&lt;/p&gt;
    &lt;p&gt;To check this claim, let’s find the DID Document for &lt;code&gt;did:plc:fpruhuo22xkm5o7ttr2ktxdo&lt;/code&gt;.&lt;/p&gt;
    &lt;p&gt;The &lt;code&gt;did:plc&lt;/code&gt; method is a specification that specifies an algorithm for that.&lt;/p&gt;
    &lt;p&gt;Essentially, you need to hit the &lt;code&gt;https://plc.directory&lt;/code&gt; service with a &lt;code&gt;GET&lt;/code&gt;:&lt;/p&gt;
    &lt;p&gt;The DID Document itself works exactly the same way. It specifies:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;How to refer to me. The &lt;code&gt;alsoKnownAs&lt;/code&gt;field confirms that whoever controls&lt;code&gt;did:plc:fpruhuo22xkm5o7ttr2ktxdo&lt;/code&gt;uses&lt;code&gt;@danabra.mov&lt;/code&gt;as a handle. ✅&lt;/item&gt;
      &lt;item&gt;How to verify the integrity of my data. The &lt;code&gt;publicKeyMultibase&lt;/code&gt;field tells us the public key with which all changes to my data are signed.&lt;/item&gt;
      &lt;item&gt;Where my data is stored. The &lt;code&gt;serviceEndpoint&lt;/code&gt;field tells us the actual server with my data. It’s currently at&lt;code&gt;https://morel.us-east.host.bsky.network&lt;/code&gt;.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Let’s visualize this:&lt;/p&gt;
    &lt;p&gt;Although my handle is &lt;code&gt;@danabra.mov&lt;/code&gt;, the actual server storing my data is currently &lt;code&gt;https://morel.us-east.host.bsky.network&lt;/code&gt;. I’m happy to keep hosting it there but I’m thinking of moving it to a host I control in the future. I can change both my handle and my hosting without disruption to my social apps.&lt;/p&gt;
    &lt;p&gt;Unlike Rudy, who has a &lt;code&gt;did:web&lt;/code&gt; identity, I stuck with &lt;code&gt;did:plc&lt;/code&gt; (which is the default one when you create an account on Bluesky) so that I’m not irrecovably tying myself to any web domain. “PLC” officially stands for a “Public Ledger of Credentials”—essentially, it is like an npm registry but for DID Documents. (Fun fact: originally PLC meant “placeholder” but they’ve decided it’s a good tradeoff.)&lt;/p&gt;
    &lt;p&gt;The upside of a &lt;code&gt;did:plc&lt;/code&gt; identity is that I can’t lose my identity if I forget to renew a domain, or if something bad happens at the top level to my TLD.&lt;/p&gt;
    &lt;p&gt;The downside of a &lt;code&gt;did:plc&lt;/code&gt; identity is that whoever operates the PLC registry has some degree of control over my identity. They can’t outright change it because every version is recursively signed with the hash of the previous version, every past version is queryable, and the hash of the initial version is the DID itself.&lt;/p&gt;
    &lt;p&gt;However, in theory, whoever operates the PLC registry could deny my requests to update the DID Document, or refuse to serve some information about it. Bluesky is currently moving PLC to an independent legal entity in Switzerland to address some of these concerns. The AT community is also thinking and experimenting.&lt;/p&gt;
    &lt;head rend="h3"&gt;From Hosting to JSON&lt;/head&gt;
    &lt;p&gt;So far, you’ve learned how to:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Resolve a handle to a DID.&lt;/item&gt;
      &lt;item&gt;Grab the DID Document for that DID.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;That actually tells you enough to get the JSON by its &lt;code&gt;at://&lt;/code&gt; URI!&lt;/p&gt;
    &lt;p&gt;Each DID Document includes the &lt;code&gt;serviceEndpoint&lt;/code&gt; which is the actual hosting. That’s the service you can hit by HTTPS to grab any JSON record it stores.&lt;/p&gt;
    &lt;p&gt;For example, the &lt;code&gt;@ruuuuu.de&lt;/code&gt; handle resolves to &lt;code&gt;did:web:iam.ruuuuu.de&lt;/code&gt;, and its DID Document has a &lt;code&gt;serviceEndpoint&lt;/code&gt; pointing at &lt;code&gt;https://blacksky.app&lt;/code&gt;.&lt;/p&gt;
    &lt;p&gt;To get the &lt;code&gt;at://ruuuuu.de/app.bsky.feed.post/3lzy2ji4nms2z&lt;/code&gt; record, hit the &lt;code&gt;https://blacksky.app&lt;/code&gt; server with the &lt;code&gt;com.atproto.repo.getRecord&lt;/code&gt; endpoint, passing different parts of the &lt;code&gt;at://&lt;/code&gt; URI as parameters:&lt;/p&gt;
    &lt;p&gt;And there it is:&lt;/p&gt;
    &lt;p&gt;Now let’s get &lt;code&gt;at://danabra.mov/sh.tangled.feed.star/3m23ddgjpgn22&lt;/code&gt;:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;The &lt;code&gt;@danabra.mov&lt;/code&gt;handle resolves to&lt;code&gt;did:plc:fpruhuo22xkm5o7ttr2ktxdo&lt;/code&gt;.&lt;/item&gt;
      &lt;item&gt;The DID Document for &lt;code&gt;did:plc:fpruhuo22xkm5o7ttr2ktxdo&lt;/code&gt;points at&lt;code&gt;https://morel.us-east.host.bsky.network&lt;/code&gt;as the current hosting.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Let’s hit it:&lt;/p&gt;
    &lt;p&gt;And there you have it:&lt;/p&gt;
    &lt;p&gt;And that’s how you resolve an &lt;code&gt;at://&lt;/code&gt; URI.&lt;/p&gt;
    &lt;p&gt;Exercise: In the record above, the &lt;code&gt;subject&lt;/code&gt; is a link to another record. Figure out the handle of its owner and the contents of that record. Use pdsls to check your answer.&lt;/p&gt;
    &lt;head rend="h3"&gt;In Conclusion&lt;/head&gt;
    &lt;p&gt;To resolve an arbitrary &lt;code&gt;at://&lt;/code&gt; URI, you need to follow three steps:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Resolve the handle to an identity (using DNS and/or HTTPS).&lt;/item&gt;
      &lt;item&gt;Resolve that identity to a hosting (using the DID Document).&lt;/item&gt;
      &lt;item&gt;Request the JSON from that hosting (by hitting it with &lt;code&gt;getRecord&lt;/code&gt;).&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;If you’re building a client app or a small project, an SDK will handle all of this for you. However, for good performance, you’ll want to hit a resolution cache instead of doing DNS/HTTPS lookups on every request. QuickDID is one such cache. You can also check out the pdsls source to see how exactly it handles resolution.&lt;/p&gt;
    &lt;p&gt;In practice, a lot of apps don’t end up needing to resolve &lt;code&gt;at://&lt;/code&gt; URIs or load JSON records because they receive data from the network via a websocket and aggregate it in a local database. If that’s your approach, you’ll still use the &lt;code&gt;at://&lt;/code&gt; URIs as unique identifiers for user-created data, but the data itself will get pushed to you rather than pulled by you. Still, it’s useful to know that you can fetch it on demand.&lt;/p&gt;
    &lt;p&gt;The AT protocol is fundamentally an abstraction over HTTP, DNS, and JSON. But by standardizing how these pieces fit together—putting the user in the authority position, separating identity from hosting, and making data portable—it turns the web into a place where your content belongs to you, not to the apps that display it.&lt;/p&gt;
    &lt;p&gt;There’s more to explore in the atmosphere, but now you know where it’s &lt;code&gt;at://&lt;/code&gt;.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://overreacted.io/where-its-at/"/><published>2025-10-02T20:31:43+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45463319</id><title>I turned the Lego Game Boy into a working Game Boy</title><updated>2025-10-04T15:08:36.064543+00:00</updated><content>&lt;doc fingerprint="15cf6c54ebc4b5f9"&gt;
  &lt;main&gt;
    &lt;head rend="h1"&gt;I turned the Lego Game Boy into a working Game Boy part. 1&lt;/head&gt;
    &lt;p&gt;Through my documentation of Game Boy boards, I have drawn up schematics of each device. I know them pretty well. Check out my board scan wiki https://wiki.nataliethenerd.com/&lt;/p&gt;
    &lt;p&gt;I jokingly made this tweet when the kit was announced, but decided to actually do it.&lt;/p&gt;
    &lt;p&gt;I know from experience of routing Game Boy CPU PCBs that there isn't much to it. There's the RAM, CPU, some decoupling capacitors and power regulation. &lt;lb/&gt;Note: I went with the MGB (Pocket) CPU rather than DMG for a couple of reasons.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;They are pretty much the same&lt;/item&gt;
      &lt;item&gt;I have more of them&lt;/item&gt;
      &lt;item&gt;They are cheaper and easier to get. This opens up the project to more people&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The DMG CPU has external VRAM, the MGB CPU has internal VRAM and in a very space conscious build that was the biggest factor.&lt;/p&gt;
    &lt;head rend="h2"&gt;Pre Planning&lt;/head&gt;
    &lt;p&gt;I only had the press pictures to work off. I used the dimensions to scale the image on my PC and from that I got measurements for the screen inserts; since that's where I plan to put the Game Boy.&lt;/p&gt;
    &lt;p&gt;I incorporated the power circuit I use for my Safer Charger boards, changed the power switch to a soft latching power button, added pin outs for the button matrix and audio.&lt;/p&gt;
    &lt;p&gt;I didn't really know what the buttons on the Lego would be like, but the fact that they could be pressed was enough for me to know I could implement them. At the moment I have them wired up to custom 3D printed *toy brick* parts. Same with the USB C&lt;/p&gt;
    &lt;p&gt;I am currently working on refining the board now I have the Lego build in my hands. This project will be released in full once I am finished with it - so stay tuned!&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://blog.nataliethenerd.com/i-turned-the-lego-game-boy-into-a-working-game-boy-part-1/"/><published>2025-10-03T14:18:56+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45464429</id><title>Jeff Bezos says AI is in a bubble but society will get 'gigantic' benefits</title><updated>2025-10-04T15:08:35.673445+00:00</updated><content>&lt;doc fingerprint="49cf831b4a053dfc"&gt;
  &lt;main&gt;
    &lt;p&gt;TURIN, Italy — Artificial intelligence is currently in an "industrial bubble" but the technology is "real" and will bring big benefits to society, Amazon Founder Jeff Bezos said on Friday.&lt;/p&gt;
    &lt;p&gt;The term bubble usually refers to a period of inflated stock prices or valuations of companies that have disconnected from the fundamentals of a business. One of the most famous bubbles that burst was the 2000 dotcom crash where the value of internet companies plummeted.&lt;/p&gt;
    &lt;p&gt;Exor CEO John Elkann asked Bezos on stage at Italian Tech Week in Turin, Italy whether there were signs that the current AI industry is in bubble.&lt;/p&gt;
    &lt;p&gt;"This is a kind of industrial bubble," the Amazon founder said.&lt;/p&gt;
    &lt;p&gt;Bezos laid out some of the key characteristics of bubbles, noting that when they happen, stock prices are "disconnected from the fundamentals" of a business.&lt;/p&gt;
    &lt;p&gt;"The second thing that happens is that people get very excited like they are today about artificial intelligence," Bezos added.&lt;/p&gt;
    &lt;p&gt;During bubbles, every experiment or idea gets funded, he told the audience.&lt;/p&gt;
    &lt;p&gt;"The good ideas and the bad ideas. And investors have a hard time in the middle of this excitement, distinguishing between the good ideas and the bad ideas. And that's also probably happening today," Bezos said.&lt;/p&gt;
    &lt;p&gt;"But that doesn't mean anything that is happening isn't real. AI is real, and it is going to change every industry."&lt;/p&gt;
    &lt;p&gt;Bezos gave the example of a six-person company receiving billions of dollars of funding. This is "very unusual behavior" and yet this kind of activity is happening today, he said without making it clear what company he was referring to.&lt;/p&gt;
    &lt;p&gt;The billionaire however, said that ultimately industrial bubbles could be positive. He pointed to the biotech and pharmaceutical company bubble in the 1990s, which led to the development of some life-saving drugs even though many companies eventually went bust.&lt;/p&gt;
    &lt;p&gt;"The [bubbles] that are industrial are not nearly as bad, it can even be good, because when the dust settles and you see who are the winners, societies benefits from those inventions," Bezos said.&lt;/p&gt;
    &lt;p&gt;"That is what is going to happen here too. This is real, the benefits to society from AI are going to be gigantic."&lt;/p&gt;
    &lt;head rend="h2"&gt;AI bubble warnings grow&lt;/head&gt;
    &lt;p&gt;Bezos is not the only major business figure warning about an AI bubble. In August, OpenAI CEO Sam Altman reportedly said the AI market is in a bubble, and many investors have also raised the issue.&lt;/p&gt;
    &lt;p&gt;Goldman Sachs CEO David Solomon on Friday expressed some concerns about stock market levels amid the AI hype.&lt;/p&gt;
    &lt;p&gt;"When [investors are] excited, they tend to think about the good things that can go right, and they diminish the things you should be skeptical about that can go wrong ... There will be a reset, there will be a check at some point, there will be a drawdown," Solomon said at Italian Tech Week. "The extent of that will depend on how long this [bull run] goes."&lt;/p&gt;
    &lt;p&gt;Karim Moussalem, chief investment officer of equities at Selwood Asset Management, said last week that the "AI trade is beginning to resemble one of the great speculative manias of market history."&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://www.cnbc.com/2025/10/03/jeff-bezos-ai-in-an-industrial-bubble-but-society-to-benefit.html"/><published>2025-10-03T16:00:00+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45466086</id><title>PEP 810 – Explicit lazy imports</title><updated>2025-10-04T15:08:34.695375+00:00</updated><content>&lt;doc fingerprint="d0324610caa1e4dc"&gt;
  &lt;main&gt;
    &lt;head rend="h1"&gt;PEP 810 – Explicit lazy imports&lt;/head&gt;
    &lt;list rend="dl"&gt;
      &lt;item rend="dt-1"&gt;Author:&lt;/item&gt;
      &lt;item rend="dd-1"&gt;Pablo Galindo &amp;lt;pablogsal at python.org&amp;gt;, Germán Méndez Bravo &amp;lt;german.mb at gmail.com&amp;gt;, Thomas Wouters &amp;lt;thomas at python.org&amp;gt;, Dino Viehland &amp;lt;dinoviehland at gmail.com&amp;gt;, Brittany Reynoso &amp;lt;brittanyrey at gmail.com&amp;gt;, Noah Kim &amp;lt;noahbkim at gmail.com&amp;gt;, Tim Stumbaugh &amp;lt;me at tjstum.com&amp;gt;&lt;/item&gt;
      &lt;item rend="dt-2"&gt;Discussions-To:&lt;/item&gt;
      &lt;item rend="dd-2"&gt;Discourse thread&lt;/item&gt;
      &lt;item rend="dt-3"&gt;Status:&lt;/item&gt;
      &lt;item rend="dd-3"&gt;Draft&lt;/item&gt;
      &lt;item rend="dt-4"&gt;Type:&lt;/item&gt;
      &lt;item rend="dd-4"&gt;Standards Track&lt;/item&gt;
      &lt;item rend="dt-5"&gt;Created:&lt;/item&gt;
      &lt;item rend="dd-5"&gt;02-Oct-2025&lt;/item&gt;
      &lt;item rend="dt-6"&gt;Python-Version:&lt;/item&gt;
      &lt;item rend="dd-6"&gt;3.15&lt;/item&gt;
      &lt;item rend="dt-7"&gt;Post-History:&lt;/item&gt;
      &lt;item rend="dd-7"&gt;03-Oct-2025&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h2"&gt;Abstract&lt;/head&gt;
    &lt;p&gt;This PEP introduces syntax for lazy imports as an explicit language feature:&lt;/p&gt;
    &lt;code&gt;lazy import json
lazy from json import dumps
&lt;/code&gt;
    &lt;p&gt;Lazy imports defer the loading and execution of a module until the first time the imported name is used, in contrast to ‘normal’ imports, which eagerly load and execute a module at the point of the import statement.&lt;/p&gt;
    &lt;p&gt;By allowing developers to mark individual imports as lazy with explicit syntax, Python programs can reduce startup time, memory usage, and unnecessary work. This is particularly beneficial for command-line tools, test suites, and applications with large dependency graphs.&lt;/p&gt;
    &lt;p&gt;This proposal preserves full backwards compatibility: normal import statements remain unchanged, and lazy imports are enabled only where explicitly requested.&lt;/p&gt;
    &lt;head rend="h2"&gt;Motivation&lt;/head&gt;
    &lt;p&gt;The dominant convention in Python code is to place all imports at the module level, typically at the beginning of the file. This avoids repetition, makes import dependencies clear and minimizes runtime overhead by only evaluating an import statement once per module.&lt;/p&gt;
    &lt;p&gt;A major drawback with this approach is that importing the first module for an execution of Python (the “main” module) often triggers an immediate cascade of imports, and optimistically loads many dependencies that may never be used. The effect is especially costly for command-line tools with multiple subcommands, where even running the command with &lt;code&gt;--help&lt;/code&gt; can load dozens of
unnecessary modules and take several seconds. This basic example demonstrates
what must be loaded just to get helpful feedback to the user on how to run the
program at all. Inefficiently, the user incurs this overhead again when they
figure out the command they want and invoke the program “for real.”&lt;/p&gt;
    &lt;p&gt;A somewhat common way to delay imports is to move the imports into functions (inline imports), but this practice requires more work to implement and maintain, and can be subverted by a single inadvertent top-level import. Additionally, it obfuscates the full set of dependencies for a module. Analysis of the Python standard library shows that approximately 17% of all imports outside tests (nearly 3500 total imports across 730 files) are already placed inside functions or methods specifically to defer their execution. This demonstrates that developers are already manually implementing lazy imports in performance-sensitive code, but doing so requires scattering imports throughout the codebase and makes the full dependency graph harder to understand at a glance.&lt;/p&gt;
    &lt;p&gt;The standard library provides the &lt;code&gt;LazyLoader&lt;/code&gt; class to
solve some of these inefficiency problems. It permits imports at the module
level to work mostly like inline imports do. Many scientific Python
libraries have adopted a similar pattern, formalized in
SPEC 1.
There’s also the third-party lazy_loader package, yet another
implementation of lazy imports. Imports used solely for static type checking
are another source of potentially unneeded imports, and there are similarly
disparate approaches to minimizing the overhead. The various approaches used
here to defer or remove eager imports do not cover all potential use-cases for
a general lazy import mechanism. There is no clear standard, and there are
several drawbacks including runtime overhead in unexpected places, or worse
runtime introspection.&lt;/p&gt;
    &lt;p&gt;This proposal introduces syntax for lazy imports with a design that is local, explicit, controlled, and granular. Each of these qualities is essential to making the feature predictable and safe to use in practice.&lt;/p&gt;
    &lt;p&gt;The behavior is local: laziness applies only to the specific import marked with the &lt;code&gt;lazy&lt;/code&gt; keyword, and it does not cascade recursively into other
imports. This ensures that developers can reason about the effect of laziness
by looking only at the line of code in front of them, without worrying about
whether imported modules will themselves behave differently. A &lt;code&gt;lazy import&lt;/code&gt;
is an isolated decision each time it is used, not a global shift in semantics.&lt;/p&gt;
    &lt;p&gt;The semantics are explicit. When a name is imported lazily, the binding is created in the importing module immediately, but the target module is not loaded until the first time the name is accessed. After this point, the binding is indistinguishable from one created by a normal import. This clarity reduces surprises and makes the feature accessible to developers who may not be deeply familiar with Python’s import machinery.&lt;/p&gt;
    &lt;p&gt;Lazy imports are controlled, in the sense that deferred loading is only triggered by the importing code itself. In the general case, a library will only experience lazy imports if its own authors choose to mark them as such. This avoids shifting responsibility onto downstream users and prevents accidental surprises in library behavior. Since library authors typically manage their own import subgraphs, they retain predictable control over when and how laziness is applied.&lt;/p&gt;
    &lt;p&gt;The mechanism is also granular. It is introduced through explicit syntax on individual imports, rather than a global flag or implicit setting. This allows developers to adopt it incrementally, starting with the most performance-sensitive areas of a codebase. As this feature is introduced to the community, we want to make the experience of onboarding optional, progressive, and adaptable to the needs of each project.&lt;/p&gt;
    &lt;p&gt;Lazy imports provide several concrete advantages:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Command-line tools are often invoked directly by a user, so latency – in particular startup latency – is quite noticeable. These programs are also typically short-lived processes (contrasted with, e.g., a web server). With lazy imports, only the code paths actually reached will import a module. This can reduce startup time by 50-70% in practice, providing a significant improvement to a common user experience and improving Python’s competitiveness in domains where fast startup matters most.&lt;/item&gt;
      &lt;item&gt;Type annotations frequently require imports that are never used at runtime. The common workaround is to wrap them in &lt;code&gt;if TYPE_CHECKING:&lt;/code&gt;blocks [1]. With lazy imports, annotation-only imports impose no runtime penalty, eliminating the need for such guards and making annotated codebases cleaner.&lt;/item&gt;
      &lt;item&gt;Large applications often import thousands of modules, and each module creates function and type objects, incurring memory costs. In long-lived processes, this noticeably raises baseline memory usage. Lazy imports defer these costs until a module is needed, keeping unused subsystems unloaded. Memory savings of 30-40% have been observed in real workloads.&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h2"&gt;Rationale&lt;/head&gt;
    &lt;p&gt;The design of this proposal is centered on clarity, predictability, and ease of adoption. Each decision was made to ensure that lazy imports provide tangible benefits without introducing unnecessary complexity into the language or its runtime.&lt;/p&gt;
    &lt;p&gt;It is also worth noting that while this PEP outlines one specific approach, we list alternate implementation strategies for some of the core aspects and semantics of the proposal. If the community expresses a strong preference for a different technical path that still preserves the same core semantics or there is fundamental disagreement over the specific option, we have included the brainstorming we have already completed in preparation for this proposal as reference.&lt;/p&gt;
    &lt;p&gt;The choice to introduce a new &lt;code&gt;lazy&lt;/code&gt; keyword reflects the need for explicit
syntax. Import behavior is too fundamental to be left implicit or hidden
behind global flags or environment variables. By marking laziness directly at
the import site, the intent is immediately visible to both readers and tools.
This avoids surprises, reduces the cognitive burden of reasoning about
imports, and keeps lazy import semantics in line with Python’s tradition of
explicitness.&lt;/p&gt;
    &lt;p&gt;Another important decision is to represent lazy imports with proxy objects in the module’s namespace, rather than by modifying dictionary lookup. Earlier approaches experimented with embedding laziness into dictionaries, but this blurred abstractions and risked affecting unrelated parts of the runtime. The dictionary is a fundamental data structure in Python – literally every object is built on top of dicts – and adding hooks to dictionaries would prevent critical optimizations and complicate the entire runtime. The proxy approach is simpler: it behaves like a placeholder until first use, at which point it resolves the import and rebinds the name. From then on, the binding is indistinguishable from a normal import. This makes the mechanism easy to explain and keeps the rest of the interpreter unchanged.&lt;/p&gt;
    &lt;p&gt;Compatibility for library authors was also a key concern. Many maintainers need a migration path that allows them to support both new and old versions of Python at once. For this reason, the proposal includes the &lt;code&gt;__lazy_modules__&lt;/code&gt; global as a transitional mechanism. A module can
declare which imports should be treated as lazy (by listing the module names
as strings), and on Python 3.15 or later those imports will become lazy
automatically, as if they were imported with the &lt;code&gt;lazy&lt;/code&gt; keyword. On earlier
versions the declaration is ignored, leaving imports eager. This gives authors
a practical bridge until they can rely on the keyword as the canonical syntax.&lt;/p&gt;
    &lt;p&gt;Finally, the feature is designed to be adopted incrementally. Nothing changes unless a developer explicitly opts in, and adoption can begin with just a few imports in performance-sensitive areas. This mirrors the experience of gradual typing in Python: a mechanism that can be introduced progressively, without forcing projects to commit globally from day one. Notably, the adoption can also be done from the “outside in”, permitting CLI authors to introduce lazy imports and speed up user-facing tools, without requiring changes to every library the tool might use.&lt;/p&gt;
    &lt;head rend="h3"&gt;Other design decisions&lt;/head&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;The scope of laziness is deliberately local and non-recursive. A lazy import only affects the specific statement where it appears; it does not cascade into other modules or submodules. This choice is crucial for predictability. When developers read code, they can reason about import behavior line by line, without worrying about hidden laziness deeper in the dependency graph. The result is a feature that is powerful but still easy to understand in context.&lt;/item&gt;
      &lt;item&gt;In addition, it is useful to provide a mechanism to activate or deactivate lazy imports at a global level. While the primary design centers on explicit syntax, there are scenarios – such as large applications, testing environments, or frameworks – where enabling laziness consistently across many modules provides the most benefit. A global switch makes it easy to experiment with or enforce consistent behavior, while still working in combination with the filtering API to respect exclusions or tool-specific configuration. This ensures that global adoption can be practical without reducing flexibility or control.&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h2"&gt;Specification&lt;/head&gt;
    &lt;head rend="h3"&gt;Grammar&lt;/head&gt;
    &lt;p&gt;A new soft keyword &lt;code&gt;lazy&lt;/code&gt; is added. A soft keyword is a context-sensitive
keyword that only has special meaning in specific grammatical contexts;
elsewhere it can be used as a regular identifier (e.g., as a variable name).
The &lt;code&gt;lazy&lt;/code&gt; keyword only has special meaning when it appears before import
statements:&lt;/p&gt;
    &lt;code&gt;import_name:
    | 'lazy'? 'import' dotted_as_names

import_from:
    | 'lazy'? 'from' ('.' | '...')* dotted_name 'import' import_from_targets
    | 'lazy'? 'from' ('.' | '...')+ 'import' import_from_targets
&lt;/code&gt;
    &lt;head rend="h4"&gt;Syntax restrictions&lt;/head&gt;
    &lt;p&gt;The soft keyword is only allowed at the global (module) level, not inside functions, class bodies, with &lt;code&gt;try&lt;/code&gt;/&lt;code&gt;with&lt;/code&gt; blocks, or &lt;code&gt;import *&lt;/code&gt;. Import
statements that use the soft keyword are potentially lazy. Imports that
can’t be lazy are unaffected by the global lazy imports flag, and instead are
always eager.&lt;/p&gt;
    &lt;p&gt;Examples of syntax errors:&lt;/p&gt;
    &lt;code&gt;# SyntaxError: lazy import not allowed inside functions
def foo():
    lazy import json

# SyntaxError: lazy import not allowed inside classes
class Bar:
    lazy import json

# SyntaxError: lazy import not allowed inside try/except blocks
try:
    lazy import json
except ImportError:
    pass

# SyntaxError: lazy import not allowed inside with blocks
with suppress(ImportError):
    lazy import json

# SyntaxError: lazy from ... import * is not allowed
lazy from json import *
&lt;/code&gt;
    &lt;head rend="h3"&gt;Semantics&lt;/head&gt;
    &lt;p&gt;When the &lt;code&gt;lazy&lt;/code&gt; keyword is used, the import becomes potentially lazy.
Unless lazy imports are disabled or suppressed (see below), the module is not
loaded immediately at the import statement; instead, a lazy proxy object is
created and bound to the name. The actual module is loaded on first use of
that name.&lt;/p&gt;
    &lt;p&gt;Example:&lt;/p&gt;
    &lt;code&gt;import sys

lazy import json

print('json' in sys.modules)  # False - module not loaded yet

# First use triggers loading
result = json.dumps({"hello": "world"})

print('json' in sys.modules)  # True - now loaded
&lt;/code&gt;
    &lt;p&gt;A module may contain a &lt;code&gt;__lazy_modules__&lt;/code&gt; attribute, which is a
sequence of fully qualified module names (strings) to make potentially lazy
(as if the &lt;code&gt;lazy&lt;/code&gt; keyword was used). This attribute is checked on each
&lt;code&gt;import&lt;/code&gt; statement to determine whether the import should be made
potentially lazy. When a module is made lazy this way, from-imports using
that module are also lazy, but not necessarily imports of sub-modules.&lt;/p&gt;
    &lt;p&gt;The normal (non-lazy) import statement will check the global lazy imports flag. If it is “enabled”, all imports are potentially lazy (except for imports that can’t be lazy, as mentioned above.)&lt;/p&gt;
    &lt;p&gt;Example:&lt;/p&gt;
    &lt;code&gt;__lazy_modules__ = ["json"]
import json
print('json' in sys.modules)  # False
result = json.dumps({"hello": "world"})
print('json' in sys.modules)  # True
&lt;/code&gt;
    &lt;p&gt;If the global lazy imports flag is set to “disabled”, no potentially lazy import is ever imported lazily, and the behavior is equivalent to a regular import statement: the import is eager (as if the lazy keyword was not used).&lt;/p&gt;
    &lt;p&gt;For a potentially lazy import, the lazy imports filter (if set) is called with the name of the module doing the import, the name of the module being imported, and (if applicable) the fromlist. If the lazy import filter returns &lt;code&gt;True&lt;/code&gt;, the potentially lazy import becomes a lazy import. Otherwise, the
import is not lazy, and the normal (eager) import continues.&lt;/p&gt;
    &lt;head rend="h3"&gt;Lazy import mechanism&lt;/head&gt;
    &lt;p&gt;When an import is lazy, &lt;code&gt;__lazy_import__&lt;/code&gt; is called instead of
&lt;code&gt;__import__&lt;/code&gt;. &lt;code&gt;__lazy_import__&lt;/code&gt; has the same function signature as
&lt;code&gt;__import__&lt;/code&gt;. It adds the module name to &lt;code&gt;sys.lazy_modules&lt;/code&gt;, a set of
fully-qualified module names which have been lazily imported at some point
(primarily for diagnostics and introspection), and returns a “lazy module
object.”&lt;/p&gt;
    &lt;p&gt;The implementation of &lt;code&gt;from ... import&lt;/code&gt; (the &lt;code&gt;IMPORT_FROM&lt;/code&gt; bytecode
implementation) checks if the module it’s fetching from is a lazy module
object, and if so, returns a lazy object for each name instead.&lt;/p&gt;
    &lt;p&gt;The end result of this process is that lazy imports (regardless of how they are enabled) result in lazy objects being assigned to global variables.&lt;/p&gt;
    &lt;p&gt;Lazy module objects do not appear in &lt;code&gt;sys.modules&lt;/code&gt;, they’re just listed in
the &lt;code&gt;sys.lazy_modules&lt;/code&gt; set. Under normal operation lazy objects should only
end up stored in global variables, and the common ways to access those
variables (regular variable access, module attributes) will resolve lazy
imports (“reify”) and replace them when they’re accessed.&lt;/p&gt;
    &lt;p&gt;It is still possible to expose lazy objects through other means, like debuggers. This is not considered a problem.&lt;/p&gt;
    &lt;head rend="h3"&gt;Reification&lt;/head&gt;
    &lt;p&gt;When a lazy object is first used, it needs to be reified. This means resolving the import at that point in the program and replacing the lazy object with the concrete one. Reification imports the module in the same way as it would have been if it had been imported eagerly, barring intervening changes to the import system (e.g. to &lt;code&gt;sys.path&lt;/code&gt;, &lt;code&gt;sys.meta_path&lt;/code&gt;, &lt;code&gt;sys.path_hooks&lt;/code&gt; or
&lt;code&gt;__import__&lt;/code&gt;).&lt;/p&gt;
    &lt;p&gt;Reification still calls &lt;code&gt;__import__&lt;/code&gt; to resolve the import. When the module
is first reified, it’s removed from &lt;code&gt;sys.lazy_modules&lt;/code&gt; (even if there are
still other unreified lazy references to it). When a package is reified and
submodules in the package were also previously lazily imported, those
submodules are not automatically reified but they are added to the reified
package’s globals (unless the package already assigned something else to the
name of the submodule).&lt;/p&gt;
    &lt;p&gt;If reification fails (e.g., due to an &lt;code&gt;ImportError&lt;/code&gt;), the exception is
enhanced with chaining to show both where the lazy import was defined and
where it was first accessed (even though it propagates from the code that
triggered reification). This provides clear debugging information:&lt;/p&gt;
    &lt;code&gt;# app.py - has a typo in the import
lazy from json import dumsp  # Typo: should be 'dumps'

print("App started successfully")
print("Processing data...")

# Error occurs here on first use
result = dumsp({"key": "value"})
&lt;/code&gt;
    &lt;p&gt;The traceback shows both locations:&lt;/p&gt;
    &lt;code&gt;App started successfully
Processing data...
Traceback (most recent call last):
  File "app.py", line 2, in &amp;lt;module&amp;gt;
    lazy from json import dumsp
ImportError: deferred import of 'json.dumsp' raised an exception during resolution

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "app.py", line 8, in &amp;lt;module&amp;gt;
    result = dumsp({"key": "value"})
             ^^^^^
ImportError: cannot import name 'dumsp' from 'json'. Did you mean: 'dump'?
&lt;/code&gt;
    &lt;p&gt;This exception chaining clearly shows: (1) where the lazy import was defined, (2) that it was deferred, and (3) where the actual access happened that triggered the error.&lt;/p&gt;
    &lt;p&gt;Reification does not automatically occur when a module that was previously lazily imported is subsequently eagerly imported. Reification does not immediately resolve all lazy objects (e.g. &lt;code&gt;lazy from&lt;/code&gt; statements) that
referenced the module. It only resolves the lazy object being accessed.&lt;/p&gt;
    &lt;p&gt;Accessing a lazy object (from a global variable or a module attribute) reifies the object. Accessing a module’s &lt;code&gt;__dict__&lt;/code&gt; reifies all lazy objects in
that module. Operations that indirectly access &lt;code&gt;__dict__&lt;/code&gt; (such as
&lt;code&gt;dir()&lt;/code&gt;) also trigger this behavior.&lt;/p&gt;
    &lt;p&gt;Example using &lt;code&gt;__dict__&lt;/code&gt; from external code:&lt;/p&gt;
    &lt;code&gt;# my_module.py
import sys
lazy import json

print('json' in sys.modules)  # False - still lazy

# main.py
import sys
import my_module

# Accessing __dict__ from external code DOES reify all lazy imports
d = my_module.__dict__

print('json' in sys.modules)  # True - reified by __dict__ access
print(type(d['json']))  # &amp;lt;class 'module'&amp;gt;
&lt;/code&gt;
    &lt;p&gt;However, calling &lt;code&gt;globals()&lt;/code&gt; does not trigger reification – it returns
the module’s dictionary, and accessing lazy objects through that dictionary
still returns lazy proxy objects that need to be manually reified upon use. A
lazy object can be resolved explicitly by calling the &lt;code&gt;get&lt;/code&gt; method. Other,
more indirect ways of accessing arbitrary globals (e.g. inspecting
&lt;code&gt;frame.f_globals&lt;/code&gt;) also do not reify all the objects.&lt;/p&gt;
    &lt;p&gt;Example using &lt;code&gt;globals()&lt;/code&gt;:&lt;/p&gt;
    &lt;code&gt;import sys
lazy import json

# Calling globals() does NOT trigger reification
g = globals()

print('json' in sys.modules)  # False - still lazy
print(type(g['json']))  # &amp;lt;class 'lazy_import'&amp;gt;

# Explicitly reify using the get() method
resolved = g['json'].get()

print(type(resolved))  # &amp;lt;class 'module'&amp;gt;
print('json' in sys.modules)  # True - now loaded
&lt;/code&gt;
    &lt;head rend="h2"&gt;Reference Implementation&lt;/head&gt;
    &lt;p&gt;A reference implementation is available at: https://github.com/LazyImportsCabal/cpython/tree/lazy&lt;/p&gt;
    &lt;head rend="h3"&gt;Bytecode and adaptive specialization&lt;/head&gt;
    &lt;p&gt;Lazy imports are implemented through modifications to four bytecode instructions: &lt;code&gt;IMPORT_NAME&lt;/code&gt;, &lt;code&gt;IMPORT_FROM&lt;/code&gt;, &lt;code&gt;LOAD_GLOBAL&lt;/code&gt;, and
&lt;code&gt;LOAD_NAME&lt;/code&gt;.&lt;/p&gt;
    &lt;p&gt;The &lt;code&gt;lazy&lt;/code&gt; syntax sets a flag in the &lt;code&gt;IMPORT_NAME&lt;/code&gt; instruction’s oparg
(&lt;code&gt;oparg &amp;amp; 0x01&lt;/code&gt;). The interpreter checks this flag and calls
&lt;code&gt;_PyEval_LazyImportName()&lt;/code&gt; instead of &lt;code&gt;_PyEval_ImportName()&lt;/code&gt;, creating a
lazy import object rather than executing the import immediately. The
&lt;code&gt;IMPORT_FROM&lt;/code&gt; instruction checks whether its source is a lazy import
(&lt;code&gt;PyLazyImport_CheckExact()&lt;/code&gt;) and creates a lazy object for the attribute
rather than accessing it immediately.&lt;/p&gt;
    &lt;p&gt;When a lazy object is accessed, it must be reified. The &lt;code&gt;LOAD_GLOBAL&lt;/code&gt;
instruction (used in function scopes) and &lt;code&gt;LOAD_NAME&lt;/code&gt; instruction (used at
module and class level) both check whether the object being loaded is a lazy
import. If so, they call &lt;code&gt;_PyImport_LoadLazyImportTstate()&lt;/code&gt; to perform the
actual import and store the module in &lt;code&gt;sys.modules&lt;/code&gt;.&lt;/p&gt;
    &lt;p&gt;This check incurs a very small cost on each access. However, Python’s adaptive interpreter can specialize &lt;code&gt;LOAD_GLOBAL&lt;/code&gt; after observing that a lazy import
has been reified. After several executions, &lt;code&gt;LOAD_GLOBAL&lt;/code&gt; becomes
&lt;code&gt;LOAD_GLOBAL_MODULE&lt;/code&gt;, which accesses the module dictionary directly without
checking for lazy imports.&lt;/p&gt;
    &lt;p&gt;Examples of the bytecode generated:&lt;/p&gt;
    &lt;code&gt;lazy import json  # IMPORT_NAME with flag set
&lt;/code&gt;
    &lt;p&gt;Generates:&lt;/p&gt;
    &lt;code&gt;IMPORT_NAME              1 (json + lazy)
&lt;/code&gt;
    &lt;code&gt;lazy from json import dumps  # IMPORT_NAME + IMPORT_FROM
&lt;/code&gt;
    &lt;p&gt;Generates:&lt;/p&gt;
    &lt;code&gt;IMPORT_NAME              1 (json + lazy)
IMPORT_FROM              1 (dumps)
&lt;/code&gt;
    &lt;code&gt;lazy import json
x = json  # Module-level access
&lt;/code&gt;
    &lt;p&gt;Generates:&lt;/p&gt;
    &lt;code&gt;LOAD_NAME                0 (json)
&lt;/code&gt;
    &lt;code&gt;lazy import json

def use_json():
    return json.dumps({})  # Function scope
&lt;/code&gt;
    &lt;p&gt;Before any calls:&lt;/p&gt;
    &lt;code&gt;LOAD_GLOBAL              0 (json)
LOAD_ATTR                2 (dumps)
&lt;/code&gt;
    &lt;p&gt;After several calls, &lt;code&gt;LOAD_GLOBAL&lt;/code&gt; specializes to &lt;code&gt;LOAD_GLOBAL_MODULE&lt;/code&gt;:&lt;/p&gt;
    &lt;code&gt;LOAD_GLOBAL_MODULE       0 (json)
LOAD_ATTR_MODULE         2 (dumps)
&lt;/code&gt;
    &lt;head rend="h3"&gt;Lazy imports filter&lt;/head&gt;
    &lt;p&gt;This PEP adds two new functions to the &lt;code&gt;sys&lt;/code&gt; module to manage the lazy
imports filter:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;sys.set_lazy_imports_filter(func)&lt;/code&gt;- Sets the filter function. The&lt;code&gt;func&lt;/code&gt;parameter must have the signature:&lt;code&gt;func(importer: str, name: str, fromlist: tuple[str, ...] | None) -&amp;gt; bool&lt;/code&gt;&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;sys.get_lazy_imports_filter()&lt;/code&gt;- Returns the currently installed filter function, or&lt;code&gt;None&lt;/code&gt;if no filter is set.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The filter function is called for every potentially lazy import, and must return &lt;code&gt;True&lt;/code&gt; if the import should be lazy. This allows for fine-grained
control over which imports should be lazy, useful for excluding modules with
known side-effect dependencies or registration patterns.&lt;/p&gt;
    &lt;p&gt;The filter mechanism serves as a foundation that tools, debuggers, linters, and other ecosystem utilities can leverage to provide better lazy import experiences. For example, static analysis tools could detect modules with side effects and automatically configure appropriate filters. In the future (out of scope for this PEP), this foundation may enable better ways to declaratively specify which modules are safe for lazy importing, such as package metadata, type stubs with lazy-safety annotations, or configuration files. The current filter API is designed to be flexible enough to accommodate such future enhancements without requiring changes to the core language specification.&lt;/p&gt;
    &lt;p&gt;Example:&lt;/p&gt;
    &lt;code&gt;import sys

def exclude_side_effect_modules(importer, name, fromlist):
    """
    Filter function to exclude modules with import-time side effects.

    Args:
        importer: Name of the module doing the import
        name: Name of the module being imported
        fromlist: Tuple of names being imported (for 'from' imports), or None

    Returns:
        True to allow lazy import, False to force eager import
    """
    # Modules known to have important import-time side effects
    side_effect_modules = {'legacy_plugin_system', 'metrics_collector'}

    if name in side_effect_modules:
        return False  # Force eager import

    return True  # Allow lazy import

# Install the filter
sys.set_lazy_imports_filter(exclude_side_effect_modules)

# These imports are checked by the filter
lazy import data_processor        # Filter returns True -&amp;gt; stays lazy
lazy import legacy_plugin_system  # Filter returns False -&amp;gt; imported eagerly

print('data_processor' in sys.modules)       # False - still lazy
print('legacy_plugin_system' in sys.modules) # True - loaded eagerly

# First use of data_processor triggers loading
result = data_processor.transform(data)
print('data_processor' in sys.modules)       # True - now loaded
&lt;/code&gt;
    &lt;head rend="h3"&gt;Global lazy imports control&lt;/head&gt;
    &lt;p&gt;The global lazy imports flag can be controlled through:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;The &lt;code&gt;-X lazy_imports=&amp;lt;mode&amp;gt;&lt;/code&gt;command-line option&lt;/item&gt;
      &lt;item&gt;The &lt;code&gt;PYTHON_LAZY_IMPORTS=&amp;lt;mode&amp;gt;&lt;/code&gt;environment variable&lt;/item&gt;
      &lt;item&gt;The &lt;code&gt;sys.set_lazy_imports(mode)&lt;/code&gt;function (primarily for testing)&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Where &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; can be:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;"default"&lt;/code&gt;(or unset): Only explicitly marked lazy imports are lazy&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;"enabled"&lt;/code&gt;: All module-level imports (except in&lt;code&gt;try&lt;/code&gt;or&lt;code&gt;with&lt;/code&gt;blocks and&lt;code&gt;import *&lt;/code&gt;) become potentially lazy&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;"disabled"&lt;/code&gt;: No imports are lazy, even those explicitly marked with&lt;code&gt;lazy&lt;/code&gt;keyword&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;When the global flag is set to &lt;code&gt;"enabled"&lt;/code&gt;, all imports at the global level
of all modules are potentially lazy except for those inside a &lt;code&gt;try&lt;/code&gt; or
&lt;code&gt;with&lt;/code&gt; block or any wild card (&lt;code&gt;from ... import *&lt;/code&gt;) import.&lt;/p&gt;
    &lt;p&gt;If the global lazy imports flag is set to &lt;code&gt;"disabled"&lt;/code&gt;, no potentially
lazy import is ever imported lazily, the import filter is never called, and
the behavior is equivalent to a regular &lt;code&gt;import&lt;/code&gt; statement: the import is
eager (as if the lazy keyword was not used).&lt;/p&gt;
    &lt;head rend="h2"&gt;Backwards Compatibility&lt;/head&gt;
    &lt;p&gt;Lazy imports are opt-in. Existing programs continue to run unchanged unless a project explicitly enables laziness (via &lt;code&gt;lazy&lt;/code&gt; syntax,
&lt;code&gt;__lazy_modules__&lt;/code&gt;, or an interpreter-wide switch).&lt;/p&gt;
    &lt;head rend="h3"&gt;Unchanged semantics&lt;/head&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Regular &lt;code&gt;import&lt;/code&gt;and&lt;code&gt;from ... import ...&lt;/code&gt;statements remain eager unless explicitly made potentially lazy by the local or global mechanisms provided.&lt;/item&gt;
      &lt;item&gt;Dynamic import APIs remain eager and unchanged: &lt;code&gt;__import__()&lt;/code&gt;and&lt;code&gt;importlib.import_module()&lt;/code&gt;.&lt;/item&gt;
      &lt;item&gt;Import hooks and loaders continue to run under the standard import protocol when a lazy object is reified.&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h3"&gt;Observable behavioral shifts (opt-in only)&lt;/head&gt;
    &lt;p&gt;These changes are limited to bindings explicitly made lazy:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Error timing. Exceptions that would have occurred during an eager import (for example &lt;code&gt;ImportError&lt;/code&gt;or&lt;code&gt;AttributeError&lt;/code&gt;for a missing member) now occur at the first use of the lazy name.&lt;quote&gt;# With eager import - error at import statement import broken_module # ImportError raised here # With lazy import - error deferred lazy import broken_module print("Import succeeded") broken_module.foo() # ImportError raised here on first use&lt;/quote&gt;&lt;/item&gt;
      &lt;item&gt;Side-effect timing. Import-time side effects in lazily imported modules occur at first use of the binding, not at module import time.&lt;/item&gt;
      &lt;item&gt;Import order. Because modules are imported on first use, the order in which modules are imported may differ from how they appear in code.&lt;/item&gt;
      &lt;item&gt;Presence in ``sys.modules``. A lazily imported module does not appear in &lt;code&gt;sys.modules&lt;/code&gt;until first use. After reification, it must appear in&lt;code&gt;sys.modules&lt;/code&gt;. If some other code eagerly imports the same module before first use, the lazy binding resolves to that existing (lazy) module object when it is first used.&lt;/item&gt;
      &lt;item&gt;Proxy visibility. Before first use, the bound name refers to a lazy proxy. Indirect introspection that touches the value may observe a proxy lazy object representation. After first use, the name is rebound to the real object and becomes indistinguishable from an eager import.&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h3"&gt;Thread-safety and reification&lt;/head&gt;
    &lt;p&gt;First use of a lazy binding follows the existing import-lock discipline. Exactly one thread performs the import and atomically rebinds the importing module’s global to the resolved object. Concurrent readers thereafter observe the real object.&lt;/p&gt;
    &lt;p&gt;Lazy imports are thread-safe and have no special considerations for free-threading. A module that would normally be imported in the main thread may be imported in a different thread if that thread triggers the first access to the lazy import. This is not a problem: the import lock ensures thread safety regardless of which thread performs the import.&lt;/p&gt;
    &lt;p&gt;Subinterpreters are supported. Each subinterpreter maintains its own &lt;code&gt;sys.lazy_modules&lt;/code&gt; and import state, so lazy imports in one subinterpreter
do not affect others.&lt;/p&gt;
    &lt;head rend="h3"&gt;Typing and tools&lt;/head&gt;
    &lt;p&gt;Type checkers and static analyzers may treat &lt;code&gt;lazy&lt;/code&gt; imports as ordinary
imports for name resolution. At runtime, annotation-only imports can be marked
&lt;code&gt;lazy&lt;/code&gt; to avoid startup overhead. IDEs and debuggers should be prepared to
display lazy proxies before first use and the real objects thereafter.&lt;/p&gt;
    &lt;head rend="h2"&gt;Security Implications&lt;/head&gt;
    &lt;p&gt;There are no known security vulnerabilities introduced by lazy imports.&lt;/p&gt;
    &lt;head rend="h2"&gt;How to Teach This&lt;/head&gt;
    &lt;p&gt;The new &lt;code&gt;lazy&lt;/code&gt; keyword will be documented as part of the language standard.&lt;/p&gt;
    &lt;p&gt;As this feature is opt-in, new Python users should be able to continue using the language as they are used to. For experienced developers, we expect them to leverage lazy imports for the variety of benefits listed above (decreased latency, decreased memory usage, etc) on a case-by-case basis. Developers interested in the performance of their Python binary will likely leverage profiling to understand the import time overhead in their codebase and mark the necessary imports as &lt;code&gt;lazy&lt;/code&gt;. In addition, developers can mark imports
that will only be used for type annotations as &lt;code&gt;lazy&lt;/code&gt;.&lt;/p&gt;
    &lt;p&gt;Below is guidance on how to best take advantage of lazy imports and how to avoid incompatibilities:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;When adopting lazy imports, users should be aware that eliding an import until it is used will result in side effects not being executed. In turn, users should be wary of modules that rely on import time side effects. Perhaps the most common reliance on import side effects is the registry pattern, where population of some external registry happens implicitly during the importing of modules, often via decorators but sometimes implemented via metaclasses or &lt;code&gt;__init_subclass__&lt;/code&gt;. Instead, registries of objects should be constructed via explicit discovery processes (e.g. a well-known function to call).&lt;quote&gt;# Problematic: Plugin registers itself on import # my_plugin.py from plugin_registry import register_plugin @register_plugin("MyPlugin") class MyPlugin: pass # In main code: lazy import my_plugin # Plugin NOT registered yet - module not loaded! # Better: Explicit discovery # plugin_registry.py def discover_plugins(): from my_plugin import MyPlugin register_plugin(MyPlugin) # In main code: plugin_registry.discover_plugins() # Explicit loading&lt;/quote&gt;&lt;/item&gt;
      &lt;item&gt;Always import needed submodules explicitly. It is not enough to rely on a different import to ensure a module has its submodules as attributes. Plainly, unless there is an explicit &lt;code&gt;from . import bar&lt;/code&gt;in&lt;code&gt;foo/__init__.py&lt;/code&gt;, always use&lt;code&gt;import foo.bar; foo.bar.Baz&lt;/code&gt;, not&lt;code&gt;import foo; foo.bar.Baz&lt;/code&gt;. The latter only works (unreliably) because the attribute&lt;code&gt;foo.bar&lt;/code&gt;is added as a side effect of&lt;code&gt;foo.bar&lt;/code&gt;being imported somewhere else.&lt;/item&gt;
      &lt;item&gt;Users who are moving imports into functions to improve startup time, should instead consider keeping them where they are but adding the &lt;code&gt;lazy&lt;/code&gt;keyword. This allows them to keep dependencies clear and avoid the overhead of repeatedly re-resolving the import but will still speed up the program.&lt;quote&gt;# Before: Inline import (repeated overhead) def process_data(data): import json # Re-resolved on every call return json.dumps(data) # After: Lazy import at module level lazy import json def process_data(data): return json.dumps(data) # Loaded once on first call&lt;/quote&gt;&lt;/item&gt;
      &lt;item&gt;Avoid using wild card (star) imports, as those are always eager.&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h2"&gt;FAQ&lt;/head&gt;
    &lt;p&gt;Q: How does this differ from the rejected PEP 690?&lt;/p&gt;
    &lt;p&gt;A: PEP 810 takes an explicit, opt-in approach instead of PEP 690’s implicit global approach. The key differences are:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Explicit syntax: &lt;code&gt;lazy import foo&lt;/code&gt;clearly marks which imports are lazy.&lt;/item&gt;
      &lt;item&gt;Local scope: Laziness only affects the specific import statement, not cascading to dependencies.&lt;/item&gt;
      &lt;item&gt;Simpler implementation: Uses proxy objects instead of modifying core dictionary behavior.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Q: What happens when lazy imports encounter errors?&lt;/p&gt;
    &lt;p&gt;A: Import errors (&lt;code&gt;ImportError&lt;/code&gt;, &lt;code&gt;ModuleNotFoundError&lt;/code&gt;, syntax errors) are
deferred until first use of the lazy name. This is similar to moving an import
into a function. The error will occur with a clear traceback pointing to the
first access of the lazy object.&lt;/p&gt;
    &lt;p&gt;The implementation provides enhanced error reporting through exception chaining. When a lazy import fails during reification, the original exception is preserved and chained, showing both where the import was defined and where it was first used:&lt;/p&gt;
    &lt;code&gt;Traceback (most recent call last):
  File "test.py", line 1, in &amp;lt;module&amp;gt;
    lazy import broken_module
ImportError: deferred import of 'broken_module' raised an exception during resolution

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "test.py", line 3, in &amp;lt;module&amp;gt;
    broken_module.foo()
    ^^^^^^^^^^^^^
  File "broken_module.py", line 2, in &amp;lt;module&amp;gt;
    1/0
ZeroDivisionError: division by zero
&lt;/code&gt;
    &lt;p&gt;Q: How do lazy imports affect modules with import-time side effects?&lt;/p&gt;
    &lt;p&gt;A: Side effects are deferred until first use. This is generally desirable for performance, but may require code changes for modules that rely on import-time registration patterns. We recommend:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Use explicit initialization functions instead of import-time side effects&lt;/item&gt;
      &lt;item&gt;Call initialization functions explicitly when needed&lt;/item&gt;
      &lt;item&gt;Avoid relying on import order for side effects&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Q: Can I use lazy imports with &lt;code&gt;from ... import ...&lt;/code&gt; statements?&lt;/p&gt;
    &lt;p&gt;A: Yes, as long as you don’t use &lt;code&gt;from ... import *&lt;/code&gt;. Both &lt;code&gt;lazy import
foo&lt;/code&gt; and &lt;code&gt;lazy from foo import bar&lt;/code&gt; are supported. The &lt;code&gt;bar&lt;/code&gt; name will be
bound to a lazy object that resolves to &lt;code&gt;foo.bar&lt;/code&gt; on first use.&lt;/p&gt;
    &lt;p&gt;Q: Does &lt;code&gt;lazy from module import Class&lt;/code&gt; load the entire module or just
the class?&lt;/p&gt;
    &lt;p&gt;A: It loads the entire module, not just the class. This is because Python’s import system always executes the complete module file – there’s no mechanism to execute only part of a &lt;code&gt;.py&lt;/code&gt; file. When you first access
&lt;code&gt;Class&lt;/code&gt;, Python:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Loads and executes the entire &lt;code&gt;module.py&lt;/code&gt;file&lt;/item&gt;
      &lt;item&gt;Extracts the &lt;code&gt;Class&lt;/code&gt;attribute from the resulting module object&lt;/item&gt;
      &lt;item&gt;Binds &lt;code&gt;Class&lt;/code&gt;to the name in your namespace&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;This is identical to eager &lt;code&gt;from module import Class&lt;/code&gt; behavior. The only
difference with lazy imports is that steps 1-3 happen on first use instead of
at the import statement.&lt;/p&gt;
    &lt;code&gt;# heavy_module.py
print("Loading heavy_module")  # This ALWAYS runs when module loads

class MyClass:
    pass

class UnusedClass:
    pass  # Also gets defined, even though we don't import it

# app.py
lazy from heavy_module import MyClass

print("Import statement done")  # heavy_module not loaded yet
obj = MyClass()                  # NOW "Loading heavy_module" prints
                                 # (and UnusedClass gets defined too)
&lt;/code&gt;
    &lt;p&gt;Key point: Lazy imports defer when a module loads, not what gets loaded. You cannot selectively load only parts of a module – Python’s import system doesn’t support partial module execution.&lt;/p&gt;
    &lt;p&gt;Q: What about type annotations and &lt;code&gt;TYPE_CHECKING&lt;/code&gt; imports?&lt;/p&gt;
    &lt;p&gt;A: Lazy imports eliminate the common need for &lt;code&gt;TYPE_CHECKING&lt;/code&gt; guards. You
can write:&lt;/p&gt;
    &lt;code&gt;lazy from collections.abc import Sequence, Mapping  # No runtime cost

def process(items: Sequence[str]) -&amp;gt; Mapping[str, int]:
    ...
&lt;/code&gt;
    &lt;p&gt;Instead of:&lt;/p&gt;
    &lt;code&gt;from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from collections.abc import Sequence, Mapping

def process(items: Sequence[str]) -&amp;gt; Mapping[str, int]:
    ...
&lt;/code&gt;
    &lt;p&gt;Q: What’s the performance overhead of lazy imports?&lt;/p&gt;
    &lt;p&gt;A: The overhead is minimal:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Zero overhead after first use thanks to the adaptive interpreter optimizing the slow path away.&lt;/item&gt;
      &lt;item&gt;Small one-time cost to create the proxy object.&lt;/item&gt;
      &lt;item&gt;Reification (first use) has the same cost as a regular import.&lt;/item&gt;
      &lt;item&gt;No ongoing performance penalty unlike &lt;code&gt;importlib.util.LazyLoader&lt;/code&gt;.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Benchmarking with the pyperformance suite shows the implementation is performance neutral when lazy imports are not used.&lt;/p&gt;
    &lt;p&gt;Q: Can I mix lazy and eager imports of the same module?&lt;/p&gt;
    &lt;p&gt;A: Yes. If module &lt;code&gt;foo&lt;/code&gt; is imported both lazily and eagerly in the same
program, the eager import takes precedence and both bindings resolve to the
same module object.&lt;/p&gt;
    &lt;p&gt;Q: How do I migrate existing code to use lazy imports?&lt;/p&gt;
    &lt;p&gt;A: Migration is incremental:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Identify slow-loading modules using profiling tools.&lt;/item&gt;
      &lt;item&gt;Add &lt;code&gt;lazy&lt;/code&gt;keyword to imports that aren’t needed immediately.&lt;/item&gt;
      &lt;item&gt;Test that side-effect timing changes don’t break functionality.&lt;/item&gt;
      &lt;item&gt;Use &lt;code&gt;__lazy_modules__&lt;/code&gt;for compatibility with older Python versions.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Q: What about star imports (&lt;code&gt;from module import *&lt;/code&gt;)?&lt;/p&gt;
    &lt;p&gt;A: Wild card (star) imports cannot be lazy - they remain eager. This is because the set of names being imported cannot be determined without loading the module. Using the &lt;code&gt;lazy&lt;/code&gt; keyword with star imports will be a syntax
error. If lazy imports are globally enabled, star imports will still be eager.&lt;/p&gt;
    &lt;p&gt;Q: How do lazy imports interact with import hooks and custom loaders?&lt;/p&gt;
    &lt;p&gt;A: Import hooks and loaders work normally. When a lazy object is first used, the standard import protocol runs, including any custom hooks or loaders that were in place at reification time.&lt;/p&gt;
    &lt;p&gt;Q: What happens in multi-threaded environments?&lt;/p&gt;
    &lt;p&gt;A: Lazy import reification is thread-safe. Only one thread will perform the actual import, and the binding is atomically updated. Other threads will see either the lazy proxy or the final resolved object.&lt;/p&gt;
    &lt;p&gt;Q: Can I force reification of a lazy import without using it?&lt;/p&gt;
    &lt;p&gt;A: Yes, accessing a module’s &lt;code&gt;__dict__&lt;/code&gt; will reify all lazy objects in that
module. Individual lazy objects can be resolved by calling their &lt;code&gt;get()&lt;/code&gt;
method.&lt;/p&gt;
    &lt;p&gt;Q: What’s the difference between &lt;code&gt;globals()&lt;/code&gt; and &lt;code&gt;mod.__dict__&lt;/code&gt; for lazy imports?&lt;/p&gt;
    &lt;p&gt;A: Calling &lt;code&gt;globals()&lt;/code&gt; returns the module’s dictionary without reifying lazy
imports – you’ll see lazy proxy objects when accessing them through the
returned dictionary. However, accessing &lt;code&gt;mod.__dict__&lt;/code&gt; from external code
reifies all lazy imports in that module first. This design ensures:&lt;/p&gt;
    &lt;code&gt;# In your module:
lazy import json

g = globals()
print(type(g['json']))  # &amp;lt;class 'lazy_import'&amp;gt; - your problem

# From external code:
import sys
mod = sys.modules['your_module']
d = mod.__dict__
print(type(d['json']))  # &amp;lt;class 'module'&amp;gt; - reified for external access
&lt;/code&gt;
    &lt;p&gt;This distinction means adding lazy imports and calling &lt;code&gt;globals()&lt;/code&gt; is your
responsibility to manage, while external code accessing &lt;code&gt;mod.__dict__&lt;/code&gt;
always sees fully loaded modules.&lt;/p&gt;
    &lt;p&gt;Q: Why not use &lt;code&gt;importlib.util.LazyLoader&lt;/code&gt; instead?&lt;/p&gt;
    &lt;p&gt;A: &lt;code&gt;LazyLoader&lt;/code&gt; has significant limitations:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Requires verbose setup code for each lazy import.&lt;/item&gt;
      &lt;item&gt;Has ongoing performance overhead on every attribute access.&lt;/item&gt;
      &lt;item&gt;Doesn’t work well with &lt;code&gt;from ... import&lt;/code&gt;statements.&lt;/item&gt;
      &lt;item&gt;Less clear and standard than dedicated syntax.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Q: Will this break tools like &lt;code&gt;isort&lt;/code&gt; or &lt;code&gt;black&lt;/code&gt;?&lt;/p&gt;
    &lt;p&gt;A: Tools will need updates to recognize the &lt;code&gt;lazy&lt;/code&gt; keyword, but the changes
should be minimal since the import structure remains the same. The keyword
appears at the beginning, making it easy to parse.&lt;/p&gt;
    &lt;p&gt;Q: How do I know if a library is compatible with lazy imports?&lt;/p&gt;
    &lt;p&gt;A: Most libraries should work fine with lazy imports. Libraries that might have issues:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Those with essential import-time side effects (registration, monkey-patching).&lt;/item&gt;
      &lt;item&gt;Those that expect specific import ordering.&lt;/item&gt;
      &lt;item&gt;Those that modify global state during import.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;When in doubt, test lazy imports with your specific use cases.&lt;/p&gt;
    &lt;p&gt;Q: What happens if I globally enable lazy imports mode and a library doesn’t work correctly?&lt;/p&gt;
    &lt;p&gt;A: Note: This is an advanced feature. You can use the lazy imports filter to exclude specific modules that are known to have problematic side effects:&lt;/p&gt;
    &lt;code&gt;import sys

def my_filter(importer, name, fromlist):
    # Don't lazily import modules known to have side effects
    if name in {'problematic_module', 'another_module'}:
        return False  # Import eagerly
    return True  # Allow lazy import

sys.set_lazy_imports_filter(my_filter)
&lt;/code&gt;
    &lt;p&gt;The filter function receives the importer module name, the module being imported, and the fromlist (if using &lt;code&gt;from ... import&lt;/code&gt;). Returning &lt;code&gt;False&lt;/code&gt;
forces an eager import.&lt;/p&gt;
    &lt;p&gt;Alternatively, set the global mode to &lt;code&gt;"disabled"&lt;/code&gt; via &lt;code&gt;-X
lazy_imports=disabled&lt;/code&gt; to turn off all lazy imports for debugging.&lt;/p&gt;
    &lt;p&gt;Q: Can I use lazy imports inside functions?&lt;/p&gt;
    &lt;p&gt;A: No, the &lt;code&gt;lazy&lt;/code&gt; keyword is only allowed at module level. For
function-level lazy loading, use traditional inline imports or move the import
to module level with &lt;code&gt;lazy&lt;/code&gt;.&lt;/p&gt;
    &lt;p&gt;Q: What about forwards compatibility with older Python versions?&lt;/p&gt;
    &lt;p&gt;A: Use the &lt;code&gt;__lazy_modules__&lt;/code&gt; global for compatibility:&lt;/p&gt;
    &lt;code&gt;# Works on Python 3.15+ as lazy, eager on older versions
__lazy_modules__ = ['expensive_module', 'expensive_module_2']
import expensive_module
from expensive_module_2 import MyClass
&lt;/code&gt;
    &lt;p&gt;The &lt;code&gt;__lazy_modules__&lt;/code&gt; attribute is a list of module name strings. When
an import statement is executed, Python checks if the module name being
imported appears in &lt;code&gt;__lazy_modules__&lt;/code&gt;. If it does, the import is
treated as if it had the &lt;code&gt;lazy&lt;/code&gt; keyword (becoming potentially lazy). On
Python versions before 3.15 that don’t support lazy imports, the
&lt;code&gt;__lazy_modules__&lt;/code&gt; attribute is simply ignored and imports proceed
eagerly as normal.&lt;/p&gt;
    &lt;p&gt;This provides a migration path until you can rely on the &lt;code&gt;lazy&lt;/code&gt; keyword. For
maximum predictability, it’s recommended to define &lt;code&gt;__lazy_modules__&lt;/code&gt;
once, before any imports. But as it is checked on each import, it can be
modified between &lt;code&gt;import&lt;/code&gt; statements.&lt;/p&gt;
    &lt;p&gt;Q: How do explicit lazy imports interact with PEP-649/PEP-749&lt;/p&gt;
    &lt;p&gt;A: If an annotation is not stringified, it is an expression that is evaluated at a later time. It will only be resolved if the annotation is accessed. In the example below, the &lt;code&gt;fake_typing&lt;/code&gt; module is only loaded when the user
inspects the &lt;code&gt;__annotations__&lt;/code&gt; dictionary. The &lt;code&gt;fake_typing&lt;/code&gt; module would
also be loaded if the user uses &lt;code&gt;annotationlib.get_annotations()&lt;/code&gt; or
&lt;code&gt;getattr&lt;/code&gt; to access the annotations.&lt;/p&gt;
    &lt;code&gt;lazy from fake_typing import MyFakeType
def foo(x: MyFakeType):
  pass
print(foo.__annotations__)  # Triggers loading the fake_typing module
&lt;/code&gt;
    &lt;p&gt;Q: How do lazy imports interact with &lt;code&gt;dir()&lt;/code&gt;, &lt;code&gt;getattr()&lt;/code&gt;, and
module introspection?&lt;/p&gt;
    &lt;p&gt;A: Accessing lazy imports through normal attribute access or &lt;code&gt;getattr()&lt;/code&gt;
will trigger reification. Calling &lt;code&gt;dir()&lt;/code&gt; on a module will reify all lazy
imports in that module to ensure the directory listing is complete. This is
similar to accessing &lt;code&gt;mod.__dict__&lt;/code&gt;.&lt;/p&gt;
    &lt;code&gt;lazy import json

# Before any access
# json not in sys.modules

# Any of these trigger reification:
dumps_func = json.dumps
dumps_func = getattr(json, 'dumps')
dir(json)
# Now json is in sys.modules
&lt;/code&gt;
    &lt;p&gt;Q: Do lazy imports work with circular imports?&lt;/p&gt;
    &lt;p&gt;A: Lazy imports don’t automatically solve circular import problems. If two modules have a circular dependency, making the imports lazy might help only if the circular reference isn’t accessed during module initialization. However, if either module accesses the other during import time, you’ll still get an error.&lt;/p&gt;
    &lt;p&gt;Example that works (deferred access in functions):&lt;/p&gt;
    &lt;code&gt;# user_model.py
lazy import post_model

class User:
    def get_posts(self):
        # OK - post_model accessed inside function, not during import
        return post_model.Post.get_by_user(self.name)

# post_model.py
lazy import user_model

class Post:
    @staticmethod
    def get_by_user(username):
        return f"Posts by {username}"
&lt;/code&gt;
    &lt;p&gt;This works because neither module accesses the other at module level – the access happens later when &lt;code&gt;get_posts()&lt;/code&gt; is called.&lt;/p&gt;
    &lt;p&gt;Example that fails (access during import):&lt;/p&gt;
    &lt;code&gt;# module_a.py
lazy import module_b

result = module_b.get_value()  # Error! Accessing during import

def func():
    return "A"

# module_b.py
lazy import module_a

result = module_a.func()  # Circular dependency error here

def get_value():
    return "B"
&lt;/code&gt;
    &lt;p&gt;This fails because &lt;code&gt;module_a&lt;/code&gt; tries to access &lt;code&gt;module_b&lt;/code&gt; at import time,
which then tries to access &lt;code&gt;module_a&lt;/code&gt; before it’s fully initialized.&lt;/p&gt;
    &lt;p&gt;The best practice is still to avoid circular imports in your code design.&lt;/p&gt;
    &lt;p&gt;Q: Will lazy imports affect the performance of my hot paths?&lt;/p&gt;
    &lt;p&gt;A: After first use, lazy imports have zero overhead thanks to the adaptive interpreter. The interpreter specializes the bytecode (e.g., &lt;code&gt;LOAD_GLOBAL&lt;/code&gt;
becomes &lt;code&gt;LOAD_GLOBAL_MODULE&lt;/code&gt;) which eliminates the lazy check on subsequent
accesses. This means once a lazy import is reified, accessing it is just as
fast as a normal import.&lt;/p&gt;
    &lt;code&gt;lazy import json

def use_json():
    return json.dumps({"test": 1})

# First call triggers reification
use_json()

# After 2-3 calls, bytecode is specialized
use_json()
use_json()
&lt;/code&gt;
    &lt;p&gt;You can observe the specialization using &lt;code&gt;dis.dis(use_json, adaptive=True)&lt;/code&gt;:&lt;/p&gt;
    &lt;code&gt;=== Before specialization ===
LOAD_GLOBAL              0 (json)
LOAD_ATTR                2 (dumps)

=== After 3 calls (specialized) ===
LOAD_GLOBAL_MODULE       0 (json)
LOAD_ATTR_MODULE         2 (dumps)
&lt;/code&gt;
    &lt;p&gt;The specialized &lt;code&gt;LOAD_GLOBAL_MODULE&lt;/code&gt; and &lt;code&gt;LOAD_ATTR_MODULE&lt;/code&gt; instructions
are optimized fast paths with no overhead for checking lazy imports.&lt;/p&gt;
    &lt;p&gt;Q: What about &lt;code&gt;sys.modules&lt;/code&gt;? When does a lazy import appear there?&lt;/p&gt;
    &lt;p&gt;A: A lazily imported module does not appear in &lt;code&gt;sys.modules&lt;/code&gt; until it’s
reified (first used). Once reified, it appears in &lt;code&gt;sys.modules&lt;/code&gt; just like
any eager import.&lt;/p&gt;
    &lt;code&gt;import sys
lazy import json

print('json' in sys.modules)  # False

result = json.dumps({"key": "value"})  # First use

print('json' in sys.modules)  # True
&lt;/code&gt;
    &lt;p&gt;Q: Why you chose ``lazy`` as the keyword name?&lt;/p&gt;
    &lt;p&gt;A: Not “why”… memorize! :)&lt;/p&gt;
    &lt;head rend="h2"&gt;Alternate Implementation Ideas&lt;/head&gt;
    &lt;p&gt;Here are some alternative design decisions that were considered during the development of this PEP. While the current proposal represents what we believe to be the best balance of simplicity, performance, and maintainability, these alternatives offer different trade-offs that may be valuable for implementers to consider or for future refinements.&lt;/p&gt;
    &lt;head rend="h3"&gt;Leveraging a subclass of dict&lt;/head&gt;
    &lt;p&gt;Instead of updating the internal dict object to directly add the fields needed to support lazy imports, we could create a subclass of the dict object to be used specifically for Lazy Import enablement. This would still be a leaky abstraction though - methods can be called directly such as &lt;code&gt;dict.__getitem__&lt;/code&gt; and it would impact the performance of globals lookup in
the interpreter.&lt;/p&gt;
    &lt;head rend="h3"&gt;Alternate keyword names&lt;/head&gt;
    &lt;p&gt;For this PEP, we decided to propose &lt;code&gt;lazy&lt;/code&gt; for the explicit keyword as it
felt the most familar to those already focused on optimizing import overhead.
We also considered a variety of other options to support explicit lazy
imports. The most compelling alternates were &lt;code&gt;defer&lt;/code&gt; and &lt;code&gt;delay&lt;/code&gt;.&lt;/p&gt;
    &lt;head rend="h2"&gt;Rejected Ideas&lt;/head&gt;
    &lt;head rend="h3"&gt;Modification of the dict object&lt;/head&gt;
    &lt;p&gt;The initial PEP for lazy imports (PEP 690) relied heavily on the modification of the internal dict object to support lazy imports. We recognize that this data structure is highly tuned, heavily used across the codebase, and very performance sensitive. Because of the importance of this data structure and the desire to keep the implementation of lazy imports encapsulated from users who may have no interest in the feature, we’ve decided to invest in an alternate approach.&lt;/p&gt;
    &lt;p&gt;The dictionary is the foundational data structure in Python. Every object’s attributes are stored in a dict, and dicts are used throughout the runtime for namespaces, keyword arguments, and more. Adding any kind of hook or special behavior to dicts to support lazy imports would:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Prevent critical interpreter optimizations including future JIT compilation.&lt;/item&gt;
      &lt;item&gt;Add complexity to a data structure that must remain simple and fast.&lt;/item&gt;
      &lt;item&gt;Affect every part of Python, not just import behavior.&lt;/item&gt;
      &lt;item&gt;Violate separation of concerns – the hash table shouldn’t know about the import system.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Past decisions that violated this principle of keeping core abstractions clean have caused significant pain in the CPython ecosystem, making optimization difficult and introducing subtle bugs.&lt;/p&gt;
    &lt;head rend="h3"&gt;Placing the &lt;code&gt;lazy&lt;/code&gt; keyword in the middle of from imports&lt;/head&gt;
    &lt;p&gt;While we found &lt;code&gt;from foo lazy import bar&lt;/code&gt; to be a really intuitive placement
for the new explicit syntax, we quickly learned that placing the &lt;code&gt;lazy&lt;/code&gt;
keyword here is already syntactically allowed in Python. This is because
&lt;code&gt;from . lazy import bar&lt;/code&gt; is legal syntax (because whitespace does not
matter.)&lt;/p&gt;
    &lt;head rend="h3"&gt;Placing the &lt;code&gt;lazy&lt;/code&gt; keyword at the end of import statements&lt;/head&gt;
    &lt;p&gt;We discussed appending lazy to the end of import statements like such &lt;code&gt;import
foo lazy&lt;/code&gt; or &lt;code&gt;from foo import bar, baz lazy&lt;/code&gt; but ultimately decided that
this approach provided less clarity. For example, if multiple modules are
imported in a single statement, it is unclear if the lazy binding applies to
all of the imported objects or just a subset of the items.&lt;/p&gt;
    &lt;head rend="h3"&gt;Returning a proxy dict from &lt;code&gt;globals()&lt;/code&gt;&lt;/head&gt;
    &lt;p&gt;An alternative to reifying on &lt;code&gt;globals()&lt;/code&gt; or exposing lazy objects would be
to return a proxy dictionary that automatically reifies lazy objects when
they’re accessed through the proxy. This would seemingly give the best of both
worlds: &lt;code&gt;globals()&lt;/code&gt; returns immediately without reification cost, but
accessing items through the result would automatically resolve lazy imports.&lt;/p&gt;
    &lt;p&gt;However, this approach is fundamentally incompatible with how &lt;code&gt;globals()&lt;/code&gt; is
used in practice. Many standard library functions and built-ins expect
&lt;code&gt;globals()&lt;/code&gt; to return a real &lt;code&gt;dict&lt;/code&gt; object, not a proxy:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;exec(code, globals())&lt;/code&gt;requires a real dict.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;eval(expr, globals())&lt;/code&gt;requires a real dict.&lt;/item&gt;
      &lt;item&gt;Functions that check &lt;code&gt;type(globals()) is dict&lt;/code&gt;would break.&lt;/item&gt;
      &lt;item&gt;Dictionary methods like &lt;code&gt;.update()&lt;/code&gt;would need special handling.&lt;/item&gt;
      &lt;item&gt;Performance would suffer from the indirection on every access.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The proxy would need to be so transparent that it would be indistinguishable from a real dict in almost all cases, which is extremely difficult to achieve correctly. Any deviation from true dict behavior would be a source of subtle bugs.&lt;/p&gt;
    &lt;head rend="h3"&gt;Reifying lazy imports when &lt;code&gt;globals()&lt;/code&gt; is called&lt;/head&gt;
    &lt;p&gt;Calling &lt;code&gt;globals()&lt;/code&gt; returns the module’s namespace dictionary without
triggering reification of lazy imports. Accessing lazy objects through the
returned dictionary yields the lazy proxy objects themselves. This is an
intentional design decision for several reasons:&lt;/p&gt;
    &lt;p&gt;The key distinction: Adding a lazy import and calling &lt;code&gt;globals()&lt;/code&gt; is the
module author’s concern and under their control. However, accessing
&lt;code&gt;mod.__dict__&lt;/code&gt; from external code is a different scenario – it crosses
module boundaries and affects someone else’s code. Therefore, &lt;code&gt;mod.__dict__&lt;/code&gt;
access reifies all lazy imports to ensure external code sees fully realized
modules, while &lt;code&gt;globals()&lt;/code&gt; preserves lazy objects for the module’s own
introspection needs.&lt;/p&gt;
    &lt;p&gt;Technical challenges: It is impossible to safely reify on-demand when &lt;code&gt;globals()&lt;/code&gt; is called because we cannot return a proxy dictionary – this
would break common usages like passing the result to &lt;code&gt;exec()&lt;/code&gt; or other
built-ins that expect a real dictionary. The only alternative would be to
eagerly reify all lazy imports whenever &lt;code&gt;globals()&lt;/code&gt; is called, but this
behavior would be surprising and potentially expensive.&lt;/p&gt;
    &lt;p&gt;Performance concerns: It is impractical to cache whether a reification scan has been performed with just the globals dictionary reference, whereas module attribute access (the primary use case) can efficiently cache reification state in the module object itself.&lt;/p&gt;
    &lt;p&gt;Use case rationale: The chosen design makes sense precisely because of this distinction: adding a lazy import and calling &lt;code&gt;globals()&lt;/code&gt; is your
problem to manage, while having lazy imports visible in &lt;code&gt;mod.__dict__&lt;/code&gt;
becomes someone else’s problem. By reifying on &lt;code&gt;__dict__&lt;/code&gt; access but not on
&lt;code&gt;globals()&lt;/code&gt;, we ensure external code always sees fully loaded modules while
giving module authors control over their own introspection.&lt;/p&gt;
    &lt;p&gt;Note that three options were considered:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Calling &lt;code&gt;globals()&lt;/code&gt;or&lt;code&gt;mod.__dict__&lt;/code&gt;traverses and resolves all lazy objects before returning.&lt;/item&gt;
      &lt;item&gt;Calling &lt;code&gt;globals()&lt;/code&gt;or&lt;code&gt;mod.__dict__&lt;/code&gt;returns the dictionary with lazy objects present.&lt;/item&gt;
      &lt;item&gt;Calling &lt;code&gt;globals()&lt;/code&gt;returns the dictionary with lazy objects, but&lt;code&gt;mod.__dict__&lt;/code&gt;reifies everything.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;We chose the third option because it properly delineates responsibility: if you add lazy imports to your module and call &lt;code&gt;globals()&lt;/code&gt;, you’re responsible
for handling the lazy objects. But external code accessing your module’s
&lt;code&gt;__dict__&lt;/code&gt; shouldn’t need to know about your lazy imports – it gets fully
resolved modules.&lt;/p&gt;
    &lt;head rend="h2"&gt;Acknowledgements&lt;/head&gt;
    &lt;p&gt;We would like to thank Paul Ganssle, Yury Selivanov, Łukasz Langa, Lysandros Nikolaou, Pradyun Gedam, Mark Shannon, Hana Joo and the Python Google team, the Python team(s) @ Meta, the Python @ HRT team, the Bloomberg Python team, the Scientific Python community, everyone who participated in the initial discussion of PEP 690, and many others who provided valuable feedback and insights that helped shape this PEP.&lt;/p&gt;
    &lt;head rend="h2"&gt;Footnotes&lt;/head&gt;
    &lt;head rend="h2"&gt;Copyright&lt;/head&gt;
    &lt;p&gt;This document is placed in the public domain or under the CC0-1.0-Universal license, whichever is more permissive.&lt;/p&gt;
    &lt;p&gt;Source: https://github.com/python/peps/blob/main/peps/pep-0810.rst&lt;/p&gt;
    &lt;p&gt;Last modified: 2025-10-03 20:29:13 GMT&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://pep-previews--4622.org.readthedocs.build/pep-0810/"/><published>2025-10-03T18:24:58+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45466588</id><title>Jules, remote coding agent from Google Labs, announces API</title><updated>2025-10-04T15:08:34.375164+00:00</updated><content>&lt;doc fingerprint="2f0466b1ac650a9d"&gt;
  &lt;main&gt;
    &lt;div&gt;&lt;head rend="h2"&gt; Jules in the command line &lt;/head&gt; October 2, 2025 &lt;p&gt;Weâre launching Jules Tools, a new command-line interface designed to give you direct control over your AI coding agent, making it scriptable, customizable, and easy to integrate into your existing workflows.&lt;/p&gt;&lt;p&gt;Key Features:&lt;/p&gt;&lt;list rend="ul"&gt;&lt;item&gt;Direct Control: Create tasks (jules remote new), list active sessions (jules remote list), and monitor Jules without leaving your command line.&lt;/item&gt;&lt;item&gt;Apply Patches Locally: Instantly pull work-in-progress code from an active Jules session and apply it to your local machine. This lets you test changes immediately, without waiting for a commit to GitHub.&lt;/item&gt;&lt;item&gt;Scriptable &amp;amp; Composable: Integrate Jules into your automations by piping in output from other tools like gh, jq, or cat.&lt;/item&gt;&lt;item&gt;Interactive Dashboard: For a more guided experience, launch the built-in terminal user interface (TUI) to create and manage tasks step-by-step.&lt;/item&gt;&lt;/list&gt;&lt;p&gt;How to Install:&lt;/p&gt;&lt;p&gt;Install globally via npm: &lt;code&gt;npm install -g @google/jules&lt;/code&gt;&lt;/p&gt;&lt;p&gt;Or run directly without a permanent installation: &lt;code&gt;npx @google/jules&lt;/code&gt;&lt;/p&gt;&lt;p&gt;Starter Commands to Try:&lt;/p&gt;&lt;p&gt;See all available commands: &lt;code&gt;jules help&lt;/code&gt;&lt;/p&gt;&lt;p&gt;List all repos connected to Jules: &lt;code&gt;jules remote list --repo&lt;/code&gt;&lt;/p&gt;&lt;p&gt;Create a new task in a specific repo: &lt;code&gt;jules remote new --repo torvalds/linux --session "write unit tests"&lt;/code&gt;&lt;/p&gt;&lt;head rend="h5"&gt;A Note for Google Workspace Users&lt;/head&gt;&lt;p&gt;Support for workspace users is coming later in October!&lt;/p&gt;&lt;p&gt;If you run into any issues, please share your experience with us via in-app feedback or on our Discord channel.&lt;/p&gt;&lt;head rend="h2"&gt; Jules gains memory! &lt;/head&gt; September 30, 2025 &lt;p&gt;Jules Memory for Repositories: Weâre excited to introduce a new Memory feature! Jules now has the ability to learn from your interactions.&lt;/p&gt;&lt;list rend="ul"&gt;&lt;item&gt;How it works: During a task, Jules will save your preferences, nudges, and corrections.&lt;/item&gt;&lt;item&gt;The benefit: The next time you run the same or a similar task in that specific repository, Jules will reference its memory to better anticipate your needs and follow your established patterns, leading to more accurate results with less guidance.&lt;/item&gt;&lt;item&gt;Settings: You can toggle memory on or off for the repo in the repo settings page under âKnowledgeâ&lt;/item&gt;&lt;/list&gt;&lt;head rend="h2"&gt; Tell Jules exactly what file to work on using file selector &lt;/head&gt; September 29, 2025 &lt;p&gt;You can now tell Jules exactly which files to work with for any given task. Use the new file selector to easily and precisely reference specific files.&lt;/p&gt;&lt;p&gt;This removes ambiguity and gives you more granular control over Julesâs actions, helping to tighten the context for your task.&lt;/p&gt;&lt;head rend="h2"&gt; Jules Acts on PR Feedback &lt;/head&gt; September 23, 2025 &lt;p&gt;Jules is now able to read and respond to your comments on pull requests!&lt;/p&gt;&lt;p&gt;When you start a review, Jules will add a ð emoji to each comment to let you know itâs been read. Based on your feedback, Jules will then push a commit with the requested changes.&lt;/p&gt;&lt;p&gt;For more control, you can switch to Reactive Mode in your global Jules UI settings. In this mode, Jules will only act on comments where you specifically mention &lt;code&gt;@Jules&lt;/code&gt;.&lt;/p&gt;&lt;head rend="h2"&gt; All Hands on Deck! &lt;/head&gt; September 19, 2025 &lt;p&gt;Ahoy, mateys! To celebrate International Talk Like a Pirate Day, weâve given Jules a temporary map to the treasure.&lt;/p&gt;&lt;list rend="ul"&gt;&lt;item&gt;&lt;p&gt;Jules Speaks Pirate: Youâll find your AI agentâs responses are a bit moreâ¦ swashbucklingâ¦ for today only.&lt;/p&gt;&lt;/item&gt;&lt;item&gt;&lt;p&gt;Same Great Logic: Fear not! Beneath the eyepatch and Jolly Roger, itâs the same powerful coding engine ready to help you plunder that backlog and send bugs to Davy Jonesâ locker.&lt;/p&gt;&lt;/item&gt;&lt;/list&gt;&lt;head rend="h2"&gt; Image upload &lt;/head&gt; September 9, 2025 &lt;p&gt;You can now upload images when creating a task in Jules. Use this to show frontend bugs, design inspiration, UI mocks, or any visual context you want Jules to consider while generating code.&lt;/p&gt;&lt;p&gt;For now:&lt;/p&gt;&lt;list rend="ul"&gt;&lt;item&gt;Only JPEG and PNG formats are supported.&lt;/item&gt;&lt;item&gt;You can uplaod as many images as you want, as long as the total size is under 5MB.&lt;/item&gt;&lt;item&gt;Image upload is only supported at task creation (weâre working on enabling it for follow-up prompts soon).&lt;/item&gt;&lt;/list&gt;&lt;p&gt;Note: If your task involves using assets (e.g. logos) directly in code, those must still be committed to your GitHub repo.&lt;/p&gt;&lt;p&gt;Read more about Jules image support.&lt;/p&gt;&lt;head rend="h2"&gt; Stacked Diff &lt;/head&gt; September 4, 2025 &lt;p&gt;To improve the code review experience, weâve introduced a new stacked layout for the diff viewer. This change displays diffs for multiple files vertically on a single screen. The stacked view makes it easier to see related changes across your codebase at a glance, providing better context and speeding up your review process.&lt;/p&gt;&lt;p&gt;Changes:&lt;/p&gt;&lt;list rend="ul"&gt;&lt;item&gt;The diff viewer now stacks file changes vertically by default&lt;/item&gt;&lt;item&gt;You can also toggle back to the previous tabbed diff viewer&lt;/item&gt;&lt;/list&gt;&lt;head rend="h2"&gt; Improved Jules Critic &lt;/head&gt; September 3, 2025 &lt;p&gt;Weâve shipped significant improvements to the Jules critic agent, making its feedback more insightful and reliable. To increase transparency and give you more insight into its evaluation process, you can now see the criticâs real-time analysis as it works.&lt;/p&gt;&lt;p&gt;Changes:&lt;/p&gt;&lt;list rend="ul"&gt;&lt;item&gt;The criticâs thought process is now visible in the UI, showing its step-by-step evaluation of the code in real-time.&lt;/item&gt;&lt;item&gt;The criticâs now incorporates more contextual information when making decisions, leading to more accurate and relevant feedback on potential bugs and logic flaws.&lt;/item&gt;&lt;/list&gt;&lt;head rend="h2"&gt; Jules Sample Prompts &lt;/head&gt; September 2, 2025 &lt;p&gt;To help new users get started with Jules, weâve added sample prompts to the home page. These static prompts provide examples of how to use Jules and can be added to the text box with a single click.&lt;/p&gt;&lt;p&gt;Changes:&lt;/p&gt;&lt;list rend="ul"&gt;&lt;item&gt;Sample prompts are now displayed on the home page for all users.&lt;/item&gt;&lt;item&gt;Clicking on a sample prompt will add the text of the prompt to the input box.&lt;/item&gt;&lt;/list&gt;&lt;head rend="h2"&gt; Render images in the diff viewer &lt;/head&gt; August 22, 2025 &lt;p&gt;Jules now intelligently renders images within the diff viewer, providing an immediate visual context for your modifications.&lt;/p&gt;&lt;p&gt;This means:&lt;/p&gt;&lt;list rend="ul"&gt;&lt;item&gt;Instant Visual Feedback: When Jules generates images (like charts, diagrams, or web UI screenshots), youâll see the actual image in the diff, not just its code representation.&lt;/item&gt;&lt;item&gt;Streamlined Workflow: No need to switch between tools or download files to see the results. Jules keeps everything in one place.&lt;/item&gt;&lt;/list&gt;&lt;p&gt;Try it out! Ask Jules to render an output, like a graph based on data, and commit it to your repository. Youâll be able to see the generated image seamlessly within your diff viewer.&lt;/p&gt;&lt;head rend="h2"&gt; Export at any time &lt;/head&gt; August 15, 2025 &lt;p&gt;Youâre now in full control of when your code gets to GitHub. No need to wait for a task to finish or ask Jules to do it for you. At any point during a task, just click the GitHub icon in the top right to publish the current work-in-progress as a new branch or open a pull request. This gives you more flexibility and control to review, test, or take over whenever youâre ready.&lt;/p&gt;&lt;head rend="h2"&gt; Increasing the VM Size to 20GB &lt;/head&gt; August 15, 2025 &lt;p&gt;We heard your feedback about running into disk space limits on larger projects. To address this, weâve significantly increased the available disk space in the Jules VM to 20GB. This provides more room for large dependencies, build artifacts, and complex repositories, reducing disk-related failures so Jules can tackle bigger tasks. Happy Julesing!&lt;/p&gt;&lt;head rend="h2"&gt; Interactive Plan &lt;/head&gt; August 8, 2025 &lt;p&gt;Meet Interactive Plan. Instead of jumping straight to the solution, Jules will now read your codebase, ask clarifying questions, and work with you to refine the plan. This collaborative approach gives you more control and ensures youâre on the same page, leading to higher-quality code and a more reliable solution.&lt;/p&gt;&lt;p&gt;In summary:&lt;/p&gt;&lt;list rend="ul"&gt;&lt;item&gt;Trigger the interactive plan from the dropdown when you start a task&lt;/item&gt;&lt;item&gt;Jules will start a brainstorm with you and ask clarifying questions&lt;/item&gt;&lt;/list&gt;&lt;head rend="h2"&gt; Jules can surf the web &lt;/head&gt; August 8, 2025 &lt;p&gt;Jules can now proactively search the web for relevant content, documentation, or code snippets to help complete your tasks. This means Jules can get the information it needs, resulting in more accurate and successful task completion.&lt;/p&gt;&lt;p&gt;In Summary:&lt;/p&gt;&lt;list rend="ul"&gt;&lt;item&gt;Jules can find the latest documentation for dependencies/libraries youâre using&lt;/item&gt;&lt;item&gt;Jules can proactively find examples or code snippets that can help inform its implementation&lt;/item&gt;&lt;/list&gt;&lt;p&gt;Note: web search works best when working on technical documentation. Queries like: âWhat is the latest news today?â are not supported.&lt;/p&gt;&lt;head rend="h2"&gt; Critic Agent &lt;/head&gt; August 8, 2025 &lt;p&gt;Great developers donât just write code, they question it. And now, so does Jules. Weâve built the Jules critic agent to ensure that every line of code isnât just functional, but robust, secure, and efficient. It acts as an internal peer reviewer, challenging every proposed change to elevate the quality of the final output.&lt;/p&gt;&lt;p&gt;Some high level notes:&lt;/p&gt;&lt;list rend="ul"&gt;&lt;item&gt;&lt;p&gt;Critic-augmented generation: The Jules critic is integrated directly into the generation process. Every proposed change undergoes adversarial review before completion.&lt;/p&gt;&lt;/item&gt;&lt;item&gt;&lt;p&gt;Improved code quality: The critic flags subtle bugs, missed edge cases, and inefficient code. Jules then uses this feedback to improve the patch in real-time.&lt;/p&gt;&lt;/item&gt;&lt;item&gt;&lt;p&gt;A new kind of review: The critic is not just another linter or test. It understands the intent and context behind code, similar to a human peer reviewer.&lt;/p&gt;&lt;/item&gt;&lt;item&gt;&lt;p&gt;Built on research: This feature draws on research into multi-step, tool interactive critiquing and actor-critic reinforcement learning, where an âactorâ generates and a âcriticâ evaluates.&lt;/p&gt;&lt;/item&gt;&lt;/list&gt;&lt;head rend="h2"&gt; Jules can test web-apps and show you the results &lt;/head&gt; August 7, 2025 &lt;p&gt;Next time you are working on a front end project with Jules, ask it to verify its work and itâll render the website and send you back a screenshot!&lt;/p&gt;&lt;list rend="ul"&gt;&lt;item&gt;Ask Jules to complete a web development task and to verify the front end&lt;/item&gt;&lt;item&gt;Jules will send you a screenshot of the front end along with any code changes&lt;/item&gt;&lt;item&gt;The default Jules base image now includes Playwright for front end testing&lt;/item&gt;&lt;item&gt;Users can also add images in the form of public URLs for Jules to use as input&lt;/item&gt;&lt;/list&gt;&lt;head rend="h2"&gt; Jules is out of beta! &lt;/head&gt; August 6, 2025 &lt;p&gt;Today we are thrilled to announce that Jules is no longer in beta! Since launch just two months ago, Jules has passed over 140k public commits. Thank you to our amazing beta users for all your support and feedback.&lt;/p&gt;&lt;p&gt;In addition, weâre launching our pricing plans to unlock higher task limits, along with a bunch of quality improvements in the Jules app and agent. Here are the details:&lt;/p&gt;&lt;list rend="ul"&gt;&lt;item&gt;Get higher task limits through the Google AI Pro and Ultra plans. More details at Limits and Plans.&lt;/item&gt;&lt;item&gt;Jules now uses the power of Gemini 2.5 thinking when creating its plan, resulting in higher quality plans and more complete tasks&lt;/item&gt;&lt;item&gt;Numerous bug fixes so Jules gets stuck less, and is better at following your instructions in agents.md&lt;/item&gt;&lt;/list&gt;&lt;head rend="h2"&gt; Environment snapshots for faster tasks &lt;/head&gt; August 5, 2025 &lt;p&gt;Jules now creates a snapshot of your environment when you add environment setup scripts. For complicated environment, users should see faster and more consistent task execution.&lt;/p&gt;&lt;p&gt;In summary:&lt;/p&gt;&lt;list rend="ul"&gt;&lt;item&gt;Jules will now snapshot your environment when you provide an environment setup script&lt;/item&gt;&lt;item&gt;Snapshots are loaded automatically next time you run a task&lt;/item&gt;&lt;item&gt;This provides for faster task startups, especially for complex environments&lt;/item&gt;&lt;item&gt;You can find environment configuration by clicking the âcodebaseâ in the left hand panel, or by clicking the âconfigure environmentâ button in the task pane.&lt;/item&gt;&lt;/list&gt;&lt;head rend="h2"&gt; Open A PR directly from Jules &lt;/head&gt; August 4, 2025 &lt;p&gt;Closing the loop from task to merge ð¤&lt;/p&gt;&lt;p&gt;Jules can now open a pull request directly from the UI. After a task completes, just use the new dropdown next to the âPublish Branchâ button to open a PR. Jules will request to merge the newly published branch into main, streamlining your entire workflow. Less context switching, faster merging.&lt;/p&gt;&lt;head rend="h2"&gt; Added Bun runtime support &lt;/head&gt; July 18, 2025 &lt;p&gt;Jules now supports Bun. You can run tasks using Bun out of the box, no extra setup required. This expands compatibility for projects that use Bun instead of Node.&lt;/p&gt;&lt;p&gt;Read more about the jules base image and what tooling works with Jules.&lt;/p&gt;&lt;head rend="h2"&gt; Improved task controls and other ð UI delight &lt;/head&gt; July 3, 2025 &lt;list rend="ul"&gt;&lt;item&gt;Pause, resume, and delete tasksâwithout losing your sense of place. Available from sidebar and repo view. You can even quickly copy task urls!&lt;/item&gt;&lt;item&gt;Non-urgent task icons are now more recessive&lt;/item&gt;&lt;item&gt;Certain hover statesâwhich did not look goodâhave been toned back.&lt;/item&gt;&lt;item&gt;System messages have more consistent padding and borders&lt;/item&gt;&lt;/list&gt;&lt;p&gt;Learn more about running a task.&lt;/p&gt;&lt;head rend="h2"&gt; Jules now listens to GitHub issues &lt;/head&gt; June 26, 2025 &lt;p&gt;Add the label âjulesâ to any GitHub issue to start a task in Jules. Thatâs itâlabel on, task live.&lt;/p&gt;&lt;p&gt;How to summon Jules:&lt;/p&gt;&lt;list rend="ul"&gt;&lt;item&gt;Open a GitHub issue.&lt;/item&gt;&lt;item&gt;Click the gear next to âLabelsâ.&lt;/item&gt;&lt;item&gt;Add the label âjules.â&lt;/item&gt;&lt;/list&gt;&lt;p&gt;Make sure the Jules GitHub App has access to your repo. After that, Jules takes it from there. Read more about running tasks in Jules!&lt;/p&gt;&lt;head rend="h2"&gt; Jules Agent Update: Faster, Smarter, More Reliable &lt;/head&gt; June 20, 2025 &lt;p&gt;Weâve shipped a big upgrade to the Jules agent under the hood.&lt;/p&gt;&lt;p&gt;Whatâs new:&lt;/p&gt;&lt;list rend="ul"&gt;&lt;item&gt;Smarter context. Jules reads from AGENTS.md if itâs in your repo.&lt;/item&gt;&lt;item&gt;Improved performance. Tasks now complete fasterâno numbers to share just yet, but youâll feel it.&lt;/item&gt;&lt;item&gt;Significantly reduced punting. We tightened the loop to keep Jules moving forward.&lt;/item&gt;&lt;item&gt;More reliable setup. If youâve added an environment setup script, Jules now runs it consistently.&lt;/item&gt;&lt;item&gt;Better test habits. Jules is more likely to write and run tests on its own.&lt;/item&gt;&lt;/list&gt;&lt;p&gt;Check out the Getting Started guide to learn more about AGENTS.md support.&lt;/p&gt; June 18, 2025 &lt;p&gt;Weâve overhauled the Jules development environment to move beyond the default Ubuntu 24.04 LTS packages. This includes:&lt;/p&gt;&lt;list rend="ul"&gt;&lt;item&gt;Explicitly installing newer versions of key toolchains like Rust, Node, and Python, addressing long-standing version issues.&lt;/item&gt;&lt;item&gt;Adding finer-grained control over installation steps via custom scripts instead of relying solely on apt.&lt;/item&gt;&lt;item&gt;Introducing support for multiple runtimes, improved isolation, and version pinning to reduce drift and better match developer expectations.&lt;/item&gt;&lt;/list&gt;&lt;p&gt;These changes unblock several issues developers encountered with outdated dependencies and improve alignment with modern project requirements.&lt;/p&gt;&lt;p&gt;Read about the Jules environment setup to learn more about whatâs pre-installed.&lt;/p&gt;&lt;head rend="h2"&gt; Customization and Efficiency Enhancements &lt;/head&gt; June 6, 2025 &lt;p&gt;Performance upgrades: Enjoy a smoother, faster Jules experience with recent under-the-hood improvements.&lt;/p&gt;&lt;p&gt;Quickly copy and download code: New copy and download buttons are now available in the code view pane, making it easier to grab your code directly from Jules.&lt;/p&gt;&lt;p&gt;Stay focused with task modals: Initiate multiple tasks seamlessly through a new modal option, allowing you to keep your context and workflow intact. Learn more about kicking off tasks.&lt;/p&gt;&lt;p&gt;Adjustable code panel: Customize your workspace by adjusting the width of the code panel to your preferred viewing experience.&lt;/p&gt;&lt;p&gt;Check out the docs to learn more about how to download code that Jules writes.&lt;/p&gt;&lt;head rend="h2"&gt; A faster, smoother and more reliable Jules &lt;/head&gt; May 30, 2025 &lt;p&gt;This week, our focus has been on improving reliability, fixing our GitHub integration, and scaling capacity.&lt;/p&gt;&lt;p&gt;Hereâs whatâs we shipped:&lt;/p&gt;&lt;list rend="ul"&gt;&lt;item&gt;Updated our limits to 60 tasks per day, 5 concurrent.&lt;/item&gt;&lt;item&gt;We substantially improved the reliability of the GitHub sync. Export to GitHub should also be fixed on previously created tasks.&lt;/item&gt;&lt;item&gt;Weâve decreased the number of failure cases by 2/3&lt;/item&gt;&lt;/list&gt;&lt;p&gt;Learn more about usage limits.&lt;/p&gt;&lt;head rend="h2"&gt; Improving Stablity &lt;/head&gt; May 22, 2025 &lt;p&gt;Weâve been heads down improving stability and fixing bugsâbig and smallâto make Jules faster, smoother, and more reliable for you.&lt;/p&gt;&lt;p&gt;Hereâs whatâs fixed:&lt;/p&gt;&lt;list rend="ul"&gt;&lt;item&gt;Upgraded our queuing system and added more compute to reduce wait times during peak usage&lt;/item&gt;&lt;item&gt;Publish Branch button is now part of the summary UI in the activity feed so itâs easier to find&lt;/item&gt;&lt;item&gt;Bug vixes for task status and mobile&lt;/item&gt;&lt;/list&gt;&lt;p&gt;Learn more about how to publish a branch on GitHub.&lt;/p&gt;&lt;head rend="h2"&gt; Jules is here &lt;/head&gt; May 19, 2025 &lt;p&gt;Today, weâre launching Jules, a new AI coding agent.&lt;/p&gt;&lt;p&gt;Jules helps you move faster by working asynchronously on tasks in your GitHub repo. It can fix bugs, update dependencies, migrate code, and add new features.&lt;/p&gt;&lt;p&gt;Once you give Jules a task, it spins up a fresh dev environment in a VM, installs dependencies, writes tests, makes the changes, runs the tests, and opens a pull request. Jules shows its work as it makes progress, so you never have to guess what code itâs writing, or what itâs thinking.&lt;/p&gt;&lt;p&gt;What Jules can do today&lt;/p&gt;&lt;list rend="ul"&gt;&lt;item&gt;Fix bugs with test verified patches&lt;/item&gt;&lt;item&gt;Handle version bumps and dependency upgrades&lt;/item&gt;&lt;item&gt;Perform scoped code transformations&lt;/item&gt;&lt;item&gt;Migrate code across languages or frameworks&lt;/item&gt;&lt;item&gt;Ship isolated, scoped, features&lt;/item&gt;&lt;item&gt;Open PRs with runnable code and test results&lt;/item&gt;&lt;/list&gt;&lt;p&gt;Get started with the Jules documentation, and visit jules.google.com to run your first Jules task.&lt;/p&gt;&lt;/div&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://jules.google/docs/changelog/"/><published>2025-10-03T19:08:11+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45467166</id><title>AMD's EPYC 9355P: Inside a 32 Core Zen 5 Server Chip</title><updated>2025-10-04T15:08:34.224837+00:00</updated><content>&lt;doc fingerprint="6ef3d4bf70380ac1"&gt;
  &lt;main&gt;
    &lt;p&gt;High core count chips are headline grabbers. But maxing out the metaphorical core count slider isn’t the only way to go. Server players like Intel, AMD, and Arm aim for scalable designs that cover a range of core counts. Not all applications can take advantage of the highest core count models in their lineups, and per-core performance still matters.&lt;/p&gt;
    &lt;p&gt;AMD’s EPYC 9355P is a 32 core part. But rather than just being a lower core count part, the 9355P pulls levers to let each core count for more. First, it clocks up to 4.4 GHz. AMD has faster clocking chips in its server lineup, but 4.4 GHz is still a good bit higher than the 3.7 or 4.1 GHz that 128 or 192 core Zen 5 SKUs reach. Then, AMD uses eight CPU dies (CCDs) to house those 32 cores. Each CCD only has four cores enabled out of the eight physically present, but still has its full 32 MB of L3 cache usable. That provides a high cache capacity to core count ratio. Finally, each CCD connects to the IO die using a “GMI-Wide” setup, giving each CCD 64B/cycle of bandwidth to the rest of the system in both the read and write directions. GMI here stands for Global Memory Interconnect. Zen 5’s server IO die has 16 GMI links to support up to 16 CCDs for high core count parts, plus some xGMI (external) links to allow a dual socket setup. GMI-Wide uses two links per CCD, fully utilizing the IO die’s GMI links even though the EPYC 9355P only has eight CCDs.&lt;/p&gt;
    &lt;head rend="h1"&gt;Acknowledgments&lt;/head&gt;
    &lt;p&gt;Dell has kindly provided a PowerEdge R6715 for testing, and it came equipped with the aforementioned AMD EPYC 9355P along with 768 GB of DDR5-5200. The 12 memory controllers on the IO die provide a 768-bit memory bus, so the setup provides just under 500 GB/s of theoretical bandwidth. Besides providing a look into how a lower core count SKU behaves, we have BMC access which provides an opportunity to investigate different NUMA setups.&lt;/p&gt;
    &lt;p&gt;We’d also like to thank Zack and the rest of the fine folks at ZeroOne Technology for hosting the Dell PowerEdge R6715 at no cost to us.&lt;/p&gt;
    &lt;head rend="h1"&gt;Memory Subsystem and NUMA Characteristics&lt;/head&gt;
    &lt;p&gt;NPS1 mode stripes memory accesses across all 12 of the chip’s memory controllers, presenting software with a monolithic view of memory at the cost of latency. DRAM latency in that mode is slightly better than what Intel’s Xeon 6 achieves in SNC3 mode. SNC3 on Intel divides the chip into three NUMA nodes that correspond to its compute dies. The EPYC 9355P has good memory latency in that respect, but it falls behind compared to the Ryzen 9 9900X with DDR5-5600. Interconnects that tie more agents together tend to have higher latency. On AMD’s server platform, the Infinity Fabric network within the IO die has to connect up to 16 CCDs with 12 memory controllers and other IO, so the higher latency isn’t surprising.&lt;/p&gt;
    &lt;p&gt;Cache performance is similar across AMD’s desktop and server Zen 5 implementations, with the server variant only losing because of lower clock speeds. That’s not a surprise because AMD reuses the same CCDs on desktop and server products. But it does create a contrast to Intel’s approach, where client and server memory subsystems differ starting at L3. Intel trades L3 latency for capacity and the ability to a logical L3 instance across more cores.&lt;/p&gt;
    &lt;p&gt;Different NUMA configurations can subdivide EPYC 9355P, associating cores with the closest memory controllers to improve latency. NPS2 divides the chip into two hemispheres, and has 16 cores form a NUMA node with the six memory controllers on one half of the die. NPS4 divides the chip into quadrants, each with two CCDs and three memory controllers. Finally, the chip can present each CCD as a NUMA node. Doing so makes it easier to pin threads to cores that share a L3 cache, but doesn’t affect how memory is interleaved across channels. Memory addresses are still assigned to memory controllers according to the selected NPS1/2/4 scheme, which is a separate setting.&lt;/p&gt;
    &lt;p&gt;NPS2 and NPS4 only provide marginal latency improvements, and latency remains much higher than in a desktop platform. At the same time, crossing NUMA boundaries comes with little penalty. Apparently requests can traverse the huge IO die quite quickly, adding 20-30 ns at worst. I’m not sure what the underlying Infinity Fabric topology looks like, but the worst case unloaded cross-node latencies were under 140 ns. On Xeon 6, latency starts higher and can climb over 180 ns when cores on one compute die access memory controllers on the compute die at the other end of the chip.&lt;/p&gt;
    &lt;p&gt;EPYC 9355P can get close to theoretical memory bandwidth in any of the three NUMA nodes, as long as code keeps accesses within each node. NPS2 and NPS4 offer slightly better bandwidth, at the cost of requiring code to be NUMA aware. I tried to cause congestion on Infinity Fabric by having cores on each NUMA node access memory on another. That does lower achieved bandwidth, but not by a huge amount.&lt;/p&gt;
    &lt;p&gt;An individual NPS4 node achieves 117.33 GB/s to its local memory pool, and just over 107 GB/s to the memory on the other three nodes. The bandwidth penalty is minor, but a bigger potential pitfall is lower bandwidth to each NUMA node’s memory pool. Two CCDs can draw more bandwidth than the three memory controllers they’re associated with. Manually distributing memory accesses across NUMA nodes can improve bandwidth for a workload contained within one NUMA node’s cores. But doing so in practice may be an intricate exercise.&lt;/p&gt;
    &lt;p&gt;In general, EPYC 9355P has very mild NUMA characteristics and little penalty associated with running the chip in NPS1 or NPS2 mode. I imagine just using NPS1 mode would work well enough in the vast majority of cases, with little performance to be gained from carrying out NUMA optimizations.&lt;/p&gt;
    &lt;head rend="h1"&gt;Looking into GMI-Wide&lt;/head&gt;
    &lt;p&gt;GMI-Wide is AMD’s attempt to address bandwidth pinch points between CCDs and the rest of the system. With GMI-Wide, a single CCD can achieve 99.8 GB/s of read bandwidth, significantly more than the 62.5 GB/s from a Ryzen 9 9900X CCD with GMI-Narrow. GMI-Wide also allows better latency control under high bandwidth load. The Ryzen 9 9900X suffers from a corner case where a single core pulling maximum bandwidth can saturate the GMI-Narrow link and starve out another latency sensitive thread. That sends latency to nearly 500 ns, as observed by a latency test thread sharing a CCD with a thread linearly traversing an array. Having more threads generate bandwidth load seems to make QoS mechanisms kick in, which slightly reduces bandwidth throughput but brings latency back under control.&lt;/p&gt;
    &lt;p&gt;I previously wrote about loaded memory latency on the Ryzen 9 9950X when testing the system remotely, and thought it controlled latency well under high bandwidth load. But back then, George (Cheese) set that system up with very fast DDR5-8000 along with a higher 2.2 GHz FCLK. A single core was likely unable to monopolize off-CCD bandwidth in that setup, avoiding the corner case seen on my system. GMI-Wide increases off-CCD bandwidth by a much larger extent and has a similar effect. Under increasing bandwidth load, GMI-WIde can both achieve more total bandwidth and control latency better than its desktop single-link counterpart.&lt;/p&gt;
    &lt;p&gt;A read-modify-write pattern gets maximum bandwidth from GMI-Wide by exercising both the read and write paths. It doesn’t scale perfectly, but it’s a substantial improvement over using only reads or writes. A Ryzen 9 9900X CCD can theoretically get 48B/cycle to the IO die with a 2:1 read-to-write ratio. I tried modifying every other cacheline to achieve this ratio, but didn’t get better bandwidth probably because the memory controller is limited by a 32B/cycle link to Infinity Fabric. However, mixing in writes does get rid of the single bandwidth thread corner case, possibly because a single thread doesn’t saturate the 32B/cycle read link when mixing reads and writes.&lt;/p&gt;
    &lt;p&gt;On the desktop platform, latency under high load gets worse possibly because writes contend with reads at the DRAM controller. The DDR bus is unidirectional, and must waste cycles on “turnarounds” to switch between read and write mode. Bandwidth isn’t affected, probably because the Infinity Fabric bottleneck leaves spare cycles at the memory controller, which can absorb those turnarounds. However, reads from the latency test thread may be delayed while the memory controller drains writes before switching the bus back to read mode.&lt;/p&gt;
    &lt;p&gt;On the EPYC 9355P in NPS1 mode, bandwidth demands from a single GMI-Wide CCD leave plenty of spare cycles across the 12 memory controllers, so there’s little latency or bandwidth penalty when mixing reads and writes. The same isn’t true in NPS4 mode, where a GMI-Wide link can outmatch a NPS4 node’s three memory controllers. Everything’s fine with just reads, which actually benefit possibly because of lower latency and not having to traverse as much of the IO die. But with a read-modify-write pattern, bandwidth drops from 134 GB/s in NPS1 mode to 96.6 GB/s with NPS4. Latency gets worse too, rising to 248 ns. Again, NPS4 is something to be careful with, particularly if applications might require high bandwidth from a small subset of cores.&lt;/p&gt;
    &lt;head rend="h1"&gt;SPEC CPU2017&lt;/head&gt;
    &lt;p&gt;From a single thread perspective, the EPYC 9355P falls some distance behind the Ryzen 9 9900X. Desktop CPUs are designed around single threaded performance, so that’s to be expected. But with boost turned off on the desktop CPU to match clock speeds, performance is surprisingly close. Higher memory latency still hurts the EPYC 9355P, but it’s within striking distance.&lt;/p&gt;
    &lt;p&gt;NUMA modes barely make any difference. NPS4 technically wins, but by an insignificant margin. The latency advantage was barely measurable anyway. Compared to the more density optimized Graviton 4 and Xeon 6 6975P-C, the EPYC 9355P delivers noticeably better single threaded performance.&lt;/p&gt;
    &lt;p&gt;CCD-level bandwidth pinch points are worth a look too, since that’s traditionally been a distinguishing factor between AMD’s EPYC and more logically monolithic designs. Here, I’m filling a quad core CCD by running SPEC CPU2017’s rate tests with eight copies. I did the same on the Ryzen 9 9900X, pinning the eight copies to four cores and leaving the CCD’s other two cores unused. I bound the test to a single NUMA node on all tested setups.&lt;/p&gt;
    &lt;p&gt;SPEC’s floating point suite starts to tell a different story now. Several tests within the floating point suite are bandwidth hungry even from a single core. 549.fotonik3d for example pulled 28.23 GB/s from Meteor Lake’s memory controller when I first went through SPEC CPU2017’s tests. Running eight copies in parallel would multiply memory bandwidth demands, and that’s where server memory subsystems shine.&lt;/p&gt;
    &lt;p&gt;In 549.fotonik3d, high bandwidth demands make the Ryzen 9 9900X’s unloaded latency advantage irrelevant. The 9900X even loses to Redwood Cove cores on Xeon 6. The EPYC 9355P does very well in this test against both the 9900X and Xeon 6. Intel’s interconnect strategy tries to keep the chip logically monolithic and doesn’t have pinch points at cluster boundaries. But each core on Xeon 6 can only get to ~33 GB/s of DRAM bandwidth at best, using an even mix of reads and writes. AMD’s GMI-Wide can more than match that, and Intel’s advantage doesn’t show through in this scenario. However, Intel does have a potential advantage against more density focused AMD SKUs where eight cores sit in front of a narrower link.&lt;/p&gt;
    &lt;p&gt;NPS4 is also detrimental to the EPYC 9355P’s performance in this test. It only provides a minimal latency benefit at the cost of lower per-node bandwidth. The bandwidth part seems to hurt here, and taking the extra latency of striping accesses across 6 or 12 memory controllers gives a notable performance improvement.&lt;/p&gt;
    &lt;head rend="h1"&gt;Final Words&lt;/head&gt;
    &lt;p&gt;Core count isn’t the last word in server design. A lot of scenarios are better served by lower core count parts. Applications might not scale to fill a high core count chip. Bandwidth bound workloads might not benefit from adding cores. Traditionally lower core count server chips just traded core counts for higher clock speeds. Today, chips like the EPYC 9355P do a bit more, using both wider CCD-to-IOD links and more cache to maximize per-core performance.&lt;/p&gt;
    &lt;p&gt;Looking at EPYC 9355P’s NUMA characteristics reveals very consistent memory performance across NUMA modes. Intel’s Xeon 6 may be more monolithic from a caching point of view, but AMD’s DRAM access performance feels more monolithic than Intel’s. AMD made a tradeoff back in the Zen 2 days where they took lower local memory latency in exchange for more even memory performance across the socket. Measured latencies on EPYC 9355P are a bit higher than figures on the Zen 2 slide above. DDR5 is higher latency, and the Infinity Fabric topology is probably more complex these days to handle more CCDs and memory channels.&lt;/p&gt;
    &lt;p&gt;But the big picture remains. AMD’s Turin platform handles well in NPS1 mode, and cross-node penalties are low in NPS2/NPS4 modes. Those characteristics likely carry over across the Zen 5 EPYC SKU stack. It’s quite different from Intel’s Xeon 6 platform, which places memory controllers on compute dies like Zen 1 did. For now, AMD’s approach seems to be better at the DRAM level. Intel’s theoretical latency advantage in SNC3 mode doesn’t show through, and AMD gets to reap the benefits of a hub-and-spoke model while not getting hit where it should have downsides.&lt;/p&gt;
    &lt;p&gt;AMD seems to have found a good formula back in the Zen 2 days, and they’re content with reinforcing success. Intel is furiously iterating to find a setup that preserves a single level, logically monolithic interconnect while scaling well across a range of core counts. And of course, there’s Arm chips, which generally lean towards a single level monolithic interconnect too. It’ll be interesting to watch what all of these players do going forward as they continue to iterate and refine their designs.&lt;/p&gt;
    &lt;p&gt;And again, we’d like to thank both Dell and ZeroOne for, respectively, providing and hosting this PowerEdge R6715 without both of whom this article wouldn’t have been possible.&lt;/p&gt;
    &lt;p&gt;If you like the content then consider heading over to the Patreon or PayPal if you want to toss a few bucks to Chips and Cheese. Also consider joining the Discord.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://chipsandcheese.com/p/amds-epyc-9355p-inside-a-32-core"/><published>2025-10-03T20:01:36+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45467500</id><title>Offline card payments should be possible no later than 1 July 2026</title><updated>2025-10-04T15:08:33.636488+00:00</updated><content>&lt;doc fingerprint="cb8cfa25092dfffd"&gt;
  &lt;main&gt;
    &lt;head rend="h1"&gt;Offline card payments should be possible no later than 1 July 2026&lt;/head&gt;
    &lt;p&gt;Press release The Riksbank and representatives from the payment market have today reached an agreement to increase the possibility to make offline card payments for essential goods. The agreement is an important step in the work to strengthen Sweden's payment preparedness and increase resilience to disruptions in the digital payments system. The goal is for the measures to be in place no later than 1 July 2026.&lt;/p&gt;
    &lt;p&gt;“In Sweden, we pay digitally to a large degree and the use of cash is low. The general public being able to pay by card for example for food and medicines even in the event of a serious breakdown in data communication, that is offline, is a milestone in our intensified efforts to strengthen emergency preparedness”, says Governor Erik Thedéen.&lt;/p&gt;
    &lt;p&gt;The agreement describes the measures that participants in Swedish card payments – card issuers, card networks, card acquirers, the retail sector and the Riksbank – will implement to increase the possibility of offline payments by card. For instance, financial agents will adapt their regulatory frameworks, and the retail trade will introduce technological solutions. The Riksbank is leading this work and is responsible for monitoring its implementation.&lt;/p&gt;
    &lt;p&gt;“We are very pleased that all participants involved are taking responsibility for strengthening Sweden's payment readiness. Some are covered by the Riksbank's regulations, but far from all. We regard the fact that so many are nevertheless choosing to contribute as very positive for Sweden's overall civil preparedness”, concludes Erik Thedéen.&lt;/p&gt;
    &lt;p&gt;The online function shall apply to physical payment cards and accompanying PIN code when purchasing essential goods such as food, medicine and fuel. The Riksbank will continue its work on enabling offline payments for other payment methods after 1 July 2026.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://www.riksbank.se/en-gb/press-and-published/notices-and-press-releases/press-releases/2025/offline-card-payments-should-be-possible-no-later-than-1-july-2026/"/><published>2025-10-03T20:36:03+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45468698</id><title>Zig builds are getting faster</title><updated>2025-10-04T15:08:33.544191+00:00</updated><content>&lt;doc fingerprint="adc8b06e29012720"&gt;
  &lt;main&gt;
    &lt;head rend="h1"&gt;Mitchell Hashimoto&lt;/head&gt;
    &lt;head rend="h1"&gt;Zig Builds Are Getting Faster&lt;/head&gt;
    &lt;p&gt;Andrew Kelley famously (or infamously, depending on your views) said "the compiler is too damn slow, that's why we have bugs."1&lt;/p&gt;
    &lt;p&gt;As a result, one of the primary stated goals of Zig for years has been faster compile times. The Zig team has been working on extremely hard problems to make this a reality (such as yeeting LLVM, writing their own code generation backends, building their own linkers, and marching towards incremental compilation in general).2&lt;/p&gt;
    &lt;p&gt;The fruits of this multi-year labor are finally starting to show with Zig 0.15.1. The Ghostty project just completed upgrading to Zig 0.15.1, and I'd like to share some real-world build times.3&lt;/p&gt;
    &lt;head rend="h2"&gt;Build Script Compilation&lt;/head&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Zig 0.14: 7sec 167ms&lt;/item&gt;
      &lt;item&gt;Zig 0.15: 1sec 702ms&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;This is the time it takes to build the &lt;code&gt;build.zig&lt;/code&gt; script itself. The
times above were measured by running &lt;code&gt;zig build --help&lt;/code&gt;.&lt;/p&gt;
    &lt;p&gt;A well-written build script should only rebuild itself rarely. However, this is a cost every new uncached source build will pay (e.g. a user downloading the project to build from source one time). As such, it directly impacts the time to build a usable binary.&lt;/p&gt;
    &lt;head rend="h2"&gt;Full Uncached Ghostty Binary&lt;/head&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Zig 0.14: 41sec&lt;/item&gt;
      &lt;item&gt;Zig 0.15: 32sec&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;This includes the time to build the build script itself. Given the prior results, Zig 0.15 is building everything else ~2 seconds faster. But, you can still see in wall time the change in this initial build time.&lt;/p&gt;
    &lt;p&gt;Important: most of this is still using LLVM. Ghostty still can't fully build and link using the self-hosted x86_64 backend, since the backend still has bugs. So, this just shows the general improvements in the Zig compiler itself, even with LLVM in the picture.&lt;/p&gt;
    &lt;p&gt;Once Ghostty can use the self-hosted x86_64 backend completely, I expect this time to plummet to around 25 seconds or less, fully half the time it would take with Zig 0.14.&lt;/p&gt;
    &lt;head rend="h2"&gt;Incremental Build (Ghostty Executable)&lt;/head&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Zig 0.14: 19sec&lt;/item&gt;
      &lt;item&gt;Zig 0.15: 16sec&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;This is the time it takes to rebuild Ghostty after a one-line change to the most core terminal emulation code (adding a log function call to the escape sequence parser).&lt;/p&gt;
    &lt;p&gt;This build has a fully cached build script and dependency graph, so it is only rebuilding what it needs to. Incremental compilation in Zig isn't functional yet, so this still recompiles a considerable amount of code. Additionally, as with the prior section, this is still using LLVM. By simply dropping LLVM out of the picture, I expect this time to drop to around 12 seconds or so (less the time LLVM is emitting).&lt;/p&gt;
    &lt;p&gt;Going further, once Zig supports incremental compilation, I expect we'll be able to measure incremental builds like this within milliseconds at worst. But, let's wait and see when that is reality.&lt;/p&gt;
    &lt;head rend="h2"&gt;Incremental Build (libghostty-vt)&lt;/head&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Zig 0.14: 2sec 884ms&lt;/item&gt;
      &lt;item&gt;Zig 0.15: 975ms&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;This is the time it takes to rebuild only libghostty-vt after a one-line change. Unlike the Ghostty executable, &lt;code&gt;libghostty-vt&lt;/code&gt;
is fully functional with the self-hosted x86_64 backend, so this
shows the differences in build times without LLVM in the picture.&lt;/p&gt;
    &lt;p&gt;Similar to the Ghostty executable, this is still rebuilding the full Zig module for &lt;code&gt;libghostty-vt&lt;/code&gt;, since incremental compilation isn't
fully functional yet. I expect this to also drop to single-digit milliseconds
at worst once incremental compilation is a reality.&lt;/p&gt;
    &lt;p&gt;But still, a sub-second build time for a non-trivial library is amazing. This is the library I'm spending most of my time working on right now, and even in a few short days since upgrading to Zig 0.15.1, I've felt a huge difference in my workflow. Previously, I might tab out to read an email between builds or tests, but now its so fast I can stay in flow in my terminal.&lt;/p&gt;
    &lt;p&gt;This improvement is most indicative of what's to come in the short term. The self-hosted x86_64 backend is already stable enough to build all debug builds by default and the aarch64 backend is getting there, too. We aren't able to build the full Ghostty executable yet, but I bet this will get ironed out within months.&lt;/p&gt;
    &lt;head rend="h2"&gt;Faster Builds Are Here&lt;/head&gt;
    &lt;p&gt;As you can see, building Ghostty with Zig 0.15.1 is faster in every single scenario, despite the fact that a lot of Ghostty still can't even take advantage of the self-hosted backend! And despite the fact that incremental compilation isn't functional yet!&lt;/p&gt;
    &lt;p&gt;I've loved betting on Zig for Ghostty, and I love that they're focusing on compile times. These improvements are real, and they're here now. And I suspect in the next couple years, the results posted today will look downright slow. 😜&lt;/p&gt;
    &lt;head rend="h2"&gt;Footnotes&lt;/head&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;
        &lt;p&gt;Timestamped link: https://youtu.be/5eL_LcxwwHg?t=565 ↩&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;This ignores an astronomical amount of work that has gone into making every aspect of the Zig compiler faster, more parallelizable, etc. ↩&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;All measurements done on the same x86_64 Linux machine. ↩&lt;/p&gt;
      &lt;/item&gt;
    &lt;/list&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://mitchellh.com/writing/zig-builds-getting-faster"/><published>2025-10-03T22:45:28+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45469579</id><title>New antibiotic targets IBD and AI predicted how it would work</title><updated>2025-10-04T15:08:33.289010+00:00</updated><content/><link href="https://healthsci.mcmaster.ca/new-antibiotic-targets-ibd-and-ai-predicted-how-it-would-work-before-scientists-could-prove-it/"/><published>2025-10-04T01:09:37+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45470206</id><title>Toyota runs a car-hacking event to boost security (2024)</title><updated>2025-10-04T15:08:33.148885+00:00</updated><content>&lt;doc fingerprint="775970e409ba9767"&gt;
  &lt;main&gt;
    &lt;p&gt;Toyota organizes a car-hacking event that captivates participating students. We uncovered the important purpose behind the event.&lt;/p&gt;
    &lt;p&gt;What comes to mind when you hear the word âhacking?â&lt;/p&gt;
    &lt;p&gt;Generally, it means âan act of unauthorized access into a system or network, intended to cause harm.â&lt;/p&gt;
    &lt;p&gt;In films and comics, hackers are often portrayed as criminals.&lt;/p&gt;
    &lt;p&gt;You may have watched scenes where such hackers tap away on keyboards as lines of numbers and symbols fill the computer screen to steal data and hijack machines.&lt;/p&gt;
    &lt;p&gt;How, then, would you feel about Toyota holding a car-hacking event?&lt;/p&gt;
    &lt;head rend="h3"&gt;Not just in Japan&lt;/head&gt;
    &lt;p&gt;Many students have gathered in a conference room. All are engrossed in a unique competition unfolding on their computer screens.&lt;/p&gt;
    &lt;p&gt;The event is Hack Festa*, a chance for IT students to pit their hacking skills against each other.&lt;/p&gt;
    &lt;p&gt;*Jointly organized by Toyota, Toyota Motor North America, Inc., and Toyota Tsusho Systems US, Inc.&lt;/p&gt;
    &lt;p&gt;The students form groups of around four and tackle the assigned tasks as a team. All of the challenges are car-related, ranging from controlling a vehicleâs speed adjustment mechanism to overwriting engine RPMs.&lt;/p&gt;
    &lt;p&gt;Their efforts are tested on simulators, earning points for every task cleared. The team with the highest score wins.&lt;/p&gt;
    &lt;p&gt;Aside from Japan, the events are also held in the United States and Ireland.&lt;/p&gt;
    &lt;p&gt;Why is Toyota hosting such events? Isnât hacking harmful?&lt;/p&gt;
    &lt;p&gt;When we posed these questions to the event producer, Hisashi Oguma, a project general manager at InfoTech-IS, explained that we first had to understand the challenges facing the auto industry.&lt;/p&gt;
    &lt;head rend="h3"&gt;With convenience comes new threats&lt;/head&gt;
    &lt;p&gt;Hisashi Oguma, Ph.D., Project General Manager/Principal Researcher, InfoTech-IS&lt;/p&gt;
    &lt;p&gt;Today, cars are evolving in unprecedented ways through internet connectivity, with automated driving and connected cars as obvious examples.&lt;/p&gt;
    &lt;p&gt;Another concept that has emerged recently is the SDV (Software Defined Vehicle). Simply put, it involves updating the onboard software after purchase, continuing to expand the carâs functionality as you would a smartphone.&lt;/p&gt;
    &lt;p&gt;Internet integration improves convenience. At the same time, it also makes it easier for malicious third parties to hack car systems.&lt;/p&gt;
    &lt;p&gt;The cybersecurity that protects customers from such harm has become more important than ever, not only for Toyota but for the entire auto industry.&lt;/p&gt;
    &lt;p&gt;In serious cases, a hacked car could mean a loss of control over its basic functions of driving, turning, and stopping.&lt;/p&gt;
    &lt;p&gt;As an example, the video below shows a simulation of what might happen if steering wheel control is compromised while driving.&lt;/p&gt;
    &lt;p&gt;Would you be able to keep your cool if this happened in real life?&lt;/p&gt;
    &lt;p&gt;Ogumaâs division researches ways to prevent such harm. It organizes the Hack Festa to help counter potential threats.&lt;/p&gt;
    &lt;p&gt;A hacking event to boost cybersecurity. It sounds contradictory, but what on earth does it mean?&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://toyotatimes.jp/en/spotlights/1061.html"/><published>2025-10-04T03:11:28+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45471136</id><title>Alibaba cloud FPGA: the $200 Kintex UltraScale+</title><updated>2025-10-04T15:08:32.914050+00:00</updated><content>&lt;doc fingerprint="bd18a05c4875d6f6"&gt;
  &lt;main&gt;
    &lt;head rend="h2"&gt;Introduction#&lt;/head&gt;
    &lt;p&gt;I was recently in the market for a new FPGA to start building my upcoming projects on.&lt;/p&gt;
    &lt;p&gt;Due to the scale of my upcoming projects a Xilinx series 7 UltraScale+ FPGA of the Virtex family would be perfect, but a Kintex series FPGA will be sufficient for early prototyping. Due to not wanting to part ways with the eye watering amounts of money that is required for an Vivado enterprise edition license my choice was effectively narrowed to the FPGA chips available under the WebPack version of Vivado.&lt;/p&gt;
    &lt;p&gt;Unsurprisingly Xilinx are well aware of how top of the range the Virtex series are, and doesn’t offer any Virtex UltraScale+ chips with the webpack license. That said, they do offer support for two very respectable Kintex UltraScale+ FPGA models, the &lt;code&gt;XCKU3P&lt;/code&gt; and the &lt;code&gt;XCKU5P&lt;/code&gt;.&lt;/p&gt;
    &lt;p&gt;These two chips are far from being small hobbyist toys, with the smaller &lt;code&gt;XCUK3P&lt;/code&gt; already boasting +162K LUTs and
16 GTY transceivers, capable, depending on the physical constraints imposed by the chip packaging of
operating at up to 32.75Gb/s.&lt;/p&gt;
    &lt;p&gt;Now that the chip selection has been narrowed down I set out to look for a dev board.&lt;/p&gt;
    &lt;p&gt;My requirements for the board where that it featured :&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;at least 2 SFP+ or 1 QSFP connector&lt;/item&gt;
      &lt;item&gt;a JTAG interface&lt;/item&gt;
      &lt;item&gt;a PCIe interface at least x8 wide&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;As to where to get the board from, my options where :&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Design the board myself&lt;/item&gt;
      &lt;item&gt;Get the AXKU5 or AXKU3 from Alinx&lt;/item&gt;
      &lt;item&gt;See what I could unearth on the second hand market&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Although option &lt;code&gt;1&lt;/code&gt; could have been very interesting, designing a
dev board with both a high speed PCIe and ethernet interface was not the goal of
today’s project.&lt;/p&gt;
    &lt;p&gt;As for option &lt;code&gt;2&lt;/code&gt;,
Alinx is newer vendor that is still building up its credibility in the west,
their technical documentation is a bit sparse, but the feedback seems to be positive with no major issues being reported.
Most importantly, Alinx provided very fairly priced development boards
in the 900 to 1050 dollar range ( +150$ for the HPC FMC SFP+ extension board ).
Although these are not cheap by any metric, compared to the competitions
price point, they are the best value.&lt;/p&gt;
    &lt;p&gt;Option &lt;code&gt;2&lt;/code&gt; was coming up ahead until I stumbled upon this ebay listing :&lt;/p&gt;
    &lt;p&gt;For 200$ this board featured a &lt;code&gt;XCKU3P-FFVB676&lt;/code&gt;, 2 SPF+ connector and a x8 PCIe interface.
On the flip side it came with no documentation whatsoever, no guaranty it worked, and the
faint promise in the listing that there was a JTAG interface.
A sane person would likely have dismissed this as an interesting internet oddity, a remanence
of what happens when a generation of accelerator cards gets phased out in favor of the next,
or maybe just an expensive paperweight.&lt;/p&gt;
    &lt;p&gt;But I like a challenge, and the appeal of unlocking the 200$ Kintex UltraScale+ development board was too great to ignore.&lt;/p&gt;
    &lt;p&gt;As such, I aim for this article to become the documentation paving the way to though this mirage.&lt;/p&gt;
    &lt;head rend="h2"&gt;The debugger challenge#&lt;/head&gt;
    &lt;p&gt;Xilinx’s UG908 Programming and Debugging User Guide (Appendix D) specifies their blessed JTAG probe ecosystem for FPGA configuration and debug. Rather than dropping $100+ on yet another proprietary dongle that’ll collect dust after the project ends, I’m exploring alternatives. The obvious tradeoff: abandoning Xilinx’s toolchain means losing ILA integration. However, the ILA fundamentally just captures samples and streams them via JTAG USER registers, there’s nothing preventing us from building our own logic analyzer with equivalent functionality and a custom host interface.&lt;/p&gt;
    &lt;p&gt;Enter OpenOCD. While primarily targeting ARM/RISC-V SoCs, it maintains an impressive database of supported probe hardware and provides granular control over JTAG operations. More importantly, it natively supports SVF (Serial Vector Format), a vendor-neutral bitstream format that Vivado can export.&lt;/p&gt;
    &lt;p&gt;The documentation landscape is admittedly sparse for anything beyond 7-series FPGAs, and the most recent OpenOCD documentation I could unearth was focused on Zynq ARM core debugging rather than fabric configuration. But the fundamentals remain sound: JTAG is JTAG, SVF is standardized, and the boundary scan architecture hasn’t fundamentally changed.&lt;/p&gt;
    &lt;p&gt;The approach should be straightforward: generate SVF from Vivado, feed it through OpenOCD with a commodity JTAG adapter, and validate the configuration. Worst case, we’ll need to patch some adapter-specific quirks or boundary scan chain register addresses. Time to find out if this theory holds up in practice.&lt;/p&gt;
    &lt;head rend="h2"&gt;The plan#&lt;/head&gt;
    &lt;p&gt;So, to resume, the current plan is to buy a second hand hardware accelerator of eBay at a too good to be true price, and try to configure it with an unofficial probe using open source software without any clear official support.&lt;lb/&gt;The answer to the obvious question you are thinking if you, like me, have been around the block a few times is: many things.&lt;/p&gt;
    &lt;p&gt;As such, we need a plan for approaching this. The goal of this plan is to outline incremental steps that will build upon themselves with the end goal of being able to use this as a dev board.&lt;/p&gt;
    &lt;head rend="h3"&gt;1 - Confirming the board works#&lt;/head&gt;
    &lt;p&gt;First order of business will be to confirm the board is showing signs of working as intended.&lt;/p&gt;
    &lt;p&gt;There is a high probability that the flash wasn’t wiped before this board was sold off, as such the previous bitstream should still be in the flash. Given this board was used as an accelerator, we should be able to use that to confirm the board is working by either checking if the board is presenting itself as a PCIe endpoint or if the SFP’s are sending the ethernet PHY idle sequence.&lt;/p&gt;
    &lt;head rend="h3"&gt;2 - Connecting a debugger to it#&lt;/head&gt;
    &lt;p&gt;The next step is going to be to try and connect the debugger. The eBay listing advertised there is a JTAG interface, but the picture is grainy enough that where that JTAG is and what pins are available is unclear.&lt;/p&gt;
    &lt;p&gt;Additionally, we have no indication of what devices are daisy chained together onto the JTAG scan chain. This is an essential question for flashing over JTAG, so it will need to be figured out.&lt;/p&gt;
    &lt;p&gt;At this point, it would also be strategic to try and do some more probing into the FPGA via JTAG. Xilinx FPGAs exposes a handful of useful system registers accessible over JTAG. The most well known of these interfaces is the SYSMON, which allows us, among other things, to get real time temperature and voltage reading from inside the chip. Although openOCD doesn’t have SYSMON support out of the box it would be worth while to build it, to :&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Familiarise myself with openOCD scripting, this might come in handy when building my ILA replacement down the line&lt;/item&gt;
      &lt;item&gt;Having an easy side channel to monitor FPGA operating parameters&lt;/item&gt;
      &lt;item&gt;Make a contribution to openOCD as it have support for the interfacing with XADC but not SYSMON&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h3"&gt;3 - Figuring out the Pinout#&lt;/head&gt;
    &lt;p&gt;The hardest part will be figuring out the FPGA’s pinout and my clock sources. The questions that need answering are :&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;what external clocks sources do I have, what are there frequencies and which pins are they connected to&lt;/item&gt;
      &lt;item&gt;which transceivers are the SFPs connected to&lt;/item&gt;
      &lt;item&gt;which transceivers is the PCIe connected to&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h3"&gt;4 - Writing a bitstream#&lt;/head&gt;
    &lt;p&gt;For now I will be focusing on writing a temporary configurations over JTAG to the CCLs and not re-writing the flash.&lt;/p&gt;
    &lt;p&gt;That plan is to trying writing either the bitstream directly though openOCD’s &lt;code&gt;virtex2&lt;/code&gt; + &lt;code&gt;pld&lt;/code&gt; drivers, or by replaying the
SVF generated by Vivado.&lt;/p&gt;
    &lt;p&gt;Since I believe a low iteration time is paramount to project velocity and getting big things done, I also want automatize all of the Vivado flow from taking the rtl to the SVF generation.&lt;/p&gt;
    &lt;p&gt;Simple enough ?&lt;/p&gt;
    &lt;head rend="h2"&gt;Liveness test#&lt;/head&gt;
    &lt;p&gt;A few days later my prize arrived via express mail.&lt;/p&gt;
    &lt;p&gt;Unexpectedly it even came with a free 25G SFP28 Huawei transceiver rated for a 300m distance and a single 1m long OS2 fiber patch cable. This was likely not intentional as the transceiver was jammed in the SFP cage, but it was still very generous of them to include the fiber patch cable.&lt;/p&gt;
    &lt;p&gt;The board also came with a travel case and half of a PCIe to USB adapter and a 12V power supply that one could use to power the board as a standalone device. Although this standalone configuration will not be of any use to me, for those looking to develop just networking interfaces without any PCIe interface, this could come in handy.&lt;/p&gt;
    &lt;p&gt;Overall the board looked a little worn, but both the transceiver cages and PCIe connectors didn’t look to be damaged.&lt;/p&gt;
    &lt;head rend="h3"&gt;Standalone configuration#&lt;/head&gt;
    &lt;p&gt;Before real testing could start I first did a small power-up test using the PCIe to USB adapter that the seller provided. I was able to do a quick check using the LEDs and the FPGAs dissipated heat that the board seemed to be powering up at a surface level (pun intended).&lt;/p&gt;
    &lt;head rend="h3"&gt;PCIe interface#&lt;/head&gt;
    &lt;p&gt;Since I didn’t want to directly plug mystery hardware into my prized build server, I decided to use a Raspberry Pi 5 as my sacrificial test device and got myself an external PCIe adapter.&lt;/p&gt;
    &lt;p&gt;It just so happened that the latest Raspberry Pi version, the Pi 5, now features an external PCIe Gen 2.0 x1 interface. Though our FPGA can handle up to a PCIe Gen 3.0 and the board had a x8 wide interface, since PCIe standard is backwards compatible and the number of lanes on the interface can be downgraded, plugging our FPGA with this Raspberry Pi will work.&lt;/p&gt;
    &lt;p&gt;After both the Raspberry and the FPGA were booted, I SSHed into my rpi and started looking for the PCIe enumeration sequence logged from the Linux PCIe core subsystem.&lt;/p&gt;
    &lt;p&gt;&lt;code&gt;dmesg&lt;/code&gt; log :&lt;/p&gt;
    &lt;code&gt;[    0.388790] pci 0000:00:00.0: [14e4:2712] type 01 class 0x060400
[    0.388817] pci 0000:00:00.0: PME# supported from D0 D3hot
[    0.389752] pci 0000:00:00.0: bridge configuration invalid ([bus 00-00]), reconfiguring
[    0.495733] brcm-pcie 1000110000.pcie: link up, 5.0 GT/s PCIe x1 (!SSC)
[    0.495759] pci 0000:01:00.0: [dabc:1017] type 00 class 0x020000
&lt;/code&gt;
    &lt;head rend="h4"&gt;Background information#&lt;/head&gt;
    &lt;p&gt;Since most people might not be intimately as familiar with PCIe terminology, allow me to quickly document what is going on here.&lt;/p&gt;
    &lt;p&gt;&lt;code&gt;0000:00:00.0&lt;/code&gt;: is the identifier of a specific PCIe device connected through the PCIe network
to the kernel, it read as &lt;code&gt;domain&lt;/code&gt;:&lt;code&gt;bus&lt;/code&gt;:&lt;code&gt;device&lt;/code&gt;.&lt;code&gt;function&lt;/code&gt;.&lt;/p&gt;
    &lt;p&gt;&lt;code&gt;[14e4:2712]&lt;/code&gt;: is the device’s &lt;code&gt;[vendor id:device id]&lt;/code&gt;, these vendor id identifiers are
assigned by the PCI standard body to hardware vendors. Vendors are then free to define there
own vendor id’s.&lt;/p&gt;
    &lt;p&gt;The full list of official vendor id’s and released device id can be found : https://admin.pci-ids.ucw.cz/read/PC/14e4 or in the linux kernel code : https://github.com/torvalds/linux/blob/7aac71907bdea16e2754a782b9d9155449a9d49d/include/linux/pci_ids.h#L160-L3256&lt;/p&gt;
    &lt;p&gt;&lt;code&gt;type 01&lt;/code&gt;: PCIe has two types of devices, bridges allowing the connection of multiple downstream devices to an
upstream device, and endpoints are the leafs.
Bridges are of type &lt;code&gt;01&lt;/code&gt; and endpoints of type &lt;code&gt;00&lt;/code&gt;.&lt;/p&gt;
    &lt;p&gt;&lt;code&gt;class 0x60400&lt;/code&gt;: is the PCIe device class, it categorizes the kind of function the device performs. It
uses the following format &lt;code&gt;0x[Base Class (8 bits)][Sub Class (8 bits)][Programming Interface (8 bits)]&lt;/code&gt;,
( note : the sub class field might be unused ).&lt;/p&gt;
    &lt;p&gt;A list of class and sub class identifiers can be found: https://admin.pci-ids.ucw.cz/read/PD or again in the linux codebase : https://github.com/torvalds/linux/blob/7aac71907bdea16e2754a782b9d9155449a9d49d/include/linux/pci_ids.h#L15-L158&lt;/p&gt;
    &lt;head rend="h4"&gt;Dmesg log#&lt;/head&gt;
    &lt;p&gt;The two most interesting lines of the &lt;code&gt;dmesg&lt;/code&gt; log are :&lt;/p&gt;
    &lt;code&gt;[    0.388790] pci 0000:00:00.0: [14e4:2712] type 01 class 0x060400
[    0.495759] pci 0000:01:00.0: [dabc:1017] type 00 class 0x020000
&lt;/code&gt;
    &lt;p&gt;Firstly the PCIe subsystem logs that at &lt;code&gt;0000:00:00.0&lt;/code&gt; it has discovered a Broadcom BCM2712 PCIe Bridge ( vendor id &lt;code&gt;14e4&lt;/code&gt;, device id &lt;code&gt;0x2712&lt;/code&gt; ).This bridge (type &lt;code&gt;01&lt;/code&gt;) class &lt;code&gt;0x0604xx&lt;/code&gt; tells us it is a PCI-to-PCI bridge, meaning it is essentially creating additional PCIe lanes downstream for endpoint devices or additional bridges.&lt;/p&gt;
    &lt;p&gt;The subsystem then discovers a second device at &lt;code&gt;0000:01:00.0&lt;/code&gt;, this is an endpoint (type &lt;code&gt;00&lt;/code&gt;), and class &lt;code&gt;0x02000&lt;/code&gt; tells us it is an ethernet networking equipment.&lt;lb/&gt;Of note &lt;code&gt;dabc&lt;/code&gt; doesn’t correspond to a known vendor id.
When designing a PCIe interface in hardware these
are parameters we can configured. Additionally, among the different ways Linux uses to identify which driver to load for a PCIe device
the vendor id and device id can be used for matching. Supposing we are implementing custom logic, in order to prevent any bug where the wrong driver
might be loaded, it is best to use a separate vendor id.
This also helps identify your custom accelerator at a glance and use it to load your custom driver.&lt;/p&gt;
    &lt;p&gt;As such, it is not surprising to see an unknown vendor id appear for an FPGA, this with the class as an ethernet networking device is a strong hint this is our board.&lt;/p&gt;
    &lt;head rend="h4"&gt;Full PCIe device status#&lt;/head&gt;
    &lt;p&gt;Dmesg logs have already given us a good indication that our FPGA board and its PCIe interface was working but to confirm with certainty that the device with vendor id &lt;code&gt;dabc&lt;/code&gt; is our FPGA we now turn to &lt;code&gt;lspci&lt;/code&gt;.
&lt;code&gt;lspci -vvv&lt;/code&gt; is the most verbose output and gives us a full overview of the detected PCIe devices capabilities and current configurations.&lt;/p&gt;
    &lt;p&gt;Broadcom bridge:&lt;/p&gt;
    &lt;code&gt;0000:00:00.0 PCI bridge: Broadcom Inc. and subsidiaries BCM2712 PCIe Bridge (rev 21) (prog-if 00 [Normal decode])
        Control: I/O- Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr- Stepping- SERR- FastB2B- DisINTx-
        Status: Cap+ 66MHz- UDF- FastB2B- ParErr- DEVSEL=fast &amp;gt;TAbort- &amp;lt;TAbort- &amp;lt;MAbort- &amp;gt;SERR- &amp;lt;PERR- INTx-
        Latency: 0
        Interrupt: pin A routed to IRQ 38
        Bus: primary=00, secondary=01, subordinate=01, sec-latency=0
        Memory behind bridge: [disabled] [32-bit]
        Prefetchable memory behind bridge: 1800000000-182fffffff [size=768M] [32-bit]
        Secondary status: 66MHz- FastB2B- ParErr- DEVSEL=fast &amp;gt;TAbort- &amp;lt;TAbort- &amp;lt;MAbort- &amp;lt;SERR- &amp;lt;PERR-
        BridgeCtl: Parity- SERR- NoISA- VGA- VGA16- MAbort- &amp;gt;Reset- FastB2B-
                PriDiscTmr- SecDiscTmr- DiscTmrStat- DiscTmrSERREn-
        Capabilities: [48] Power Management version 3
                Flags: PMEClk- DSI- D1- D2- AuxCurrent=0mA PME(D0+,D1-,D2-,D3hot+,D3cold-)
                Status: D0 NoSoftRst+ PME-Enable- DSel=0 DScale=1 PME-
        Capabilities: [ac] Express (v2) Root Port (Slot-), MSI 00
                DevCap: MaxPayload 512 bytes, PhantFunc 0
                        ExtTag- RBE+
                DevCtl: CorrErr- NonFatalErr- FatalErr- UnsupReq-
                        RlxdOrd+ ExtTag- PhantFunc- AuxPwr+ NoSnoop+
                        MaxPayload 512 bytes, MaxReadReq 512 bytes
                DevSta: CorrErr- NonFatalErr- FatalErr- UnsupReq- AuxPwr- TransPend-
                LnkCap: Port #0, Speed 5GT/s, Width x1, ASPM L0s L1, Exit Latency L0s &amp;lt;2us, L1 &amp;lt;4us
                        ClockPM+ Surprise- LLActRep- BwNot+ ASPMOptComp+
                LnkCtl: ASPM Disabled; RCB 64 bytes, Disabled- CommClk-
                        ExtSynch- ClockPM- AutWidDis- BWInt- AutBWInt-
                LnkSta: Speed 5GT/s, Width x1
                        TrErr- Train- SlotClk+ DLActive- BWMgmt- ABWMgmt+
                RootCap: CRSVisible+
                RootCtl: ErrCorrectable- ErrNon-Fatal- ErrFatal- PMEIntEna+ CRSVisible+
                RootSta: PME ReqID 0000, PMEStatus- PMEPending-
                DevCap2: Completion Timeout: Range ABCD, TimeoutDis+ NROPrPrP- LTR+
                         10BitTagComp- 10BitTagReq- OBFF Via WAKE#, ExtFmt- EETLPPrefix-
                         EmergencyPowerReduction Not Supported, EmergencyPowerReductionInit-
                         FRS- LN System CLS Not Supported, TPHComp- ExtTPHComp- ARIFwd+
                         AtomicOpsCap: Routing- 32bit- 64bit- 128bitCAS-
                DevCtl2: Completion Timeout: 50us to 50ms, TimeoutDis- LTR- 10BitTagReq- OBFF Disabled, ARIFwd-
                         AtomicOpsCtl: ReqEn- EgressBlck-
                LnkCap2: Supported Link Speeds: 2.5-5GT/s, Crosslink- Retimer- 2Retimers- DRS+
                LnkCtl2: Target Link Speed: 5GT/s, EnterCompliance- SpeedDis-
                         Transmit Margin: Normal Operating Range, EnterModifiedCompliance- ComplianceSOS-
                         Compliance Preset/De-emphasis: -6dB de-emphasis, 0dB preshoot
                LnkSta2: Current De-emphasis Level: -6dB, EqualizationComplete- EqualizationPhase1-
                         EqualizationPhase2- EqualizationPhase3- LinkEqualizationRequest-
                         Retimer- 2Retimers- CrosslinkRes: unsupported, DRS-
                         DownstreamComp: Link Up - Present
        Capabilities: [100 v1] Advanced Error Reporting
                UESta:  DLP- SDES- TLP- FCP- CmpltTO- CmpltAbrt- UnxCmplt- RxOF- MalfTLP- ECRC- UnsupReq- ACSViol-
                UEMsk:  DLP- SDES- TLP- FCP- CmpltTO- CmpltAbrt- UnxCmplt- RxOF- MalfTLP- ECRC- UnsupReq- ACSViol-
                UESvrt: DLP+ SDES+ TLP- FCP+ CmpltTO- CmpltAbrt- UnxCmplt- RxOF+ MalfTLP+ ECRC- UnsupReq- ACSViol-
                CESta:  RxErr- BadTLP- BadDLLP- Rollover- Timeout- AdvNonFatalErr-
                CEMsk:  RxErr- BadTLP- BadDLLP- Rollover- Timeout- AdvNonFatalErr+
                AERCap: First Error Pointer: 00, ECRCGenCap+ ECRCGenEn- ECRCChkCap+ ECRCChkEn-
                        MultHdrRecCap- MultHdrRecEn- TLPPfxPres- HdrLogCap-
                HeaderLog: 00000000 00000000 00000000 00000000
                RootCmd: CERptEn+ NFERptEn+ FERptEn+
                RootSta: CERcvd- MultCERcvd- UERcvd- MultUERcvd-
                         FirstFatal- NonFatalMsg- FatalMsg- IntMsg 0
                ErrorSrc: ERR_COR: 0000 ERR_FATAL/NONFATAL: 0000
        Capabilities: [160 v1] Virtual Channel
                Caps:   LPEVC=0 RefClk=100ns PATEntryBits=1
                Arb:    Fixed- WRR32- WRR64- WRR128-
                Ctrl:   ArbSelect=Fixed
                Status: InProgress-
                VC0:    Caps:   PATOffset=00 MaxTimeSlots=1 RejSnoopTrans-
                        Arb:    Fixed- WRR32- WRR64- WRR128- TWRR128- WRR256-
                        Ctrl:   Enable+ ID=0 ArbSelect=Fixed TC/VC=ff
                        Status: NegoPending- InProgress-
        Capabilities: [180 v1] Vendor Specific Information: ID=0000 Rev=0 Len=028 &amp;lt;?&amp;gt;
        Capabilities: [240 v1] L1 PM Substates
                L1SubCap: PCI-PM_L1.2+ PCI-PM_L1.1+ ASPM_L1.2+ ASPM_L1.1+ L1_PM_Substates+
                          PortCommonModeRestoreTime=8us PortTPowerOnTime=10us
                L1SubCtl1: PCI-PM_L1.2- PCI-PM_L1.1- ASPM_L1.2- ASPM_L1.1-
                           T_CommonMode=1us LTR1.2_Threshold=0ns
                L1SubCtl2: T_PwrOn=10us
        Capabilities: [300 v1] Secondary PCI Express
                LnkCtl3: LnkEquIntrruptEn- PerformEqu-
                LaneErrStat: 0
        Kernel driver in use: pcieport
&lt;/code&gt;
    &lt;p&gt;FPGA board:&lt;/p&gt;
    &lt;code&gt;0000:01:00.0 Ethernet controller: Device dabc:1017
        Subsystem: Red Hat, Inc. Device a001
        Control: I/O- Mem- BusMaster- SpecCycle- MemWINV- VGASnoop- ParErr- Stepping- SERR- FastB2B- DisINTx-
        Status: Cap+ 66MHz- UDF- FastB2B- ParErr- DEVSEL=fast &amp;gt;TAbort- &amp;lt;TAbort- &amp;lt;MAbort- &amp;gt;SERR- &amp;lt;PERR- INTx-
        Region 0: Memory at 1820000000 (64-bit, prefetchable) [disabled] [size=2K]
        Region 2: Memory at 1800000000 (64-bit, prefetchable) [disabled] [size=512M]
        Capabilities: [40] Power Management version 3
                Flags: PMEClk- DSI- D1- D2- AuxCurrent=0mA PME(D0-,D1-,D2-,D3hot-,D3cold-)
                Status: D0 NoSoftRst+ PME-Enable- DSel=0 DScale=0 PME-
        Capabilities: [70] Express (v2) Endpoint, MSI 00
                DevCap: MaxPayload 1024 bytes, PhantFunc 0, Latency L0s &amp;lt;64ns, L1 &amp;lt;1us
                        ExtTag+ AttnBtn- AttnInd- PwrInd- RBE+ FLReset- SlotPowerLimit 0W
                DevCtl: CorrErr+ NonFatalErr+ FatalErr+ UnsupReq+
                        RlxdOrd+ ExtTag+ PhantFunc- AuxPwr- NoSnoop+
                        MaxPayload 512 bytes, MaxReadReq 512 bytes
                DevSta: CorrErr- NonFatalErr- FatalErr- UnsupReq- AuxPwr- TransPend-
                LnkCap: Port #0, Speed 8GT/s, Width x8, ASPM not supported
                        ClockPM- Surprise- LLActRep- BwNot- ASPMOptComp+
                LnkCtl: ASPM Disabled; RCB 64 bytes, Disabled- CommClk-
                        ExtSynch- ClockPM- AutWidDis- BWInt- AutBWInt-
                LnkSta: Speed 5GT/s (downgraded), Width x1 (downgraded)
                        TrErr- Train- SlotClk+ DLActive- BWMgmt- ABWMgmt-
                DevCap2: Completion Timeout: Range BC, TimeoutDis+ NROPrPrP- LTR-
                         10BitTagComp- 10BitTagReq- OBFF Not Supported, ExtFmt- EETLPPrefix-
                         EmergencyPowerReduction Not Supported, EmergencyPowerReductionInit-
                         FRS- TPHComp- ExtTPHComp-
                         AtomicOpsCap: 32bit- 64bit- 128bitCAS-
                DevCtl2: Completion Timeout: 50us to 50ms, TimeoutDis- LTR- 10BitTagReq- OBFF Disabled,
                         AtomicOpsCtl: ReqEn-
                LnkCap2: Supported Link Speeds: 2.5-8GT/s, Crosslink- Retimer- 2Retimers- DRS-
                LnkCtl2: Target Link Speed: 8GT/s, EnterCompliance- SpeedDis-
                         Transmit Margin: Normal Operating Range, EnterModifiedCompliance- ComplianceSOS-
                         Compliance Preset/De-emphasis: -6dB de-emphasis, 0dB preshoot
                LnkSta2: Current De-emphasis Level: -6dB, EqualizationComplete- EqualizationPhase1-
                         EqualizationPhase2- EqualizationPhase3- LinkEqualizationRequest-
                         Retimer- 2Retimers- CrosslinkRes: unsupported
        Capabilities: [100 v1] Advanced Error Reporting
                UESta:  DLP- SDES- TLP- FCP- CmpltTO- CmpltAbrt- UnxCmplt- RxOF- MalfTLP- ECRC- UnsupReq- ACSViol-
                UEMsk:  DLP- SDES- TLP- FCP- CmpltTO- CmpltAbrt- UnxCmplt- RxOF- MalfTLP- ECRC- UnsupReq- ACSViol-
                UESvrt: DLP+ SDES+ TLP- FCP+ CmpltTO- CmpltAbrt- UnxCmplt- RxOF+ MalfTLP+ ECRC- UnsupReq- ACSViol-
                CESta:  RxErr- BadTLP- BadDLLP- Rollover- Timeout- AdvNonFatalErr-
                CEMsk:  RxErr- BadTLP- BadDLLP- Rollover- Timeout- AdvNonFatalErr+
                AERCap: First Error Pointer: 00, ECRCGenCap- ECRCGenEn- ECRCChkCap- ECRCChkEn-
                        MultHdrRecCap- MultHdrRecEn- TLPPfxPres- HdrLogCap-
                HeaderLog: 00000000 00000000 00000000 00000000
        Capabilities: [1c0 v1] Secondary PCI Express
                LnkCtl3: LnkEquIntrruptEn- PerformEqu-
                LaneErrStat: 0
&lt;/code&gt;
    &lt;p&gt;For our board, the following lines are particularly interesting:&lt;/p&gt;
    &lt;code&gt;                LnkCap: Port #0, Speed 8GT/s, Width x8, ASPM not supported
                        ClockPM- Surprise- LLActRep- BwNot- ASPMOptComp+
                LnkCtl: ASPM Disabled; RCB 64 bytes, Disabled- CommClk-
                        ExtSynch- ClockPM- AutWidDis- BWInt- AutBWInt-
                LnkSta: Speed 5GT/s (downgraded), Width x1 (downgraded)0x060400
&lt;/code&gt;
    &lt;p&gt;The &lt;code&gt;LnkCap&lt;/code&gt; tells us about the full capabilities of this PCIe device, here we can see that
the current design supports PCIe Gen 3.0 x8.
The &lt;code&gt;LnkSta&lt;/code&gt; tells us the current configuration, here we have been downgraded to PCIe Gen 2.0 at 5GT/s with a width of only x1.&lt;/p&gt;
    &lt;p&gt;During startup of when a new PCIe device is plugged, PCIe performs a link speed and width negotiation where it tries to reach the highest supported stable configuration for the current system. In our current system, though our FPGA is capable of 8GT/s, as it is located downstream of the Broadcom bridge with a maximum link capacity of Gen 2.0 ( 5GT/s ), the FPGA has been downgraded to 5GT/s.&lt;/p&gt;
    &lt;p&gt;As for the width of x1, that is expected since the Broadcom bridge is also only x1 wide, and our board’s other 7 PCIe lanes are literally hanging over the side.&lt;/p&gt;
    &lt;p&gt;Thus, we can finally confirm that this is our board and that the PCIe interface is working. We can now proceed to establishing the JTAG connection.&lt;/p&gt;
    &lt;head rend="h2"&gt;JTAG interface#&lt;/head&gt;
    &lt;p&gt;Xilinx FPGAs can be configured by writing a bitstream to their internal CMOS Configuration Latches (CCL). CCL is SRAM memory and volatile, thus the configuration is re-done on every power cycle. For devices in the field this bitstream would be read from an external SPI memory during initialization, or written from an external device, such as an embedded controller. But for development purposes overwriting the contents of the CCLs over JTAG is acceptable.&lt;/p&gt;
    &lt;p&gt;This configuration is done by shifting in the entire FPGA bitstream into the device’s configuration logic over the JTAG bus.&lt;/p&gt;
    &lt;head rend="h3"&gt;FPGA board JTAG interface#&lt;/head&gt;
    &lt;p&gt;As promised by the original eBay listing the board did come with an accessible JTAG interface, and gloriously enough, this time there wasn’t even the need for any additional soldering.&lt;/p&gt;
    &lt;p&gt;In addition to a power reference, and ground, conformely to the Xilinx JTAG interface it featured the four mandatory signals comprising the JTAG TAP :&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;TCK Test Clock&lt;/item&gt;
      &lt;item&gt;TMS Test Mode Select&lt;/item&gt;
      &lt;item&gt;TDI Test Data Input&lt;/item&gt;
      &lt;item&gt;TDO Test Data Output&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Of note, the JTAG interface can also come with an independent reset signal. But since Xilinx JTAG interfaces do not have this independent reset signal, we be using the JTAG FSM reset state for our reset signal.&lt;/p&gt;
    &lt;p&gt;This interface layout doesn’t follow a standard layout so I cannot just plug in one of my debug probes, it requires some re-wiring.&lt;/p&gt;
    &lt;head rend="h3"&gt;Segger JLINK :heart:#&lt;/head&gt;
    &lt;p&gt;I do not own an AMD approved JTAG programmer.&lt;/p&gt;
    &lt;p&gt;Traditionally speaking, the Segger JLink is used for debugging embedded CPUs let them be standalone or in a Zynq, and not for configuring FPGAs.&lt;/p&gt;
    &lt;p&gt;That said, all we need to do is use JTAG to shift in a bitstream to the CCLs, so technically speaking any programmable device with 4 sufficiently fast GPIOs can be used as a JTAG programmer. Additionally, the JLink is well supported by OpenOCD, the JLink’s libraries are open source, and I happened to own one.&lt;/p&gt;
    &lt;head rend="h4"&gt;Wiring#&lt;/head&gt;
    &lt;p&gt;Rewiring :&lt;/p&gt;
    &lt;p&gt;JTAG is a parallel protocol where &lt;code&gt;TDI&lt;/code&gt; and &lt;code&gt;TMS&lt;/code&gt; will be captured according to &lt;code&gt;TCK&lt;/code&gt;.
Because of this, good JTAG PCB trace length matching is advised in order to minimize skew.&lt;/p&gt;
    &lt;p&gt;Ideally a custom connector with length matched traces to work as an interface between the JLink’s probe and a board specific connector would be used.&lt;/p&gt;
    &lt;p&gt;Yet, here we are shoving breadboard wires between our debugger and the board. Since OpenOCD allows us to easily control the debugger clock speed, we can increase the skew tolerance by slowing down the TCK clock signal. As such there is no immediate need for a custom connector but we will not be able to reach the maximum JTAG speeds.&lt;/p&gt;
    &lt;p&gt;No issues were encountered at these speeds.&lt;/p&gt;
    &lt;head rend="h3"&gt;OpenOCD#&lt;/head&gt;
    &lt;p&gt;OpenOCD is a free and open source on-chip debugger software that aims to be compatible with as many probes, boards and chips as possible.&lt;/p&gt;
    &lt;p&gt;Since OpenOCD has support for the standard SVF file format, my plan for my flashing flow will be to use Vivado to generate the SVF and have OpenOCD flash it. Now, some of you might be starting to notice that I am diverging quite far from the well lit path of officially supported tools. Not only am I using a not officially supported debug probe, but I am also using some obscure open source software with questionable support for interfacing with Xilinx UltraScale+ FPGAs. You might be wondering, given that the officially supported tools can already prove themselves to be a headache to get working properly, why am I seemingly making my life even harder?&lt;/p&gt;
    &lt;p&gt;The reason is quite simple: when things inevitably start going wrong, as they will, having an entirely open toolchain, allows me to have more visibility as to what is going on and the ability to fix it. I cannot delve into a black box.&lt;/p&gt;
    &lt;head rend="h4"&gt;Building OpenOCD#&lt;/head&gt;
    &lt;p&gt;By default the version of OpenOCD that I got on my server via the official packet manager was outdated and missing features I will need.&lt;/p&gt;
    &lt;p&gt;Also, since saving the ability to modify OpenOCD’s source code could come in handy, I decided to re-build it from source.&lt;/p&gt;
    &lt;p&gt;Thus, in the following logs, I will be running OpenOCD version &lt;code&gt;0.12.0+dev-02170-gfcff4b712&lt;/code&gt;.&lt;/p&gt;
    &lt;p&gt;Note : I have also re-build the JLink libs from source.&lt;/p&gt;
    &lt;head rend="h3"&gt;Determining the scan chain#&lt;/head&gt;
    &lt;p&gt;Since I do not have the schematics for the board I do not know how many devices are daisy-chainned on the board JTAG bus. Also, I want to confirm if the FPGA on the ebay listing is actually the one on the board. In JTAG, each chained device exposes an accessible &lt;code&gt;IDCODE&lt;/code&gt; register used to identify the manufacturer, device type, and revision number.&lt;/p&gt;
    &lt;p&gt;When setting up the JTAG server, we typically define the scan chain by specifying the expected &lt;code&gt;IDCODE&lt;/code&gt; for each TAP and the corresponding instruction register length, so that instructions can be correctly aligned and routed to the intended device.
Given this is an undocumented board off Ebay, I do not know what the chain looks like.
Fortunately, OpenOCD has an autoprobing functionality, to do a blind interrogation in an attempt to discover
the available devices.&lt;/p&gt;
    &lt;p&gt;Thus, my first order of business was doing this autoprobing.&lt;/p&gt;
    &lt;p&gt;In OpenOCD the autoprobing is done when the configuration does not specify any taps.&lt;/p&gt;
    &lt;code&gt;source [find interface/jlink.cfg]
transport select jtag

set SPEED 1
jtag_rclk $SPEED
adapter speed $SPEED

reset_config none
&lt;/code&gt;
    &lt;p&gt;The blind interrogation successfully discovered a single device on the chain with an &lt;code&gt;IDCODE&lt;/code&gt; of &lt;code&gt;0x04a63093&lt;/code&gt;.&lt;/p&gt;
    &lt;code&gt;gp@workhorse:~/tools/openocd_jlink_test/autoprob$ openocd
Open On-Chip Debugger 0.12.0+dev-02170-gfcff4b712 (2025-09-04-21:02)
Licensed under GNU GPL v2
For bug reports, read
	http://openocd.org/doc/doxygen/bugs.html
none separate
Info : Listening on port 6666 for tcl connections
Info : Listening on port 4444 for telnet connections
Info : J-Link V10 compiled Jan 30 2023 11:28:07
Info : Hardware version: 10.10
Info : VTarget = 1.812 V
Info : clock speed 1 kHz
Warn : There are no enabled taps.  AUTO PROBING MIGHT NOT WORK!!
Info : JTAG tap: auto0.tap tap/device found: 0x04a63093 (mfg: 0x049 (Xilinx), part: 0x4a63, ver: 0x0)
Warn : AUTO auto0.tap - use "jtag newtap auto0 tap -irlen 2 -expected-id 0x04a63093"
Error: IR capture error at bit 2, saw 0x3ffffffffffffff5 not 0x...3
Warn : Bypassing JTAG setup events due to errors
Warn : gdb services need one or more targets defined
&lt;/code&gt;
    &lt;p&gt;Comparing against the &lt;code&gt;UltraScale Architecture Configuration User Guide (UG570)&lt;/code&gt; we see that this &lt;code&gt;IDCODE&lt;/code&gt; matches up
precisely with the expected value for the &lt;code&gt;KU3P&lt;/code&gt;.&lt;/p&gt;
    &lt;p&gt;By default OpenOCD assumes a JTAG IR length of 2 bits, while our FPGA has an IR length of 6 bits. This is the cause behind the IR capture error encountered during autoprobing. By updating the script with an IR length of 6 bits we can re-detect the FPGA with no errors.&lt;/p&gt;
    &lt;code&gt;source [find interface/jlink.cfg]
transport select jtag

set SPEED 1
jtag_rclk $SPEED
adapter speed $SPEED

reset_config none

jtag newtap auto_detect tap -irlen 6
&lt;/code&gt;
    &lt;p&gt;Output :&lt;/p&gt;
    &lt;code&gt;gp@workhorse:~/tools/openocd_jlink_test/autoprob$ openocd
Open On-Chip Debugger 0.12.0+dev-02170-gfcff4b712 (2025-09-04-21:02)
Licensed under GNU GPL v2
For bug reports, read
	http://openocd.org/doc/doxygen/bugs.html
Info : Listening on port 6666 for tcl connections
Info : Listening on port 4444 for telnet connections
Info : J-Link V10 compiled Jan 30 2023 11:28:07
Info : Hardware version: 10.10
Info : VTarget = 1.812 V
Info : clock speed 1 kHz
Info : JTAG tap: auto_detect.tap tap/device found: 0x04a63093 (mfg: 0x049 (Xilinx), part: 0x4a63, ver: 0x0)
Warn : gdb services need one or more targets defined
&lt;/code&gt;
    &lt;p&gt;Based on the probing, this is the JTAG scan chain for our board :&lt;/p&gt;
    &lt;head rend="h3"&gt;System Monitor Registers#&lt;/head&gt;
    &lt;p&gt;Previous generations of Xilinx FPGA had a system called the XADC that, among other features, allowed you to acquire chip temperature and voltage readings. The newer UltraScale and UltraScale+ family have deprecated this XADC module in favor of the SYSMON (and SYSMON4) which allows you to also get these temperature readings, just better.&lt;/p&gt;
    &lt;p&gt;Unfortunately, openOCD didn’t have support for reading the SYSMON over JTAG out of the box, so I will be adding it.&lt;/p&gt;
    &lt;p&gt;To be more precise, the Kintex UltraScale+ has a SYSMON4 and not a SYSMON. For full context, there are 3 flavors of SYSMON:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;SYSMON1&lt;/code&gt;used in the Kintex and Virtex UltraScale series&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;SYSMON4&lt;/code&gt;used in the Kintex, Virtex and in the Zynq programmable logic for the UltraScale+ series&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;SYSMON&lt;/code&gt;used in the Zynq in the processing system of the UltraScale+ series.&lt;lb/&gt;Yes, you read that correctly the Zynq of the UltraScale+ series features not one, but at least two unique SYSMON instances.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;For the purpose of this article, all these instances are similar enough that I will be using the terms SYSMON4 and SYSMON interchangeably.&lt;/p&gt;
    &lt;p&gt;In order for the JTAG to interact with the SYSMON, we first need to write the &lt;code&gt;SYSMON_DRP&lt;/code&gt; command to the
JTAG Instruction Register (IR).
Based on the documentation, we see that this command has a value of &lt;code&gt;0x37&lt;/code&gt;, which funnily enough,
is the same command code as the XADC, solidifying the SYSMON as the XADC’s descendant.&lt;/p&gt;
    &lt;p&gt;The SYSMON offers a lot more additional functionalities than just being used to read voltage and temperature, but for today’s use case we will not be using any of that. Rather, we will focus only on reading a subset of the SYSMON status registers.&lt;/p&gt;
    &lt;p&gt;These status registers are located at addresses &lt;code&gt;(00h-3Fh, 80h-BFh)&lt;/code&gt;,
and contain the measurement results of the analog-to-digital conversions, the flag registers,
and the calibration coefficients. We can select which address we wish to read by writing the
address to the Data Register (DR) over JTAG and the data will be read out of &lt;code&gt;TDO&lt;/code&gt;.&lt;/p&gt;
    &lt;code&gt;# SPDX-License-Identifier: GPL-2.0-or-later

# Xilinx SYSMON4 support
#
# Based on UG580, used for UltraScale+ Xilinx FPGA
# This code implements access through the JTAG TAP.
#
# build a 32 bit DRP command for the SYSMON DRP
proc sysmon_cmd {cmd addr data} {
	array set cmds {
		NOP 0x00
		READ 0x01
		WRITE 0x02
	}
	return [expr {($cmds($cmd) &amp;lt;&amp;lt; 26) | ($addr &amp;lt;&amp;lt; 16) | ($data &amp;lt;&amp;lt; 0)}]
}

# Status register addresses
# Some addresses (status registers 0-3) have special function when written to.
proc SYSMON {key} {
	array set addrs {
		TEMP 0x00
		VCCINT 0x01
		VCCAUX 0x02
		VPVN 0x03
		VREFP 0x04
		VREFN 0x05
		VCCBRAM 0x06
		SUPAOFFS 0x08
		ADCAOFFS 0x09
		ADCAGAIN 0x0a
		VCCPINTLP 0x0d
		VCCPINTFP 0x0e
		VCCPAUX 0x0f
		VAUX0 0x10
		VAUX1 0x11
		VAUX2 0x12
		VAUX3 0x13
		VAUX4 0x14
		VAUX5 0x15
		VAUX6 0x16
		VAUX7 0x17
		VAUX8 0x18
		VAUX9 0x19
		VAUX10 0x1a
		VAUX11 0x1b
		VAUX12 0x1c
		VAUX13 0x1d
		VAUX14 0x1e
		VAUX15 0x1f
		MAXTEMP 0x20
		MAXVCC 0x21
		MAXVCCAUX 0x22
	}
	return $addrs($key)
}

# transfer
proc sysmon_xfer {tap cmd addr data} {
	set ret [drscan $tap 32 [sysmon_cmd $cmd $addr $data]]
	runtest 10
	return [expr "0x$ret"]
}

# sysmon register write
proc sysmon_write {tap addr data} {
	sysmon_xfer $tap WRITE $addr $data
}

# sysmon register read, non-pipelined
proc sysmon_read {tap addr} {
	sysmon_xfer $tap READ $addr 0
	return [sysmon_xfer $tap NOP 0 0]
}


# Select the sysmon DR, SYSMON_DRP has the same binary code value as the XADC
proc sysmon_select {tap} {
	set SYSMON_IR 0x37
	irscan $tap $SYSMON_IR
	runtest 10
}

# convert 16 bit temperature measurement to Celsius
proc sysmon_temp_internal {code} {
	return [expr {$code * 509.314/(1 &amp;lt;&amp;lt; 16) - 280.23}]
}

# convert 16 bit supply voltage measurments to Volt
proc sysmon_sup {code} {
	return [expr {$code * 3./(1 &amp;lt;&amp;lt; 16)}]
}

# measure all internal voltages
proc sysmon_report {tap} {
	puts "Sysmon status report :"
	sysmon_select $tap
	foreach ch [list TEMP MAXTEMP] {
		echo "$ch [format %.2f [sysmon_temp_internal [sysmon_read $tap [SYSMON $ch]]]] C"
	}
	foreach ch [list VCCINT MAXVCC VCCAUX MAXVCCAUX] {
		echo "$ch [format %.3f [sysmon_sup [sysmon_read $tap [SYSMON $ch]]]] V"	
	}
}
&lt;/code&gt;
    &lt;p&gt;I added a report that reads the current chip temperature, internal and external voltages as well as the maximum values for these recorded since FPGA power cycle, to my flashing script output:&lt;/p&gt;
    &lt;code&gt;gp@workhorse:~/tools/openocd_jlink_test$ openocd
Open On-Chip Debugger 0.12.0+dev-02170-gfcff4b712 (2025-09-04-20:02)
Licensed under GNU GPL v2
For bug reports, read
	http://openocd.org/doc/doxygen/bugs.html
set chipname XCKU3P
Read temperature sysmon 4
Info : J-Link V10 compiled Jan 30 2023 11:28:07
Info : Hardware version: 10.10
Info : VTarget = 1.819 V
Info : clock speed 1 kHz
Info : JTAG tap: XCKU3P.tap tap/device found: 0x04a63093 (mfg: 0x049 (Xilinx), part: 0x4a63, ver: 0x0)
Warn : gdb services need one or more targets defined
--------------------
Sysmon status report :
TEMP 31.12 C
MAXTEMP 34.62 C
VCCINT 0.852 V
MAXVCC 0.855 V
VCCAUX 1.805 V
MAXVCCAUX 1.807 V
&lt;/code&gt;
    &lt;head rend="h2"&gt;Pinout#&lt;/head&gt;
    &lt;p&gt;To my indescribable joy I happened to stumble onto this gold mine, in which we get the board pinout. This most likely fell off a truck: https://blog.csdn.net/qq_37650251/article/details/145716953&lt;/p&gt;
    &lt;p&gt;So far this pinout looks correct.&lt;/p&gt;
    &lt;table&gt;
      &lt;row span="5"&gt;
        &lt;cell role="head"&gt;Pin Index&lt;/cell&gt;
        &lt;cell role="head"&gt;Name&lt;/cell&gt;
        &lt;cell role="head"&gt;IO Standard&lt;/cell&gt;
        &lt;cell role="head"&gt;Location&lt;/cell&gt;
        &lt;cell role="head"&gt;Bank&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="5"&gt;
        &lt;cell&gt;0&lt;/cell&gt;
        &lt;cell&gt;diff_100mhz_clk_p&lt;/cell&gt;
        &lt;cell&gt;LVDS&lt;/cell&gt;
        &lt;cell&gt;E18&lt;/cell&gt;
        &lt;cell&gt;BANK67&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="5"&gt;
        &lt;cell&gt;1&lt;/cell&gt;
        &lt;cell&gt;diff_100mhz_clk_n&lt;/cell&gt;
        &lt;cell&gt;LVDS&lt;/cell&gt;
        &lt;cell&gt;D18&lt;/cell&gt;
        &lt;cell&gt;BANK67&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="5"&gt;
        &lt;cell&gt;2&lt;/cell&gt;
        &lt;cell&gt;sfp_mgt_clk_p&lt;/cell&gt;
        &lt;cell&gt;LVDS&lt;/cell&gt;
        &lt;cell&gt;K7&lt;/cell&gt;
        &lt;cell&gt;BANK227&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="5"&gt;
        &lt;cell&gt;3&lt;/cell&gt;
        &lt;cell&gt;sfp_mgt_clk_n&lt;/cell&gt;
        &lt;cell&gt;LVDS&lt;/cell&gt;
        &lt;cell&gt;K6&lt;/cell&gt;
        &lt;cell&gt;BANK227&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="5"&gt;
        &lt;cell&gt;4&lt;/cell&gt;
        &lt;cell&gt;sfp_1_txn&lt;/cell&gt;
        &lt;cell&gt;-&lt;/cell&gt;
        &lt;cell&gt;B6&lt;/cell&gt;
        &lt;cell&gt;BANK227&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="5"&gt;
        &lt;cell&gt;5&lt;/cell&gt;
        &lt;cell&gt;sfp_1_txp&lt;/cell&gt;
        &lt;cell&gt;-&lt;/cell&gt;
        &lt;cell&gt;B7&lt;/cell&gt;
        &lt;cell&gt;BANK227&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="5"&gt;
        &lt;cell&gt;6&lt;/cell&gt;
        &lt;cell&gt;sfp_1_rxn&lt;/cell&gt;
        &lt;cell&gt;-&lt;/cell&gt;
        &lt;cell&gt;A3&lt;/cell&gt;
        &lt;cell&gt;BANK227&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="5"&gt;
        &lt;cell&gt;7&lt;/cell&gt;
        &lt;cell&gt;sfp_1_rxp&lt;/cell&gt;
        &lt;cell&gt;-&lt;/cell&gt;
        &lt;cell&gt;A4&lt;/cell&gt;
        &lt;cell&gt;BANK227&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="5"&gt;
        &lt;cell&gt;8&lt;/cell&gt;
        &lt;cell&gt;sfp_2_txn&lt;/cell&gt;
        &lt;cell&gt;-&lt;/cell&gt;
        &lt;cell&gt;D6&lt;/cell&gt;
        &lt;cell&gt;BANK227&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="5"&gt;
        &lt;cell&gt;9&lt;/cell&gt;
        &lt;cell&gt;sfp_2_txp&lt;/cell&gt;
        &lt;cell&gt;-&lt;/cell&gt;
        &lt;cell&gt;D7&lt;/cell&gt;
        &lt;cell&gt;BANK227&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="5"&gt;
        &lt;cell&gt;10&lt;/cell&gt;
        &lt;cell&gt;sfp_2_rxn&lt;/cell&gt;
        &lt;cell&gt;-&lt;/cell&gt;
        &lt;cell&gt;B1&lt;/cell&gt;
        &lt;cell&gt;BANK227&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="5"&gt;
        &lt;cell&gt;11&lt;/cell&gt;
        &lt;cell&gt;sfp_2_rxp&lt;/cell&gt;
        &lt;cell&gt;-&lt;/cell&gt;
        &lt;cell&gt;B2&lt;/cell&gt;
        &lt;cell&gt;BANK227&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="5"&gt;
        &lt;cell&gt;12&lt;/cell&gt;
        &lt;cell&gt;SFP_1_MOD_DEF_0&lt;/cell&gt;
        &lt;cell&gt;LVCMOS18&lt;/cell&gt;
        &lt;cell&gt;D14&lt;/cell&gt;
        &lt;cell&gt;BANK87&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="5"&gt;
        &lt;cell&gt;13&lt;/cell&gt;
        &lt;cell&gt;SFP_1_TX_FAULT&lt;/cell&gt;
        &lt;cell&gt;LVCMOS18&lt;/cell&gt;
        &lt;cell&gt;B14&lt;/cell&gt;
        &lt;cell&gt;BANK87&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="5"&gt;
        &lt;cell&gt;14&lt;/cell&gt;
        &lt;cell&gt;SFP_1_LOS&lt;/cell&gt;
        &lt;cell&gt;LVCMOS18&lt;/cell&gt;
        &lt;cell&gt;D13&lt;/cell&gt;
        &lt;cell&gt;BANK87&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="5"&gt;
        &lt;cell&gt;15&lt;/cell&gt;
        &lt;cell&gt;SFP_1_LED&lt;/cell&gt;
        &lt;cell&gt;LVCMOS18&lt;/cell&gt;
        &lt;cell&gt;B12&lt;/cell&gt;
        &lt;cell&gt;BANK87&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="5"&gt;
        &lt;cell&gt;16&lt;/cell&gt;
        &lt;cell&gt;SFP_2_MOD_DEF_0&lt;/cell&gt;
        &lt;cell&gt;LVCMOS18&lt;/cell&gt;
        &lt;cell&gt;E11&lt;/cell&gt;
        &lt;cell&gt;BANK86&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="5"&gt;
        &lt;cell&gt;17&lt;/cell&gt;
        &lt;cell&gt;SFP_2_TX_FAULT&lt;/cell&gt;
        &lt;cell&gt;LVCMOS18&lt;/cell&gt;
        &lt;cell&gt;F9&lt;/cell&gt;
        &lt;cell&gt;BANK86&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="5"&gt;
        &lt;cell&gt;18&lt;/cell&gt;
        &lt;cell&gt;SFP_2_LOS&lt;/cell&gt;
        &lt;cell&gt;LVCMOS18&lt;/cell&gt;
        &lt;cell&gt;E10&lt;/cell&gt;
        &lt;cell&gt;BANK86&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="5"&gt;
        &lt;cell&gt;19&lt;/cell&gt;
        &lt;cell&gt;SFP_2_LED&lt;/cell&gt;
        &lt;cell&gt;LVCMOS18&lt;/cell&gt;
        &lt;cell&gt;C12&lt;/cell&gt;
        &lt;cell&gt;BANK87&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="5"&gt;
        &lt;cell&gt;20&lt;/cell&gt;
        &lt;cell&gt;IIC_SDA_SFP_1&lt;/cell&gt;
        &lt;cell&gt;LVCMOS18&lt;/cell&gt;
        &lt;cell&gt;C14&lt;/cell&gt;
        &lt;cell&gt;BANK87&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="5"&gt;
        &lt;cell&gt;21&lt;/cell&gt;
        &lt;cell&gt;IIC_SCL_SFP_1&lt;/cell&gt;
        &lt;cell&gt;LVCMOS18&lt;/cell&gt;
        &lt;cell&gt;C13&lt;/cell&gt;
        &lt;cell&gt;BANK87&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="5"&gt;
        &lt;cell&gt;22&lt;/cell&gt;
        &lt;cell&gt;IIC_SDA_SFP_2&lt;/cell&gt;
        &lt;cell&gt;LVCMOS18&lt;/cell&gt;
        &lt;cell&gt;D11&lt;/cell&gt;
        &lt;cell&gt;BANK86&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="5"&gt;
        &lt;cell&gt;23&lt;/cell&gt;
        &lt;cell&gt;IIC_SCL_SFP_2&lt;/cell&gt;
        &lt;cell&gt;LVCMOS18&lt;/cell&gt;
        &lt;cell&gt;D10&lt;/cell&gt;
        &lt;cell&gt;BANK86&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="5"&gt;
        &lt;cell&gt;24&lt;/cell&gt;
        &lt;cell&gt;IIC_SDA_EEPROM_0&lt;/cell&gt;
        &lt;cell&gt;LVCMOS18&lt;/cell&gt;
        &lt;cell&gt;G10&lt;/cell&gt;
        &lt;cell&gt;BANK86&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="5"&gt;
        &lt;cell&gt;25&lt;/cell&gt;
        &lt;cell&gt;IIC_SCL_EEPROM_0&lt;/cell&gt;
        &lt;cell&gt;LVCMOS18&lt;/cell&gt;
        &lt;cell&gt;G9&lt;/cell&gt;
        &lt;cell&gt;BANK86&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="5"&gt;
        &lt;cell&gt;26&lt;/cell&gt;
        &lt;cell&gt;IIC_SDA_EEPROM_1&lt;/cell&gt;
        &lt;cell&gt;LVCMOS18&lt;/cell&gt;
        &lt;cell&gt;J15&lt;/cell&gt;
        &lt;cell&gt;BANK87&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="5"&gt;
        &lt;cell&gt;27&lt;/cell&gt;
        &lt;cell&gt;IIC_SCL_EEPROM_1&lt;/cell&gt;
        &lt;cell&gt;LVCMOS18&lt;/cell&gt;
        &lt;cell&gt;J14&lt;/cell&gt;
        &lt;cell&gt;BANK87&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="5"&gt;
        &lt;cell&gt;28&lt;/cell&gt;
        &lt;cell&gt;GPIO_LED_R&lt;/cell&gt;
        &lt;cell&gt;LVCMOS18&lt;/cell&gt;
        &lt;cell&gt;A13&lt;/cell&gt;
        &lt;cell&gt;BANK87&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="5"&gt;
        &lt;cell&gt;29&lt;/cell&gt;
        &lt;cell&gt;GPIO_LED_G&lt;/cell&gt;
        &lt;cell&gt;LVCMOS18&lt;/cell&gt;
        &lt;cell&gt;A12&lt;/cell&gt;
        &lt;cell&gt;BANK87&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="5"&gt;
        &lt;cell&gt;30&lt;/cell&gt;
        &lt;cell&gt;GPIO_LED_H&lt;/cell&gt;
        &lt;cell&gt;LVCMOS18&lt;/cell&gt;
        &lt;cell&gt;B9&lt;/cell&gt;
        &lt;cell&gt;BANK86&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="5"&gt;
        &lt;cell&gt;31&lt;/cell&gt;
        &lt;cell&gt;GPIO_LED_1&lt;/cell&gt;
        &lt;cell&gt;LVCMOS18&lt;/cell&gt;
        &lt;cell&gt;B11&lt;/cell&gt;
        &lt;cell&gt;BANK86&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="5"&gt;
        &lt;cell&gt;32&lt;/cell&gt;
        &lt;cell&gt;GPIO_LED_2&lt;/cell&gt;
        &lt;cell&gt;LVCMOS18&lt;/cell&gt;
        &lt;cell&gt;C11&lt;/cell&gt;
        &lt;cell&gt;BANK86&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="5"&gt;
        &lt;cell&gt;33&lt;/cell&gt;
        &lt;cell&gt;GPIO_LED_3&lt;/cell&gt;
        &lt;cell&gt;LVCMOS18&lt;/cell&gt;
        &lt;cell&gt;A10&lt;/cell&gt;
        &lt;cell&gt;BANK86&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="5"&gt;
        &lt;cell&gt;34&lt;/cell&gt;
        &lt;cell&gt;GPIO_LED_4&lt;/cell&gt;
        &lt;cell&gt;LVCMOS18&lt;/cell&gt;
        &lt;cell&gt;B10&lt;/cell&gt;
        &lt;cell&gt;BANK86&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="5"&gt;
        &lt;cell&gt;35&lt;/cell&gt;
        &lt;cell&gt;pcie_mgt_clkn&lt;/cell&gt;
        &lt;cell&gt;-&lt;/cell&gt;
        &lt;cell&gt;T6&lt;/cell&gt;
        &lt;cell&gt;BANK225&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="5"&gt;
        &lt;cell&gt;36&lt;/cell&gt;
        &lt;cell&gt;pcie_mgt_clkp&lt;/cell&gt;
        &lt;cell&gt;-&lt;/cell&gt;
        &lt;cell&gt;T7&lt;/cell&gt;
        &lt;cell&gt;BANK225&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="5"&gt;
        &lt;cell&gt;37&lt;/cell&gt;
        &lt;cell&gt;pcie_tx0_n&lt;/cell&gt;
        &lt;cell&gt;-&lt;/cell&gt;
        &lt;cell&gt;R4&lt;/cell&gt;
        &lt;cell&gt;BANK225&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="5"&gt;
        &lt;cell&gt;38&lt;/cell&gt;
        &lt;cell&gt;pcie_tx1_n&lt;/cell&gt;
        &lt;cell&gt;-&lt;/cell&gt;
        &lt;cell&gt;U4&lt;/cell&gt;
        &lt;cell&gt;BANK225&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="5"&gt;
        &lt;cell&gt;39&lt;/cell&gt;
        &lt;cell&gt;pcie_tx2_n&lt;/cell&gt;
        &lt;cell&gt;-&lt;/cell&gt;
        &lt;cell&gt;W4&lt;/cell&gt;
        &lt;cell&gt;BANK225&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="5"&gt;
        &lt;cell&gt;40&lt;/cell&gt;
        &lt;cell&gt;pcie_tx3_n&lt;/cell&gt;
        &lt;cell&gt;-&lt;/cell&gt;
        &lt;cell&gt;AA4&lt;/cell&gt;
        &lt;cell&gt;BANK225&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="5"&gt;
        &lt;cell&gt;41&lt;/cell&gt;
        &lt;cell&gt;pcie_tx4_n&lt;/cell&gt;
        &lt;cell&gt;-&lt;/cell&gt;
        &lt;cell&gt;AC4&lt;/cell&gt;
        &lt;cell&gt;BANK224&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="5"&gt;
        &lt;cell&gt;42&lt;/cell&gt;
        &lt;cell&gt;pcie_tx5_n&lt;/cell&gt;
        &lt;cell&gt;-&lt;/cell&gt;
        &lt;cell&gt;AD6&lt;/cell&gt;
        &lt;cell&gt;BANK224&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="5"&gt;
        &lt;cell&gt;43&lt;/cell&gt;
        &lt;cell&gt;pcie_tx6_n&lt;/cell&gt;
        &lt;cell&gt;-&lt;/cell&gt;
        &lt;cell&gt;AE8&lt;/cell&gt;
        &lt;cell&gt;BANK224&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="5"&gt;
        &lt;cell&gt;44&lt;/cell&gt;
        &lt;cell&gt;pcie_tx7_n&lt;/cell&gt;
        &lt;cell&gt;-&lt;/cell&gt;
        &lt;cell&gt;AF6&lt;/cell&gt;
        &lt;cell&gt;BANK224&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="5"&gt;
        &lt;cell&gt;45&lt;/cell&gt;
        &lt;cell&gt;pcie_rx0_n&lt;/cell&gt;
        &lt;cell&gt;-&lt;/cell&gt;
        &lt;cell&gt;P1&lt;/cell&gt;
        &lt;cell&gt;BANK225&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="5"&gt;
        &lt;cell&gt;46&lt;/cell&gt;
        &lt;cell&gt;pcie_rx1_n&lt;/cell&gt;
        &lt;cell&gt;-&lt;/cell&gt;
        &lt;cell&gt;T1&lt;/cell&gt;
        &lt;cell&gt;BANK225&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="5"&gt;
        &lt;cell&gt;47&lt;/cell&gt;
        &lt;cell&gt;pcie_rx2_n&lt;/cell&gt;
        &lt;cell&gt;-&lt;/cell&gt;
        &lt;cell&gt;V1&lt;/cell&gt;
        &lt;cell&gt;BANK225&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="5"&gt;
        &lt;cell&gt;48&lt;/cell&gt;
        &lt;cell&gt;pcie_rx3_n&lt;/cell&gt;
        &lt;cell&gt;-&lt;/cell&gt;
        &lt;cell&gt;Y1&lt;/cell&gt;
        &lt;cell&gt;BANK225&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="5"&gt;
        &lt;cell&gt;49&lt;/cell&gt;
        &lt;cell&gt;pcie_rx4_n&lt;/cell&gt;
        &lt;cell&gt;-&lt;/cell&gt;
        &lt;cell&gt;AB1&lt;/cell&gt;
        &lt;cell&gt;BANK224&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="5"&gt;
        &lt;cell&gt;50&lt;/cell&gt;
        &lt;cell&gt;pcie_rx5_n&lt;/cell&gt;
        &lt;cell&gt;-&lt;/cell&gt;
        &lt;cell&gt;AD1&lt;/cell&gt;
        &lt;cell&gt;BANK224&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="5"&gt;
        &lt;cell&gt;51&lt;/cell&gt;
        &lt;cell&gt;pcie_rx6_n&lt;/cell&gt;
        &lt;cell&gt;-&lt;/cell&gt;
        &lt;cell&gt;AE3&lt;/cell&gt;
        &lt;cell&gt;BANK224&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="5"&gt;
        &lt;cell&gt;52&lt;/cell&gt;
        &lt;cell&gt;pcie_rx7_n&lt;/cell&gt;
        &lt;cell&gt;-&lt;/cell&gt;
        &lt;cell&gt;AF1&lt;/cell&gt;
        &lt;cell&gt;BANK224&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="5"&gt;
        &lt;cell&gt;53&lt;/cell&gt;
        &lt;cell&gt;pcie_tx0_p&lt;/cell&gt;
        &lt;cell&gt;-&lt;/cell&gt;
        &lt;cell&gt;R5&lt;/cell&gt;
        &lt;cell&gt;BANK225&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="5"&gt;
        &lt;cell&gt;54&lt;/cell&gt;
        &lt;cell&gt;pcie_tx1_p&lt;/cell&gt;
        &lt;cell&gt;-&lt;/cell&gt;
        &lt;cell&gt;U5&lt;/cell&gt;
        &lt;cell&gt;BANK225&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="5"&gt;
        &lt;cell&gt;55&lt;/cell&gt;
        &lt;cell&gt;pcie_tx2_p&lt;/cell&gt;
        &lt;cell&gt;-&lt;/cell&gt;
        &lt;cell&gt;W5&lt;/cell&gt;
        &lt;cell&gt;BANK225&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="5"&gt;
        &lt;cell&gt;56&lt;/cell&gt;
        &lt;cell&gt;pcie_tx3_p&lt;/cell&gt;
        &lt;cell&gt;-&lt;/cell&gt;
        &lt;cell&gt;AA5&lt;/cell&gt;
        &lt;cell&gt;BANK225&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="5"&gt;
        &lt;cell&gt;57&lt;/cell&gt;
        &lt;cell&gt;pcie_tx4_p&lt;/cell&gt;
        &lt;cell&gt;-&lt;/cell&gt;
        &lt;cell&gt;AC5&lt;/cell&gt;
        &lt;cell&gt;BANK224&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="5"&gt;
        &lt;cell&gt;58&lt;/cell&gt;
        &lt;cell&gt;pcie_tx5_p&lt;/cell&gt;
        &lt;cell&gt;-&lt;/cell&gt;
        &lt;cell&gt;AD7&lt;/cell&gt;
        &lt;cell&gt;BANK224&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="5"&gt;
        &lt;cell&gt;59&lt;/cell&gt;
        &lt;cell&gt;pcie_tx6_p&lt;/cell&gt;
        &lt;cell&gt;-&lt;/cell&gt;
        &lt;cell&gt;AE9&lt;/cell&gt;
        &lt;cell&gt;BANK224&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="5"&gt;
        &lt;cell&gt;60&lt;/cell&gt;
        &lt;cell&gt;pcie_tx7_p&lt;/cell&gt;
        &lt;cell&gt;-&lt;/cell&gt;
        &lt;cell&gt;AF7&lt;/cell&gt;
        &lt;cell&gt;BANK224&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="5"&gt;
        &lt;cell&gt;61&lt;/cell&gt;
        &lt;cell&gt;pcie_rx0_p&lt;/cell&gt;
        &lt;cell&gt;-&lt;/cell&gt;
        &lt;cell&gt;P2&lt;/cell&gt;
        &lt;cell&gt;BANK225&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="5"&gt;
        &lt;cell&gt;62&lt;/cell&gt;
        &lt;cell&gt;pcie_rx1_p&lt;/cell&gt;
        &lt;cell&gt;-&lt;/cell&gt;
        &lt;cell&gt;T2&lt;/cell&gt;
        &lt;cell&gt;BANK225&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="5"&gt;
        &lt;cell&gt;63&lt;/cell&gt;
        &lt;cell&gt;pcie_rx2_p&lt;/cell&gt;
        &lt;cell&gt;-&lt;/cell&gt;
        &lt;cell&gt;V2&lt;/cell&gt;
        &lt;cell&gt;BANK225&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="5"&gt;
        &lt;cell&gt;64&lt;/cell&gt;
        &lt;cell&gt;pcie_rx3_p&lt;/cell&gt;
        &lt;cell&gt;-&lt;/cell&gt;
        &lt;cell&gt;Y2&lt;/cell&gt;
        &lt;cell&gt;BANK225&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="5"&gt;
        &lt;cell&gt;65&lt;/cell&gt;
        &lt;cell&gt;pcie_rx4_p&lt;/cell&gt;
        &lt;cell&gt;-&lt;/cell&gt;
        &lt;cell&gt;AB2&lt;/cell&gt;
        &lt;cell&gt;BANK224&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="5"&gt;
        &lt;cell&gt;66&lt;/cell&gt;
        &lt;cell&gt;pcie_rx5_p&lt;/cell&gt;
        &lt;cell&gt;-&lt;/cell&gt;
        &lt;cell&gt;AD2&lt;/cell&gt;
        &lt;cell&gt;BANK224&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="5"&gt;
        &lt;cell&gt;67&lt;/cell&gt;
        &lt;cell&gt;pcie_rx6_p&lt;/cell&gt;
        &lt;cell&gt;-&lt;/cell&gt;
        &lt;cell&gt;AE4&lt;/cell&gt;
        &lt;cell&gt;BANK224&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="5"&gt;
        &lt;cell&gt;68&lt;/cell&gt;
        &lt;cell&gt;pcie_rx7_p&lt;/cell&gt;
        &lt;cell&gt;-&lt;/cell&gt;
        &lt;cell&gt;AF2&lt;/cell&gt;
        &lt;cell&gt;BANK224&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;cell&gt;69&lt;/cell&gt;
        &lt;cell&gt;pcie_perstn_rst&lt;/cell&gt;
        &lt;cell&gt;LVCMOS18&lt;/cell&gt;
        &lt;cell&gt;A9&lt;/cell&gt;
        &lt;cell&gt;BANK86&lt;/cell&gt;
      &lt;/row&gt;
    &lt;/table&gt;
    &lt;head rend="h3"&gt;Global clock#&lt;/head&gt;
    &lt;p&gt;On high end FPGAs like the UltraScale+ family, high-speed global clocks are typically driven from external sources using differential pairs for better signal integrity.&lt;/p&gt;
    &lt;p&gt;According to the pinout we have two such differential pairs.&lt;/p&gt;
    &lt;p&gt;First I must determine the nature of these external reference clocks to see how I can use them to drive my clocks.&lt;/p&gt;
    &lt;p&gt;These differential pairs are provided over the following pins:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;100MHz : {E18, D18}&lt;/item&gt;
      &lt;item&gt;156.25MHz : {K7, K6}&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Judging by the naming and the frequencies, the 156.25MHz clock is likely my SFP reference clock, and the 100MHz can be used as my global clock.&lt;/p&gt;
    &lt;p&gt;We can confirm by querying the pin properties.&lt;/p&gt;
    &lt;p&gt;K6 properties :&lt;/p&gt;
    &lt;code&gt;Vivado% report_property [get_package_pins K6]
Property                Type    Read-only  Value
BANK                    string  true       227
BUFIO_2_REGION          string  true       TR
CLASS                   string  true       package_pin
DIFF_PAIR_PIN           string  true       K7
IS_BONDED               bool    true       1
IS_DIFFERENTIAL         bool    true       1
IS_GENERAL_PURPOSE      bool    true       0
IS_GLOBAL_CLK           bool    true       0
IS_LOW_CAP              bool    true       0
IS_MASTER               bool    true       0
IS_VREF                 bool    true       0
IS_VRN                  bool    true       0
IS_VRP                  bool    true       0
MAX_DELAY               int     true       38764
MIN_DELAY               int     true       38378
NAME                    string  true       K6
PIN_FUNC                enum    true       MGTREFCLK0N_227
PIN_FUNC_COUNT          int     true       1
PKGPIN_BYTEGROUP_INDEX  int     true       0
PKGPIN_NIBBLE_INDEX     int     true       0
&lt;/code&gt;
    &lt;p&gt;E18 properties :&lt;/p&gt;
    &lt;code&gt;Vivado% report_property [get_package_pins E18]
Property                Type    Read-only  Value
BANK                    string  true       67
BUFIO_2_REGION          string  true       TL
CLASS                   string  true       package_pin
DIFF_PAIR_PIN           string  true       D18
IS_BONDED               bool    true       1
IS_DIFFERENTIAL         bool    true       1
IS_GENERAL_PURPOSE      bool    true       1
IS_GLOBAL_CLK           bool    true       1
IS_LOW_CAP              bool    true       0
IS_MASTER               bool    true       1
IS_VREF                 bool    true       0
IS_VRN                  bool    true       0
IS_VRP                  bool    true       0
MAX_DELAY               int     true       87126
MIN_DELAY               int     true       86259
NAME                    string  true       E18
PIN_FUNC                enum    true       IO_L11P_T1U_N8_GC_67
PIN_FUNC_COUNT          int     true       2
PKGPIN_BYTEGROUP_INDEX  int     true       8
PKGPIN_NIBBLE_INDEX     int     true       2
&lt;/code&gt;
    &lt;p&gt;This tells us:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;The differential pairings are correct: {K6, K7}, {E18, D18}&lt;/item&gt;
      &lt;item&gt;We can easily use the 100MHz as a source to drive our global clocking network&lt;/item&gt;
      &lt;item&gt;The 156.25MHz clock is to be used as the reference clock for our GTY transceivers and lands on bank 227 as indicated by the &lt;code&gt;PIN_FUNC&lt;/code&gt;property&lt;code&gt;MGTREFCLK0N_227&lt;/code&gt;&lt;/item&gt;
      &lt;item&gt;We cannot directly use the 156.25MHz clock to drive our global clock network&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;With all this we have sufficient information to write a constraint file (&lt;code&gt;xdc&lt;/code&gt;) for this board.&lt;/p&gt;
    &lt;head rend="h2"&gt;Test design#&lt;/head&gt;
    &lt;p&gt;Further sections will be using the following design files.&lt;/p&gt;
    &lt;p&gt;&lt;code&gt;top.v&lt;/code&gt;:&lt;/p&gt;
    &lt;code&gt;module top (
    input wire Clk_100mhz_p_i, 
    input wire Clk_100mhz_n_i,

    output wire [3:0] Led_o 
);
    wire        clk_ibuf;
    reg  [28:0] ctr_q; 
    reg         unused_ctr_q;


    IBUFDS #(
        .DIFF_TERM("TRUE"),
        .IOSTANDARD("LVDS")
    ) m_ibufds (
        .I(Clk_100mhz_p_i),
        .IB(Clk_100mhz_n_i),
        .O(clk_ibuf)
    );

    BUFG m_bufg (
        .I(clk_ibuf),
        .O(clk)
    );

    always @(posedge clk)
        { unused_ctr_q, ctr_q } &amp;lt;= ctr_q + 29'b1;    
    
    assign Led_o = ctr_q[28:25];
endmodule
&lt;/code&gt;
    &lt;p&gt;&lt;code&gt;alibaba_cloud.xdc&lt;/code&gt; :&lt;/p&gt;
    &lt;code&gt;# Global clock signal 
set_property -dict {LOC E18 IOSTANDARD LVDS} [get_ports Clk_100mhz_p_i]
set_property -dict {LOC D18 IOSTANDARD LVDS} [get_ports Clk_100mhz_n_i]
create_clock -period 10 -name clk_100mhz [get_ports Clk_100mhz_p_i]

# LEDS
set_property -dict {LOC B11 IOSTANDARD LVCMOS18} [get_ports { Led_o[0]}]
set_property -dict {LOC C11 IOSTANDARD LVCMOS18} [get_ports { Led_o[1]}]
set_property -dict {LOC A10 IOSTANDARD LVCMOS18} [get_ports { Led_o[2]}]
set_property -dict {LOC B10 IOSTANDARD LVCMOS18} [get_ports { Led_o[3]}]
&lt;/code&gt;
    &lt;head rend="h2"&gt;Writing the bitstream#&lt;/head&gt;
    &lt;p&gt;My personal belief is that one of the most important contributors to design quality is iteration cost. The lower your iteration cost, the higher your design quality is going to be.&lt;/p&gt;
    &lt;p&gt;As such I will invest the small upfront cost to have the workflow be as streamlined as efficiently feasible.&lt;/p&gt;
    &lt;p&gt;Thus, my workflow evolved into doing practically everything over the command line interfaces and only interacting with the tools, Vivado in this case, through tcl scripts.&lt;/p&gt;
    &lt;head rend="h3"&gt;Vivado flow#&lt;/head&gt;
    &lt;p&gt;The goal of this flow is to, given a few verilog design and constraint files produce a SVF file. Our steps are :&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;creat the Vivado project &lt;code&gt;setup.tcl&lt;/code&gt;&lt;/item&gt;
      &lt;item&gt;run the implementation &lt;code&gt;build.tcl&lt;/code&gt;&lt;/item&gt;
      &lt;item&gt;generate the bitstream and the SVF &lt;code&gt;gen.tcl&lt;/code&gt;&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;I will be using &lt;code&gt;make&lt;/code&gt; to kick off and manage the dependencies between the different steps, though I recognise this isn’t a widespread practice for hardware projects. &lt;code&gt;make&lt;/code&gt; is a highly flexible, reliable and powerful tool and I believe its ability to tie together any type of workflow makes it a prime tool for this use case.&lt;/p&gt;
    &lt;p&gt;We will be invoking Vivado in batch mode, this allows us to provide a tcl script alongside script arguments, the format is as following :&lt;/p&gt;
    &lt;code&gt;vivado -mode batch &amp;lt;path to tcl script&amp;gt; -tclargs &amp;lt;script args&amp;gt;
&lt;/code&gt;
    &lt;p&gt;Though this allows us to easily break down our flow into incremental stages, invoking a single script in batch mode has the drawback of restarting Vivado and needing to re-load the project or the project checkpoint on each invocation.&lt;/p&gt;
    &lt;p&gt;As the project size grows so will the project load time, so segmenting the flow into a large number of independent scripts comes at an increasing cost.&lt;/p&gt;
    &lt;p&gt;&lt;code&gt;Makefile&lt;/code&gt; :&lt;/p&gt;
    &lt;code&gt;SHELL := /bin/bash

VIVADO_PRJ_DIR=prj
VIVADO_PRJ_NAME=$(VIVADO_PRJ_DIR)
VIVADO_PRJ_PATH=$(VIVADO_PRJ_DIR)/$(VIVADO_PRJ_NAME).xpr
VIVADO_CHECKPOINT_PATH=$(VIVADO_PRJ_DIR)/$(VIVADO_PRJ_NAME)_checkpoint.dcp

VIVADO_CMD=vivado -mode batch -source

SRC_PATH=src
OUT_DIR=out


all: setup build gen

$(VIVADO_PRJ_PATH):  
    mkdir -p $(VIVADO_PRJ_DIR)
    $(VIVADO_CMD) setup.tcl -tclargs $(VIVADO_PRJ_DIR) $(VIVADO_PRJ_NAME)

setup: $(VIVADO_PRJ_PATH) 

$(VIVADO_CHECKPOINT_PATH): $(VIVADO_PRJ_PATH) $(wildcard $(SRC_PATH)/*.xdc) $(wildcard $(SRC_PATH)/*.v)
    $(VIVADO_CMD) build.tcl -tclargs $(VIVADO_PRJ_PATH) $(SRC_PATH) $(VIVADO_CHECKPOINT_PATH)

build: $(VIVADO_CHECKPOINT_PATH)

$(OUT_DIR)/$(VIVADO_PRJ_NAME).svf: $(VIVADO_CHECKPOINT_PATH) 
    mkdir -p $(OUT_DIR)
    $(VIVADO_CMD) gen.tcl -tclargs $(VIVADO_CHECKPOINT_PATH) $(OUT_DIR)

gen: $(OUT_DIR)/$(VIVADO_PRJ_NAME).svf

flash: $(OUT_DIR)/$(VIVADO_PRJ_NAME).svf
    openocd	

clean: 
    rm -rf $(VIVADO_PRJ_DIR)
    rm -rf $(OUT_DIR)
    rm -f vivado*{log,jou}
    rm -f webtalk*{log,jou}
    rm -f usage_statistics_webtalk*{html,xml}
&lt;/code&gt;
    &lt;p&gt;&lt;code&gt;setup.tcl&lt;/code&gt; :&lt;/p&gt;
    &lt;code&gt;set project_dir [lindex $argv 0]
set project_name [lindex $argv 1]

puts "Creating project $project_name at path [pwd]/$project_dir"
create_project -part xcku3p-ffvb676-2-e -force $project_name $project_dir

close_project
exit 0
&lt;/code&gt;
    &lt;p&gt;&lt;code&gt;build.tcl&lt;/code&gt; :&lt;/p&gt;
    &lt;code&gt;set project_path [lindex $argv 0]
set src_path [lindex $argv 1]
set checkpoint_path [lindex $argv 2]
puts "Implementation script called with project path $project_path and src path $src_path, generating checkpoint at $checkpoint_path"

open_project $project_path 

# load src
read_verilog [glob -directory $src_path *.v]
read_xdc [glob -directory $src_path *.xdc]


# synth
synth_design -top top

# implement
opt_design
place_design
route_design
phys_opt_design

write_checkpoint $checkpoint_path -force 
close_project
exit 0
&lt;/code&gt;
    &lt;head rend="h4"&gt;Generating the SVF file#&lt;/head&gt;
    &lt;p&gt;The SVF for Serial Vector Format is a human readable, vendor agnostic specification used to specify JTAG bus operations.&lt;/p&gt;
    &lt;p&gt;Example SVF file, test program:&lt;/p&gt;
    &lt;code&gt;! Initialize UUT
STATE RESET;
! End IR scans in DRPAUSE
ENDIR DRPAUSE;
! End DR scans in DRPAUSE
ENDDR DRPAUSE;
! 24 bit IR header
HIR 24 TDI (FFFFFF);
! 3 bit DR header
HDR 3 TDI (7);
! 16 bit IR trailer
TIR 16 TDI (FFFF);
! 2 bit DR trailer
TDR 2 TDI (3);
! 8 bit IR scan, load BIST opcode
SIR 8 TDI (41) TDO (81) MASK (FF);
! 16 bit DR scan, load BIST seed
SDR 16 TDI (ABCD);
! RUNBIST for 95 TCK Clocks
RUNTEST 95 TCK ENDSTATE IRPAUSE;
! 16 bit DR scan, check BIST status
SDR 16 TDI (0000) TDO(1234) MASK(FFFF);
! Enter Test-Logic-Reset
STATE RESET;
! End Test Program
&lt;/code&gt;
    &lt;p&gt;Vivado can generate a hardware aware SVF file containing the configuration sequence for an FPGA board, allowing us to write a bitstream.&lt;/p&gt;
    &lt;p&gt;Given the SVF file literally contains the bitstream written in clear hexademical, in the file, our first step is to generate our design’s bitstream.&lt;/p&gt;
    &lt;p&gt;Vivado proper isn’t the software that generates the SVF file, this task is done by the hardware manager which handles all of the configuration.&lt;/p&gt;
    &lt;p&gt;We can launch a new instance &lt;code&gt;open_hw_manager&lt;/code&gt; and connect to it &lt;code&gt;connect_hw_server&lt;/code&gt;.
Since JTAG is a daisy chained bus, and given the SVF file is just a standardised way of specifying
JTAG bus operations, in order to generate a correct JTAG configuration sequence, we must inform the hardware manger
of our scan chain.&lt;/p&gt;
    &lt;p&gt;During our earlier probing of the scan chain, we have established that our FPGA is the only device on the chain. We inform the hardware manager of this by creating a new device configuration ( the term “device” refers to the “board” here ) and add our fpga to the chain using the &lt;code&gt;create_hw_device -part &amp;lt;device name&amp;gt;&lt;/code&gt;.When we have multiple
devices we should register them following the order in which they appear on the chain.&lt;/p&gt;
    &lt;p&gt;Finally to generate the SVF file, we must select the device we wish to program with &lt;code&gt;program_hw_device &amp;lt;hw_device&amp;gt;&lt;/code&gt;,
then write out the SVF to the file using &lt;code&gt;write_hw_svf &amp;lt;path to svf file&amp;gt;&lt;/code&gt;.&lt;/p&gt;
    &lt;p&gt;&lt;code&gt;gen.tcl&lt;/code&gt;:&lt;/p&gt;
    &lt;code&gt;set checkpoint_path [lindex $argv 0]
set out_dir [lindex $argv 1]
puts "SVF generation script called with checkpoint path $checkpoint_path, generating to $out_dir"

open_checkpoint $checkpoint_path

# defines
set hw_target "alibaba_board_svf_target"
set fpga_device "xcku3p"
set bin_path "$out_dir/[current_project]"

write_bitstream "$bin_path.bit" -force

open_hw_manager

# connect to hw server with default config
connect_hw_server
puts "connected to hw server at [current_hw_server]"

create_hw_target $hw_target
puts "current hw target [current_hw_target]"

open_hw_target

# single device on scan chain
create_hw_device -part $fpga_device
puts "scan chain : [get_hw_devices]"

set_property PROGRAM.FILE "$bin_path.bit" [get_hw_device]

#select device to program
program_hw_device [get_hw_device]

# generate svf file
write_hw_svf -force "$bin_path.svf"

close_hw_manager
exit 0
&lt;/code&gt;
    &lt;head rend="h3"&gt;Configuring the FPGA using OpenOCD#&lt;/head&gt;
    &lt;p&gt;Although not widespread openOCD has a very nice &lt;code&gt;svf&lt;/code&gt; execution command :&lt;/p&gt;
    &lt;quote&gt;&lt;head&gt;18.1 SVF: Serial Vector Format#&lt;/head&gt;&lt;p&gt;The Serial Vector Format, better known as SVF, is a way to represent JTAG test patterns in text files. In a debug session using JTAG for its transport protocol, OpenOCD supports running such test files.&lt;/p&gt;&lt;code&gt;[Command]svf filename [-tap tapname] [[-]quiet] [[-]nil] [[-]progress] [[-]ignore_error]&lt;/code&gt;&lt;p&gt;This issues a JTAG reset (Test-Logic-Reset) and then runs the SVF script from filename. Arguments can be specified in any order; the optional dash doesn’t affect their se- mantics.&lt;/p&gt;&lt;p&gt;Command options:&lt;/p&gt;&lt;code&gt;-tap&lt;/code&gt;tapname ignore IR and DR headers and footers specified by the SVF file with HIR, TIR, HDR and TDR commands; instead, calculate them automatically according to the current JTAG chain configuration, targeting tapname;&lt;code&gt;[-]quiet&lt;/code&gt;do not log every command before execution;&lt;code&gt;[-]nil&lt;/code&gt;“dry run”, i.e., do not perform any operations on the real interface;&lt;code&gt;[-]progress&lt;/code&gt;enable progress indication;&lt;code&gt;[-]ignore&lt;/code&gt;_error continue execution despite TDO check errors.&lt;/quote&gt;
    &lt;p&gt;We invoke it in our openOCD script using the &lt;code&gt;-progress&lt;/code&gt; option for additional logging.&lt;/p&gt;
    &lt;p&gt;&lt;code&gt;openocd&lt;/code&gt; :&lt;/p&gt;
    &lt;code&gt;set svf_path "out/project_prj_checkpoint.svf"

source [find interface/jlink.cfg]
transport select jtag

set SPEED 1
jtag_rclk $SPEED
adapter speed $SPEED 
reset_config none

# jlink config

set CHIPNAME XCKU3P
set CHIP $CHIPNAME
puts "set chipname "$CHIP

source [find ../openocd/tcl/cpld/xilinx-xcu.cfg]

source [find ../openocd/tcl/fpga/xilinx-sysmon.cfg]

init 

puts "--------------------"

sysmon_report $CHIP.tap

puts "--------------------"

# program
if {![file exists $svf_path]} {
    puts "Svf path not found : $svf_path"
    exit
}

svf $svf_path -progress 
 
exit 
&lt;/code&gt;
    &lt;p&gt;Flashing sequence log :&lt;/p&gt;
    &lt;code&gt;gp@workhorse:~/tools/openocd_jlink_test$ openocd
Open On-Chip Debugger 0.12.0+dev-02170-gfcff4b712 (2025-09-04-21:02)
Licensed under GNU GPL v2
For bug reports, read
	http://openocd.org/doc/doxygen/bugs.html
set chipname XCKU3P
Read temperature sysmon 4
Info : J-Link V10 compiled Jan 30 2023 11:28:07
Info : Hardware version: 10.10
Info : VTarget = 1.812 V
Info : clock speed 1 kHz
Info : JTAG tap: XCKU3P.tap tap/device found: 0x04a63093 (mfg: 0x049 (Xilinx), part: 0x4a63, ver: 0x0)
Warn : gdb services need one or more targets defined
--------------------
Sysmon status report :
TEMP 50.46 C
MAXTEMP 52.79 C
VCCINT 0.846 V
MAXVCC 0.860 V
VCCAUX 1.799 V
MAXVCCAUX 1.809 V
--------------------
svf processing file: "out/project_prj_checkpoint.svf"
  0%  TRST OFF;
  0%  ENDIR IDLE;
  0%  ENDDR IDLE;
  0%  STATE RESET;
  0%  STATE IDLE;
  0%  FREQUENCY 1.00E+07 HZ;
adapter speed: 10000 kHz
  0%  HIR 0 ;
  0%  TIR 0 ;
  0%  HDR 0 ;
  0%  TDR 0 ;
  0%  SIR 6 TDI (09) ;
  0%  SDR 32 TDI (00000000) TDO (04a63093) MASK (0fffffff) ;
  0%  STATE RESET;
  0%  STATE IDLE;
  0%  SIR 6 TDI (0b) ;
  0%  SIR 6 TDI (14) ;
  0%  RUNTEST 0.100000 SEC;
  0%  RUNTEST 10000 TCK;
  0%  SIR 6 TDI (14) TDO (11) MASK (31) ;
  0%  SIR 6 TDI (05) ;
 95%  ffffffffffff) ;
 95%  SIR 6 TDI (09) TDO (31) MASK (11) ;
 95%  STATE RESET;
 95%  RUNTEST 5 TCK;
 95%  SIR 6 TDI (05) ;
 95%  SDR 160 TDI (0000000400000004800700140000000466aa9955) ;
 95%  SIR 6 TDI (04) ;
 95%  SDR 32 TDI (00000000) TDO (3f5e0d40) MASK (08000000) ;
 95%  STATE RESET;
 95%  RUNTEST 5 TCK;
Info : Listening on port 6666 for tcl connections
Info : Listening on port 4444 for telnet connections
&lt;/code&gt;
    &lt;p&gt;Resulting in a successfully configured our FPGA.&lt;/p&gt;
    &lt;head rend="h2"&gt;Conclusion#&lt;/head&gt;
    &lt;p&gt;For $200 we got a fully working decommissioned Alibaba Cloud accelerator featuring a Kintex UltraScale+ FPGA with an easily accessible debugging/programming interface and enough pinout information to define our own constraint files.&lt;/p&gt;
    &lt;p&gt;We also have a fully automated Vivado workflow to implement our designs and the ability to write the bitstream, and interface with the FPGA’s internal JTAG accessible registers using an open source programming tool without the need for an official Xilinx programmer.&lt;/p&gt;
    &lt;p&gt;In the end, this project delivered an at least 5x cost savings over commercial boards (compared to the lowest cost $900-1050 Alinx alternatives), making this perhaps the most cost effective entry point for a Kintex UltraScale+ board.&lt;/p&gt;
    &lt;head rend="h2"&gt;External ressources#&lt;/head&gt;
    &lt;p&gt;Xilinx Vivado Supported Devices : https://docs.amd.com/r/en-US/ug973-vivado-release-notes-install-license/Supported-Devices&lt;/p&gt;
    &lt;p&gt;Official Xilinx dev board : https://www.amd.com/en/products/adaptive-socs-and-fpgas/evaluation-boards/ek-u1-kcu116-g.html&lt;/p&gt;
    &lt;p&gt;Alinx Kintex UltraScale+ dev boards : https://www.en.alinx.com/Product/FPGA-Development-Boards/Kintex-UltraScale-plus.html&lt;/p&gt;
    &lt;p&gt;UltraScale Architecture Configuration User Guide (UG570) : https://docs.amd.com/r/en-US/ug570-ultrascale-configuration/Device-Resources-and-Configuration-Bitstream-Lengths?section=gyn1703168518425__table_vyh_4hs_szb&lt;/p&gt;
    &lt;p&gt;UltraScale Architecture System Monitor User Guide (UG580): https://docs.amd.com/v/u/en-US/ug580-ultrascale-sysmon&lt;/p&gt;
    &lt;p&gt;Vivado Design Suite Tcl Command Reference Guide (UG835): https://docs.amd.com/r/en-US/ug835-vivado-tcl-commands/Tcl-Initialization-Scripts&lt;/p&gt;
    &lt;p&gt;PCI vendor/device ID database: https://admin.pci-ids.ucw.cz/read/PC/14e4&lt;/p&gt;
    &lt;p&gt;PCI device classes: https://admin.pci-ids.ucw.cz/read/PD&lt;/p&gt;
    &lt;p&gt;Linux kernel PCI IDs: https://github.com/torvalds/linux/blob/7aac71907bdea16e2754a782b9d9155449a9d49d/include/linux/pci_ids.h#L160-L3256&lt;/p&gt;
    &lt;p&gt;Linux kernel PCI classes: https://github.com/torvalds/linux/blob/7aac71907bdea16e2754a782b9d9155449a9d49d/include/linux/pci_ids.h#L15-L158&lt;/p&gt;
    &lt;p&gt;Truck-kun pinout: https://blog.csdn.net/qq_37650251/article/details/145716953&lt;/p&gt;
    &lt;p&gt;Ebay listing: https://www.ebay.com/itm/167626831054?_trksid=p4375194.c101800.m5481&lt;/p&gt;
    &lt;p&gt;OpenOCD documentation: https://openocd.org/doc-release/pdf/openocd.pdf&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://essenceia.github.io/projects/alibaba_cloud_fpga/"/><published>2025-10-04T06:49:58+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45472319</id><title>Paged Out Issue #7 [pdf]</title><updated>2025-10-04T15:08:29.775086+00:00</updated><content/><link href="https://pagedout.institute/download/PagedOut_007.pdf"/><published>2025-10-04T10:38:06+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45472614</id><title>Scientists are discovering a powerful new way to prevent cancer (Economist)</title><updated>2025-10-04T15:08:29.687008+00:00</updated><content/><link href="https://www.economist.com/science-and-technology/2025/09/02/scientists-are-discovering-a-powerful-new-way-to-prevent-cancer"/><published>2025-10-04T11:44:15+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45472678</id><title>Buchstabenmuseum Berlin closing after 20 year</title><updated>2025-10-04T15:08:26.928945+00:00</updated><content>&lt;doc fingerprint="7e81930193d6e0f3"&gt;
  &lt;main&gt;
    &lt;head rend="h1"&gt;After 20 Years:&lt;/head&gt;
    &lt;head rend="h3"&gt;The Buchstabenmuseum Berlin is closing!&lt;/head&gt;
    &lt;p&gt;Until 5 October 2025, you can visit our museum every Thursday to Sunday from 1 to 5 pm.&lt;lb/&gt; A visit outside opening hours is possible with a guided tour.&lt;lb/&gt; visit@buchstabenmuseum.de&lt;/p&gt;
    &lt;p&gt;We are still looking for long-term storage for our collection.&lt;lb/&gt; For this we need support:&lt;lb/&gt; &amp;gt;&amp;gt; betterplace&lt;/p&gt;
    &lt;head rend="h4"&gt;We look forward to your visit!&lt;/head&gt;
    &lt;p&gt;______________________________&lt;/p&gt;
    &lt;head rend="h1"&gt;20 Years of the Buchstabenmuseum!&lt;/head&gt;
    &lt;head rend="h4"&gt;On Sat 14 June 2025 from 3 to 9 pm we want to celebrate our birthday and toast with you!&lt;lb/&gt; You and all your friends and family are cordially invited.&lt;/head&gt;
    &lt;p&gt;20 years is a very long time to look back on.&lt;lb/&gt; That’s why we’ve put together a colourful brochure that we’ll be presenting on Saturday.&lt;/p&gt;
    &lt;p&gt;In addition, Sabrina Hauck (student at TU Berlin / architect at gkks) will give a talk on the use,&lt;lb/&gt; vacancy and potential of Berlin’s S-Bahn arches at 18:00.&lt;/p&gt;
    &lt;head rend="h1"&gt;FINAL SALE – FROM DEPARTMENT STORES’ TO MUSEUM &lt;/head&gt;
    &lt;p&gt;Extended Term until Autumn 2025!&lt;/p&gt;
    &lt;p&gt;AN EXHIBITION OF FORMER DEPARTMENT STORES FROM 1980 TO TODAY&lt;/p&gt;
    &lt;p&gt;Horten, Quelle, Hertie, Kaufhof and Karstadt – corporate names that are disappearing from German city centres. Galeria Karstadt Kaufhof is currently struggling with closure in instalments. With the creeping loss of the corporations, the distinctive lettering of the department stores’ chains is also being lost.&lt;lb/&gt; “FINAL SALE” tells the typographic and urban-historical stories of the letters and shows the former significance of the department stores and department stores with their architecture.&lt;lb/&gt; We invite you to discover the typographic department stores’ icons and to buy selected items in the exhibition: “Final Sale – from department stores’ to museum” in the Buchstabenmuseum in the Stadtbahnbögen in the Hansaviertel.&lt;/p&gt;
    &lt;head rend="h4"&gt;COOPERATION WITH THE STAATSBIBLIOTHEK BERLIN&lt;/head&gt;
    &lt;p&gt;In the »Staatsbibliothek Berlin«, Unter den Linden, selected Ks from the collection of the Buchstabenmuseum point the way to the in-house museum "Kulturwerk".&lt;/p&gt;
    &lt;head rend="h4"&gt;INDIVIDUAL GUIDED TOURS&lt;/head&gt;
    &lt;p&gt;Discover our unique collection and learn the exciting background stories to our letters.&lt;/p&gt;
    &lt;head rend="h4"&gt;NEON CLASSES: BENDING BASICS&lt;/head&gt;
    &lt;p&gt;The art of neon and the bending of neon tubes is a fascinating craft! Learn the basics of neon and glass bending.&lt;/p&gt;
    &lt;head rend="h2"&gt;THE BUCHSTABENMUSEUM&lt;/head&gt;
    &lt;p&gt;Preservation and documentation of letters&lt;lb/&gt; The Buchstabenmuseum is the first museum in the world to collect letterforms from public spaces and display them as part of urban history. We preserve and document three-dimensional letters and signage, and their history, as well as providing information about their origins and construction. Our collection has captured the imagination of visitors from all around the world for over 10 years. Hundreds of letters have been saved from being battered by the elements or ending up on the scrap heap. A selection of what we offer can be found under » COLLECTION&lt;/p&gt;
    &lt;head rend="h2"&gt;COLLECTION&lt;/head&gt;
    &lt;head rend="h2"&gt;SPECIALS&lt;/head&gt;
    &lt;p&gt;— BECOME A MEMBER —&lt;/p&gt;
    &lt;p&gt;Become a member of the club and actively support our museum.&lt;lb/&gt; We are always in need of help with the rescue of historic lettering, looking after our international guests or even with the classic work of the association.&lt;lb/&gt; Just write to us!&lt;lb/&gt; bindabei@buchstabenmuseum.de&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://www.buchstabenmuseum.de/en/"/><published>2025-10-04T11:58:58+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45472765</id><title>Thunderscan: A clever device transforms a printer into a scanner</title><updated>2025-10-04T15:08:26.581382+00:00</updated><content>&lt;doc fingerprint="8549597119742b9e"&gt;
  &lt;main&gt;
    &lt;p&gt;The first project that I worked on for Apple after starting in August 1979 was writing low level software for the Silentype printer (see What Hath Woz Wrought), a cute, inexpensive thermal printer for the Apple II, that was based on technology licensed from a local company named Trendcom. In typical Apple fashion, we improved on Trendcom's design by replacing their relatively expensive controller board with a much simpler one that relied on the microprocessor in the Apple II to do most of the dirty work.&lt;/p&gt;
    &lt;p&gt;The only other engineer working on the project was Victor Bull, who was the hardware designer and also the project leader. Vic was smart, taciturn and easy to work with, and I learned a lot from him about how thermal printers worked, as well as how things worked at Apple. We finished the project quickly, and the Silentype shipped in November 1979, less than four months after I began working on it.&lt;/p&gt;
    &lt;p&gt;In May 1984, during my leave of absence from Apple (see Leave Of Absence), I received a phone call from Victor Bull, who I hadn't heard from in a couple of years. He had left Apple more than a year ago to work with his friend Tom Petrie at a tiny company based in Orinda named Thunderware, that sold a single product called Thunderclock, an inexpensive calendar/clock card for the Apple II. Victor said that he thought that I might be interested in writing software for an exciting, clever new product that Thunderware was developing for the Macintosh, which he refused to describe over the phone. He invited me to come visit them to check it out.&lt;/p&gt;
    &lt;p&gt;In early June, I drove up to Thunderware's office in Orinda, which was about an hour's drive from my house in Palo Alto. After I arrived at their modest headquarters, Vic introduced me to his partner, Tom Petrie, and I signed a non-disclosure agreement before they ushered me into a back room to see their demo.&lt;/p&gt;
    &lt;p&gt;The most popular printer for both the Apple II and the Macintosh was the ImageWriter, a $500 dot-matrix printer capable of rendering bitmapped graphics, that was designed and manufactured by Japanese company named C.Itoh Electronics and marketed by Apple. Virtually every Macintosh owner purchased an ImageWriter, since it was the only printer that was supported by Apple. Tom's demo consisted of an ImageWriter printer hooked up to an Apple II, that at first glance appeared to be busily printing away. But when I looked closer, I noticed that instead of blank paper, there was a glossy photograph of a cat threaded through the printer's platen, and the printer's black plastic ribbon cartridge was missing, replaced by a makeshift contraption containing an optical sensing device that trailed an umbilical cord back to the Apple II.&lt;/p&gt;
    &lt;p&gt;Their potential new product, Thunderscan, was a low cost way to temporarily turn an ImageWriter printer into a high resolution scanner, by replacing the ribbon cartridge with an optical sensor and writing some clever software. Since the resolution was determined by the precision of the printer's stepper motors, which had to be very accurate in order to print detailed graphics, Thunderscan, priced at under $200, had better resolution than flat bed scanners costing more than ten times as much. I loved the cleverness of the ingenious concept, and the Woz-like elegance of saving money and adding flexibility by doing everything in software, but there were also a few problems.&lt;/p&gt;
    &lt;p&gt;The biggest problem was that Thunderscan could only capture one scan line's worth of data on each pass of the print head, which made it nine times slower than regular printing, since the print head could deposit nine dots at a time. This made for frustratingly slow scanning, often taking over an hour to scan a full page at the highest resolution. Thunderscan was never going to win any races.&lt;/p&gt;
    &lt;p&gt;Another apparent problem was the disappointingly low quality of the image being captured and displayed by Tom Petrie's Apple II application. Tom and Vic said their scanner was capable of capturing up to 32 different levels of light intensity, but both the Apple II (in hi-res mode) and the Macintosh only had one bit per pixel to display, so the software had to simulate gray scales using patterns of black and white dots. It looked like Tom was using a simple threshold algorithm to do the rendering, which threw away most of the gray scale information and made the resulting image look unacceptably blotchy. It was hard to tell if the quality promised by Tom and Vic was there or not.&lt;/p&gt;
    &lt;p&gt;Tom and Vic proposed to hire me to write Macintosh software for Thunderscan. I knew that a low cost scanner would be a great product for the image hungry Macintosh, but only if it had sufficient quality, and I wasn't sure about that. I told them that I'd think it over during the next few days, and, as I did, I became more excited about the potential of Thunderscan for the Macintosh, realizing that the slow speed wouldn't be that much of an impediment if the quality and resolution was good enough. The low image quality in Tom's prototype was probably caused more by the Apple II software than by anything inherent in the scanner. The Macintosh was almost ten times faster than the Apple II, so it should be able to sample the incoming data better to obtain more horizontal resolution. Plus, I knew a much better algorithm for gray scale rendering that would be fun to try out in practice.&lt;/p&gt;
    &lt;p&gt;My friend and colleague Bill Atkinson was a talented photographer, and one of his hobbies was playing around with digitized pictures, periodically experimenting to find the best algorithms for rendering them. Bill loved to explain his current work to whoever would listen to him, so I learned a lot about rendering gray scale images over the years simply by being around him. Bill had progressed over the years from using an "ordered dither" algorithm, where varying threshold values are specified in a sliding matrix, to his current favorite, which was a modified version of what was known as the "Floyd-Steinberg" algorithm, where an error term is maintained and distributed proportionally to neighboring pixels.&lt;/p&gt;
    &lt;p&gt;I called Thunderware and told them I was interested in working on Macintosh software for Thunderscan, in exchange for a per-unit royalty. I drove back up to Orinda, where Tom and Vic gave me lots of documentation about the scanner, and the sample code that Tom had written for the Apple II. For the next couple of months, I drove up to Orinda once a week, usually on Thursday, to meet with Tom and Vic show them my progress, prioritize development issues and discussion various complications as they arose. We would also discuss business terms, but we didn't sign a formal contract until the software was almost finished, when we settled on a royalty of $7.50 per unit.&lt;/p&gt;
    &lt;p&gt;Tom and Vic had already encountered and surmounted a number of tough problems just to get scanning going at all. For example, the ImageWriter printer was not really designed to be stepped one scanline at a time, and if you tried that the paper would bunch up against the platen, causing distortion. Tom and Vic solved the problem by commanding the printer to move three steps up and then two steps back, instead of a single step up, which held the paper snugly against the platen as required. There were also various techniques for sensing the beginning and end of the scan line, and some timings that were determined by tedious experimentation for how long it took the printer to respond to a command.&lt;/p&gt;
    &lt;p&gt;It took a week or so to get basic scanning working on the Macintosh, and then a few more days to render the gray scale data with Bill's modified Floyd-Steinberg dithering. After shaking out a variety of problems, mostly involving synchronization between the printer and the software, I was surprised and impressed by the consistent high quality of the results. I went through a brief, elated phase of scanning every image in sight that would fit through the printer, just to see how it would turn out.&lt;/p&gt;
    &lt;p&gt;One important design decision that I made early on was to keep the gray scale data around, to allow more flexible image processing. Thunderscan documents were five bits per pixel, before the Macintosh generally supported gray scale, and the user could manipulate the contrast and brightness of selected areas of the image, dodging and burning to reveal detail in the captured image. This also paid off in later versions when we implemented gray scale printing for Postscript printers.&lt;/p&gt;
    &lt;p&gt;My favorite feature that I came up with for Thunderscan had to do with two dimensional scrolling. Thunderscan documents could be quite large, so you could only show a portion of them in the image area of the window. You could scroll the image by dragging with a MacPaint-style "hand" scrolling tool, but you had to drag an awful lot to get to the extremes of a large image. I decided to add what I called "inertial" scrolling, where you gave the image a push and it kept scrolling at a variable speed in the direction of the push, after the mouse button was released. I had to add some hysteresis to keep the image from moving accidentally, and make various other tweaks, but soon I had it working and it felt great to be able to zip around large images by pushing them.&lt;/p&gt;
    &lt;p&gt;The hardest feature to perfect was bidirectional scanning. At first, Thunderscan only scanned from left to right, but it wasted time to return the scannner to the left after every scan line. We could almost double the speed if we scanned in both directions, but it was hard to get the adjacent scan lines that were scanned in opposite directions to line up properly. Ultimately, we made bidirectional scanning an optional feature, if you wanted to trade a little quality for greater speed.&lt;/p&gt;
    &lt;p&gt;I finished the software in November 1984, after taking a short break to work on something else (see Switcher). Thunderscan shipped in December 1984, and did well from the very beginning, with sales gradually rising from around 1,000 units/month to over 7,500 units/month at its peak in 1987. For a while, it was both the least expensive and highest quality scanning alternative for the Macintosh, although I'm sure it frustrated a lot of users by being too slow. I did three major revisions of the software over the next few years, improving the scan quality and adding features like gray scale printing and eventually gray scale display for the Macintosh II.&lt;/p&gt;
    &lt;p&gt;Eventually, the flat bed scanners caught up to Thunderscan, and then surpassed it, in both cost, quality and convenience. Over its lifetime, Thunderscan sold approximately 100,000 units and improved countless documents by providing users with an inexpensive way to capture high resolution graphics with their Macintoshes.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://www.folklore.org/Thunderscan.html"/><published>2025-10-04T12:16:37+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45473019</id><title>Functional Programming Shaped (and Twisted) Front End Development</title><updated>2025-10-04T15:08:25.636347+00:00</updated><content>&lt;doc fingerprint="bf66d30b0925bfc8"&gt;
  &lt;main&gt;
    &lt;p&gt;A friend called me last week. Someone whoâd built web applications back for a long time before moving exclusively to backend and infra work. Heâd just opened a modern React codebase for the first time in over a decade.&lt;/p&gt;
    &lt;p&gt;âWhat the hell is this?â he asked. âWhat are all these generated class names? Did we justâ¦ cancel the cascade? Who made the web work this way?â&lt;/p&gt;
    &lt;p&gt;I laughed, but his confusion cut deeper than he realized. He remembered a web where CSS cascaded naturally, where the DOM was something you worked with, where the browser handled routing, forms, and events without twenty abstractions in between. To him, our modern frontend stack looked like weâd declared war on the platform itself.&lt;/p&gt;
    &lt;p&gt;He asked me to explain how we got here. That conversation became this essay.&lt;/p&gt;
    &lt;p&gt;A disclaimer before we begin: This is one perspective, shaped by having lived through the first browser war. I applied &lt;code&gt;pngfix.js&lt;/code&gt; to make 24-bit PNGs work in IE6. I debugged hasLayout bugs at 2 AM. I wrote JavaScript when you couldnât trust &lt;code&gt;addEventListener&lt;/code&gt; to work the same way across browsers. I watched jQuery become necessary, then indispensable, then legacy. I might be wrong about some of this. My perspective is biased for sure, but it also comes with the memory that the web didnât need constant reinvention to be useful.&lt;/p&gt;
    &lt;head rend="h2"&gt;Introduction&lt;/head&gt;
    &lt;p&gt;Thereâs a strange irony at the heart of modern web development. The web was born from documents, hyperlinks, and a cascading stylesheet language. It was always messy, mutable, and gloriously side-effectful. Yet over the past decade, our most influential frontend tools have been shaped by engineers chasing functional programming purity: immutability, determinism, and the elimination of side effects.&lt;/p&gt;
    &lt;p&gt;This pursuit gave us powerful abstractions. React taught us to think in components. Redux made state changes traceable. TypeScript brought compile-time safety to a dynamic language. But it also led us down a strange path. A one where we fought against the platform instead of embracing it. We rebuilt the browserâs native capabilities in JavaScript, added layers of indirection to âprotectâ ourselves from the DOM, and convinced ourselves that the webâs inherent messiness was a problem to solve rather than a feature to understand.&lt;/p&gt;
    &lt;p&gt;The question isnât whether functional programming principles have value. They do. The question is whether applying them dogmatically to the web (a platform designed around mutability, global scope, and user-driven chaos) made our work better, or just more complex.&lt;/p&gt;
    &lt;head rend="h2"&gt;The Nature of the Web&lt;/head&gt;
    &lt;p&gt;To understand why functional programming ideals clash with web development, we need to acknowledge what the web actually is.&lt;/p&gt;
    &lt;p&gt;The web is fundamentally side-effectful. CSS cascades globally by design. Styles defined in one place affect elements everywhere, creating emergent patterns through specificity and inheritance. The DOM is a giant mutable tree that browsers optimize obsessively; changing it directly is fast and predictable. User interactions arrive asynchronously and unpredictably: clicks, scrolls, form submissions, network requests, resize events. Thereâs no pure function that captures âuser intent.â&lt;/p&gt;
    &lt;p&gt;This messiness is not accidental. Itâs how the web scales across billions of devices, remains backwards-compatible across decades, and allows disparate systems to interoperate. The browser is an open platform with escape hatches everywhere. You can style anything, hook into any event, manipulate any node. That flexibility and that refusal to enforce rigid abstractions is the webâs superpower.&lt;/p&gt;
    &lt;p&gt;When we approach the web with functional programming instincts, we see this flexibility as chaos. We see globals as dangerous. We see mutation as unpredictable. We see side effects as bugs waiting to happen. And so we build walls.&lt;/p&gt;
    &lt;head rend="h2"&gt;Enter Functional Programming Ideals&lt;/head&gt;
    &lt;p&gt;Functional programming revolves around a few core principles: functions should be pure (same inputs â same outputs, no side effects), data should be immutable, and state changes should be explicit and traceable. These ideas produce code thatâs easier to reason about, test, and parallelize, in the right context of course.&lt;/p&gt;
    &lt;p&gt;These principles had been creeping into JavaScript long before React. Underscore.js (2009) brought map, reduce, and filter to the masses. Lodash and Ramda followed with deeper FP toolkits including currying, composition and immutability helpers. The ideas were in the air: avoid mutation, compose small functions, treat data transformations as pipelines.&lt;/p&gt;
    &lt;p&gt;React itself started with class components and &lt;code&gt;setState&lt;/code&gt;, hardly pure FP. But the conceptual foundation was there: treat UI as a function of state, make rendering deterministic, isolate side effects. Then came Elm, a purely functional language created by Evan Czaplicki that codified the âModel-View-Updateâ architecture. When Dan Abramov created Redux, he explicitly cited Elm as inspiration. Reduxâs reducers are directly modeled on Elmâs update functions: &lt;code&gt;(state, action) =&amp;gt; newState&lt;/code&gt;.&lt;/p&gt;
    &lt;p&gt;Redux formalized what had been emerging patterns. Combined with React Hooks (which replaced stateful classes with functional composition), the ecosystem shifted decisively toward FP. Immutability became non-negotiable. Pure components became the ideal. Side effects were corralled into &lt;code&gt;useEffect&lt;/code&gt;. Through this convergence (library patterns, Elmâs rigor, and Reactâs evolution) Haskell-derived ideas about purity became mainstream JavaScript practice.&lt;/p&gt;
    &lt;p&gt;In the early 2010s, as JavaScript applications grew more complex, developers looked to FP for salvation. jQuery spaghetti had become unmaintainable. Backboneâs two-way binding caused cascading updates (ironically, Backboneâs documentation explicitly advised against two-way binding saying âit doesnât tend to be terribly useful in your real-world appâ yet many developers implemented it through plugins). The community wanted discipline, and FP offered it: treat your UI as a pure function of state. Make data flow in one direction. Eliminate shared mutable state.&lt;/p&gt;
    &lt;p&gt;Reactâs arrival in 2013 crystallized these ideals. It promised a world where &lt;code&gt;UI = f(state)&lt;/code&gt;: give it data, get back a component tree, re-render when data changes. No manual DOM manipulation. No implicit side effects. Just pure, predictable transformations.&lt;/p&gt;
    &lt;p&gt;This was seductive. And in many ways, it worked. But it also set us on a path toward rebuilding the web in JavaScriptâs image, rather than JavaScript in the webâs image.&lt;/p&gt;
    &lt;head rend="h2"&gt;How FP Purism Shaped Modern Frontend&lt;/head&gt;
    &lt;head rend="h3"&gt;CSS-in-JS: The War on Global Scope&lt;/head&gt;
    &lt;p&gt;CSS was designed to be global. Styles cascade, inherit, and compose across boundaries. This enables tiny stylesheets to control huge documents, and lets teams share design systems across applications. But to functional programmers, global scope is dangerous. It creates implicit dependencies and unpredictable outcomes.&lt;/p&gt;
    &lt;p&gt;Enter CSS-in-JS: styled-components, Emotion, JSS. The promise was component isolation. Styles scoped to components, no cascading surprises, no naming collisions. Styles become data, passed through JavaScript, predictably bound to elements.&lt;/p&gt;
    &lt;p&gt;But this came at a cost. CSS-in-JS libraries generate styles at runtime, injecting them into &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; tags as components mount. This adds JavaScript execution to the critical rendering path. Server-side rendering becomes complicated. You need to extract styles during the render, serialize them, and rehydrate them on the client. Debugging involves runtime-generated class names like &lt;code&gt;.css-1xbq8d9&lt;/code&gt;. And you lose the cascade; the very feature that made CSS powerful in the first place.&lt;/p&gt;
    &lt;p&gt;Worse, youâve moved a browser-optimized declarative language into JavaScript, a single-threaded runtime. The browser can parse and apply CSS in parallel, off the main thread. Your styled-components bundle? Thatâs main-thread work, blocking interactivity.&lt;/p&gt;
    &lt;p&gt;The web had a solution. Itâs called a stylesheet. But it wasnât pure enough.&lt;/p&gt;
    &lt;p&gt;The industry eventually recognized these problems and pivoted to Tailwind CSS. Instead of runtime CSS generation, use utility classes. Instead of styled-components, compose classes in JSX. This was better, at least itâs compile-time, not runtime. No more blocking the main thread to inject styles. No more hydration complexity.&lt;/p&gt;
    &lt;p&gt;But Tailwind still fights the cascade. Instead of writing &lt;code&gt;.button { padding: 1rem; }&lt;/code&gt; once and letting it cascade to all buttons, you write &lt;code&gt;class="px-4 py-2 bg-blue-500"&lt;/code&gt; on every single button element. Youâve traded runtime overhead for a different set of problems: class soup in your markup, massive HTML payloads, and losing the cascadeâs ability to make sweeping design changes in one place.&lt;/p&gt;
    &lt;p&gt;And hereâs where it gets truly revealing: when Tailwind added support for nested selectors using &lt;code&gt;&amp;amp;&lt;/code&gt; (a feature that would let developers write more cascade-like styles), parts of the community revolted. David Khourshid (creator of XState) shared examples of using nested selectors in Tailwind, and the backlash was immediate. Developers argued this defeated the purpose of Tailwind, that it brought back the âproblemsâ of traditional CSS, that it violated the utility-first philosophy.&lt;/p&gt;
    &lt;p&gt;Think about what this means. The platform has cascade. CSS-in-JS tried to eliminate it and failed. Tailwind tried to work around it with utilities. And when Tailwind cautiously reintroduced a cascade-like feature, developers who were trained by years of anti-cascade ideology rejected it. Weâve spent so long teaching people that the cascade is dangerous that even when their own tools try to reintroduce platform capabilities, they donât want them.&lt;/p&gt;
    &lt;p&gt;Weâre not just ignorant of the platform anymore. Weâre ideologically opposed to it.&lt;/p&gt;
    &lt;head rend="h3"&gt;Synthetic Events: Abstracting Away the Platform&lt;/head&gt;
    &lt;p&gt;React introduced synthetic events to normalize browser inconsistencies and integrate events into its rendering lifecycle. Instead of attaching listeners directly to DOM nodes, React uses event delegation. It listens at the root, then routes events to handlers through its own system.&lt;/p&gt;
    &lt;p&gt;This feels elegant from a functional perspective. Events become data flowing through your component tree. You donât touch the DOM directly. Everything stays inside Reactâs controlled universe.&lt;/p&gt;
    &lt;p&gt;But native browser events already work. They bubble, they capture, theyâre well-specified. The browser has spent decades optimizing event dispatch. By wrapping them in a synthetic layer, React adds indirection: memory overhead for event objects, translation logic for every interaction, and debugging friction when something behaves differently than the native API.&lt;/p&gt;
    &lt;p&gt;Worse, it trains developers to avoid the platform. Developers learn Reactâs event system, not the webâs. When they need to work with third-party libraries or custom elements, they hit impedance mismatches. &lt;code&gt;addEventListener&lt;/code&gt; becomes a foreign API in their own codebase.&lt;/p&gt;
    &lt;p&gt;Again: the web had this. The browserâs event system is fast, flexible, and well-understood. But it wasnât controlled enough for the FP ideal of a closed system.&lt;/p&gt;
    &lt;head rend="h3"&gt;Client-Side Rendering and Hydration: Reinventing the Browser&lt;/head&gt;
    &lt;p&gt;The logical extreme of âUI as a pure function of stateâ is client-side rendering: the server sends an empty HTML shell, JavaScript boots up, and the app renders entirely in the browser. From a functional perspective, this is clean. Your app is a deterministic function that takes initial state and produces a DOM tree.&lt;/p&gt;
    &lt;p&gt;From a web perspective, itâs a disaster. The browser sits idle while JavaScript parses, executes, and manually constructs the DOM. Users see blank screens. Screen readers get empty documents. Search engines see nothing. Progressive rendering which is one of the browserâs most powerful features, goes unused.&lt;/p&gt;
    &lt;p&gt;The industry noticed. Server-side rendering came back. But because the mental model was still âJavaScript owns the DOM,â we got hydration: the server renders HTML, the client renders the same tree in JavaScript, then React walks both and attaches event handlers. During hydration, the page is visible but inert. Clicks do nothing, forms donât submit.&lt;/p&gt;
    &lt;p&gt;This is architecturally absurd. The browser already rendered the page. It already knows how to handle clicks. But because the framework wants to own all interactions through its synthetic event system, it must re-create the entire component tree in JavaScript before anything works.&lt;/p&gt;
    &lt;p&gt;The absurdity extends beyond the client. Infrastructure teams watch in confusion as every user makes double the number of requests: the server renders the page and fetches data, then the client boots up and fetches the exact same data again to reconstruct the component tree for hydration. Why? Because the framework canât trust the HTML it just generated. It needs to rebuild its internal representation of the UI in JavaScript to attach event handlers and manage state.&lt;/p&gt;
    &lt;p&gt;This isnât just wasteful, itâs expensive. Database queries run twice. API calls run twice. Cache layers get hit twice. CDN costs double. And for what? So the framework can maintain its pure functional model where all state lives in JavaScript. The browser had the data. The HTML had the data. But that data wasnât in the right shape. It wasnât a JavaScript object tree, so we throw it away and fetch it again.&lt;/p&gt;
    &lt;p&gt;Hydration is what happens when you treat the web like a blank canvas instead of a platform with capabilities. The web gave us streaming HTML, progressive enhancement, and instant interactivity. We replaced it with JSON, JavaScript bundles, duplicate network requests, and âplease wait while we reconstruct reality.â&lt;/p&gt;
    &lt;head rend="h3"&gt;The Modal Problem: Teaching Malpractice as Best Practice&lt;/head&gt;
    &lt;p&gt;Consider the humble modal dialog. The web has &lt;code&gt;&amp;lt;dialog&amp;gt;&lt;/code&gt;, a native element with built-in functionality: it manages focus trapping, handles Escape key dismissal, provides a backdrop, controls scroll-locking on the body, and integrates with the accessibility tree. It exists in the DOM but remains hidden until opened. No JavaScript mounting required. Itâs fast, accessible, and battle-tested by browser vendors.&lt;/p&gt;
    &lt;p&gt;Now observe what gets taught in tutorials, bootcamps, and popular React courses: build a modal with &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; elements. Conditionally render it when &lt;code&gt;isOpen&lt;/code&gt; is true. Manually attach a click-outside handler. Write an effect to listen for the Escape key. Add another effect for focus trapping. Implement your own scroll-lock logic. Remember to add ARIA attributes. Oh, and make sure to clean up those event listeners, or youâll have memory leaks.&lt;/p&gt;
    &lt;p&gt;Youâve just written 100+ lines of JavaScript to poorly recreate what the browser gives you for free. Worse, youâve trained developers to not even look for native solutions. The platform becomes invisible. When someone asks âhow do I build a modal?â, the answer is âinstall a libraryâ or âhereâs my custom hook,â never âuse &lt;code&gt;&amp;lt;dialog&amp;gt;&lt;/code&gt;.â&lt;/p&gt;
    &lt;p&gt;The teaching is the problem. When influential tutorial authors and bootcamp curricula skip native APIs in favor of React patterns, theyâre not just showing an alternative approach. Theyâre actively teaching malpractice. A generation of developers learns to build inaccessible &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; soup because thatâs what fits the frameworkâs reactivity model, never knowing the platform already solved these problems.&lt;/p&gt;
    &lt;p&gt;And itâs not just bootcamps. Even the most popular component libraries make the same choice: shadcn/ui builds its Dialog component on Radix UI primitives, which use &lt;code&gt;&amp;lt;div role="dialog"&amp;gt;&lt;/code&gt; instead of the native &lt;code&gt;&amp;lt;dialog&amp;gt;&lt;/code&gt; element. There are open GitHub issues requesting native &lt;code&gt;&amp;lt;dialog&amp;gt;&lt;/code&gt; support, but the implicit message is clear: itâs easier to reimplement the browser than to work with it.&lt;/p&gt;
    &lt;head rend="h3"&gt;When Frameworks Canât Keep Up with the Platform&lt;/head&gt;
    &lt;p&gt;The problem runs deeper than ignorance or inertia. The frameworks themselves increasingly struggle to work with the platformâs evolution. Not because the platform features are bad, but because the frameworkâs architectural assumptions canât accommodate them.&lt;/p&gt;
    &lt;p&gt;Consider why component libraries like Radix UI choose &lt;code&gt;&amp;lt;div role="dialog"&amp;gt;&lt;/code&gt; over &lt;code&gt;&amp;lt;dialog&amp;gt;&lt;/code&gt;. The native &lt;code&gt;&amp;lt;dialog&amp;gt;&lt;/code&gt; element manages its own state: it knows when itâs open, it handles its own visibility, it controls focus internally. But Reactâs reactivity model expects all state to live in JavaScript, flowing unidirectionally into the DOM. When a native element manages its own state, Reactâs mental model breaks down. Keeping &lt;code&gt;isOpen&lt;/code&gt; in your React state synchronized with the &lt;code&gt;&amp;lt;dialog&amp;gt;&lt;/code&gt; elementâs actual open/closed state becomes a nightmare of refs, effects, and imperative calls. Precisely what React was supposed to eliminate.&lt;/p&gt;
    &lt;p&gt;Rather than adapt their patterns to work with stateful native elements, library authors reimplement the entire behavior in a way that fits the framework. Itâs architecturally easier to build a fake dialog in JavaScript than to integrate with the platformâs real one.&lt;/p&gt;
    &lt;p&gt;But the conflict extends beyond architectural preferences. Even when the platform adds features that developers desperately want, frameworks canât always use them.&lt;/p&gt;
    &lt;p&gt;Accordions? The web has &lt;code&gt;&amp;lt;details&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;summary&amp;gt;&lt;/code&gt;. Tooltips? Thereâs &lt;code&gt;title&lt;/code&gt; attribute and the emerging &lt;code&gt;popover&lt;/code&gt; API. Date pickers? &lt;code&gt;&amp;lt;input type="date"&amp;gt;&lt;/code&gt;. Custom dropdowns? The web now supports styling &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; elements with &lt;code&gt;appearance: base-select&lt;/code&gt; and &lt;code&gt;::picker(select)&lt;/code&gt; pseudo-elements. You can even put &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; elements with images inside &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; elements now. It eliminates the need for the countless JavaScript select libraries that exist solely because designers wanted custom styling.&lt;/p&gt;
    &lt;p&gt;Frameworks encourage conditional rendering and component state, so these elements donât get rendered until JavaScript decides they should exist. The mental model is âUI appears when state changes,â not âUI exists, state controls visibility.â Even when the platform adds the exact features developers have been rebuilding in JavaScript for years, the ecosystem momentum means most developers never learn these features exist.&lt;/p&gt;
    &lt;p&gt;And hereâs the truly absurd part: even when developers do know about these new platform features, the frameworks themselves canât handle them. MDNâs documentation for customizable &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; elements includes this warning: âSome JavaScript frameworks block these features; in others, they cause hydration failures when Server-Side Rendering (SSR) is enabled.â The platform evolved. The HTML parser now allows richer content inside &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; elements. But Reactâs JSX parser and hydration system werenât designed for this. They expect &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; to only contain text. Updating the framework to accommodate the platformâs evolution takes time, coordination, and breaking changes that teams are reluctant to make.&lt;/p&gt;
    &lt;p&gt;The web platform added features that eliminate entire categories of JavaScript libraries, but the dominant frameworks canât use those features without causing hydration errors. The stack that was supposed to make development easier now lags behind the platform itâs built on.&lt;/p&gt;
    &lt;head rend="h3"&gt;Routing and Forms: JavaScript All the Way Down&lt;/head&gt;
    &lt;p&gt;The browser has native routing: &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; tags, the History API, forward/back buttons. It has native forms: &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; elements, validation attributes, submit events. These work without JavaScript. Theyâre accessible by default. Theyâre fast.&lt;/p&gt;
    &lt;p&gt;Modern frameworks threw them out. React Router, Next.jsâs router, Vue Router; they intercept link clicks, prevent browser navigation, and handle routing in JavaScript. Why? Because client-side routing feels like a pure state transition: URL changes, state updates, component re-renders. No page reload. No âlostâ JavaScript state.&lt;/p&gt;
    &lt;p&gt;But youâve now made navigation depend on JavaScript. Ctrl+click to open in a new tab? Broken, unless you carefully re-implement it. Right-click to copy link? The URL might not match whatâs rendered. Accessibility tools that rely on standard navigation patterns? Confused.&lt;/p&gt;
    &lt;p&gt;Forms got the same treatment. Instead of letting the browser handle submission, validation, and accessibility, frameworks encourage JavaScript-controlled forms. Formik, React Hook Form, uncontrolled vs. controlled inputs; entire libraries exist to manage what &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; already does. The browser can validate &lt;code&gt;&amp;lt;input type="email"&amp;gt;&lt;/code&gt; instantly, with no JavaScript. But thatâs not reactive enough, so we rebuild validation in JavaScript, ship it to the client, and hope we got the logic right.&lt;/p&gt;
    &lt;p&gt;The web had these primitives. We rejected them because they didnât fit our FP-inspired mental model of âstate flows through JavaScript.â&lt;/p&gt;
    &lt;head rend="h2"&gt;What We Lost in the Process&lt;/head&gt;
    &lt;p&gt;Progressive enhancement used to be a best practice: start with working HTML, layer on CSS for style, add JavaScript for interactivity. The page works at every level. Now, we start with JavaScript and work backwards, trying to squeeze HTML out of our component trees and hoping hydration doesnât break.&lt;/p&gt;
    &lt;p&gt;We lost built-in accessibility. Native HTML elements have roles, labels, and keyboard support by default. Custom JavaScript widgets require &lt;code&gt;aria-*&lt;/code&gt; attributes, focus management, and keyboard handlers. All easy to forget or misconfigure.&lt;/p&gt;
    &lt;p&gt;We lost performance. The browserâs streaming parser can render HTML as it arrives. Modern frameworks send JavaScript, parse JavaScript, execute JavaScript, then finally render. Thatâs slower. The browser can cache CSS and HTML aggressively. JavaScript bundles invalidate on every deploy.&lt;/p&gt;
    &lt;p&gt;We lost simplicity. &lt;code&gt;&amp;lt;a href="/about"&amp;gt;&lt;/code&gt; is eight characters. A client-side router is a dependency, a config file, and a mental model. &lt;code&gt;&amp;lt;form action="/submit" method="POST"&amp;gt;&lt;/code&gt; is self-documenting. A controlled form with validation is dozens of lines of state management.&lt;/p&gt;
    &lt;p&gt;And we lost alignment with the platform. The browser vendors spend millions optimizing HTML parsing, CSS rendering, and event dispatch. We spend thousands of developer-hours rebuilding those features in JavaScript, slower.&lt;/p&gt;
    &lt;head rend="h2"&gt;Why This Happened&lt;/head&gt;
    &lt;p&gt;This isnât a story of incompetence. Smart people built these tools for real reasons.&lt;/p&gt;
    &lt;p&gt;By the early 2010s, JavaScript applications had become unmaintainable. jQuery spaghetti sprawled across codebases. Two-way data binding caused cascading updates that were impossible to debug. Teams needed discipline, and functional programming offered it: pure components, immutable state, unidirectional data flow. For complex, stateful applications (like dashboards with hundreds of interactive components, real-time collaboration tools, data visualization platforms) Reactâs model was genuinely better than manually wiring up event handlers and tracking mutations.&lt;/p&gt;
    &lt;p&gt;The FP purists werenât wrong that unpredictable mutation causes bugs. They were wrong that the solution was avoiding the platformâs mutation-friendly APIs instead of learning to use them well. But in the chaos of 2013, that distinction didnât matter. React worked. It scaled. And Facebook was using it in production.&lt;/p&gt;
    &lt;p&gt;Then came the hype cycle. React dominated the conversation. Every conference had React talks. Every tutorial assumed React as the starting point. CSS-in-JS became âmodern.â Client-side rendering became the default. When big companies like Facebook, Airbnb, Netflix and others adopted these patterns, they became industry standards. Bootcamps taught React exclusively. Job postings required React experience. The narrative solidified: this is how you build for the web now.&lt;/p&gt;
    &lt;p&gt;The ecosystem became self-reinforcing through its own momentum. Once React dominated hiring pipelines and Stack Overflow answers, alternatives faced an uphill battle. Teams that had already invested in React by training developers, building component libraries, establishing patterns are now facing enormous switching costs. New developers learned React because thatâs what jobs required. Jobs required React because thatâs what developers knew. The cycle fed itself, independent of whether React was the best tool for any particular job.&lt;/p&gt;
    &lt;p&gt;This is where we lost the plot. Somewhere in the transition from âReact solves complex application problemsâ to âReact is how you build websites,â we stopped asking whether the problems we were solving actually needed these solutions. Iâve watched developers build personal blogs with Next.js. Sites that are 95% static content with maybe a contact form, because thatâs what they learned in bootcamp. Iâve seen companies choose React for marketing sites with zero interactivity, not because itâs appropriate, but because they canât hire developers who know anything else.&lt;/p&gt;
    &lt;p&gt;The tool designed for complex, stateful applications became the default for everything, including problems the web solved in 1995 with HTML and CSS. A generation of developers never learned that most websites donât need a framework at all. The question stopped being âdoes this problem need React?â and became âwhich React pattern should I use?â The platformâs native capabilities like progressive rendering, semantic HTML, the cascade, instant navigation are now considered âold-fashioned.â Reinventing them in JavaScript became âbest practices.â&lt;/p&gt;
    &lt;p&gt;We chased functional purity on a platform that was never designed for it. And we built complexity to paper over the mismatch.&lt;/p&gt;
    &lt;head rend="h2"&gt;The Way Forward&lt;/head&gt;
    &lt;p&gt;The good news: weâre learning. The industry is rediscovering the platform.&lt;/p&gt;
    &lt;p&gt;HTMX embraces HTML as the medium of exchange. Server sends HTML, browser renders it, no hydration needed. Qwik resumable architecture avoids hydration entirely, serializing only whatâs needed. Astro defaults to server-rendered HTML with minimal JavaScript. Remix and SvelteKit lean into web standards: forms that work without JS, progressive enhancement, leveraging the browserâs cache.&lt;/p&gt;
    &lt;p&gt;These tools acknowledge what the web is: a document-based platform with powerful native capabilities. Instead of fighting it, they work with it.&lt;/p&gt;
    &lt;p&gt;This doesnât mean abandoning components or reactivity. It means recognizing that &lt;code&gt;UI = f(state)&lt;/code&gt; is a useful model inside your framework, not a justification to rebuild the entire browser stack. It means using CSS for styling, native events for interactions, and HTML for structure and then reaching for JavaScript when you need interactivity beyond what the platform provides.&lt;/p&gt;
    &lt;p&gt;The best frameworks of the next decade will be the ones that feel like the web, not in spite of it.&lt;/p&gt;
    &lt;head rend="h2"&gt;Conclusion&lt;/head&gt;
    &lt;p&gt;In chasing functional purity, we built a frontend stack that is more complex, more fragile, and less aligned with the platform it runs on. We recreated CSS in JavaScript, events in synthetic wrappers, rendering in hydration layers, and routing in client-side state machines. We did this because we wanted predictability, control, and clean abstractions.&lt;/p&gt;
    &lt;p&gt;But the web was never meant to be pure. Itâs a sprawling, messy, miraculous platform built on decades of emergent behavior, pragmatic compromises, and radical openness. Its mutability isnât a bug. Itâs the reason a document written in 1995 still renders in 2025. Its global scope isnât dangerous. Itâs what lets billions of pages share a design language.&lt;/p&gt;
    &lt;p&gt;Maybe the web didnât need to be purified. Maybe it just needed to be understood.&lt;/p&gt;
    &lt;p&gt;I want to thank my friend Ihab Khattab for reviewing this piece and providing invaluable feedback.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://alfy.blog/2025/10/04/how-functional-programming-shaped-modern-frontend.html"/><published>2025-10-04T13:04:15+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45473033</id><title>Circular Financing: Does Nvidia's $110B Bet Echo the Telecom Bubble?</title><updated>2025-10-04T15:08:25.396026+00:00</updated><content>&lt;doc fingerprint="7d3a81d9cabac7ee"&gt;
  &lt;main&gt;
    &lt;p&gt;When Nvidia announced a $100 billion investment commitment to OpenAI1 in September 2025 , analysts immediately drew comparisons to the telecom bubble. The concern : is this vendor financing , where a supplier lends money to customers so they can buy the supplier’s products , a harbinger of another spectacular collapse?&lt;/p&gt;
    &lt;p&gt;American tech companies will spend $300-400 billion on AI infrastructure in 20252,3 , exceeding any prior single-year corporate infrastructure investment in nominal dollars.3 David Cahn estimates the revenue gap has grown to $600 billion4.&lt;/p&gt;
    &lt;p&gt;I analyzed the numbers. The similarities are striking , but the differences matter.&lt;/p&gt;
    &lt;head rend="h2"&gt;The Lucent Playbook&lt;/head&gt;
    &lt;p&gt;Lucent’s revenue peaked at $37.92B in 1999 , crashed 69% to $11.80B by 2002 , never recovered. Merged with Alcatel in 2006.&lt;/p&gt;
    &lt;p&gt;In 1999 , Lucent Technologies reached $37.92 billion in revenue at the peak of the dot-com bubble. 5 Lucent was the #1 North American telecommunications equipment manufacturer with 157,000 employees &amp;amp; dominated markets alongside Nortel Networks (combined 53% optical transport market share). 6 Behind the scenes , equipment makers extended billions in vendor financing to telecom customers. Lucent committed $8.1B7 , Nortel extended $3.1B with $1.4B outstanding , &amp;amp; Cisco promised $2.4B in customer loans.8&lt;/p&gt;
    &lt;p&gt;The strategy seemed brilliant : lend money to cash-strapped telecom companies so they could buy your equipment. Everyone wins—until the merry-go-round stops.&lt;/p&gt;
    &lt;p&gt;When the bubble burst :&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;47 Competitive Local Exchange Carriers (CLECs) bankrupted 2000-2003 , including Covad , Focal Communications , McLeod , Northpoint , Winstar 9,10 &lt;list rend="ul"&gt;&lt;item&gt;Why they failed : $60B overbuild 1996-2001 , market saturation from identical business models , sudden funding collapse (Jan 2001 : billions available , Apr 2001 : zero)11&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;33-80% of vendor loan portfolios went uncollected as customers failed &amp;amp; equipment became worthless12&lt;/item&gt;
      &lt;item&gt;Fiber networks were using less than 0.002% of available capacity , with potential for 60,000x speed increases. 13 It was just too early.&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h2"&gt;Nvidia’s Playbook&lt;/head&gt;
    &lt;p&gt;Fast forward to 2025. Nvidia’s vendor financing strategy totals $110 billion in direct investments plus another $15+ billion in GPU-backed debt. The largest commitment is $100B to OpenAI (September 2025)1,14 , structured as 10 tranches of $10B each tied to infrastructure deployment milestones. The first $10B was valued at a $500B OpenAI valuation , with subsequent tranches priced at prevailing valuations. Payment comes via lease arrangements , not upfront GPU purchases. OpenAI CFO Sarah Friar confirmed : “Most of the money will go back to Nvidia”14&lt;/p&gt;
    &lt;p&gt;Beyond OpenAI , Nvidia holds a $3B stake in CoreWeave15 , a company that has spent $7.5B on Nvidia GPUs , &amp;amp; $3.7B in other AI startup investments16 through NVentures.&lt;/p&gt;
    &lt;p&gt;The GPU-backed debt market adds another layer. CoreWeave alone carries $10.45B in debt using GPUs as collateral17. An additional $10B+ in GPU-backed debt has emerged for “Neoclouds” including Lambda Labs ($500M GPU-backed loan)18,19.&lt;/p&gt;
    &lt;p&gt;Lucent in 1999-2000 had vendor financing commitments of $8.1B (20% of $41.4B revenue). Nvidia’s direct investments total 85% of annual revenue ($110B against $130B). Nvidia’s exposure is 4x larger relative to revenue than Lucent’s official outstanding loans , though Lucent’s off-balance-sheet guarantees masked the true exposure.&lt;/p&gt;
    &lt;head rend="h2"&gt;The Numbers Side-by-Side (2024 Dollars)&lt;/head&gt;
    &lt;table&gt;
      &lt;row span="3"&gt;
        &lt;cell role="head"&gt;Metric&lt;/cell&gt;
        &lt;cell role="head"&gt;Lucent (FY2000, inflation-adj.)&lt;/cell&gt;
        &lt;cell role="head"&gt;Nvidia (2025)&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;Vendor financing&lt;/cell&gt;
        &lt;cell&gt;$15B&lt;/cell&gt;
        &lt;cell&gt;$110B&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;Operating cash flow&lt;/cell&gt;
        &lt;cell&gt;$304M20&lt;/cell&gt;
        &lt;cell&gt;$15.4B (Q2 FY26)&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;Revenue&lt;/cell&gt;
        &lt;cell&gt;$34B&lt;/cell&gt;
        &lt;cell&gt;$130B&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;cell&gt;Top 2 Customers represent&lt;/cell&gt;
        &lt;cell&gt;23%21&lt;/cell&gt;
        &lt;cell&gt;39%&lt;/cell&gt;
      &lt;/row&gt;
    &lt;/table&gt;
    &lt;head rend="h2"&gt;The Reasons to be Wary&lt;/head&gt;
    &lt;head rend="h3"&gt;1. The AI Customer Base is More Concentrated&lt;/head&gt;
    &lt;p&gt;Lucent’s top 2 customers—AT&amp;amp;T at 10% &amp;amp; Verizon at 13%—accounted for 23% of revenue in FY2000.21 The Regional Bell Operating Companies , or RBOCs , the seven “Baby Bells” created from AT&amp;amp;T’s 1984 breakup , were also major customers. Nvidia has 39% of revenue from just 2 customers &amp;amp; 46% from 4 customers , nearly double Lucent’s concentration. 88% of Nvidia’s revenue comes from data centers.&lt;/p&gt;
    &lt;head rend="h3"&gt;2. GPU-Backed Debt Is New&lt;/head&gt;
    &lt;p&gt;The new $10B+ GPU-backed debt market is built on the assumption that GPUs will hold their value over 4-6 years. GPU-backed loans carry ~14% interest rates22 , triple investment-grade corporate debt.23&lt;/p&gt;
    &lt;p&gt;How Depreciation Schedules Changed :&lt;/p&gt;
    &lt;table&gt;
      &lt;row span="6"&gt;
        &lt;cell role="head"&gt;Company&lt;/cell&gt;
        &lt;cell role="head"&gt;Pre-2020&lt;/cell&gt;
        &lt;cell role="head"&gt;2020-2021&lt;/cell&gt;
        &lt;cell role="head"&gt;2022-2023&lt;/cell&gt;
        &lt;cell role="head"&gt;2024-2025&lt;/cell&gt;
        &lt;cell role="head"&gt;Change&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="6"&gt;
        &lt;cell&gt;Amazon24&lt;/cell&gt;
        &lt;cell&gt;3 years&lt;/cell&gt;
        &lt;cell&gt;4 years (2020) → 5 years (2021)&lt;/cell&gt;
        &lt;cell&gt;5 years&lt;/cell&gt;
        &lt;cell&gt;6 years (2024) → 5 years (2025)&lt;/cell&gt;
        &lt;cell&gt;First reversal&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="6"&gt;
        &lt;cell&gt;Microsoft25&lt;/cell&gt;
        &lt;cell&gt;~3 years&lt;/cell&gt;
        &lt;cell&gt;4 years&lt;/cell&gt;
        &lt;cell&gt;6 years&lt;/cell&gt;
        &lt;cell&gt;6 years&lt;/cell&gt;
        &lt;cell&gt;+100%&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="6"&gt;
        &lt;cell&gt;Google26&lt;/cell&gt;
        &lt;cell&gt;~3 years&lt;/cell&gt;
        &lt;cell&gt;4 years&lt;/cell&gt;
        &lt;cell&gt;6 years&lt;/cell&gt;
        &lt;cell&gt;6 years&lt;/cell&gt;
        &lt;cell&gt;+100%&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="6"&gt;
        &lt;cell&gt;Meta27&lt;/cell&gt;
        &lt;cell&gt;~3 years&lt;/cell&gt;
        &lt;cell&gt;4 years&lt;/cell&gt;
        &lt;cell&gt;4.5 years → 5 years&lt;/cell&gt;
        &lt;cell&gt;5.5 years&lt;/cell&gt;
        &lt;cell&gt;+83%&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="6"&gt;
        &lt;cell&gt;CoreWeave28&lt;/cell&gt;
        &lt;cell&gt;N/A&lt;/cell&gt;
        &lt;cell&gt;N/A&lt;/cell&gt;
        &lt;cell&gt;4 years → 6 years (Jan 2023)&lt;/cell&gt;
        &lt;cell&gt;6 years&lt;/cell&gt;
        &lt;cell&gt;+50% (GPUs)&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;cell&gt;Nebius29&lt;/cell&gt;
        &lt;cell&gt;N/A&lt;/cell&gt;
        &lt;cell&gt;N/A&lt;/cell&gt;
        &lt;cell&gt;4 years&lt;/cell&gt;
        &lt;cell&gt;4 years&lt;/cell&gt;
        &lt;cell&gt;Industry standard&lt;/cell&gt;
      &lt;/row&gt;
    &lt;/table&gt;
    &lt;p&gt;Amazon’s 2025 reversal (6 → 5 years) is the first major pullback.&lt;/p&gt;
    &lt;p&gt;CPUs historically have 5-10 years of useful life , while GPUs in AI datacenters last 1-3 years in practice , despite 6-year accounting assumptions.30,31 Evidence from Google architects shows GPUs at 60-70% utilization survive 1-2 years , with 3 years maximum.31 Meta’s Llama 3 training experienced 9% annual GPU failure rates , suggesting 27% failure over 3 years.31&lt;/p&gt;
    &lt;p&gt;Cerno Capital raises the question : “Are these policies a reflection of genuine economic &amp;amp; technological realities? Or are these policies a lever by which hyperscalers are enhancing the optics of their investment programs amid rising investor concerns?”32&lt;/p&gt;
    &lt;head rend="h3"&gt;4. The Use of SPVs&lt;/head&gt;
    &lt;p&gt;Tech companies use Special Purpose Vehicles (SPVs) to finance AI datacenter construction. A hyperscaler like Meta partners with a private equity firm like Apollo , contributing capital to a separate legal entity that builds &amp;amp; owns the datacenter.&lt;/p&gt;
    &lt;p&gt;As investor Paul Kedrosky explains : “I have a stake in it as Meta. Some giant private debt provider has a stake in it. The datacenter is under my control. But I don’t own it, so you don’t get to roll it back into my balance sheet.”2*&lt;/p&gt;
    &lt;p&gt;The Structure&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Entity Creation : Hyperscaler &amp;amp; PE firm form separate legal entity (SPV)&lt;/item&gt;
      &lt;item&gt;Capital Structure : Typically 10-30% equity, 70-90% debt from private credit markets&lt;/item&gt;
      &lt;item&gt;Lease Agreement : SPV leases capacity back to hyperscaler&lt;/item&gt;
      &lt;item&gt;Balance Sheet Treatment : SPV debt doesn’t appear on hyperscaler’s balance sheet&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The hyperscaler maintains operational control through long-term lease agreements. Because it doesn’t directly own the SPV , the debt remains off its balance sheet under current accounting standards.&lt;/p&gt;
    &lt;p&gt;The appeal is straightforward. “I don’t want the credit rating agencies to look at what I’m spending. I don’t want investors to roll it up into my income statement.”2*&lt;/p&gt;
    &lt;p&gt;Market Scale&lt;/p&gt;
    &lt;p&gt;American tech companies are projected to spend $300-400 billion on AI infrastructure in 2025. Hyperscaler capital expenditures have reached approximately 50% of operating income2, levels historically associated with government infrastructure buildouts rather than technology companies.&lt;/p&gt;
    &lt;p&gt;Where the Risk Sits&lt;/p&gt;
    &lt;p&gt;Datacenter assets now represent 10-22% of major REIT portfolios2 , up from near zero two years ago. The thin equity layer (10-30%) means if datacenter utilization falls short of projections or if GPUs depreciate faster than projected , equity holders face losses before debt holders experience impairment.&lt;/p&gt;
    &lt;p&gt;*Quotes lightly edited for clarity &amp;amp; brevity&lt;/p&gt;
    &lt;head rend="h3"&gt;5. Custom Silicon Threat&lt;/head&gt;
    &lt;p&gt;Hyperscalers are building their own AI accelerators to reduce Nvidia dependence. Microsoft aims to use “mainly Microsoft silicon” , specifically Maia accelerators , in datacenters.33 Google deploys TPUs , Amazon builds Trainium &amp;amp; Inferentia chips , &amp;amp; Meta develops MTIA processors. If customers shift to in-house silicon , CoreWeave’s GPU collateral value &amp;amp; Nvidia’s vendor financing become exposure to customers building competitive alternatives.&lt;/p&gt;
    &lt;head rend="h2"&gt;Nvidia Isn’t Lucent &amp;amp; 2025 Isn’t 2000&lt;/head&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Accounting : Lucent manipulated $1.148B in revenue , SEC charged 10 executives with fraud5 ; Nvidia shows no evidence of manipulation , audited by PwC , Aa3 rated34&lt;/item&gt;
      &lt;item&gt;Cash flow : Lucent lent $8.1B while cash flow lagged profitability &amp;amp; receivables exploded $5.4B (1998-1999)20 ; Nvidia lends with $50B+ annual operating cash flow &amp;amp; $46.2B net cash35&lt;/item&gt;
      &lt;item&gt;Credit rating : Lucent downgraded to A3 (December 2000)36 ; Nvidia upgraded to Aa3 (March 2024)34&lt;/item&gt;
      &lt;item&gt;Customer base : Lucent’s customers were leveraged CLECs burning capital ; Nvidia’s top 4 customers generated $451B in operating cash flow in 2024 (Microsoft $119B , Alphabet $125B , Amazon $116B , Meta $91.3B)37&lt;/item&gt;
      &lt;item&gt;Capacity : Fiber networks used &amp;lt;0.002% of capacity in 200013 ; Microsoft &amp;amp; AWS report AI capacity constraints in 202538,39&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h2"&gt;What I’m Watching&lt;/head&gt;
    &lt;p&gt;Is AI demand real (like cloud computing) or speculative (like dot-com fiber)?&lt;/p&gt;
    &lt;p&gt;Here’s what I’m watching :&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;GPU utilization rates : Are data centers actually using the chips or just stockpiling?&lt;/item&gt;
      &lt;item&gt;OpenAI’s monetization : Can they generate enough revenue to justify the buildout?&lt;/item&gt;
      &lt;item&gt;Debt defaults : Any cracks in the $15B GPU-backed debt market?&lt;/item&gt;
      &lt;item&gt;AR trends : AR improved from 68% (FY24) to 30% (Q2 FY26) , but still watch for deterioration&lt;/item&gt;
      &lt;item&gt;Customer adds : Are new customers emerging , or is Nvidia dependent on the same 2-4 hyperscalers?&lt;/item&gt;
      &lt;item&gt;Custom silicon threat : Microsoft developing Maia accelerators , aiming to use “mainly Microsoft silicon in the data center.”33 If hyperscalers shift to in-house chips , Nvidia’s vendor financing becomes exposure to customers building competitive alternatives.&lt;/item&gt;
      &lt;item&gt;Vendor consolidation : Many companies are in a period of experimentation trying 2-3 competing vendors. Those experimental budgets may thin with time , reducing overall spend.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;AI is already broadly deployed—40% of US employees used AI at work by September 2025 , double the 20% rate in 2023.40 Questions persist about effectiveness : the oft cited MIT study found 95% of AI pilots failed to deliver measurable P&amp;amp;L impact , primarily due to poor integration rather than technical failures.41&lt;/p&gt;
    &lt;p&gt;Yet the pace of improvement is tremendous. Labor market data shows wages rising twice as fast in AI-exposed industries , &amp;amp; workers using AI boost performance up to 40%.40 Many of Nvidia’s customers are profitable &amp;amp; sophisticated hyperscalers—Microsoft , Google , Amazon , Meta—generating $451B in operating cash flow in 2024 , with tremendous pull from their own enterprise customers demanding AI. OpenAI is not profitable , reporting a $4.7B loss in H1 2025 on $4.3B revenue , though nearly half the loss is stock-based compensation.42&lt;/p&gt;
    &lt;p&gt;Unlike the telecom bubble , where demand was speculative &amp;amp; customers burned cash , this merry-go-round has paying riders.&lt;/p&gt;
    &lt;head rend="h2"&gt;Coda : Lucent’s Accounting Fraud&lt;/head&gt;
    &lt;p&gt;Behind the vendor financing disaster was systematic accounting fraud. The SEC charged Lucent with manipulating $1.148 billion in revenue &amp;amp; $470 million in pre-tax income during fiscal year 2000. 5 The fraud involved multiple schemes :&lt;/p&gt;
    &lt;p&gt;Channel Stuffing : Lucent sent $452 million in equipment to distributors but counted it as revenue before the distributors sold to end customers.5 This created phantom sales.&lt;/p&gt;
    &lt;p&gt;Side Agreements : Lucent executives entered secret agreements with distributors granting them return rights &amp;amp; privileges beyond their distribution contracts , making it improper to recognize revenue.5 These side deals were hidden from auditors.&lt;/p&gt;
    &lt;p&gt;Reserve Manipulation : Lucent improperly established &amp;amp; maintained excess reserves to smooth earnings , violating GAAP.5&lt;/p&gt;
    &lt;p&gt;The SEC charged 10 Lucent executives with securities fraud.5 The company paid a $25 million fine—the largest ever for failing to cooperate with an SEC investigation.5 The accounting manipulation masked deteriorating fundamentals until too late.&lt;/p&gt;
    &lt;p&gt;The WinStar Collapse : Lucent committed $2 billion in vendor financing to WinStar Communications , a CLEC. When WinStar struggled , Lucent refused a final $90 million loan extension. WinStar filed bankruptcy. Lucent wrote off $700 million in bad debts.43 This pattern repeated across customer defaults : Lucent made provisions for bad debts of $2.2 billion (2001) &amp;amp; $1.3 billion (2002)—a total of $3.5 billion in customer loan losses.43&lt;/p&gt;
    &lt;head rend="h2"&gt;References&lt;/head&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;
        &lt;p&gt;“Nvidia to Invest Up to $100 Billion in OpenAI”, CNBC (September 22, 2024) ↩︎ ↩︎&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Paul Kedrosky , “This Is How the AI Bubble Could Burst”, Plain English with Derek Thompson podcast (September 23, 2024) ; “SPVs, Credit &amp;amp; AI Datacenters”, Paul Kedrosky blog ↩︎ ↩︎ ↩︎ ↩︎ ↩︎&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;“OpenAI, Oracle, and SoftBank expand Stargate”, Stargate $500B commitment details ↩︎ ↩︎&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;“AI’s $600B Question”, Sequoia Capital analysis by David Cahn showing AI revenue gap expanded from $125B to $600B ↩︎&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Lucent Technologies financial data &amp;amp; accounting fraud details ↩︎ ↩︎ ↩︎ ↩︎ ↩︎ ↩︎ ↩︎ ↩︎&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;“Nortel Networks and Lucent Technologies dominate North American optical transport market”, Lightwave (1999) ; “Who Lost Lucent?”, American Affairs Journal confirming Lucent $41.4B revenue fiscal 2000 &amp;amp; combined 53% market share ↩︎&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Lucent vendor financing commitments ↩︎&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;“Cisco, Lucent &amp;amp; Nortel: Prime Lenders for Network Buildout”, TheStreet (2001) ↩︎&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Industry analysis of telecom bankruptcies 2000-2003 , including 47 CLEC failures ↩︎&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;“Competitive Local Exchange Carrier”, Wikipedia ↩︎&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;“The rise and fall of the competitive local exchange carriers in the U.S.”, ResearchGate academic analysis ; “The Great Telecom Implosion”, Princeton analysis ↩︎&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Industry analysis of vendor financing losses during telecom bubble collapse ↩︎&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Fiber Broadband Association , “Fiber Broadband Scalability &amp;amp; Longevity” white paper (2024) ; IEEE research on optical fiber capacity ↩︎ ↩︎&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;“Nvidia’s investment in OpenAI will be in cash, and most will be used to lease Nvidia chips”, CNBC interview with OpenAI CFO Sarah Friar (September 24, 2024) ↩︎ ↩︎&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Industry reports on CoreWeave equity &amp;amp; GPU purchases (2024) ↩︎&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Nvidia investor presentations &amp;amp; NVentures portfolio data (2024) ↩︎&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;“CoreWeave Raises $7.5 Billion in Debt”, Bloomberg (May 2024) ↩︎&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Lambda Labs GPU financing announcements (2024) ↩︎&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Financial Times reporting on GPU-backed debt market emergence (2024) ↩︎&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Lucent Technologies 10-K Annual Report (FY2000) : “Revenues from AT&amp;amp;T accounted for approximately 10% of consolidated revenues in fiscal 2000. Revenues from Verizon accounted for approximately 13% of consolidated revenues in fiscal 2000.” ↩︎ ↩︎&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;“CoreWeave’s GPU-Backed Debt Strategy”, AIinvest analysis of ~14% interest rates on GPU-backed loans ↩︎&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;“As venture debt gambles on GPUs, not all are sold on silicon-backed loans”, PitchBook analysis of GPU collateral risks ↩︎&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;“Amazon Revises Server Lifespan” &amp;amp; The Register reporting on AWS depreciation changes (2020-2025) ↩︎&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;“Accounting for AI: Hyperscaler Depreciation Policies”, Cerno Capital analysis ↩︎&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;“Google Extends Server Life to Six Years”, Data Center Dynamics (2023) ↩︎&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;“Meta Extends Server Life”, The Stack Technology (2025) ↩︎&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;“CoreWeave Depreciates Its GPUs Over 6 Years”, WCCFtech (2025) ↩︎&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;“How Long Do GPUs Last Anyway?”, Applied Conjectures analysis of GPU depreciation policies ↩︎&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;“Datacenter GPU service life can be surprisingly short — only one to three years”, Tom’s Hardware ; “How Long Should a GPU Actually Last?”, confirming 3-4 year GPU lifecycle vs CPUs at 5-7 years ↩︎&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;“Datacenter GPU service life can be surprisingly short”, Tom’s Hardware reporting on Google architect analysis ↩︎ ↩︎ ↩︎&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;“Accounting for AI: Financial Accounting Issues and Capital Deployment in the Hyperscaler Landscape”, Cerno Capital analysis (2025) ↩︎&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;“Microsoft wants to use ‘mainly Microsoft silicon’ in its data centers”, The Register (October 2, 2025) ↩︎ ↩︎&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Moody’s Investors Service upgrade of Nvidia to Aa3 (March 2024) ↩︎ ↩︎&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Nvidia Q2 FY26 Financial Results (ended July 27, 2025) ↩︎&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Lucent credit rating downgrades ↩︎&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Fiscal year 2024 operating cash flow data from company financial statements : Microsoft FY2024 (ended June 30, 2024) Form 10-K , Alphabet FY2024 (ended December 31, 2024) Form 10-K , Amazon FY2024 (ended December 31, 2024) Form 10-K , Meta FY2024 (ended December 31, 2024) $91.328B operating cash flow ↩︎&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;"$13b Run Rate &amp;amp; Doubling", Tomasz Tunguz analysis of Microsoft Q3 2025 earnings (January 30, 2025) ↩︎&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;“Google’s Future in Search &amp;amp; AI”, Tomasz Tunguz analysis citing AWS capacity constraints (2025) ↩︎&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;“Anthropic Economic Index report: Uneven geographic and enterprise AI adoption”, Anthropic (September 2025) showing 40% of US employees used AI at work , double the 20% in 2023 ; “AI in Productivity: Top Insights and Statistics for 2024”, showing workers using AI boost performance up to 40% &amp;amp; wages rising twice as fast in AI-exposed industries ↩︎ ↩︎&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;“MIT report: 95% of generative AI pilots at companies are failing”, Fortune (August 2025) ; Study by Aditya Challapally found 95% of AI pilots failed to deliver measurable P&amp;amp;L impact , primarily due to poor integration with existing workflows rather than technical AI model failures ↩︎&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;“OpenAI’s First Half Results: $4.3 Billion in Sales, $2.5 Billion Cash Burn”, The Information ; OpenAI reported $4.3B revenue &amp;amp; $4.7B loss in H1 2025 , with stock-based compensation expenses approaching $2.5B , nearly half the total loss ↩︎&lt;/p&gt;
      &lt;/item&gt;
    &lt;/list&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://tomtunguz.com/nvidia_nortel_vendor_financing_comparison/"/><published>2025-10-04T13:06:32+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45473126</id><title>It's not a hack to satisfy known requirements</title><updated>2025-10-04T15:08:25.328035+00:00</updated><content>&lt;doc fingerprint="fad19863e753ce9d"&gt;
  &lt;main&gt;
    &lt;head rend="h2"&gt;It's not a hack to satisfy known requirements&lt;/head&gt;
    &lt;p&gt;And you should even take pride in doing less&lt;/p&gt;
    &lt;p&gt;I so frequently see extremely capable software engineers waste their skills with over-engineering, and it makes me feel sad. Here are some tips to help avoid the over-engineering trap, and so also to help keep me happy 😀.&lt;/p&gt;
    &lt;head rend="h3"&gt;Find out what is seen as valuable&lt;/head&gt;
    &lt;p&gt;We're not here to write code, but to solve problems. Find exactly what problems you are expected to solve and focus on those. Remember that code that clearly solves just those problems is in no way a hack.&lt;/p&gt;
    &lt;head rend="h3"&gt;Deliver value as often as possible to get feedback&lt;/head&gt;
    &lt;p&gt;Frequently delivering value is a great way to avoid over-engineering. It basically gives you regular course correction towards appropriate-engineering, because you quickly and frequently find out if there is no value for the code you're writing.&lt;/p&gt;
    &lt;p&gt;I generally argue for at least daily delivery of value; see the "Deliver value daily" manifesto (which I co-wrote).&lt;/p&gt;
    &lt;head rend="h3"&gt;Write and maintain integration tests that survive refactoring&lt;/head&gt;
    &lt;p&gt;One of the worst pieces of advice that I ever received was that every function should be unit tested. This is the path to designing code that you never want to change because no matter what change you make, tests will break, and thus leads you to trying to handle every possible future up-front. Please, I beg you, no.&lt;/p&gt;
    &lt;p&gt;Instead, write higher level tests close to the client/user facing behaviour that actually give you protection against breaking things unintentionally, and so free to you make changes later once you have evidence they're needed.&lt;/p&gt;
    &lt;head rend="h3"&gt;Avoid Object-Oriented Programming, or at least be extra careful with it&lt;/head&gt;
    &lt;p&gt;Object-oriented code is more susceptible to over-engineering if you're not careful, because every object has its own set of responsibilities on what it looks after, often quite divorced from the actual data flows in your application. So many problems have only a handful of possible cases, and yet if you look at all the classes and member functions involved in typical object-oriented solutions, they're coded up as though there were many orders of magnitude more cases, which makes them difficult to optimise for the actual cases. Inheritance-based reuse is also notoriously hard to change, and so pushes you to design the "perfect" system up front.&lt;/p&gt;
    &lt;p&gt;Don't be scared of keeping data and code separate via free functions, especially pure functions. Basic data-in data-out patterns often result in very clear separation of responsibilities, and they are often easy to refactor.&lt;/p&gt;
    &lt;head rend="h3"&gt;Remember you can still add in that complication tomorrow&lt;/head&gt;
    &lt;p&gt;Train yourself to realise you can always add in that complication tomorrow if you judge that it's still needed tomorrow. Sometimes the answer will be yes, but so often the answer will be no, and that's a great thing.&lt;/p&gt;
    &lt;p&gt;This is much easier when high-level integration tests are in place.&lt;/p&gt;
    &lt;head rend="h3"&gt;Be concious of what makes you over-engineer&lt;/head&gt;
    &lt;p&gt;Run a search for "What causes software over-engeneering?" and see which apply to you. Self-awareness is half the battle.&lt;/p&gt;
    &lt;head rend="h3"&gt;Get yourself a better definition of perfection&lt;/head&gt;
    &lt;p&gt;If you think you're fighting against a drive for perfectionism, give in to the drive but instead find a better definition of perfection. This is basically mine:&lt;/p&gt;
    &lt;quote&gt;&lt;p&gt;Perfection is achieved, not when there is nothing more to add, but when there is nothing left to take away.&lt;/p&gt;Antoine de Saint-Exupéry&lt;/quote&gt;
    &lt;head rend="h3"&gt;When should you create stuff just in case?&lt;/head&gt;
    &lt;p&gt;This all being said, there are times when you should create something just in case, and that's when all three of the following are satisfied:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;There is a reasonable chance it will be useful later&lt;/item&gt;
      &lt;item&gt;It will be difficult to add in later&lt;/item&gt;
      &lt;item&gt;It won't meanginfully slow down the meeting of more likely requirements&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;To determine if all those hold true, you have to have an idea of what features are likely going to be needed. This is beyond the scope of code and much more do with people—users or stakeholders—that you will have to speak to. You can always choose to assume without validating the assumption, but doing so will almost definitely be due to arrogance or fear. Do not make engineering decisions because of arrogance or fear!&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://charemza.name/blog/posts/agile/over-engineering/not-a-hack-to-meet-requirements/"/><published>2025-10-04T13:20:15+00:00</published></entry></feed>