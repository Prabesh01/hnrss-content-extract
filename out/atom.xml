<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><id>hnrss.org/frontpage</id><title>Hacker News: Front Page</title><updated>2025-10-24T20:38:37.808811+00:00</updated><link href="https://news.ycombinator.com/" rel="alternate"/><link href="https://raw.githubusercontent.com/Prabesh01/hnrss-content-extract/refs/heads/main/out/rss.xml" rel="self"/><generator uri="https://lkiesow.github.io/python-feedgen" version="1.0.0">python-feedgen</generator><subtitle>Hacker News RSS</subtitle><entry><id>https://news.ycombinator.com/item?id=45678001</id><title>Clojure Zippers (2021)</title><updated>2025-10-24T20:38:46.819972+00:00</updated><content>&lt;doc fingerprint="bf039b1a1c1d8f21"&gt;
  &lt;main&gt;
    &lt;head rend="h1"&gt;Clojure Zippers&lt;/head&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Part 1. The Basics of Navigation&lt;/item&gt;
      &lt;item&gt;Part 2. Automatic navigation&lt;/item&gt;
      &lt;item&gt;Part 3. XML zippers&lt;/item&gt;
      &lt;item&gt;Part 4. XML search&lt;/item&gt;
      &lt;item&gt;Part 5. Editing&lt;/item&gt;
      &lt;item&gt;Part 6. Virtual Trees. Currency Exchange&lt;/item&gt;
      &lt;item&gt;Part 7. Breadth-First Traversal. Improved Currency Exchange&lt;/item&gt;
      &lt;item&gt;Part 8. Summary&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h2"&gt;Part 1. The Basics of Navigation&lt;/head&gt;
    &lt;p&gt;In this article, we will discuss zippers in the Clojure language. These are an unusual way to work with collections. Using a zipper, you can traverse a data structure arbitrarily and modify its content as well as search in it. A zipper is a powerful abstraction that pays off over time. However, it is not as straightforward as regular tools and requires training to deal with.&lt;/p&gt;
    &lt;p&gt;Let’s talk about a zipper in simple terms. It is a wrapper that offers a variety of data manipulations. Let’s list the main ones:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;moving vertically: down to children or up to a parent;&lt;/item&gt;
      &lt;item&gt;moving horizontally: left or right among children;&lt;/item&gt;
      &lt;item&gt;traversal of the entire data structure;&lt;/item&gt;
      &lt;item&gt;adding, editing and deleting nodes.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;This is a partial list, and you will see the most interesting solutions more later. Note: these capabilities are available when working with arbitrary data, whether it’s a combination of vectors and maps, XML, or a tree. This makes zippers a powerful tool. If you figure out how to handle them, you will boost your skills and open new doors.&lt;/p&gt;
    &lt;p&gt;The good news is that zippers are available in the base Clojure package. It’s better than a third party library that needs to be included. Zippers are easy to add to a project with no fear of license issues or new dependencies.&lt;/p&gt;
    &lt;p&gt;Clojure zippers harness the power of immutable collections. Technically, a zipper is a collection that stores data and the position of the pointer. Together they are called a location. A step in either direction returns a new location, just like the &lt;code&gt;assoc&lt;/code&gt; or &lt;code&gt;update&lt;/code&gt; functions generate new data from old data.&lt;/p&gt;
    &lt;p&gt;From the current location, you can get a node, that is, a piece of data that the pointer refers to. Let’s clarify their difference to avoid confusing beginners. Location is the source data and the position in it. Moving around the location generates a new location. From the location, you can retrieve a node — the data that is in this area.&lt;/p&gt;
    &lt;p&gt;Below is an example with the vector &lt;code&gt;[1 2 3]&lt;/code&gt;. To move to the second item, the two, you need to wrap the data in a zipper and execute the &lt;code&gt;zip/down&lt;/code&gt; and&lt;code&gt; zip/right&lt;/code&gt; commands. In the first step, we’ll get into the vector and find ourselves on element 1. A step to the right will move us to 2. Let’s express it in code: include the package with the alias &lt;code&gt;zip&lt;/code&gt; and traverse the vector.&lt;/p&gt;
    &lt;code&gt;(require '[clojure.zip :as zip])

(-&amp;gt; [1 2 3]
    zip/vector-zip
    zip/down
    zip/right
    zip/node)
;; 2
&lt;/code&gt;
    &lt;p&gt;Chaining these functions will return 2 as expected. The last action — &lt;code&gt;zip/node&lt;/code&gt; — outputs the value (a node) from the current location. If we remove &lt;code&gt;zip/node&lt;/code&gt;, we’ll get a location that corresponds to 2. It looks like this:&lt;/p&gt;
    &lt;code&gt;(-&amp;gt; [1 2 3]
    zip/vector-zip
    zip/down
    zip/right)

;; [2 {:l [1], :pnodes [[1 2 3]], :ppath nil, :r (3)}]
&lt;/code&gt;
    &lt;p&gt;Maybe you have some questions: how do we know the path to the 2 when it could have been elsewhere in the vector? What happens if we go outside the collection? You’ll find the answers to these questions below. For now, if something is not clear to you, do not panic: we’ll clarify more than once everything happening here.&lt;/p&gt;
    &lt;p&gt;So, the zipper suggests navigating through the data. Despite its power, it doesn’t know how to do this for a specific collection, so you need to teach it. In addition to data, a zipper requires answers to two questions:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;
        &lt;p&gt;Is the current element a branch? This is the name of the element from which you can get other ones.&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;If it’s a branch, how do you fetch children from it?&lt;/p&gt;
      &lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;That’s all a zipper needs to know to navigate. Note, for changing the zipper itself, you need to know the answer to one more question — how to attach children to a branch. However, we are only looking at navigation, so the third question can wait.&lt;/p&gt;
    &lt;p&gt;Technically, functions give the answers to the first and second questions. The first one takes a node and returns &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. If it returns &lt;code&gt;true&lt;/code&gt;, the zipper calls the second function. It takes the same node but should return a sequence of child nodes or &lt;code&gt;nil&lt;/code&gt; if they don’t exist. In code, these functions are called &lt;code&gt;branch?&lt;/code&gt; and &lt;code&gt;children&lt;/code&gt;.&lt;/p&gt;
    &lt;p&gt;To get a zipper, you need to tell it input data and the two functions just described. As long as we only read a zipper, the third function can be &lt;code&gt;nil&lt;/code&gt;. The zippers locate in the &lt;code&gt;clojure.zip&lt;/code&gt; package. Include it into namespace:&lt;/p&gt;
    &lt;code&gt;(ns my.project
  (:require [clojure.zip :as zip]))
&lt;/code&gt;
    &lt;p&gt;Explore the source code for this module in your leisure time. It is only 280 lines long!&lt;/p&gt;
    &lt;p&gt;The &lt;code&gt;zip/zipper&lt;/code&gt; function creates a zipper from source data and functions. This is the module’s main point, its building blocks. For common cases, the module offers some predefined zippers that only expect data. &lt;code&gt;Vector-zip&lt;/code&gt; for nested vectors is a good example. Here is its code without the third parameter:&lt;/p&gt;
    &lt;code&gt;(defn vector-zip
  [root]
  (zipper vector?
          seq
          ...
          root))
&lt;/code&gt;
    &lt;p&gt;We replaced it with three dots. The third parameter is a function that attaches child nodes to the branch on change (ignore it for now). If you pass the vector &lt;code&gt;[1 2 3]&lt;/code&gt; to &lt;code&gt;vector-zip&lt;/code&gt;, the following happens:&lt;/p&gt;
    &lt;p&gt;The zipper will wrap the vector and expose a pointer to it. From the starting position, you can only traverse down, because at the top a zipper has no parent (up) and neighbors (left and right). When navigating down, the zipper first checks if the branch is the current node. That triggers the expression &lt;code&gt;(vector? [1 2 3])&lt;/code&gt; that gets evaluated to &lt;code&gt;true&lt;/code&gt;. In this case, the zipper will execute &lt;code&gt;(seq [1 2 3])&lt;/code&gt; to get children. They will be the sequence &lt;code&gt;(1 2 3)&lt;/code&gt;. Once the children are found, the zipper will set the pointer to the leftmost child — 1.&lt;/p&gt;
    &lt;p&gt;Let’s show this in the diagram. Start position, a pointer is on the source vector:&lt;/p&gt;
    &lt;code&gt;                ┌───────┐
                │  nil  │
                └───────┘
                    ▲
                    │
 ┌───────┐    ┏━━━━━━━━━━━┓    ┌───────┐
 │  nil  │◀───┃  [1 2 3]  ┃───▶│  nil  │
 └───────┘    ┗━━━━━━━━━━━┛    └───────┘
                    │
                    ▼
                ┌───────┐
                │   1   │
                └───────┘
&lt;/code&gt;
    &lt;p&gt;Step down, the pointer is at 1:&lt;/p&gt;
    &lt;code&gt;                ┌───────┐
                │[1 2 3]│
                └───────┘
                    ▲
                    │
 ┌───────┐    ┏━━━━━━━━━━━┓    ┌───────┐
 │  nil  │◀───┃     1     ┃───▶│   2   │
 └───────┘    ┗━━━━━━━━━━━┛    └───────┘
                    │
                    ▼
                ┌───────┐
                │  nil  │
                └───────┘
&lt;/code&gt;
    &lt;p&gt;Step to the right, the pointer on 2:&lt;/p&gt;
    &lt;code&gt;                ┌───────┐
                │[1 2 3]│
                └───────┘
                    ▲
                    │
 ┌───────┐    ┏━━━━━━━━━━━┓    ┌───────┐
 │  nil  │◀───┃     2     ┃───▶│   3   │
 └───────┘    ┗━━━━━━━━━━━┛    └───────┘
                    │
                    ▼
                ┌───────┐
                │  nil  │
                └───────┘
&lt;/code&gt;
    &lt;p&gt;So, we are on 2 and can move horizontally. A step to the right will move us to 3, to the left — to 1. In the code, it looks like this:&lt;/p&gt;
    &lt;code&gt;(def loc2
  (-&amp;gt; [1 2 3]
      zip/vector-zip
      zip/down
      zip/right))

(-&amp;gt; loc2 zip/node)
;; 2

(-&amp;gt; loc2 zip/right zip/node)
;; 3

(-&amp;gt; loc2 zip/left zip/node)
;; 1
&lt;/code&gt;
    &lt;p&gt;When trying to move down, the zipper will execute the &lt;code&gt;(vector? 2)&lt;/code&gt; predicate. The result
will be &lt;code&gt;false&lt;/code&gt;, which means that the current element is not a branch and no downward movement is allowed.&lt;/p&gt;
    &lt;p&gt;Remember the following as you traverse. Each step creates a new location without changing the old one. If you save any particular location in a variable, subsequent calls to &lt;code&gt;zip/right,&lt;/code&gt; &lt;code&gt;zip/down&lt;/code&gt;, and others will not change it in any way. Above, we have declared the &lt;code&gt;loc2&lt;/code&gt; variable,
which points to 2. You can use it to get the source vector.&lt;/p&gt;
    &lt;code&gt;(-&amp;gt; loc2 zip/up zip/node)
;; [1 2 3]
&lt;/code&gt;
    &lt;p&gt;If you move along manually, chances are good that you will go outside the collection. A step to nowhere will return &lt;code&gt;nil&lt;/code&gt; instead of a location:&lt;/p&gt;
    &lt;code&gt;(-&amp;gt; [1 2 3]
    zip/vector-zip
    zip/down
    zip/left)
nil
&lt;/code&gt;
    &lt;p&gt;This is a signal that you are on the wrong route. The bad news is that you cannot go back from &lt;code&gt;nil&lt;/code&gt;. &lt;code&gt;Nil&lt;/code&gt; signifies an empty location, and there is no reference to the previous step in it. The &lt;code&gt;zip/up&lt;/code&gt;, &lt;code&gt;zip/right&lt;/code&gt; and other functions also return &lt;code&gt;nil&lt;/code&gt; for an empty location. If you iterate in a cycle and do not take this into account, you’ll just end up spinning your wheels.&lt;/p&gt;
    &lt;code&gt;(-&amp;gt; [1 2 3]
zip/vector-zip
zip/down
zip/left
zip/left
zip/left
zip/left)
&lt;/code&gt;
    &lt;p&gt;The &lt;code&gt;zip/down&lt;/code&gt; function is an exception: if you try to descend from &lt;code&gt;nil&lt;/code&gt;, you’ll get a &lt;code&gt;NullPointerException&lt;/code&gt; error. This is a slight defect that probably will be fixed on day.&lt;/p&gt;
    &lt;code&gt;(-&amp;gt; [1 2 3]
zip/vector-zip
zip/down
zip/left
zip/down)

;; Execution error (NullPointerException)...
&lt;/code&gt;
    &lt;p&gt;Let’s take a look at a more complex vector. One of its children is another vector — &lt;code&gt;[1 [2 3] 4]&lt;/code&gt;. To move the pointer to 3, make the steps &lt;code&gt;down&lt;/code&gt;, &lt;code&gt;right&lt;/code&gt;, &lt;code&gt;down&lt;/code&gt;, and &lt;code&gt;right&lt;/code&gt;. Let’s store a location in a variable:&lt;/p&gt;
    &lt;code&gt;(def loc3
  (-&amp;gt; [1 [2 3] 4]
      zip/vector-zip
      zip/down
      zip/right
      zip/down
      zip/right))

(zip/node loc3)
3
&lt;/code&gt;
    &lt;p&gt;The pictures below show what happens at each step. Starting position:&lt;/p&gt;
    &lt;code&gt;                ┌───────┐
                │  nil  │
                └───────┘
                    ▲
                    │
 ┌───────┐    ┏━━━━━━━━━━━┓    ┌───────┐
 │  nil  │◀───┃[1 [2 3] 4]┃───▶│  nil  │
 └───────┘    ┗━━━━━━━━━━━┛    └───────┘
                    │
                    ▼
                ┌───────┐
                │   1   │
                └───────┘
&lt;/code&gt;
    &lt;p&gt;Step down:&lt;/p&gt;
    &lt;code&gt;              ┌───────────┐
              │[1 [2 3] 4]│
              └───────────┘
                    ▲
                    │
 ┌───────┐    ┏━━━━━━━━━━━┓    ┌───────┐
 │  nil  │◀───┃     1     ┃───▶│ [2 3] │
 └───────┘    ┗━━━━━━━━━━━┛    └───────┘
                    │
                    ▼
                ┌───────┐
                │  nil  │
                └───────┘
&lt;/code&gt;
    &lt;p&gt;To the right:&lt;/p&gt;
    &lt;code&gt;              ┌───────────┐
              │[1 [2 3] 4]│
              └───────────┘
                    ▲
                    │
 ┌───────┐    ┏━━━━━━━━━━━┓    ┌───────┐
 │   1   │◀───┃   [2 3]   ┃───▶│   4   │
 └───────┘    ┗━━━━━━━━━━━┛    └───────┘
                    │
                    ▼
                ┌───────┐
                │   2   │
                └───────┘
&lt;/code&gt;
    &lt;p&gt;Down:&lt;/p&gt;
    &lt;code&gt;              ┌───────────┐
              │   [2 3]   │
              └───────────┘
                    ▲
                    │
 ┌───────┐    ┏━━━━━━━━━━━┓    ┌───────┐
 │   1   │◀───┃     2     ┃───▶│   3   │
 └───────┘    ┗━━━━━━━━━━━┛    └───────┘
                    │
                    ▼
                ┌───────┐
                │  nil  │
                └───────┘
&lt;/code&gt;
    &lt;p&gt;To the right. We are at our goal:&lt;/p&gt;
    &lt;code&gt;              ┌───────────┐
              │   [2 3]   │
              └───────────┘
                    ▲
                    │
 ┌───────┐    ┏━━━━━━━━━━━┓    ┌───────┐
 │   2   │◀───┃     3     ┃───▶│  nil  │
 └───────┘    ┗━━━━━━━━━━━┛    └───────┘
                    │
                    ▼
                ┌───────┐
                │  nil  │
                └───────┘
&lt;/code&gt;
    &lt;p&gt;To move to 4 from the current position, you first need to go up. The pointer will move to vector &lt;code&gt;[2 3]&lt;/code&gt;. Now we are among the children of the original vector and can move horizontally. Let’s take a step to the right and find ourselves at number 4.&lt;/p&gt;
    &lt;p&gt;Here the same actions are shown graphically. The current location (i.e., 3):&lt;/p&gt;
    &lt;code&gt;              ┌───────────┐
              │   [2 3]   │
              └───────────┘
                    ▲
                    │
 ┌───────┐    ┏━━━━━━━━━━━┓    ┌───────┐
 │   2   │◀───┃     3     ┃───▶│  nil  │
 └───────┘    ┗━━━━━━━━━━━┛    └───────┘
                    │
                    ▼
                ┌───────┐
                │  nil  │
                └───────┘
&lt;/code&gt;
    &lt;p&gt;Step up:&lt;/p&gt;
    &lt;code&gt;              ┌───────────┐
              │[1 [2 3] 4]│
              └───────────┘
                    ▲
                    │
 ┌───────┐    ┏━━━━━━━━━━━┓    ┌───────┐
 │   1   │◀───┃   [2 3]   ┃───▶│   4   │
 └───────┘    ┗━━━━━━━━━━━┛    └───────┘
                    │
                    ▼
                ┌───────┐
                │   2   │
                └───────┘
&lt;/code&gt;
    &lt;p&gt;Step to the right:&lt;/p&gt;
    &lt;code&gt;              ┌───────────┐
              │[1 [2 3] 4]│
              └───────────┘
                    ▲
                    │
 ┌───────┐    ┏━━━━━━━━━━━┓    ┌───────┐
 │ [2 3] │◀───┃     4     ┃───▶│  nil  │
 └───────┘    ┗━━━━━━━━━━━┛    └───────┘
                    │
                    ▼
                ┌───────┐
                │  nil  │
                └───────┘
&lt;/code&gt;
    &lt;p&gt;The original vector can be of any nesting. As an exercise, replace 3 with another vector and go down into it.&lt;/p&gt;
    &lt;p&gt;What does happen if you pass something other than a vector to &lt;code&gt;vector-zip&lt;/code&gt;?  For example, it might be a string, nil, or a number. Before traversing, the zipper checks to see if the node is a branch and if it has child nodes. For &lt;code&gt;vector-zip&lt;/code&gt;, it checks the data with the &lt;code&gt;vector?&lt;/code&gt; function, which returns &lt;code&gt;nil&lt;/code&gt; for all non-vector values. As a result, we get a location from where we can’t step anywhere: neither down nor laterally. This dead end must be avoided.&lt;/p&gt;
    &lt;code&gt;(-&amp;gt; "test"
    zip/vector-zip
    zip/down)
nil
&lt;/code&gt;
    &lt;p&gt;The &lt;code&gt;clojure.zip&lt;/code&gt; module also offers other built-in zippers. The &lt;code&gt;xml-zip&lt;/code&gt; is especially interesting for navigating XML trees. We’ll discuss it separately when you get to know the other zipper features.&lt;/p&gt;
    &lt;head rend="h2"&gt;Part 2. Automatic navigation&lt;/head&gt;
    &lt;p&gt;We figured out how to navigate through the collection. However, you might wonder how the path goes? How do you know in advance in which direction to go?&lt;/p&gt;
    &lt;p&gt;The main message of this section is: Manual navigation through data makes no sense. If you know the path beforehand, you don’t need a zipper.&lt;/p&gt;
    &lt;p&gt;For data whose structure you know in advance, Clojure offers an easier way to work with. For example, if we know for sure that the input data structure is a vector, and its second element is another vector, we’ll use &lt;code&gt;get-in&lt;/code&gt;:&lt;/p&gt;
    &lt;code&gt;(def data [1 [2 3] 4])

(get-in data [1 1])
;; 3
&lt;/code&gt;
    &lt;p&gt;The same goes for other data types. It doesn’t matter what combination lists and maps make. If the structure is known in advance, the data you need can be easily reached with a &lt;code&gt;get-in&lt;/code&gt; or threading macro. In this case, zippers will only complicate the code.&lt;/p&gt;
    &lt;code&gt;(def data {:users [{:name "Ivan"}]})

(-&amp;gt; data :users first :name)
;; "Ivan"
&lt;/code&gt;
    &lt;p&gt;What is the advantage of zippers? Their strengths are manifested in situations where &lt;code&gt;get-in&lt;/code&gt; can’t work. It’s about data with an unknown structure. Let’s say there is an arbitrary vector as input, and you need to find a string in it. For example, it might be at the first nesting level, or at the third, and so on. Another example is an XML document. The required tag can be located anywhere in it, but you need to find it somehow. In short, the ideal situation for a zipper is a fuzzy data structure that we’re only guessing about.&lt;/p&gt;
    &lt;p&gt;Together, the functions &lt;code&gt;zip/up&lt;/code&gt;, &lt;code&gt;zip/down&lt;/code&gt;, and others form the universal function — &lt;code&gt;zip/next&lt;/code&gt;. It
moves the pointer so that sooner or later we’ll traverse the entire structure. When traversing, repetitions are excluded: we’ll visit each place only once. Here is an example with a vector:&lt;/p&gt;
    &lt;code&gt;(def vzip (zip/vector-zip [1 [2 3] 4]))

(-&amp;gt; vzip zip/node)
;; [1 [2 3] 4]

(-&amp;gt; vzip zip/next zip/node)
;; 1

(-&amp;gt; vzip zip/next zip/next zip/node)
;; [2 3]

(-&amp;gt; vzip zip/next zip/next zip/next zip/node)
;; 2
&lt;/code&gt;
    &lt;p&gt;We don’t know how many times to call &lt;code&gt;zip/next&lt;/code&gt;, so let’s resort to a ploy. The &lt;code&gt;iterate&lt;/code&gt; function takes the &lt;code&gt;f&lt;/code&gt; function and an &lt;code&gt;x&lt;/code&gt; value. It returns a sequence where the first element is &lt;code&gt;x&lt;/code&gt;, and each next is an &lt;code&gt;f(x)&lt;/code&gt; from the previous one. For a zipper, we get the initial location, then &lt;code&gt;zip/next&lt;/code&gt; from it, then &lt;code&gt;zip/next&lt;/code&gt; from the previous movement, and so on.&lt;/p&gt;
    &lt;p&gt;Below, the variable &lt;code&gt;loc-seq&lt;/code&gt; is the location chain of the source zipper. To get the nodes, we take the first six elements (the number we take randomly) and call &lt;code&gt;zip/node&lt;/code&gt; for each.&lt;/p&gt;
    &lt;code&gt;(def loc-seq (iterate zip/next vzip))

(-&amp;gt;&amp;gt; loc-seq
     (take 6)
     (map zip/node))

;; ([1 [2 3] 4]
;;   1
;;   [2 3]
;;   2
;;   3
;;   4)
&lt;/code&gt;
    &lt;p&gt;&lt;code&gt;Iterate&lt;/code&gt; returns a lazy and infinite sequence. Both characteristics are important. Laziness means that the next shift (i.e., calling &lt;code&gt;zip/next&lt;/code&gt;) will not happen until you reach an element in the chain. Infinity means that &lt;code&gt;zip/next&lt;/code&gt; is called an unlimited number of times. We need a flag to indicate that we need to stop calling &lt;code&gt;zip/next&lt;/code&gt;, otherwise the stream of locations will never end.&lt;/p&gt;
    &lt;p&gt;In addition, at some point, &lt;code&gt;zip/next&lt;/code&gt; stops moving the pointer. Take, for example, the hundredth and thousandth elements of an iteration. Their node will be the initial vector:&lt;/p&gt;
    &lt;code&gt;(-&amp;gt; loc-seq (nth 100) zip/node)
;; [1 [2 3] 4]

(-&amp;gt; loc-seq (nth 1000) zip/node)
;; [1 [2 3] 4]
&lt;/code&gt;
    &lt;p&gt;The reason lies in how the zipper traversal works. The &lt;code&gt;zip/next&lt;/code&gt; function acts like a ring. When it reaches the initial location, the loop ends. In this case, the location will get a completion flag, and the next calling &lt;code&gt;zip/next&lt;/code&gt; will return the same location. You can check a flag presence with the &lt;code&gt;zip/end?&lt;/code&gt; function:&lt;/p&gt;
    &lt;code&gt;(def loc-end
  (-&amp;gt; [1 2 3]
      zip/vector-zip
      zip/next
      zip/next
      zip/next
      zip/next))

loc-end
;; [[1 2 3] :end]

(zip/end? loc-end)
&lt;/code&gt;
    &lt;p&gt;To create the finite chain of locations, we’ll keep moving the pointer until we get the last location. Together, this gives the following function:&lt;/p&gt;
    &lt;code&gt;(defn iter-zip [zipper]
  (-&amp;gt;&amp;gt; zipper
       (iterate zip/next)
       (take-while (complement zip/end?))))
&lt;/code&gt;
    &lt;p&gt;This function returns all locations in the data structure. Recall that a location stores a node (a data element) that we can get using &lt;code&gt;zip/node&lt;/code&gt;. The example below shows how to convert locations into data:&lt;/p&gt;
    &lt;code&gt;(-&amp;gt;&amp;gt; [1 [2 3] 4]
     zip/vector-zip
     iter-zip
     (map zip/node))

;; ([1 [2 3] 4]
;;  1
;;  [2 3]
;;  2
;;  3
;;  4)
&lt;/code&gt;
    &lt;p&gt;Now we have a chain of locations. Let’s write a search. Suppose you want to check if the vector contains the &lt;code&gt;:error&lt;/code&gt; keyword. First, let’s write a predicate for a location to know whether its node is equal to this value.&lt;/p&gt;
    &lt;code&gt;(defn loc-error? [loc]
  (-&amp;gt; loc zip/node (= :error)))
&lt;/code&gt;
    &lt;p&gt;Well, let’s check if there is one in the chain of locations that matches our predicate. To do this, call &lt;code&gt;some&lt;/code&gt;:&lt;/p&gt;
    &lt;code&gt;(def data [1 [2 3 [:test [:foo :error]]] 4])

(some loc-error?
      (-&amp;gt; data zip/vector-zip iter-zip))

;; true
&lt;/code&gt;
    &lt;p&gt;Note that due to laziness, we are not scanning the entire tree. If the required node appears in the middle, &lt;code&gt;iter-zip&lt;/code&gt; ends the iteration and stops making calls, and further &lt;code&gt;zip/next&lt;/code&gt; calls won’t happen.&lt;/p&gt;
    &lt;p&gt;It’s useful to know that &lt;code&gt;zip/next&lt;/code&gt; traverses a tree in depth-first order. As it moves, it tends to go down or to the right, but up only when steps in these directions return &lt;code&gt;nil&lt;/code&gt;. As we’ll see later, sometimes the traversal order is important. There’re tasks where we have to traverse in breadth-first order. There’re no other default options for traversal in &lt;code&gt;clojure.zip&lt;/code&gt;, but we can easily write
our own. We’ll look at a task that requires traversal in breadth later.&lt;/p&gt;
    &lt;p&gt;The built-in &lt;code&gt;vector-zip&lt;/code&gt; zipper is for nested vectors. But nested maps are much more common. Let’s write a zipper to traverse such data:&lt;/p&gt;
    &lt;code&gt;(def map-data
  {:foo 1
   :bar 2
   :baz {:test "hello"
         :word {:nested true}}})
&lt;/code&gt;
    &lt;p&gt;Let’s take the familiar vector-zip as a basis. These zippers are similar, the only difference is the collection type they work with. Let’s think about how to define functions that answer the questions. The map is a branch whose children are &lt;code&gt;MapEntry&lt;/code&gt; elements. This type represents a key-value pair. If the value is a map, we get a chain of nested &lt;code&gt;MapEntry&lt;/code&gt; from it and so on.&lt;/p&gt;
    &lt;p&gt;To warm up, let’s write a predicate for checking the &lt;code&gt;MapEntry&lt;/code&gt; type:&lt;/p&gt;
    &lt;code&gt;(def entry?
  (partial instance? clojure.lang.MapEntry))
&lt;/code&gt;
    &lt;p&gt;The &lt;code&gt;map-zip&lt;/code&gt; zipper looks like this:&lt;/p&gt;
    &lt;code&gt;(defn map-zip [mapping]
  (zip/zipper
   (some-fn entry? map?)
   (fn [x]
     (cond
       (map? x) (seq x)

       (and (entry? x)
            (-&amp;gt; x val map?))
       (-&amp;gt; x val seq)))
   nil
   mapping))
&lt;/code&gt;
    &lt;p&gt;Let’s discuss the main points. The &lt;code&gt;(some-fn ...)&lt;/code&gt; composition returns &lt;code&gt;true&lt;/code&gt; if one of the predicate-parameters works positively. In other words, we consider only the map or its entry (key-value pair) as a branch.&lt;/p&gt;
    &lt;p&gt;In the second function, which looks for children, we have to check some conditions. If the current value is a map, we return a sequence of map entries using the &lt;code&gt;seq&lt;/code&gt; function. If we are already in &lt;code&gt;MapEntry&lt;/code&gt;, then check if the value is a nested map. If it is, we should get its children with the same &lt;code&gt;seq&lt;/code&gt; function.&lt;/p&gt;
    &lt;p&gt;When traversing the tree, we’ll get all the key-value pairs. If the value is a nested dictionary, we’ll fall into it when traversing. Here is an example:&lt;/p&gt;
    &lt;code&gt;(-&amp;gt;&amp;gt; {:foo 42
      :bar {:baz 11
            :user/name "Ivan"}}
     map-zip
     iter-zip
     rest
     (map zip/node))

;; ([:foo 42]
;;  [:bar {:baz 11, :user/name "Ivan"}]
;;  [:baz 11]
;;  [:user/name "Ivan"])
&lt;/code&gt;
    &lt;p&gt;Notice the &lt;code&gt;rest&lt;/code&gt; function after &lt;code&gt;iter-zip&lt;/code&gt;. We skipped the first location that contains the original data. Since they are already known, their printing makes no sense.&lt;/p&gt;
    &lt;p&gt;Using our &lt;code&gt;map-zip&lt;/code&gt;, we can check if the map contains the &lt;code&gt;:error&lt;/code&gt; key with the &lt;code&gt;:auth&lt;/code&gt; value. Each of these keywords can be anywhere, both in keys and in values at any level. However, we are interested in their combination. To do this, let’s write a predicate:&lt;/p&gt;
    &lt;code&gt;(defn loc-err-auth? [loc]
  (-&amp;gt; loc zip/node (= [:error :auth])))
&lt;/code&gt;
    &lt;p&gt;Let’s make sure that there is no such pair in the first dictionary, even if the values appear separately:&lt;/p&gt;
    &lt;code&gt;(-&amp;gt;&amp;gt; {:response {:error :expired
                 :auth :failed}}
     map-zip
     iter-zip
     (some loc-err-auth?))

;; nil
&lt;/code&gt;
    &lt;p&gt;We’ll find this pair, even if it is deeply nested:&lt;/p&gt;
    &lt;code&gt;(def data
  {:response {:info {:message "Auth error"
                     :error :auth
                     :code 1005}}})

(-&amp;gt;&amp;gt; data
     map-zip
     iter-zip
     (some loc-err-auth?))

;; true
&lt;/code&gt;
    &lt;p&gt;Below are a few tasks for independent work.&lt;/p&gt;
    &lt;p&gt;1. The &lt;code&gt;map-zip&lt;/code&gt; zipper ignores the situation where the map key is another map.
For example:&lt;/p&gt;
    &lt;code&gt;{{:alg "MD5" :salt "***"} "deprecated"
{:alg "SHA2" :salt "****"} "deprecated"
{:alg "HMAC-SHA256" :key "xxx"} "ok"}
&lt;/code&gt;
    &lt;p&gt;Such collections, although rarely, are used sometimes. Modify &lt;code&gt;map-zip&lt;/code&gt; so that it checks not only the value of &lt;code&gt;MapEntry&lt;/code&gt; but also the key.&lt;/p&gt;
    &lt;p&gt;2. In practice, we work with a combination of vectors and maps. Write a universal zipper that takes into account both the map and the vector when traversing.&lt;/p&gt;
    &lt;head rend="h2"&gt;Part 3. XML zippers&lt;/head&gt;
    &lt;p&gt;The power of zippers is fully revealed when working with XML. Unlike other formats, it is specified recursively. For example, JSON, YAML, and other formats offer data types (numbers, strings, collections) with different syntax and structure. In XML, wherever we are, the current node always consists of three components: tag, attributes, and content. Content is a set of strings or other nodes. Here’s a recursive pseudocode notation:&lt;/p&gt;
    &lt;code&gt;XML = [Tag, Attrs, [String|XML]]
&lt;/code&gt;
    &lt;p&gt;To make sure the XML is homogeneous, consider an abstract file with vendor items:&lt;/p&gt;
    &lt;code&gt;&amp;lt;?xml version="1.0" encoding="UTF-8"?&amp;gt;
&amp;lt;catalog&amp;gt;
  &amp;lt;organization name="re-Store"&amp;gt;
    &amp;lt;product type="iphone"&amp;gt;iPhone 11 Pro&amp;lt;/product&amp;gt;
    &amp;lt;product type="iphone"&amp;gt;iPhone SE&amp;lt;/product&amp;gt;
  &amp;lt;/organization&amp;gt;
  &amp;lt;organization name="DNS"&amp;gt;
    &amp;lt;product type="tablet"&amp;gt;iPad 3&amp;lt;/product&amp;gt;
    &amp;lt;product type="notebook"&amp;gt;Macbook Pro&amp;lt;/product&amp;gt;
  &amp;lt;/organization&amp;gt;
&amp;lt;/catalog&amp;gt;
&lt;/code&gt;
    &lt;p&gt;At the top of the XML is the &lt;code&gt;catalog&lt;/code&gt; node. It’s just a grouping tag; we need it because there can’t be multiple tags at the top. The &lt;code&gt;catalog&lt;/code&gt; children are organizations. The &lt;code&gt;name&lt;/code&gt; attribute of the organization contains its name. Products are under the organization. A product is a node with a &lt;code&gt;product&lt;/code&gt; tag and a description of the product type. Instead of children, it has text content — its description. It’s impossible to go down below a product.&lt;/p&gt;
    &lt;p&gt;Clojure offers an XML parser that returns a structure similar to the &lt;code&gt;[Tag, Attrs, Content]&lt;/code&gt; schema above. Each node becomes a map with the keys :tag, :attrs, and &lt;code&gt;:content&lt;/code&gt;. The &lt;code&gt;:content&lt;/code&gt; key stores a vector where an element is either a string or a nested map.&lt;/p&gt;
    &lt;p&gt;We put the XML data with products in the &lt;code&gt;resources/products.xml&lt;/code&gt; file. Let’s write a function to parse a file into an XML zipper. Add module imports:&lt;/p&gt;
    &lt;code&gt;(:require
 [clojure.java.io :as io]
 [clojure.xml :as xml])
&lt;/code&gt;
    &lt;p&gt;Both come with Clojure and therefore do not require dependencies. To get the zipper, we pass the &lt;code&gt;path&lt;/code&gt; parameter through a series of functions:&lt;/p&gt;
    &lt;code&gt;(defn -&amp;gt;xml-zipper [path]
  (-&amp;gt; path
      io/resource
      io/file
      xml/parse
      zip/xml-zip))
&lt;/code&gt;
    &lt;p&gt;The &lt;code&gt;xml/parse&lt;/code&gt; function should return a nested structure consisting of maps with keys &lt;code&gt;: tag&lt;/code&gt;,
&lt;code&gt;:attrs&lt;/code&gt;, and &lt;code&gt;:content&lt;/code&gt;. Note that text content such as a product name, is also a vector with one string. This achieves the homogeneity of each node.&lt;/p&gt;
    &lt;p&gt;This is what we should get after calling &lt;code&gt;xml/parse&lt;/code&gt;:&lt;/p&gt;
    &lt;code&gt;{:tag :catalog
 :attrs nil
 :content
 [{:tag :organization
   :attrs {:name "re-Store"}
   :content
   [{:tag :product
     :attrs {:type "iphone"}
     :content ["iPhone 11 Pro"]}
    {:tag :product :attrs {:type "iphone"} :content ["iPhone SE"]}]}
  {:tag :organization
   :attrs {:name "DNS"}
   :content
   [{:tag :product :attrs {:type "tablet"} :content ["iPad 3"]}
    {:tag :product
     :attrs {:type "notebook"}
     :content ["Macbook Pro"]}]}]}
&lt;/code&gt;
    &lt;p&gt;The call of &lt;code&gt;(-&amp;gt;xml-zipper "products.xml")&lt;/code&gt; creates the initial location of the XML zipper from the data above. First, let’s take a look at the definition of &lt;code&gt;xml-zip&lt;/code&gt; to understand how it works. Here we present code excerpts:&lt;/p&gt;
    &lt;code&gt;(defn xml-zip
  [root]
  (zipper (complement string?)
          (comp seq :content)
          ...
          root))
&lt;/code&gt;
    &lt;p&gt;As you might guess, the children of the node are its &lt;code&gt;:content&lt;/code&gt;, additionally wrapped in &lt;code&gt;seq&lt;/code&gt;. A string can’t have children, so &lt;code&gt;(complement string?)&lt;/code&gt; means — search for children only in non-string nodes.&lt;/p&gt;
    &lt;p&gt;Look at how we would find all products from a given XML. First, let’s get a lazy iteration over its zipper. Recall that at each step we get not a map with &lt;code&gt;:tag&lt;/code&gt; and other fields, but a zip location with a pointer to it. It remains only to filter out the locations which nodes contain the product tag. To do this let’s write a predicate:&lt;/p&gt;
    &lt;code&gt;(defn loc-product? [loc]
  (-&amp;gt; loc zip/node :tag (= :product)))
&lt;/code&gt;
    &lt;p&gt;And let’s write a transforming selection:&lt;/p&gt;
    &lt;code&gt;(-&amp;gt;&amp;gt; "products.xml"
     -&amp;gt;xml-zipper
     iter-zip
     (filter loc-product?)
     (map loc-&amp;gt;product))

;; ("iPhone 11 Pro" "iPhone SE" "iPad 3" "Macbook Pro")
&lt;/code&gt;
    &lt;p&gt;At first glance, there is nothing special here. The XML structure is known in advance, so we can do it without zipper. Let’s select catalog children and get organizations, then we’ll get organizations’ children (i.e., goods). Here’s this simple code:&lt;/p&gt;
    &lt;code&gt;(def xml-data
  (-&amp;gt; "products.xml"
      io/resource
      io/file
      xml/parse))

(def orgs
  (:content xml-data))

(def products
  (mapcat :content orgs))

(def product-names
  (mapcat :content products))
&lt;/code&gt;
    &lt;p&gt;To make the code more concise, you can remove the intermediate variables and narrow it down to one form:&lt;/p&gt;
    &lt;code&gt;(-&amp;gt;&amp;gt; "products.xml"
     io/resource
     io/file
     xml/parse
     :content
     (mapcat :content)
     (mapcat :content))

;; ("iPhone 11 Pro" "iPhone SE" "iPad 3" "Macbook Pro")
&lt;/code&gt;
    &lt;p&gt;In practice, the structure of XML always changes. Suppose a super-large dealer breaks down products by branch. In this case, the XML looks like this (a snippet):&lt;/p&gt;
    &lt;code&gt;&amp;lt;organization name="DNS"&amp;gt;
  &amp;lt;branch name="Office 1"&amp;gt;
    &amp;lt;product type="tablet"&amp;gt;iPad 3&amp;lt;/product&amp;gt;
    &amp;lt;product type="notebook"&amp;gt;Macbook Pro&amp;lt;/product&amp;gt;
  &amp;lt;/branch&amp;gt;
  &amp;lt;branch name="Office 2"&amp;gt;
    &amp;lt;product type="tablet"&amp;gt;iPad 4&amp;lt;/product&amp;gt;
    &amp;lt;product type="phone"&amp;gt;Samsung A6+&amp;lt;/product&amp;gt;
  &amp;lt;/branch&amp;gt;
&amp;lt;/organization&amp;gt;
&lt;/code&gt;
    &lt;p&gt;The above code that selected data only by level won’t work anymore. If we run it against the new XML, we’ll get a branch node along with the products:&lt;/p&gt;
    &lt;code&gt;("iPhone 11 Pro"
 "iPhone SE"
 {:tag :product, :attrs {:type "tablet"}, :content ["iPad 3"]} ...)
&lt;/code&gt;
    &lt;p&gt;If we used a zipper, it would return only products, including those from the branch:&lt;/p&gt;
    &lt;code&gt;(-&amp;gt;&amp;gt; "products-branch.xml"
     -&amp;gt;xml-zipper
     iter-zip
     (filter loc-product?)
     (map loc-&amp;gt;product))

("iPhone 11 Pro" "iPhone SE" "iPad 3" "Macbook Pro" "iPad 4" "Samsung A6+")
&lt;/code&gt;
    &lt;p&gt;Obviously, it’s beneficial to use code that works with both XML rather than maintaining a separate version for a large dealer. In the latter case, you have to store the flag, which supplier is normal and which is large, and promptly update it.&lt;/p&gt;
    &lt;p&gt;However, this example doesn’t cover the full capacity of the zippers. The &lt;code&gt;xml-seq&lt;/code&gt; function from the core Clojure module also provides XML traversal. The function returns a lazy sequence of XML nodes in the same form (a map with &lt;code&gt;:tag&lt;/code&gt;, &lt;code&gt;:attr&lt;/code&gt;, and &lt;code&gt;:content&lt;/code&gt;). &lt;code&gt;Xml-seq&lt;/code&gt; is a special case of the more abstract &lt;code&gt;tree-seq&lt;/code&gt; function. The latter is similar to a zipper in that it takes similar functions to determine if a node can be a branch and how to get its children. As you can see from the code, the &lt;code&gt;xml-seq&lt;/code&gt; and &lt;code&gt;xml-zip&lt;/code&gt; definitions are similar:&lt;/p&gt;
    &lt;code&gt;(defn xml-seq
  [root]
  (tree-seq
    (complement string?)
    (comp seq :content)
    root))
&lt;/code&gt;
    &lt;p&gt;The difference between a zipper and &lt;code&gt;tree-seq&lt;/code&gt; is that when iterating, the zipper returns a location — a more abstract and more informative element. Instead, &lt;code&gt;tree-seq&lt;/code&gt; produces unwrapped elements during iteration. For ordinary searches, &lt;code&gt;tree-seq&lt;/code&gt; is even preferable, since it doesn’t generate unnecessary abstractions. The selection of goods, taking into account branches, looks like this:&lt;/p&gt;
    &lt;code&gt;(defn node-product? [node]
  (some-&amp;gt; node :tag (= :product)))

(-&amp;gt;&amp;gt; "products-branch.xml"
     io/resource
     io/file
     xml/parse
     xml-seq
     (filter node-product?)
     (mapcat :content))

("iPhone 11 Pro" "iPhone SE" "iPad 3" "Macbook Pro" "iPad 4" "Samsung A6+")
&lt;/code&gt;
    &lt;p&gt;To get back to zippers, let’s pick a problem where &lt;code&gt;tree-seq&lt;/code&gt; loses its benefits. Manual search can be such a task.&lt;/p&gt;
    &lt;head rend="h2"&gt;Part 4. XML search&lt;/head&gt;
    &lt;p&gt;Let’s say we need to select the stores that sell iPhones from an XML with products. Note: this is the first time we’ve touched on the relationship between nodes. That’s important! It’s easy to select the data individually. Shops are locations that have the &lt;code&gt;organization&lt;/code&gt; tag. iPhones are locations that have a node with the &lt;code&gt;product&lt;/code&gt; tag and the &lt;code&gt;type="tablet"&lt;/code&gt; attribute. But how to find a relationship between them?&lt;/p&gt;
    &lt;p&gt;The previous time, we decomposed the XML into a sequence using &lt;code&gt;xml-seq&lt;/code&gt;. The problem is that the function returns a collection of nodes with no relationship, which prevents us from solving our task. Let’s show this with an example: First, let’s get a chain of nodes:&lt;/p&gt;
    &lt;code&gt;(def xml-nodes
  (-&amp;gt;&amp;gt; "products-branch.xml"
     io/resource
     io/file
     xml/parse
     xml-seq))
&lt;/code&gt;
    &lt;p&gt;Let’s say the product we want is in one of the elements. For example, we’ll find an iPhone in the third (second from zero) node:&lt;/p&gt;
    &lt;code&gt;(-&amp;gt; xml-nodes (nth 2))
;; {:tag :product :attrs {:type "iphone"} :content ["iPhone 11 Pro"]}
&lt;/code&gt;
    &lt;p&gt;However, it is difficult to find out which store it is from. You can guess that the store is to the left of the product, because when traversing the tree, it precedes the product. This becomes clear if you print the node tags:&lt;/p&gt;
    &lt;code&gt;(-&amp;gt;&amp;gt; xml-nodes (mapv :tag) (remove nil?) (run! print))
;; :catalog :organization :product :product :organization ...
&lt;/code&gt;
    &lt;p&gt;This is a more or less correct assumption, but you shouldn’t rely on it too much because the result depends on the XML traversal order. In addition, solving the problem becomes more complicated. When traversing, you need not only to select the desired products but also to move back in search of a store. Then you will have to move forward again, skipping the found product, otherwise, you’ll find yourself in an infinite loop. This approach is stateful and works well in imperative languages but not in Clojure.&lt;/p&gt;
    &lt;p&gt;This is where a zipper comes in. A location, which it returns at each step, remembers its position in the structure. This means that we can navigate from the location to the required place using the functions &lt;code&gt;zip/up&lt;/code&gt;, &lt;code&gt;zip/right&lt;/code&gt;, and others, which we discussed in the first part. In this case, the use of manual navigation is reasonable.&lt;/p&gt;
    &lt;p&gt;Let’s go back to XML with a simple catalog-organization-products structure. Let’s refresh it in memory.&lt;/p&gt;
    &lt;code&gt;&amp;lt;?xml version="1.0" encoding="UTF-8"?&amp;gt;
&amp;lt;catalog&amp;gt;
  &amp;lt;organization name="re-Store"&amp;gt;
    &amp;lt;product type="iphone"&amp;gt;iPhone 11 Pro&amp;lt;/product&amp;gt;
    &amp;lt;product type="iphone"&amp;gt;iPhone SE&amp;lt;/product&amp;gt;
  &amp;lt;/organization&amp;gt;
  &amp;lt;organization name="DNS"&amp;gt;
    &amp;lt;product type="tablet"&amp;gt;iPad 3&amp;lt;/product&amp;gt;
    &amp;lt;product type="notebook"&amp;gt;Macbook Pro&amp;lt;/product&amp;gt;
  &amp;lt;/organization&amp;gt;
&amp;lt;/catalog&amp;gt;
&lt;/code&gt;
    &lt;p&gt;First of all, let’s find iPhones-locations and write the predicate for the iPhone:&lt;/p&gt;
    &lt;code&gt;(defn loc-iphone? [loc]
  (let [node (zip/node loc)]
    (and (-&amp;gt; node :tag (= :product))
         (-&amp;gt; node :attrs :type (= "iphone")))))
&lt;/code&gt;
    &lt;p&gt;Get locations with iPhones:&lt;/p&gt;
    &lt;code&gt;(def loc-iphones
  (-&amp;gt;&amp;gt; "products.xml"
       -&amp;gt;xml-zipper
       iter-zip
       (filter loc-iphone?)))

(count loc-iphones)
2
&lt;/code&gt;
    &lt;p&gt;Now, to find an organization by the product, just go up one level using &lt;code&gt;zip/up&lt;/code&gt;. This is true because the organization is the parent of the product:&lt;/p&gt;
    &lt;code&gt;(def loc-orgs
  (-&amp;gt;&amp;gt; loc-iphones
       (map zip/up)
       (map (comp :attrs zip/node))))

({:name "re-Store"} {:name "re-Store"})
&lt;/code&gt;
    &lt;p&gt;For each iPhone, we should get the organization that sells it. We got duplicates because both iPhones are sold in the re:Store shop. To make the result unique, wrap it in &lt;code&gt;set&lt;/code&gt;.&lt;/p&gt;
    &lt;code&gt;
(set loc-orgs)
#{{:name "re-Store"}}

&lt;/code&gt;
    &lt;p&gt;This is the answer to the question: iPhones can be bought at re:Store. If you add an iPhone to the DNS organization, the latter also appears in &lt;code&gt;loc-orgs&lt;/code&gt;.&lt;/p&gt;
    &lt;p&gt;Let’s solve the same problem for XML with branches. Now we can’t call &lt;code&gt;zip/up&lt;/code&gt; on a product to get the organization, because in some cases we’ll get a branch and it will take one more step up. In order not to guess how many steps to take up, let’s write the function &lt;code&gt;loc-&amp;gt;org&lt;/code&gt;. It’ll step up until we find the required tag:&lt;/p&gt;
    &lt;code&gt;(defn loc-org? [loc]
  (-&amp;gt; loc zip/node :tag (= :organization)))

(defn loc-&amp;gt;org [loc]
  (-&amp;gt;&amp;gt; loc
       (iterate zip/up)
       (find-first loc-org?)))
&lt;/code&gt;
    &lt;p&gt;The &lt;code&gt;find-first&lt;/code&gt; utility function finds the first collection element that matches the predicate. We’ll use this function more than once.&lt;/p&gt;
    &lt;code&gt;(defn find-first [pred coll]
  (some (fn [x]
          (when (pred x)
            x))
        coll))
&lt;/code&gt;
    &lt;p&gt;To shorten the code, we won’t declare the variables &lt;code&gt;loc-iphones&lt;/code&gt; and others. Let’s express the search in one form:&lt;/p&gt;
    &lt;code&gt;(-&amp;gt;&amp;gt; "products-branch.xml"
     -&amp;gt;xml-zipper
     iter-zip
     (filter loc-iphone?)
     (map loc-&amp;gt;org)
     (map (comp :attrs zip/node))
     (set))
&lt;/code&gt;
    &lt;p&gt;In the new solution, we have replaced &lt;code&gt;zip/up&lt;/code&gt; with a function of a more complex climbing algorithm. Otherwise, nothing has changed.&lt;/p&gt;
    &lt;p&gt;Notice how convenient XML is for searching and navigating. If we store data in JSON, it is a combination of lists and dictionaries, and the versions with and without branches are different.&lt;/p&gt;
    &lt;p&gt;Here are products without branch stores:&lt;/p&gt;
    &lt;code&gt;[{"name": "re-Store",
  "products": [{"type": "iphone", "name": "iPhone 11 Pro"},
               {"type": "iphone", "name": "iPhone SE"}]},
 {"name": "DNS",
  "products": [{"type": "tablet", "name": "iPad 3"},
               {"type": "notebook", "name": "Macbook Pro"}]}]
&lt;/code&gt;
    &lt;p&gt;Here are products with them:&lt;/p&gt;
    &lt;code&gt;[{"name": "re-Store",
  "products": [{"type": "iphone", "name": "iPhone 11 Pro"},
               {"type": "iphone", "name": "iPhone SE"}]},
 {"name": "DNS",
  "branches": [{"name": "Office 1",
                "products": [{"type": "tablet", "name": "iPad 3"},
                             {"type": "notebook", "name": "Macbook Pro"}]},
               {"name": "Office 2",
                "products": [{"type": "tablet", "name": "iPad 3"},
                             {"type": "notebook", "name": "Macbook Pro"}]}]}]
&lt;/code&gt;
    &lt;p&gt;It goes without saying that traversing these structures requires different code. In the case of XML, its structure is homogeneous: adding a branch only changes the depth of goods nesting, but the traversal rules remain unchanged.&lt;/p&gt;
    &lt;p&gt;Let’s complicate the problem requirements: there’re bundles of products among individual ones. A bundle product can’t be purchased separately. For example, screen cleaning wipes are usually sold with the device. They ask us to find a store where a wipe is sold separately.&lt;/p&gt;
    &lt;p&gt;Here is an example:&lt;/p&gt;
    &lt;code&gt;&amp;lt;?xml version="1.0" encoding="UTF-8"?&amp;gt;
&amp;lt;catalog&amp;gt;
  &amp;lt;organization name="re-Store"&amp;gt;
    &amp;lt;product type="fiber"&amp;gt;VIP Fiber Plus&amp;lt;/product&amp;gt;
    &amp;lt;product type="iphone"&amp;gt;iPhone 11 Pro&amp;lt;/product&amp;gt;
  &amp;lt;/organization&amp;gt;
  &amp;lt;organization name="DNS"&amp;gt;
    &amp;lt;branch name="Office 2"&amp;gt;
      &amp;lt;bundle&amp;gt;
        &amp;lt;product type="fiber"&amp;gt;Premium iFiber&amp;lt;/product&amp;gt;
        &amp;lt;product type="iphone"&amp;gt;iPhone 11 Pro&amp;lt;/product&amp;gt;
      &amp;lt;/bundle&amp;gt;
    &amp;lt;/branch&amp;gt;
  &amp;lt;/organization&amp;gt;
&amp;lt;/catalog&amp;gt;
&lt;/code&gt;
    &lt;p&gt;As an exercise let’s find all the wipes. Among them will be both individual products and a set.&lt;/p&gt;
    &lt;code&gt;(defn loc-fiber? [loc]
  (some-&amp;gt; loc zip/node :attrs :type (= "fiber")))

(-&amp;gt;&amp;gt; "products-bundle.xml"
     -&amp;gt;xml-zipper
     iter-zip
     (filter loc-fiber?)
     (map (comp first :content zip/node)))

("VIP Fiber Plus" "Premium iFiber")
&lt;/code&gt;
    &lt;p&gt;Let’s start solving the problem. First, we find all the wipes as we did above. Then we cut off those that are included in the bundle. In terms of a zipper, this means that this location’s parent doesn’t have the &lt;code&gt;:bundle&lt;/code&gt; tag. After that, we move on from the rest wipes to stores.&lt;/p&gt;
    &lt;p&gt;The &lt;code&gt;loc-in-bundle?&lt;/code&gt; predicate checks if a location is included in the bundle:&lt;/p&gt;
    &lt;code&gt;(defn loc-in-bundle? [loc]
  (some-&amp;gt; loc zip/up zip/node :tag (= :bundle)))
&lt;/code&gt;
    &lt;p&gt;The final solution:&lt;/p&gt;
    &lt;code&gt;(-&amp;gt;&amp;gt; "products-bundle.xml"
     -&amp;gt;xml-zipper
     iter-zip
     (filter loc-fiber?)
     (remove loc-in-bundle?)
     (map loc-&amp;gt;org)
     (map (comp :attrs zip/node))
     (set))


#{{:name "re-Store"}}

&lt;/code&gt;
    &lt;p&gt;The DNS store wasn’t included in the result because it sells wipes in a bundle only.&lt;/p&gt;
    &lt;p&gt;New complication: we want to buy an iPhone, but only in a bundle with a wipe. Which store should you direct a buyer to?&lt;/p&gt;
    &lt;p&gt;Solution: First, look for all iPhones. Select only those that present in a bundle. Next, we are looking for a wipe among the neighbors of the iPhone. If you find it, go up to the store from the iPhone or the wipe. Most of the functions required for this search are ready: these are predicates for checking a bundle, product type, and other small things. But we have not yet considered how to get the neighbors of the location.&lt;/p&gt;
    &lt;p&gt;The functions &lt;code&gt;zip/lefts&lt;/code&gt; and &lt;code&gt;zip/rights&lt;/code&gt; return the nodes to the left and right of the current location. If we &lt;code&gt;concat&lt;/code&gt; them, we get all the neighbors (also called peers):&lt;/p&gt;
    &lt;code&gt;(defn node-neighbors [loc]
  (concat (zip/lefts loc)
          (zip/rights loc)))
&lt;/code&gt;
    &lt;p&gt;Note: These are nodes, not locations. Let’s make a quick check with a vector:&lt;/p&gt;
    &lt;code&gt;(-&amp;gt; [1 2 3]
    zip/vector-zip
    zip/down
    zip/right ;; node 2
    node-neighbors)

;; (1 3)
&lt;/code&gt;
    &lt;p&gt;The zipper is designed in such a way that getting the right and left nodes is easier than moving the location to the left or right. Therefore, when looking for neighbors, it is better to work with nodes (values) rather than locations.&lt;/p&gt;
    &lt;p&gt;Let’s add functions to check if there is a wipe that is adjacent to the location:&lt;/p&gt;
    &lt;code&gt;(defn node-fiber? [node]
  (some-&amp;gt; node :attrs :type (= "fiber")))

(defn with-fiber? [loc]
  (let [nodes (node-neighbors loc)]
    (find-first node-fiber? nodes)))
&lt;/code&gt;
    &lt;p&gt;Here’s the final expression:&lt;/p&gt;
    &lt;code&gt;(-&amp;gt;&amp;gt; "products-bundle.xml"
     -&amp;gt;xml-zipper
     iter-zip
     (filter loc-iphone?)
     (filter loc-in-bundle?)
     (filter with-fiber?)
     (map loc-&amp;gt;org)
     (map (comp :name :attrs zip/node))
     (set))

;; #{"DNS"}
&lt;/code&gt;
    &lt;p&gt;As a result, we get the DNS store, because it sells the bundles including an iPhone and a wipe. Both of these products are available in re:Store, but separately. It doesn’t suit us. If we replace a wipe with a headset in the bundle, we’ll get no store.&lt;/p&gt;
    &lt;p&gt;Finally, we can add new constraints. For example, from the found stores, select those that are located within a radius of 300 meters from the customer. To do this, we need the store locations on the map and a function checking if a point is inside a circle. You can choose only open stores or those that offer delivery. Let’s write these features into the attributes of organizations and add selection functions.&lt;/p&gt;
    &lt;p&gt;Our XML zipper has become like a database. It provides answers to complex queries, and at the same time, the code grows slower than the semantic load. Because of its regular structure, XML is highly traversable, and zippers further enhance this property. Pay attention to the convenient transitions and relationships between nodes. Imagine the effort it took to split the data into tables and build SQL queries with many JOINs.&lt;/p&gt;
    &lt;p&gt;Of course, compared to a true database, XML has a drawback: it has no indexes and only a linear search works in it, not a binary tree one. Besides, in our approach, all data is in memory. It won’t work well for very large documents with millions of records, but we don’t care about that yet.&lt;/p&gt;
    &lt;head rend="h2"&gt;Part 5. Editing&lt;/head&gt;
    &lt;p&gt;So far, we’ve ignored another zipper possibility. During the traversal, you can not only parse but also change locations. In broad terms, all CRUD (Create, Read, Update, Delete) operations familiar from web development are available to us. Below we’ll discuss how they work in zippers.&lt;/p&gt;
    &lt;p&gt;As you remember, a zipper accepts a third function — &lt;code&gt;make-node&lt;/code&gt;. Until now, we’ve passed &lt;code&gt;nil&lt;/code&gt; to it. We didn’t use it because we only read the data. The zipper will call the function when we ask to return the data with the changes made to the locations. The function takes two parameters: a branch and children. Its task is to relate them in the way it is customary in a tree.&lt;/p&gt;
    &lt;p&gt;For simple collections like a vector, the function is simple. It only wraps the children in &lt;code&gt;vec&lt;/code&gt; to get a vector from the sequence. In &lt;code&gt;vector-zip&lt;/code&gt;, the function is a little more complex because it takes metadata into account. Here is the entire code of this zipper.&lt;/p&gt;
    &lt;code&gt;(defn vector-zip
  [root]
  (zipper vector?
          seq
          (fn [node children]
            (with-meta (vec children) (meta node)))
          root))
&lt;/code&gt;
    &lt;p&gt;You see that the new vector (form &lt;code&gt;(vec children)&lt;/code&gt;) copies the metadata of the old vector (variable &lt;code&gt;node&lt;/code&gt;). If you supplement the original with &lt;code&gt;assoc&lt;/code&gt; or &lt;code&gt;conj&lt;/code&gt;, the metadata is preserved. In the case of &lt;code&gt;vector-zip&lt;/code&gt;, we are building a new vector,  so we wrap it in &lt;code&gt;with-meta&lt;/code&gt;. If we remove &lt;code&gt;with-meta&lt;/code&gt;, the output will be a vector with no metadata, which may affect the program logic.&lt;/p&gt;
    &lt;p&gt;The XML zipper has a slightly different build: the children are in the &lt;code&gt;:content&lt;/code&gt; field.&lt;/p&gt;
    &lt;code&gt;(fn [node children]
  (assoc node :content (and children (apply vector children))))
&lt;/code&gt;
    &lt;p&gt;For our zipper &lt;code&gt;map-zip&lt;/code&gt; that we developed at the beginning, the build function would look like &lt;code&gt;assoc&lt;/code&gt; or &lt;code&gt;into&lt;/code&gt; with a collection of &lt;code&gt;MapEntry&lt;/code&gt; pairs.&lt;/p&gt;
    &lt;p&gt;The zipper implicitly calls this function if it finds modified nodes. The functions &lt;code&gt;zip/edit&lt;/code&gt;,  &lt;code&gt;zip/replace&lt;/code&gt;, and others are used to modify. Before looking at them, let’s discuss exactly how the modification occurs inside zippers.&lt;/p&gt;
    &lt;p&gt;The changes are specific because they affect locations, not the source data. After you have worked with a location, it is marked with the &lt;code&gt;:changed?&lt;/code&gt; flag. It is a signal to data re-building using the &lt;code&gt;zip/root&lt;/code&gt; function, which we will discuss later.&lt;/p&gt;
    &lt;p&gt;Let’s look at an example with the vector &lt;code&gt;[1 2 3]&lt;/code&gt;. Move to 2 and double it using the &lt;code&gt;zip/edit&lt;/code&gt; function. It takes a location, a function, and residual arguments.
You are familiar with this approach from topics about atoms (&lt;code&gt;swap!&lt;/code&gt;) and collections (&lt;code&gt;update&lt;/code&gt;). By analogy with them, a location will receive a new value, which the function calculated based on the previous one.&lt;/p&gt;
    &lt;p&gt;Here’s the location before changes:&lt;/p&gt;
    &lt;code&gt;(-&amp;gt; [1 2 3]
    zip/vector-zip
    zip/down
    zip/right)

[2 {:l [1] :pnodes [[1 2 3]] :ppath nil :r (3)}]
&lt;/code&gt;
    &lt;p&gt;Now, it’s the location after the changes: Pay attention to the &lt;code&gt;:changed?&lt;/code&gt; key:&lt;/p&gt;
    &lt;code&gt;(def loc-2
  (-&amp;gt; [1 2 3]
      zip/vector-zip
      zip/down
      zip/right
      (zip/edit * 2)))

[4 {:l [1] :pnodes [[1 2 3]] :ppath nil :r (3)
    :changed? true}]
&lt;/code&gt;
    &lt;p&gt;Next, we would like to get the modified vector &lt;code&gt;[1 4 3]&lt;/code&gt;. Let’s do it manually:&lt;/p&gt;
    &lt;code&gt;(-&amp;gt; loc-2
    zip/up
    zip/node)

;; [1 4 3]
&lt;/code&gt;
    &lt;p&gt;The &lt;code&gt;zip/root&lt;/code&gt; function accepts the location with changes and does the same. Its algorithm looks like this:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;ascend to the root location;&lt;/item&gt;
      &lt;item&gt;return a node.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;To get the result in one pass, add &lt;code&gt;zip/root&lt;/code&gt; to the end of the threading macro:&lt;/p&gt;
    &lt;code&gt;(-&amp;gt; [1 2 3]
    zip/vector-zip
    zip/down
    zip/right
    (zip/edit * 2)
    zip/root)

;; [1 4 3]
&lt;/code&gt;
    &lt;p&gt;The &lt;code&gt;zip/up&lt;/code&gt; function, which we called either manually or implicitly in &lt;code&gt;zip/root&lt;/code&gt;, does the bulk of the work. When going up, it checks if the location has been changed, and if so, rebuilds it with &lt;code&gt;make-node&lt;/code&gt;. Here’s a snippet of its code:&lt;/p&gt;
    &lt;code&gt;(defn up
  [loc]
  (let [[node {... changed? :changed? :as path}] loc]
    (when pnodes
      (let [pnode (peek pnodes)]
        (with-meta (if changed?
                     [(make-node loc pnode (concat l ...))
                      (and ppath (assoc ...))]
                     [pnode ppath])
                   (meta loc))))))
&lt;/code&gt;
    &lt;head rend="h3"&gt;Multiple change&lt;/head&gt;
    &lt;p&gt;When changing one location, problems usually don’t arise. However, we rarely modify a single location. In practice, we do it in a batch depending on some conditions.&lt;/p&gt;
    &lt;p&gt;Previously, we decomposed the zipper into a sequence of locations using &lt;code&gt;iter-zip&lt;/code&gt;, and then passed it through a series of &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;filter&lt;/code&gt;, and other functions. This method isn’t suitable when editing. For example, we selected the second item from the &lt;code&gt;zip-iter&lt;/code&gt; result and modified it:&lt;/p&gt;
    &lt;code&gt;(def loc-seq
  (-&amp;gt; [1 2 3]
      zip/vector-zip
      iter-zip))

(-&amp;gt; loc-seq (nth 2) (zip/edit * 2))

;; [4 {:l [1] :pnodes [[1 2 3]] :ppath nil :r (3)
;;    :changed? true}]
&lt;/code&gt;
    &lt;p&gt;Zippers themselves are immutable, and any action will return a new location. At the same time, the &lt;code&gt;zip-iter&lt;/code&gt; function is designed so that each next location is obtained from the previous one. Calling &lt;code&gt;zip/edit&lt;/code&gt; on one of the elements will not affect subsequent ones. If we go up from the last location, we get the vector unchanged, even if we have edited some locations in the middle before.&lt;/p&gt;
    &lt;code&gt;(-&amp;gt; loc-seq last zip/up zip/node)
;; [1 2 3]
&lt;/code&gt;
    &lt;p&gt;The following patterns are used when editing zippers.&lt;/p&gt;
    &lt;p&gt;One element changes. In this case, we iterate through the zipper until we meet the required location in the chain. Then we change it and call &lt;code&gt;zip/root&lt;/code&gt;.&lt;/p&gt;
    &lt;p&gt;Many elements change. With &lt;code&gt;loop&lt;/code&gt; and &lt;code&gt;zip/next&lt;/code&gt; we manually iterate through the zipper. In this case, the specified function either changes the location or leaves it intact. The &lt;code&gt;recur&lt;/code&gt; form gets &lt;code&gt;zip/next&lt;/code&gt; from the function result. So if there were changes, &lt;code&gt;zip/next&lt;/code&gt; will work with the new location, not the previous one.&lt;/p&gt;
    &lt;p&gt;The following functions can change locations:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;zip/replace&lt;/code&gt;is a literal replacement of the current node with another;&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;zip/edit&lt;/code&gt;is a more flexible node replacement. Similar to&lt;code&gt;update&lt;/code&gt;and&lt;code&gt;swap!&lt;/code&gt;it takes a function and additional arguments. The current node is the first argument of the function. The result will replace the location content;&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;zip/remove&lt;/code&gt;deletes a location and moves the pointer to the parent.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Functions for inserting neighbors or children:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;zip/insert-left&lt;/code&gt;adds a neighbor to the left of the current location;&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;zip/insert-right&lt;/code&gt;adds a neighbor to the right;&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;zip/insert-child&lt;/code&gt;adds a child to the beginning of the current location;&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;zip/append-child&lt;/code&gt;adds a child to the end.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Neighbors and children differ in hierarchy. The neighbor appears on the same level as the location, and the child appears below. In the center of the diagram is the location with the vector &lt;code&gt;[2 3]&lt;/code&gt;. Its neighbors are numbers 1 and 4, and its children are 2 and 3.&lt;/p&gt;
    &lt;code&gt;

                ┌─────────────┐
                │ [1 [2 3] 4] │
                └─────────────┘
                       ▲
                       │
    ┌───────┐    ┏━━━━━━━━━━━┓    ┌───────┐
    │   1   │◀───┃   [2 3]   ┃───▶│   4   │
    └───────┘    ┗━━━━━━━━━━━┛    └───────┘
                       │
                 ┌─────┴─────┐
                 ▼           ▼
             ┌───────┐   ┌───────┐
             │   2   │   │   3   │
             └───────┘   └───────┘

&lt;/code&gt;
    &lt;p&gt;Let’s look at these functions with simple examples. Suppose there is the key &lt;code&gt;:error&lt;/code&gt; deep in the nested vectors. You need to change this to &lt;code&gt;:ok&lt;/code&gt;. First, let’s add a predicate for the search:&lt;/p&gt;
    &lt;code&gt;(defn loc-error? [loc]
  (some-&amp;gt; loc zip/node (= :error)))
&lt;/code&gt;
    &lt;p&gt;Now, we’ll find the location, fix it and go up to the root:&lt;/p&gt;
    &lt;code&gt;(def data [1 2 [3 4 [5 :error]]])

(def loc-error
  (-&amp;gt;&amp;gt; data
       zip/vector-zip
       iter-zip
       (find-first loc-error?)))

(-&amp;gt; loc-error
    (zip/replace :ok)
    zip/root)

;; [1 2 [3 4 [5 :ok]]]
&lt;/code&gt;
    &lt;p&gt;Another example: change all &lt;code&gt;nil&lt;/code&gt; items to &lt;code&gt;0&lt;/code&gt; in the nested vector to make the math safe. This time there may be more than one location, so a traversal through the &lt;code&gt;loop&lt;/code&gt; is required. At each step, we check if the location matches the condition, and if so, we pass the &lt;code&gt;zip/next&lt;/code&gt; call from the modified version to &lt;code&gt;recur&lt;/code&gt;:&lt;/p&gt;
    &lt;code&gt;(def data [1 2 [5 nil 2 [3 nil]] nil 1])

(loop [loc (zip/vector-zip data)]
  (if (zip/end? loc)
    (zip/node loc)
    (if (-&amp;gt; loc zip/node nil?)
      (recur (zip/next (zip/replace loc 0)))
      (recur (zip/next loc)))))

;; [1 2 [5 0 2 [3 0]] 0 1]
&lt;/code&gt;
    &lt;p&gt;Do the same, but replace all negative numbers modulo. First, let’s declare the &lt;code&gt;abs&lt;/code&gt; function:&lt;/p&gt;
    &lt;code&gt;(defn abs [num]
  (if (neg? num)
    (- num)
    num))
&lt;/code&gt;
    &lt;p&gt;The traversal is similar to the previous one, but now instead of &lt;code&gt;zip/replace&lt;/code&gt;, we call
&lt;code&gt;zip/edit&lt;/code&gt;. It updates the content of the location, based on the previous value:&lt;/p&gt;
    &lt;code&gt;(def data [-1 2 [5 -2 2 [-3 2]] -1 5])

(loop [loc (zip/vector-zip data)]
  (if (zip/end? loc)
    (zip/node loc)
    (if (and (-&amp;gt; loc zip/node number?)
             (-&amp;gt; loc zip/node neg?))
      (recur (zip/next (zip/edit loc abs)))
      (recur (zip/next loc)))))
&lt;/code&gt;
    &lt;p&gt;In both cases, the loop logic is simple. If this is the final location, return its node. Recall that the final location is the initial location when you’ve returned to it after a series of &lt;code&gt;zip/next&lt;/code&gt; calls. Otherwise, if the location contains a negative number, we change the content with &lt;code&gt;zip/edit&lt;/code&gt;. From the changed location, we traverse to the next one. The key point: on the penultimate line, the call
&lt;code&gt;zip/next&lt;/code&gt; takes the result of &lt;code&gt;zip/edit&lt;/code&gt;, not the initial location. That is, changes in it will be passed on to the next step.&lt;/p&gt;
    &lt;p&gt;The examples above allow you to see patterns — repetitive techniques. Let’s put them in separate functions so as not to waste attention on them in the future.&lt;/p&gt;
    &lt;p&gt;Search for a location by predicate. It takes an initial location and predicate, and starts iteration. It returns the first location that matches the predicate:&lt;/p&gt;
    &lt;code&gt;(defn find-loc [loc loc-pred]
  (-&amp;gt;&amp;gt; loc
       iter-zip
       (find-first loc-pred)))
&lt;/code&gt;
    &lt;p&gt;Run locations with changes. It iterates locations using &lt;code&gt;zip/next&lt;/code&gt; and &lt;code&gt;loop/recur&lt;/code&gt;. When moving to the next step, it wraps the location into a function. The function should either change the location or return it unchanged. This is a generic version of &lt;code&gt;loop&lt;/code&gt; we wrote above.&lt;/p&gt;
    &lt;code&gt;(defn alter-loc [loc loc-fn]
  (loop [loc loc]
    (if (zip/end? loc)
      loc
      (-&amp;gt; loc loc-fn zip/next recur))))
&lt;/code&gt;
    &lt;p&gt;Let’s rewrite the example with the new functions. Find in the vector a location which node is 2.&lt;/p&gt;
    &lt;code&gt;(defn loc-2? [loc]
  (-&amp;gt; loc zip/node (= 2)))

(def loc-2
  (-&amp;gt; [1 2 3]
      zip/vector-zip
      (find-loc loc-2?)))
&lt;/code&gt;
    &lt;p&gt;Let’s double it and go to the final vector:&lt;/p&gt;
    &lt;code&gt;(-&amp;gt; loc-2 (zip/edit * 2) zip/root)
;; [1 4 2]
&lt;/code&gt;
    &lt;p&gt;Let’s change the negative numbers modulo. To do this, we’ll create the &lt;code&gt;loc-abs&lt;/code&gt; function. If the node has a negative number, we’ll return the corrected location, otherwise, the original one:&lt;/p&gt;
    &lt;code&gt;(defn loc-abs [loc]
  (if (and (-&amp;gt; loc zip/node number?)
           (-&amp;gt; loc zip/node neg?))
    (zip/edit loc abs)
    loc))
&lt;/code&gt;
    &lt;p&gt;Pass it to &lt;code&gt;alter-loc&lt;/code&gt;:&lt;/p&gt;
    &lt;code&gt;(-&amp;gt; [-1 2 [5 -2 2 [-3 2]] -1 5]
    zip/vector-zip
    (alter-loc loc-abs)
    zip/node)

;; [1 2 [5 2 2 [3 2]] 1 5]
&lt;/code&gt;
    &lt;head rend="h3"&gt;Prices in XML&lt;/head&gt;
    &lt;p&gt;Let’s move on to more realistic examples with XML and products. Prepare the next file: &lt;code&gt;products-price.xml&lt;/code&gt;:&lt;/p&gt;
    &lt;code&gt;&amp;lt;?xml version="1.0" encoding="UTF-8"?&amp;gt;
&amp;lt;catalog&amp;gt;
  &amp;lt;organization name="re-Store"&amp;gt;
    &amp;lt;product type="fiber" price="8.99"&amp;gt;VIP Fiber Plus&amp;lt;/product&amp;gt;
    &amp;lt;product type="iphone" price="899.99"&amp;gt;iPhone 11 Pro&amp;lt;/product&amp;gt;
  &amp;lt;/organization&amp;gt;
  &amp;lt;organization name="DNS"&amp;gt;
    &amp;lt;branch name="Office 2"&amp;gt;
      &amp;lt;bundle&amp;gt;
        &amp;lt;product type="fiber" price="9.99"&amp;gt;Premium iFiber&amp;lt;/product&amp;gt;
        &amp;lt;product type="iphone" price="999.99"&amp;gt;iPhone 11 Pro&amp;lt;/product&amp;gt;
      &amp;lt;/bundle&amp;gt;
    &amp;lt;/branch&amp;gt;
  &amp;lt;/organization&amp;gt;
&amp;lt;/catalog&amp;gt;
&lt;/code&gt;
    &lt;p&gt;Note that products now have prices — a characteristic that changes frequently.&lt;/p&gt;
    &lt;p&gt;As you might remember, in terms of Clojure, XML is nested dictionaries with keys. &lt;code&gt;:tag&lt;/code&gt;, &lt;code&gt;:attrs&lt;/code&gt; и &lt;code&gt;:content&lt;/code&gt;. But after the changes, we would like to see it in its usual, textual form. We need the opposite action: converting XML from the data structure to text. To do this, import the built-in &lt;code&gt;clojure.xml&lt;/code&gt; module. Its &lt;code&gt;emit&lt;/code&gt; function prints XML.&lt;/p&gt;
    &lt;p&gt;Often, &lt;code&gt;emit&lt;/code&gt; is wrapped in &lt;code&gt;with-out-str&lt;/code&gt; (a macro to intercept printing to a string). In the examples below, we’ll output the XML in the console. Since &lt;code&gt;emit&lt;/code&gt; doesn’t support indentation, we will add it manually for clarity.&lt;/p&gt;
    &lt;p&gt;The first task is to make a 10 percent discount on all iPhones. We have almost all abstractions ready, so let’s write the solution from top to bottom:&lt;/p&gt;
    &lt;code&gt;(require '[clojure.xml :as xml])

(-&amp;gt; "products-price.xml"
    -&amp;gt;xml-zipper
    (alter-loc alter-iphone-price)
    zip/node
    xml/emit)
&lt;/code&gt;
    &lt;p&gt;These five lines are enough for our task. It remains to write the &lt;code&gt;alter-iphone-price&lt;/code&gt; function. We need the function to take an iPhone location and return it, but with a different &lt;code&gt;price&lt;/code&gt; attribute. A location of a different type will remain unchanged. Let’s describe the function:&lt;/p&gt;
    &lt;code&gt;(defn alter-iphone-price [loc]
  (if (loc-iphone? loc)
    (zip/edit loc alter-attr-price 0.9)
    loc))
&lt;/code&gt;
    &lt;p&gt;The &lt;code&gt;loc-iphone?&lt;/code&gt; predicate checks if the location holds an iPhone. We’ve already written it in our
previous lessons:&lt;/p&gt;
    &lt;code&gt;(defn loc-iphone? [loc]
  (let [node (zip/node loc)]
    (and (-&amp;gt; node :tag (= :product))
         (-&amp;gt; node :attrs :type (= "iphone")))))
&lt;/code&gt;
    &lt;p&gt;The &lt;code&gt;alter-attr-price&lt;/code&gt; function takes a node (i.e., location content) and must change its attribute. The second function argument is the factor by which the current price should be multiplied. The slight difficulty is that attributes in XML are strings. To perform multiplication, you need to convert a string to a number, multiply it by a factor, and then convert the result, rounded to two digits, back to a string. All together gives us this function:&lt;/p&gt;
    &lt;code&gt;(defn alter-attr-price [node ratio]
  (update-in node [:attrs :price]
             (fn [price]
               (-&amp;gt;&amp;gt; price
                    read-string
                    (* ratio)
                    (format "%.2f")))))
&lt;/code&gt;
    &lt;p&gt;Quick check of the function:&lt;/p&gt;
    &lt;code&gt;(alter-attr-price {:attrs {:price "10"}} 1.1)
;; {:attrs {:price "11.00"}}
&lt;/code&gt;
    &lt;p&gt;After running the whole chain, we should get XML:&lt;/p&gt;
    &lt;code&gt;&amp;lt;?xml version="1.0" encoding="UTF-8"?&amp;gt;
&amp;lt;catalog&amp;gt;
  &amp;lt;organization name="re-Store"&amp;gt;
    &amp;lt;product price="8.99" type="fiber"&amp;gt;VIP Fiber Plus&amp;lt;/product&amp;gt;
    &amp;lt;product price="809.99" type="iphone"&amp;gt;iPhone 11 Pro&amp;lt;/product&amp;gt;
  &amp;lt;/organization&amp;gt;
  &amp;lt;organization name="DNS"&amp;gt;
    &amp;lt;branch name="Office 2"&amp;gt;
      &amp;lt;bundle&amp;gt;
        &amp;lt;product price="9.99" type="fiber"&amp;gt;Premium iFiber&amp;lt;/product&amp;gt;
        &amp;lt;product price="899.99" type="iphone"&amp;gt;iPhone 11 Pro&amp;lt;/product&amp;gt;
      &amp;lt;/bundle&amp;gt;
    &amp;lt;/branch&amp;gt;
  &amp;lt;/organization&amp;gt;
&amp;lt;/catalog&amp;gt;
&lt;/code&gt;
    &lt;p&gt;As a result, the price of iPhones changed by 10 percent, while the rest of the products remained the same.&lt;/p&gt;
    &lt;p&gt;More difficult task: add a new product — a headset — to all bundles. Again, let’s describe the solution from top to bottom:&lt;/p&gt;
    &lt;code&gt;(-&amp;gt; "products-price.xml"
    -&amp;gt;xml-zipper
    (alter-loc add-to-bundle)
    zip/node
    xml/emit)
&lt;/code&gt;
    &lt;p&gt;The solution differs from the previous one only in the &lt;code&gt;add-to-bundle&lt;/code&gt; functions. Its logic is as follows: if the current location is a bundle, add a child to it, and if not, just return the location.&lt;/p&gt;
    &lt;code&gt;(defn add-to-bundle [loc]
  (if (loc-bundle? loc)
    (zip/append-child loc node-headset)
    loc))
&lt;/code&gt;
    &lt;p&gt;Checking whether it’s a bundle or not:&lt;/p&gt;
    &lt;code&gt;(defn loc-bundle? [loc]
  (some-&amp;gt; loc zip/node :tag (= :bundle)))
&lt;/code&gt;
    &lt;p&gt;The &lt;code&gt;zip/append-child&lt;/code&gt; function appends the value to the end of the location’s children. In our case, it’s the &lt;code&gt;node-headset&lt;/code&gt; node, which we put into a constant:&lt;/p&gt;
    &lt;code&gt;(def node-headset
  {:tag :product
   :attrs {:type "headset"
           :price "199.99"}
   :content ["AirPods Pro"]})
&lt;/code&gt;
    &lt;p&gt;Here’s the final XML where a new product has been added into the bundles:&lt;/p&gt;
    &lt;code&gt;&amp;lt;?xml version="1.0" encoding="UTF-8"?&amp;gt;
&amp;lt;catalog&amp;gt;
  &amp;lt;organization name="re-Store"&amp;gt;
    &amp;lt;product price="8.99" type="fiber"&amp;gt;VIP Fiber Plus&amp;lt;/product&amp;gt;
    &amp;lt;product price="899.99" type="iphone"&amp;gt;iPhone 11 Pro&amp;lt;/product&amp;gt;
  &amp;lt;/organization&amp;gt;
  &amp;lt;organization name="DNS"&amp;gt;
    &amp;lt;branch name="Office 2"&amp;gt;
      &amp;lt;bundle&amp;gt;
        &amp;lt;product price="9.99" type="fiber"&amp;gt;Premium iFiber&amp;lt;/product&amp;gt;
        &amp;lt;product price="999.99" type="iphone"&amp;gt;iPhone 11 Pro&amp;lt;/product&amp;gt;
        &amp;lt;product price="199.99" type="headset"&amp;gt;AirPods Pro&amp;lt;/product&amp;gt;
      &amp;lt;/bundle&amp;gt;
    &amp;lt;/branch&amp;gt;
  &amp;lt;/organization&amp;gt;
&amp;lt;/catalog&amp;gt;
&lt;/code&gt;
    &lt;p&gt;The third task is to do away with all bundles. We decided that it was not profitable to sell items in bundles. All &lt;code&gt;&amp;lt;bundle&amp;gt;&lt;/code&gt; tags are removed from XML, but their products must go to organizations.&lt;/p&gt;
    &lt;p&gt;And for the third time, the solution differs only in the function:&lt;/p&gt;
    &lt;code&gt;(-&amp;gt; "products-price.xml"
    -&amp;gt;xml-zipper
    (alter-loc disband-bundle)
    zip/node
    xml/emit)
&lt;/code&gt;
    &lt;p&gt;Let’s describe the &lt;code&gt;disband-bundle&lt;/code&gt; algorithm. If the current node is a bundle, we save its children (products) to a variable to not lose them. Then we delete the bundle, which will return the parent of the deleted location. In our case, it’s an organization. We return it with the products attached.&lt;/p&gt;
    &lt;code&gt;(defn disband-bundle [loc]
  (if (loc-bundle? loc)
    (let [products (zip/children loc)
          loc-org (zip/remove loc)]
      (append-childs loc-org products))
    loc))
&lt;/code&gt;
    &lt;p&gt;The &lt;code&gt;append-childs&lt;/code&gt; function is our wrapper over the built-in &lt;code&gt;zip/append-child&lt;/code&gt;. The latter attaches only one element, which is inconvenient. To join a list, let’s write a helper function:&lt;/p&gt;
    &lt;code&gt;(defn append-childs [loc items]
  (reduce (fn [loc item]
            (zip/append-child loc item))
          loc
          items))
&lt;/code&gt;
    &lt;p&gt;Here’s the final XML with no bundles, but with the same products:&lt;/p&gt;
    &lt;code&gt;&amp;lt;?xml version="1.0" encoding="UTF-8"?&amp;gt;
&amp;lt;catalog&amp;gt;
  &amp;lt;organization name="re-Store"&amp;gt;
    &amp;lt;product price="8.99" type="fiber"&amp;gt;VIP Fiber Plus&amp;lt;/product&amp;gt;
    &amp;lt;product price="899.99" type="iphone"&amp;gt;iPhone 11 Pro&amp;lt;/product&amp;gt;
  &amp;lt;/organization&amp;gt;
  &amp;lt;organization name="DNS"&amp;gt;
    &amp;lt;branch name="Office 2"&amp;gt;
      &amp;lt;product price="9.99" type="fiber"&amp;gt;Premium iFiber&amp;lt;/product&amp;gt;
      &amp;lt;product price="999.99" type="iphone"&amp;gt;iPhone 11 Pro&amp;lt;/product&amp;gt;
    &amp;lt;/branch&amp;gt;
  &amp;lt;/organization&amp;gt;
&amp;lt;/catalog&amp;gt;
&lt;/code&gt;
    &lt;p&gt;We hope these examples are enough for you to understand how to edit zippers. Note that it took a little code: for each task, we wrote, on average, three functions. Another advantage is that the code is stateless. All functions are pure, and their call doesn’t affect the data. Should an exception pop up somewhere in the middle of editing, the XML tree won’t be half-changed.&lt;/p&gt;
    &lt;head rend="h2"&gt;Part 6. Virtual Trees. Currency Exchange&lt;/head&gt;
    &lt;p&gt;We hope that the theory and examples were enough to start experimenting with zippers. We bring to your attention an unusual example.&lt;/p&gt;
    &lt;p&gt;So far, the second function we passed to a zipper returned children from a branch. For a vector we used &lt;code&gt;seq&lt;/code&gt;, for XML — a more complex combination &lt;code&gt;(comp seq :content)&lt;/code&gt;. Both options depend on the parent node, and if there are no children, the functions return &lt;code&gt;nil&lt;/code&gt;.&lt;/p&gt;
    &lt;p&gt;But what happens if the function returns a constant set of children:&lt;/p&gt;
    &lt;code&gt;(fn [_]
  (seq [1 2 3]))
&lt;/code&gt;
    &lt;p&gt;How will such a zipper behave? Let’s write it:&lt;/p&gt;
    &lt;code&gt;(def zip-123
  (zip/zipper any?
              (constantly (seq [1 2 3]))
              nil
              1))
&lt;/code&gt;
    &lt;p&gt;Due to the fact that each element has three children, the zipper will become infinite. Traversing it with &lt;code&gt;iter-zip&lt;/code&gt; doesn’t work. &lt;code&gt;Zip/next&lt;/code&gt; will plunge deeper and deeper into the zipper but never reach its end.&lt;/p&gt;
    &lt;p&gt;For fun, let’s take a few steps on the new zipper. Let’s go down and to the right. We will find ourselves on 2 in the middle of the vector &lt;code&gt;[1 2 3]&lt;/code&gt;:&lt;/p&gt;
    &lt;code&gt;(def loc-2
  (-&amp;gt; zip-123
      zip/down
      zip/right))

(zip/node loc-2)
;; 2
&lt;/code&gt;
    &lt;p&gt;Let’s see our position on the diagram. A step to the left will move us on 1, a step to the right — on 3:&lt;/p&gt;
    &lt;code&gt;              ┌───────────┐
              │     1     │
              └───────────┘
                    ▲
                    │
 ┌───────┐    ┏━━━━━━━━━━━┓    ┌───────┐
 │   1   │◀───┃     2     ┃───▶│   3   │
 └───────┘    ┗━━━━━━━━━━━┛    └───────┘
                    │
                    ▼
                ┌───────┐
                │[1 2 3]│
                └───────┘
&lt;/code&gt;
    &lt;p&gt;Stepping down we fall into the next vector &lt;code&gt;[1 2 3]&lt;/code&gt; and so on. Let’s go down and to the right five more times, and still end up in 2:&lt;/p&gt;
    &lt;code&gt;(def down-right (comp zip/right zip/down))

(-&amp;gt; loc-2
    down-right
    down-right
    down-right
    down-right
    down-right
    zip/node)
;; 2
&lt;/code&gt;
    &lt;p&gt;The zipper can be called virtual because the data we travel through doesn’t really exist — they appear on the fly.&lt;/p&gt;
    &lt;p&gt;What the use of this zipper is yet to be seen. However, it confirms the important thesis that you can get child nodes in the process of traversing the tree. This does not violate the zipper rules and provides new opportunities.&lt;/p&gt;
    &lt;p&gt;However, the explicitly specified vector &lt;code&gt;[1 2 3]&lt;/code&gt; doesn’t expose them. If the children are known in advance, there is no need for a zipper, since the collection can be traversed in an easier way. A suitable case is when children depend on some external factors. For example, both functions &lt;code&gt;branch?&lt;/code&gt; and &lt;code&gt;children&lt;/code&gt; rely on other collections and data. This is also a traversal, but according to different rules.&lt;/p&gt;
    &lt;p&gt;Let’s look at the following problem. A bank exchanges currencies, for example, dollars for euros, rubles for lira, and so on. For brevity, let’s designate them in pairs: &lt;code&gt;(usd, eur)&lt;/code&gt; and &lt;code&gt;(rub, lir)&lt;/code&gt;. The exchange works in one direction. To exchange euros for dollars or lira for rubles, the bank must have separate rules &lt;code&gt;(eur, usd)&lt;/code&gt; and &lt;code&gt;(lir, rub)&lt;/code&gt;.&lt;/p&gt;
    &lt;p&gt;The client contacts the bank to exchange the currency &lt;code&gt;X&lt;/code&gt; for &lt;code&gt;Y&lt;/code&gt;. If there is a pair &lt;code&gt;(X, Y)&lt;/code&gt; in the exchange rules, there’s no problem. But if there is no such pair, the bank must build a chain of exchanges. For example, a client wants to exchange dollars for lira, but the bank doesn’t have the direct pair &lt;code&gt;(usd, lir)&lt;/code&gt;. However, there are pairs &lt;code&gt;(usd, eur)&lt;/code&gt; and &lt;code&gt;(eur, lir)&lt;/code&gt;. In this case, the client will be offered the exchange &lt;code&gt;usd -&amp;gt; eur -&amp;gt; lir&lt;/code&gt;.&lt;/p&gt;
    &lt;p&gt;Write a program that accepts exchange rules, as well as input and output currencies. You have to find the exchange chains. The shorter the chain, the better. If multiple chains of the same length are possible, return all of them so the client can choose. Consider the option when there are no solutions and provide an adequate response to this case, so as not to go into an eternal loop and not take up all the computer’s resources.&lt;/p&gt;
    &lt;p&gt;Let’s describe the input data in terms of Clojure. Each rule will be a vector of two keywords — which currency is exchanged for which one. The vector of rules will be called &lt;code&gt;rules&lt;/code&gt;. In addition to the rules, we takes the parameters &lt;code&gt;from&lt;/code&gt; and &lt;code&gt;to&lt;/code&gt; — these indicate which currency to change from and to which one.&lt;/p&gt;
    &lt;code&gt;;; rules
[[:usd :rub] [:rub :eur] [:eur :lir]]

:usd ;; from
:rub ;; to
&lt;/code&gt;
    &lt;p&gt;The output should be a set of chains from &lt;code&gt;from&lt;/code&gt; to &lt;code&gt;to&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt;. For the case above, the chain from dollar to euro looks like this:&lt;/p&gt;
    &lt;code&gt;[:usd :rub :eur]
&lt;/code&gt;
    &lt;p&gt;All together gives the function &lt;code&gt;exchanges&lt;/code&gt;, which body we have to fill:&lt;/p&gt;
    &lt;code&gt;(defn exchanges [rules from to]
  ...)
&lt;/code&gt;
    &lt;p&gt;First, let’s write some tests. They will help us warm up, and at the same time we’ll understand the problem better. The first test is a simple exchange, there is a rule for it:&lt;/p&gt;
    &lt;code&gt;(deftest test-simple
  (is (= [[:usd :rub]]
         (exchanges [[:usd :rub]] :usd :rub))))
&lt;/code&gt;
    &lt;p&gt;A reverse exchange is impossible unless there is a reverse rule:&lt;/p&gt;
    &lt;code&gt;(deftest test-reverse-err
  (is (nil? (exchanges [[:rub :usd]] :usd :rub))))
&lt;/code&gt;
    &lt;p&gt;Here’s a case where the exchange chain doesn’t exist:&lt;/p&gt;
    &lt;code&gt;(deftest test-no-solution
  (is (nil? (exchanges [[:rub :usd] [:lir :eur]] :usd :eur))))
&lt;/code&gt;
    &lt;p&gt;The most important scenario is multiple exchange. You can get from dollars to rubles in two ways – with euros or lira in the middle:&lt;/p&gt;
    &lt;code&gt; (deftest test-two-ways
  (is (= [[:usd :eur :rub]
          [:usd :lir :rub]]
         (exchanges [[:usd :eur]
                     [:eur :rub]
                     [:usd :lir]
                     [:lir :rub]] :usd :rub))))
&lt;/code&gt;
    &lt;p&gt;Another test checks if we only return the shortest chains. An exchange with four currencies (in this case, &lt;code&gt;[: usd: yen: eur: rub]&lt;/code&gt;) is not included in the result:&lt;/p&gt;
    &lt;code&gt;(deftest test-short-ways-only
  (is (= [[:usd :eur :rub]
          [:usd :lir :rub]]
         (exchanges [[:usd :eur]
                     [:eur :rub]
                     [:usd :lir]
                     [:lir :rub]
                     [:usd :yen]
                     [:yen :eur]] :usd :rub))))
&lt;/code&gt;
    &lt;p&gt;In terms of competitive programming, we can say that the problem offers separate edges of the graph. It’s required to check whether it’s possible to construct a continuous route from the vertex A to B from the edges. But since we’re solving the problem with zippers, we won’t use the terms “graph” and “edges”. We don’t guarantee that the solution will be optimal — perhaps the graph algorithm will do better. However, we hope that the example will further reveal the power of zippers.&lt;/p&gt;
    &lt;p&gt;As you remember, zippers are used to traverse trees, which is included in the problem statement. Let’s say the &lt;code&gt;from&lt;/code&gt; currency, which we want to exchange, is at the root node of the tree. Let it be a dollar. Obviously, children of this currency are all those that can be exchanged for the dollar. To do this, select the second element from each pair, where the first element is &lt;code&gt;:usd&lt;/code&gt;:&lt;/p&gt;
    &lt;code&gt;(def rules
  [[:usd :rub]
   [:usd :lir]
   [:rub :eur]
   [:rub :yen]
   [:eur :lir]
   [:lir :tug]])

(def from :usd)

(def usd-children
  (for [[v1 v2] rules
        :when (= v1 from)]
    v2))

;; (:rub :lir)
&lt;/code&gt;
    &lt;p&gt;In our case, the dollar children are the ruble and the lira. Let’s draw an imaginary tree and mark the levels:&lt;/p&gt;
    &lt;code&gt;                  ┌───────┐
     1            │  usd  │
                  └───────┘
                      │
          ┌───────┐   │   ┌───────┐
     2    │  rub  │◀──┴──▶│  lir  │
          └───────┘       └───────┘
&lt;/code&gt;
    &lt;p&gt;For each currency of the second level, we’ll find child nodes according to the same rule. For convenience, let’s write the &lt;code&gt;get-children&lt;/code&gt; function:&lt;/p&gt;
    &lt;code&gt;(defn get-children [value]
  (for [[v1 v2] rules
        :when (= v1 value)]
    v2))

(get-children :rub)
;; (:eur :yen)
&lt;/code&gt;
    &lt;p&gt;The new tree:&lt;/p&gt;
    &lt;code&gt;                      ┌───────┐
    1                 │  usd  │
                      └───────┘
                          │
              ┌───────┐   │   ┌───────┐
    2         │  rub  │◀──┴──▶│  lir  │
              └───────┘       └───────┘
                  │               │
       ┌───────┐  │  ┌───────┐    │  ┌───────┐
    3  │  eur  │◀─┴─▶│  yen  │    └─▶│  tug  │
       └───────┘     └───────┘       └───────┘
&lt;/code&gt;
    &lt;p&gt;Note: it’s exactly the virtual tree that we talked about recently. We don’t have this tree in advance, it appears in the process. The &lt;code&gt;make-children&lt;/code&gt; function is closed on the original exchange pairs. This is an example of traversing a data structure that we get on the fly from other data.&lt;/p&gt;
    &lt;p&gt;The structure of the currency tree is known and can be traversed. The question is, how deep should we traverse it? Apparently, we should stop as soon as we meet a location which node is equal to the &lt;code&gt;to&lt;/code&gt; currency. Let it be yen. That is, we’ve connected &lt;code&gt;from&lt;/code&gt; and &lt;code&gt;to&lt;/code&gt; using other currencies. Let’s show the solution on the diagram:&lt;/p&gt;
    &lt;code&gt;                      ┌───────┐
    1                 │  usd  │
                      └───────┘
                          │
              ┌───────┐   │   ┌ ─ ─ ─ ┐
    2         │  rub  │◀──┘
              └───────┘       └ ─ ─ ─ ┘
                  │
       ┌ ─ ─ ─ ┐  │  ┌───────┐       ┌ ─ ─ ─ ┐
    3             └─▶│  yen  │
       └ ─ ─ ─ ┘     └───────┘       └ ─ ─ ─ ┘

&lt;/code&gt;
    &lt;p&gt;To get the exchange chain, we pass the &lt;code&gt;to&lt;/code&gt; location to the &lt;code&gt;zip/path&lt;/code&gt; function. It should return the vector of all the location’s parents, excluding itself. So, the path to the location and its node form an exchange chain.&lt;/p&gt;
    &lt;p&gt;We’ll write the code based on this reasoning. Let’s prepare a zipper:&lt;/p&gt;
    &lt;code&gt;(def zip-val
  (zip/zipper keyword?      ;; is it currency?
              get-children  ;; what can it be exchanged for?
              nil
              from))        ;; original currency
&lt;/code&gt;
    &lt;p&gt;Look for a location with the target currency in the zipper:&lt;/p&gt;
    &lt;code&gt;(defn loc-to? [loc]
  (-&amp;gt; loc zip/node (= to)))

(def loc-to
  (-&amp;gt;&amp;gt; zip-val
       iter-zip
       (find-first loc-to?)))
&lt;/code&gt;
    &lt;p&gt;If it’s found, we get an exchange chain from it. To do this, add the &lt;code&gt;to&lt;/code&gt; value to the path:&lt;/p&gt;
    &lt;code&gt;(conj (zip/path loc-to) (zip/node loc-to))

;; [:usd :rub :yen]
&lt;/code&gt;
    &lt;p&gt;We have solved the main problem. But there’re drawbacks: for any data, we receive only one chain, even if there are several of them. To fix this, let’s search not only for the first location with the &lt;code&gt;to&lt;/code&gt; currency, but all of them using &lt;code&gt;filter&lt;/code&gt;.&lt;/p&gt;
    &lt;p&gt;Let’s expand the initial data:&lt;/p&gt;
    &lt;code&gt;(def rules
  [[:usd :rub]
   [:usd :lir]
   [:rub :eur]
   [:lir :yen]
   [:rub :yen]
   [:eur :lir]
   [:lir :tug]])

(def from :usd)
(def to :yen)
&lt;/code&gt;
    &lt;p&gt;and find chains. To do this, replace &lt;code&gt;find-first&lt;/code&gt; with &lt;code&gt;filter&lt;/code&gt;, which should return all elements matching the predicate.&lt;/p&gt;
    &lt;code&gt;(def locs-to
  (-&amp;gt;&amp;gt; zip-val
       iter-zip
       (filter loc-to?)))
&lt;/code&gt;
    &lt;p&gt;For each location found, let’s build a path:&lt;/p&gt;
    &lt;code&gt;(for [loc locs-to]
  (conj (zip/path loc) (zip/node loc)))

([:usd :rub :eur :lir :yen]
 [:usd :rub :yen]
 [:usd :lir :yen])
&lt;/code&gt;
    &lt;p&gt;Now we’ve found chains of any length, which may be redundant. According to the problem statement, we reject an exchange of four operations if we find it with two. Let’s write a function that returns the shortest lists from the result above. It groups exchanges by length, finds the shortest one, and selects it from a map.&lt;/p&gt;
    &lt;code&gt;(defn get-shortest-chains
  [chains]
  (when (seq chains)
    (let [count-&amp;gt;chains (group-by count chains)
          min-count (apply min (keys count-&amp;gt;chains))]
      (get count-&amp;gt;chains min-count))))
&lt;/code&gt;
    &lt;p&gt;For the last result, we get two vectors with three currencies in each. The last test &lt;code&gt;test-short-ways-only&lt;/code&gt;, where long chains are discarded, covers this case:&lt;/p&gt;
    &lt;code&gt;[[:usd :rub :yen] [:usd :lir :yen]]
&lt;/code&gt;
    &lt;p&gt;Build the &lt;code&gt;exchanges&lt;/code&gt; function from the code snippets. Make sure all tests pass. Add more cases to them.&lt;/p&gt;
    &lt;p&gt;It seems that the problem has been solved, but you can improve the solution. The fact is that with certain input data, the tree might become infinite. The program will either go into an infinite loop or, with a limited number of steps, won’t find a solution. Try to guess what might be causing this and how to fix it. In the next section, you will find the answer to these questions.&lt;/p&gt;
    &lt;head rend="h2"&gt;Part 7. Breadth-First Traversal. Improved Currency Exchange&lt;/head&gt;
    &lt;p&gt;Previously, we worked with the currency tree to find the exchange chain. We solved the problem, but mentioned that in special cases the tree can turn out to be infinite. How is this possible? Let’s remember how &lt;code&gt;zip/next&lt;/code&gt; traverses the tree.&lt;/p&gt;
    &lt;p&gt;The algorithm is called &lt;code&gt;depth-first&lt;/code&gt;. With this traversal, the code first walks down and only then to the side (in our case, to the right). This is easy to see if you decompose the data into parts using
a zipper:&lt;/p&gt;
    &lt;code&gt;(-&amp;gt;&amp;gt; [1 [2 [3] 4] 5]
     zip/vector-zip
     iter-zip
     (map zip/node)
     (map println))

;; 1
;; [2 [3] 4]
;; 2
;; [3]
;; 3
;; 4
;; 5
&lt;/code&gt;
    &lt;p&gt;The number &lt;code&gt;3&lt;/code&gt; preceding &lt;code&gt;4&lt;/code&gt; means the zipper goes deep first (inside the vector &lt;code&gt;[3]&lt;/code&gt;) and only then to the right.&lt;/p&gt;
    &lt;p&gt;Even more interesting is the case with a naive virtual tree, where each node has children &lt;code&gt;[1 2 3]&lt;/code&gt;. When traversing such a tree, the zipper will tend downward, each time descending into the next vector &lt;code&gt;[1 2 3]&lt;/code&gt; and stopping at 1. Let’s show this in the diagram:&lt;/p&gt;
    &lt;code&gt;(def zip-123
  (zip/zipper any?
              (constantly (seq [1 2 3]))
              nil
              1))
&lt;/code&gt;
    &lt;code&gt;                       ┌───────┐
                       │[1 2 3]│
                       └───────┘
                           │
               ┌───────┐   │
               │[1 2 3]│◀──┘
               └───────┘
                   │
        ┌───────┐  │
        │[1 2 3]│◀─┘
        └───────┘
            │
            │
    ...   ◀─┘

&lt;/code&gt;
    &lt;p&gt;Since there is no condition in our zipper to stop the production of child nodes, their nesting is unlimited. The &lt;code&gt;iter-zip&lt;/code&gt; function returns an infinite chain of locations, each containing 1. It doesn’t matter how much “1” we take from it — a hundred or a thousand — we get the same number of “1”.&lt;/p&gt;
    &lt;code&gt;(-&amp;gt;&amp;gt; zip-123
     iter-zip
     (take 10)
     (map zip/node))

;; (1 1 1 1 1 1 1 1 1 1)
&lt;/code&gt;
    &lt;p&gt;Now let’s get back to currency exchange. Suppose a bank changes rubles for dollars, dollars for euros, and euros for rubles. Let’s express it in code:&lt;/p&gt;
    &lt;code&gt;(def rules
  [[:rub :usd]
   [:usd :eur]
   [:eur :rub]])
&lt;/code&gt;
    &lt;p&gt;As you can see, we have a vicious circle:&lt;/p&gt;
    &lt;code&gt;             ┌───────┐
        ┌───▶│  rub  │────┐
        │    └───────┘    │
        │                 ▼
    ┌───────┐         ┌───────┐
    │  eur  │◀────────│  usd  │
    └───────┘         └───────┘
&lt;/code&gt;
    &lt;p&gt;The previous solution ignores the cyclical nature of the rules, this is its drawback. Suppose a client wants to exchange rubles for lira. Let’s start building a tree from the ruble. Here’s the beginning of the chain:&lt;/p&gt;
    &lt;code&gt;                       ┌───────┐
                       │  rub  │
                       └───────┘
                           │
               ┌───────┐   │
               │  usd  │◀──┘
               └───────┘
                   │
        ┌───────┐  │
        │  eur  │◀─┘
        └───────┘
            │
 ┌───────┐  │
 │  rub  │◀─┘
 └───────┘
&lt;/code&gt;
    &lt;p&gt;So we came to the ruble again. For it, we get the dollar again, for the dollar the euro, then the ruble. If we continue to iterate, we’ll dive into this chain endlessly.&lt;/p&gt;
    &lt;p&gt;Logic dictates that you need to stop going deep if the next currency is equal to the initial one. Simply put, a &lt;code&gt;:rub&lt;/code&gt; element that is not at the root node can’t have children. However, in the &lt;code&gt;branch?&lt;/code&gt; and &lt;code&gt;make-children&lt;/code&gt; functions, we don’t know where the element is located in the tree. They get values, not locations. We could fix this with a state, such as an atom, that would hold the list of the currencies that we traversed.&lt;/p&gt;
    &lt;p&gt;Another option is to check how many times we are referring to the &lt;code&gt;from&lt;/code&gt; currency to find children. If this is the first call, then we’re at the top of the tree (i.e., at the root node) Let’s find the children
and change the atom on which the &lt;code&gt;children&lt;/code&gt; function is closed. If not for the first time (atom
changed), we came across a cyclical case, and there are no children for it.&lt;/p&gt;
    &lt;p&gt;Both options have the right to exist, but for now, we want to do without state and mutable means.&lt;/p&gt;
    &lt;p&gt;If you examine the tree again, it becomes clear that the problem lies in the traversal order. Since we strive in depth, there is a high probability of falling into a wormhole from which we cannot get out. We might be lucky if we successfully stepped into the branch with the solution (on the left), and the infinite branch (on the right) remained untouched:&lt;/p&gt;
    &lt;code&gt;                 ┌───────┐
                 │  rub  │
                 └───────┘
                     │
         ┌───────┐   │   ┌───────┐
         │  yen  │◀──┴──▶│  usd  │
         └───────┘       └───────┘
             │               │
 ┏━━━━━━━┓   │               │   ┌───────┐
 ┃  lir  ┃◀──┘               └──▶│  eur  │
 ┗━━━━━━━┛                       └───────┘
                                     │
                                     │   ┌───────┐
                                     └──▶│  rub  │
                                         └───────┘
                                             │
                                             │
                                             └──▶  ...

&lt;/code&gt;
    &lt;p&gt;However, you cannot rely on luck when solving problems.&lt;/p&gt;
    &lt;p&gt;Now, let the zipper traverse the location not in depth, but in breadth and to the right. With this order, we are not threatened by infinite branch. We won’t try to exhaustively traverse an infinite branch if it occurs in the tree. Instead, we go down the levels of the tree and read all the elements of each level. Even if one of them originated from an endless branch, this doesn’t prevent you from exploring the rest of the elements. The figure below shows that horizontal traversal helps you get to the solution. In this case, the vertical traversal would go to infinity because both branches are cyclical.&lt;/p&gt;
    &lt;code&gt;

                               ┌───────┐
                           ┌───│  rub  │
                           │   └───────┘
                           ▼
                       ┌───────┐       ┌───────┐
                       │  yen  │──────▶│  usd  │
                       └───────┘       └───────┘
                                           │
                  ┌────────────────────────┘
                  ▼
              ┏━━━━━━━┓                         ┌───────┐
              ┃  lir  ┃────────────────────────▶│  eur  │
              ┗━━━━━━━┛                         └───────┘
                                                    │
           ┌────────────────────────────────────────┘
           ▼
       ┌───────┐     ┌───────┐           ┌───────┐     ┌───────┐
       │  rub  │────▶│  tug  │──────────▶│  yen  │────▶│  rub  │
       └───────┘     └───────┘           └───────┘     └───────┘
           │                                               │
           │                                               │
    ...  ◀─┘                                               └──▶  ...


&lt;/code&gt;
    &lt;p&gt;The problem is that the &lt;code&gt;clojure.zip&lt;/code&gt; module offers only depth-first order of traversal with &lt;code&gt;zip/next&lt;/code&gt;. There’s no other algorithm. We’ll write our own function to traverse the zipper “in layers”, as shown in the figure:&lt;/p&gt;
    &lt;code&gt;                            ┌───────┐
  1                         │   1   │
                            └───────┘
                                │
              ┌───────┐         │         ┌───────┐
  2           │   2   │◀────────┴────────▶│   3   │
              └───────┘                   └───────┘
                  │                           │
      ┌───────┐   │   ┌───────┐   ┌───────┐   │   ┌───────┐
  3   │   4   │◀──┴──▶│   5   │   │   6   │◀──┴──▶│   7   │
      └───────┘       └───────┘   └───────┘       └───────┘
&lt;/code&gt;
    &lt;p&gt;We’ll get the following layers:&lt;/p&gt;
    &lt;code&gt;[1]
[2 3]
[4 5 6 7]
&lt;/code&gt;
    &lt;p&gt;In this case, each element is not a primitive, but a location. This means that the element remembers its position in the tree, you can move from it to other elements, get its path, and so on.&lt;/p&gt;
    &lt;p&gt;First, we need a function that will return the child locations of the original one. Its logic is simple: if it’s possible to go down from the location, we move to the right until we reach emptiness.&lt;/p&gt;
    &lt;code&gt;(defn loc-children [loc]
  (when-let [loc-child (zip/down loc)]
    (-&amp;gt;&amp;gt; loc-child
         (iterate zip/right)
         (take-while some?))))
&lt;/code&gt;
    &lt;p&gt;Note that this function isn’t the same as &lt;code&gt;zip/children&lt;/code&gt;. The latter returns values, not locations, and we need locations exactly. Compare expressions:&lt;/p&gt;
    &lt;code&gt;(-&amp;gt; [1 2 3]
    zip/vector-zip
    zip/children)

(1 2 3)
&lt;/code&gt;
    &lt;p&gt;and&lt;/p&gt;
    &lt;code&gt;(-&amp;gt; [1 2 3]
    zip/vector-zip
    loc-children)

([1 {:l [] :pnodes [[1 2 3]] :ppath nil :r (2 3)}]
 [2 {:l [1] :pnodes [[1 2 3]] :ppath nil :r (3)}]
 [3 {:l [1 2] :pnodes [[1 2 3]] :ppath nil :r nil}])
&lt;/code&gt;
    &lt;p&gt;In the second case, we got the locations, while &lt;code&gt;zip/children&lt;/code&gt; simply accessed the find children function passing to the zipper.&lt;/p&gt;
    &lt;p&gt;Suppose, for some location, &lt;code&gt;loc-children&lt;/code&gt; returned a list of its children. To go down one level, you need to find their children and combine the result. The easiest way to do this is to use the following expression:&lt;/p&gt;
    &lt;code&gt;(mapcat loc-children locs)
&lt;/code&gt;
    &lt;p&gt;where &lt;code&gt;locs&lt;/code&gt; is a list of locations of the current level. If we pass the result of &lt;code&gt;mapcat&lt;/code&gt; to&lt;code&gt; locs&lt;/code&gt; parameter, we’ll move on even further. We’ll do this until we get an empty sequence. All together gives us the &lt;code&gt;loc-layers&lt;/code&gt; function:&lt;/p&gt;
    &lt;code&gt;(defn loc-layers [loc]
  (-&amp;gt;&amp;gt; [loc]
       (iterate (fn [locs]
                  (mapcat loc-children locs)))
       (take-while seq)))
&lt;/code&gt;
    &lt;p&gt;It takes the root location from where to start iterating over the layers. We set the first layer explicitly as a vector of one location. Then its children follow, then children of the children and so on. We’ll only stop when getting an empty layer. Quick check:&lt;/p&gt;
    &lt;code&gt;(def data [[[[1]]] 2 [[[3]]] 3])

(let [layers (-&amp;gt; data
                 zip/vector-zip
                 loc-layers)]
  (for [layer layers]
    (-&amp;gt;&amp;gt; layer
         (map zip/node)
         println)))

;; ([[[[1]]] 2 [[[3]]] 3])
;; ([[[1]]] 2 [[[3]]] 3)
;; ([[1]] [[3]])
;; ([1] [3])
;; (1 3)
&lt;/code&gt;
    &lt;p&gt;To get a chain where the elements go from left to right, we concatenate the layers using &lt;code&gt;concat&lt;/code&gt;. This function is not needed for solving the problem, but it can be useful:&lt;/p&gt;
    &lt;code&gt;(defn loc-seq-layers [loc]
  (apply concat (loc-layers loc)))
&lt;/code&gt;
    &lt;p&gt;Let’s go back to currency exchange. Let’s select the exchange rules so that they contain cyclical dependencies. The zipper remains the same: it builds the exchange tree using the local &lt;code&gt;get-children&lt;/code&gt; function, which is closed on the rules.&lt;/p&gt;
    &lt;code&gt;(def rules2
  [[:rub :usd]
   [:usd :eur]
   [:eur :rub]

   [:rub :lir]
   [:lir :eur]
   [:eur :din]
   [:din :tug]])
&lt;/code&gt;
    &lt;p&gt;The style of working with this zipper will change. Now we iterate through it using not &lt;code&gt;zip/next&lt;/code&gt; but our &lt;code&gt;loc-layers&lt;/code&gt;. At each step, we should get exchange layers. We have to find the locations, which node is equal to the final currency, in the next layer. As soon as we have found at least one, the problem is solved. It remains only to calculate the path to them.&lt;/p&gt;
    &lt;code&gt;(defn exchange2 [rules from to]

  (letfn [(get-children [value]
            (seq (for [[v1 v2] rules
                       :when (= v1 value)]
                   v2)))

          (loc-to? [loc]
            (-&amp;gt; loc zip/node (= to)))

          (find-locs-to [layer]
            (seq (filter loc-to? layer)))

          (-&amp;gt;exchange [loc]
            (conj (zip/path loc) (zip/node loc)))]

    (let [zipper (zip/zipper keyword?
                             get-children
                             nil
                             from)]

      (-&amp;gt;&amp;gt; zipper
           loc-layers
           (some find-locs-to)
           (map -&amp;gt;exchange)))))
&lt;/code&gt;
    &lt;p&gt;As you may have noticed, now there is no need to compare the lengths of the chains: if the locations belong to the same level, the number of steps to them is the same. According to the problem statement, we are interested in the shortest exchange options. For example, if one chain was found on the third level, and there are three chains on the fourth, the latter are not interesting to us – we complete the traversal on the third layer.&lt;/p&gt;
    &lt;p&gt;Here are examples of exchanges regarding the rules specified in &lt;code&gt;rules2&lt;/code&gt;:&lt;/p&gt;
    &lt;code&gt;(exchange2 rules2 :rub :eur)
([:rub :usd :eur] [:rub :lir :eur])

(exchange2 rules2 :rub :tug)
([:rub :usd :eur :din :tug] [:rub :lir :eur :din :tug])

(exchange2 rules2 :lir :din)
([:lir :eur :din])
&lt;/code&gt;
    &lt;p&gt;The solution is still not perfect. If we specify a pair of currencies for which there is no chain, we’ll get an infinite loop. To stop it, limit the number of layers to some reasonable number, such as five. From a financial point of view, currency exchange with no restrictions is likely to be detrimental, and therefore meaningless. Technically, we need to add the form &lt;code&gt;(take N)&lt;/code&gt; right after &lt;code&gt;loc-layers&lt;/code&gt;:&lt;/p&gt;
    &lt;code&gt;(-&amp;gt;&amp;gt; zipper
     loc-layers
     (take 5)
     (some find-locs-to)
     (map -&amp;gt;exchange))
&lt;/code&gt;
    &lt;p&gt;Now, we get an empty result for an invalid pair:&lt;/p&gt;
    &lt;code&gt;(exchange2 rules2 :tug :yen)
()
&lt;/code&gt;
    &lt;p&gt;The task can be improved further. For example, you can calculate costs and transaction fees for each chain. To do this, add the exchange rate and fee to the &lt;code&gt;[:from: to]&lt;/code&gt; vector. Depending on whether we represent a client or a bank, we’ll look for the most optimal or the most expensive exchanges. Please, come up with your own variations for this problem. At this point we’ll finish with currencies and move on.&lt;/p&gt;
    &lt;p&gt;In this chapter, we’ve discussed how the traversal order affects the solution to the problem. Breadth-first and depth-first traversal ordering applies to different cases. This is important for infinite trees, when the algorithm can loop while traversing. There is no breadth-width traversal in the &lt;code&gt;clojure.zip&lt;/code&gt; package, but you can easily write a function to divide the zipper into layers. You may find &lt;code&gt;loc-layers&lt;/code&gt; useful in other cases involving graphs and vertices.&lt;/p&gt;
    &lt;head rend="h2"&gt;Part 8. Summary&lt;/head&gt;
    &lt;p&gt;Finally, let’s take a look at other zipper features that you might find useful.&lt;/p&gt;
    &lt;head rend="h3"&gt;HTML&lt;/head&gt;
    &lt;p&gt;The previous examples show that zippers work fine with XML. By the way, you can apply them to HTML as well. Strictly speaking, the syntax of the formats is different: some HTML elements like &lt;code&gt;&amp;lt;br&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; don’t have closing tags. Parsers that take these features into account can solve the problem. As a result, we get an HTML tree that can be traversed as in the examples above.&lt;/p&gt;
    &lt;p&gt;The Hickory library offers an HTML markup parser. The parsing is based on the Java library JSoup, which builds a tree of elements. Hickory contains a function to rebuild a Java tree into Clojure-like one and get a zipper. Add a dependency to the project:&lt;/p&gt;
    &lt;code&gt;[hickory "0.7.1"]
&lt;/code&gt;
    &lt;p&gt;and run the example:&lt;/p&gt;
    &lt;code&gt;(ns zipper-manual.core
  (:require
   [hickory.core :as h]
   [hickory.zip :as hz]
   [clojure.zip :as zip]))

(def html (-&amp;gt; "https://grishaev.me/"
              java.net.URL.
              slurp))

(def doc-src (h/parse html))
(def doc-clj (h/as-hiccup doc-src))
(def doc-zip (hz/hiccup-zip doc-clj))
&lt;/code&gt;
    &lt;p&gt;How are these conversions performed? A website layout is loaded into the &lt;code&gt;html&lt;/code&gt; variable as a string. The &lt;code&gt;doc-src&lt;/code&gt; variable contains a tree obtained from HTML. It’s an object of the &lt;code&gt;Document&lt;/code&gt; class from the &lt;code&gt;org.jsoup.nodes&lt;/code&gt; package. For Clojure, it’s a black box: to work with it, it needs to read the documentation for the &lt;code&gt;Document&lt;/code&gt; class.&lt;/p&gt;
    &lt;p&gt;The &lt;code&gt;as-hiccup&lt;/code&gt; function converts the document into a set of nested vectors which look like this:&lt;/p&gt;
    &lt;code&gt;[:tag {:attr "value"} &amp;amp; [...]],
&lt;/code&gt;
    &lt;p&gt;The tag comes first, then the attribute dictionary, followed by any number of the same vectors or strings. This is the standard HTML representation in Clojure, and many libraries use the same format.&lt;/p&gt;
    &lt;p&gt;The &lt;code&gt;hiccup-zip&lt;/code&gt; function returns the zipper for that structure. It can do everything that we’ve practiced earlier, for example:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;remove unwanted tags like &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;,&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;;&lt;/item&gt;
      &lt;item&gt;leave these tags, but secure their attributes;&lt;/item&gt;
      &lt;item&gt;leave dangerous tags only if their source points to trusted sites;&lt;/item&gt;
      &lt;item&gt;look for items of interest to us.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Here’s how to find all the images on a webpage:&lt;/p&gt;
    &lt;code&gt;(defn loc-img? [loc]
  (some-&amp;gt; loc zip/node first (= :img)))

(defn loc-&amp;gt;src [loc]
  (some-&amp;gt; loc zip/node second :src))

(-&amp;gt;&amp;gt; doc-zip
     iter-zip
     (filter loc-img?)
     (map loc-&amp;gt;src))

("/assets/static/photo-round-small.png" ...)
&lt;/code&gt;
    &lt;p&gt;The first function checks if the location points to a node with the &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; tag, the second
extracts the &lt;code&gt;src&lt;/code&gt; attribute from it. The third form returns a list of links to images.&lt;/p&gt;
    &lt;p&gt;Based on these actions, you can build HTML filtering, especially if an HTML markup comes from a source you don’t trust. Another scenario is to find a suitable image for a social media cover in HTML. To do this, you need to select all images, estimate their width and height, and select the largest in area (if the &lt;code&gt;width&lt;/code&gt; and &lt;code&gt;height&lt;/code&gt; attributes are filled in).&lt;/p&gt;
    &lt;p&gt;Hickory considers typical cases and offers selectors for searching by tag and attribute. It isn’t even necessary to cast the JSoup tree to a zipper to do this. However, in rare cases, you need to find tags with complex relationships, as in the product and bundle example (either only in the bundle or strictly outside it). These problems fit zippers very well.&lt;/p&gt;
    &lt;head rend="h3"&gt;Data and Serialization&lt;/head&gt;
    &lt;p&gt;Another plus of zippers is that they are represented by data — a combination of lists and maps. This means that you can write the current zipper in EDN or JSON. When reading, we get the old data structure and continue traversing from where we left off. This is the difference between Clojure and object languages, where, in the general case, you cannot write an object to a file without some effort.&lt;/p&gt;
    &lt;p&gt;When restoring a zipper, remember about its metadata. The functions &lt;code&gt;branch?&lt;/code&gt;, &lt;code&gt;children&lt;/code&gt;, and &lt;code&gt;make-node&lt;/code&gt; that we passed to the constructor are stored in the zipper metadata. This is done to separate data from actions on it. Let’s check the zipper metadata we got from HTML:&lt;/p&gt;
    &lt;code&gt;(meta doc-zip)

#:zip{:branch? #function[clojure.core/sequential?]
      :children #function[hickory.zip/children]
      :make-node #function[hickory.zip/make]}
&lt;/code&gt;
    &lt;p&gt;Let’s write functions for resetting and reading EDN:&lt;/p&gt;
    &lt;code&gt;(defn edn-save [data path]
  (spit path (pr-str data)))

(defn edn-load [path]
  (-&amp;gt; path slurp edn/read-string))
&lt;/code&gt;
    &lt;p&gt;Let’s say we’ve made some iterations on a zipper and saved it:&lt;/p&gt;
    &lt;code&gt;(-&amp;gt; doc-zip
    zip/next
    zip/next
    zip/next
    (edn-save "zipper.edn"))
&lt;/code&gt;
    &lt;p&gt;If we read the EDN and pass the result to &lt;code&gt;zip/next&lt;/code&gt;, we’ll get an error. The function will call &lt;code&gt;branch?&lt;/code&gt; and &lt;code&gt;children&lt;/code&gt; from the metadata that has not been saved, resulting in an exception. To make a zipper from a file work, add metadata to it. You can either move it into a variable in advance or declare it manually.&lt;/p&gt;
    &lt;code&gt;(def zip-meta (meta doc-zip))

;; or

(def zip-meta
  #:zip{:branch? sequential?
        :children #'hickory.zip/children
        :make-node #'hickory.zip/make})
&lt;/code&gt;
    &lt;p&gt;In the second case, we had to specify the &lt;code&gt;children&lt;/code&gt; and &lt;code&gt;make-node&lt;/code&gt; functions as variables (instances of the &lt;code&gt;Var&lt;/code&gt; class) because they are private. The read zipper will be in the same state as at the time of saving.&lt;/p&gt;
    &lt;code&gt;(def doc-zip-new
  (-&amp;gt; "zipper.edn"
      edn-load
      (with-meta zip-meta)))

(-&amp;gt; doc-zip-new zip/node first)
:head
&lt;/code&gt;
    &lt;p&gt;Storing the zipper in long-term memory brings new possibilities. For example, traversal of certain data takes time, and the program can perform the task in chunks, keeping the intermediate result. This is how complex business scenarios work. If a customer refuses the services of the company, you must delete their records in the database, files, links to them in documents and much more. This process can be thought of as a set of steps. At each step, the code reads a zipper as EDN from the database and adds metadata. Then it shifts the zipper one &lt;code&gt;zip/next&lt;/code&gt;, performs the task, and updates the record in the database with the new version of the zipper. Once you’ve reached the initial node (&lt;code&gt;zip/end?&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;), you mark the record in the database as resolved.&lt;/p&gt;
    &lt;head rend="h3"&gt;Other Uses&lt;/head&gt;
    &lt;p&gt;The example with the currency exchange shows how to find a solution to the problem by brute force search. Whether you’re looking for the optimal chain of steps, maximum cost, or a traversal route, zippers might help you. It is easy to check if they are suitable for solving your problem. The zipper implies that you have a value and several others based on it, they in turn have their values and so on. If the condition works, you are one step away from building the tree and traversing it.&lt;/p&gt;
    &lt;p&gt;Let’s say, according to the exchange table, the dollar (current value) can be exchanged for the euro and the ruble (child values). From point A (current) you can drive to points B and C (children). In HTML, one tag can include other tags. In all three cases, you can use a zipper. You only need to define the functions &lt;code&gt;branch?&lt;/code&gt; (if an element can have children) and &lt;code&gt;children&lt;/code&gt; (how to find them specifically).&lt;/p&gt;
    &lt;head rend="h3"&gt;Third-party Libraries&lt;/head&gt;
    &lt;p&gt;The &lt;code&gt;clojure.zip&lt;/code&gt; module offers enough navigation functions. Nevertheless, throughout this chapter, we had to write a few functions ourselves. The library data.zip contains various add-ons for zippers, including the same ones as we wrote. Perhaps the library will shorten your utility code.&lt;/p&gt;
    &lt;head rend="h3"&gt;Summary&lt;/head&gt;
    &lt;p&gt;Zippers are means for navigating the data structure. A zipper offers movement in four directions: down, up, left, and right. An element in the center is called a node.&lt;/p&gt;
    &lt;p&gt;A zipper can navigate a wide variety of structures. It needs to know only two things: whether the current element is a branch of a tree, and if so, how to find the children. To do this, the zipper takes the &lt;code&gt;branch?&lt;/code&gt; and &lt;code&gt;children&lt;/code&gt; functions, which are later stored in metadata.&lt;/p&gt;
    &lt;p&gt;Usually, children are found from the parent node, but in some cases we get them dynamically. For example, to find out which currencies can be exchanged for the current one, you can refer to the exchange map. To do this, the &lt;code&gt;children&lt;/code&gt; function has to see the map as a global variable or a closure.&lt;/p&gt;
    &lt;p&gt;The current zipper element is called a location. It stores not only the value, but also the data for going in all directions, as well as the path. These qualities set zippers apart from &lt;code&gt;tree-seq&lt;/code&gt; and analogs that decompose a tree into a chain not including a path to an element. Some tasks consist precisely of finding the right path.&lt;/p&gt;
    &lt;p&gt;The zipper offers functions for editing and deleting the current node. Editing can be based on the current value (&lt;code&gt;zip/edit&lt;/code&gt;) or the new one (&lt;code&gt;zip/replace&lt;/code&gt;).&lt;/p&gt;
    &lt;p&gt;By default, zipper traversal is depth-first. When moving to the end, the location will receive a mark that the cycle has been completed. Use the &lt;code&gt;zip/end?&lt;/code&gt; function as a sign of ending an iteration. In our examples, we wrote the &lt;code&gt;zip-iter&lt;/code&gt; function that does exactly one traversal.&lt;/p&gt;
    &lt;p&gt;Breadth-first traversal is required for some tasks. This can happen when one of the tree branches is potentially infinite. For breadth-first traversal, we wrote our own functions that don’t come with the Clojure.zip.&lt;/p&gt;
    &lt;p&gt;Zippers are useful for working with XML, finding solutions, and filtering HTML. Try to figure them out to solve such problems in a short and elegant way.&lt;/p&gt;
    &lt;p&gt;Нашли ошибку? Выделите мышкой и нажмите Ctrl/⌘+Enter&lt;/p&gt;
    &lt;p&gt;VK, 7th Sep 2022, link&lt;/p&gt;
    &lt;p&gt;отлично. Thanks for sharing your wonderful perspective.&lt;/p&gt;
    &lt;p&gt;temco, 18th Oct 2022, link&lt;/p&gt;
    &lt;p&gt;thanks for your introduction to zipper, which I didn’t use before in the past years on clojure programming&lt;/p&gt;
    &lt;p&gt;Luke, 2nd Aug 2023, link&lt;/p&gt;
    &lt;p&gt;i really appreciate the effort you put into explaining zippers. i can see now how they are such a versatile and powerful construct- but i always avoided them due to a lack of documentation. i wonder if this could find its way onto the official clojure.core site as a guest post?&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://grishaev.me/en/clojure-zippers/"/><published>2025-10-23T03:51:40+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45687441</id><title>When is it better to think without words?</title><updated>2025-10-24T20:38:46.613075+00:00</updated><content>&lt;doc fingerprint="7519513caab092d0"&gt;
  &lt;main&gt;
    &lt;head rend="h6"&gt;Portrait of a Man with Glasses I, Francis Bacon, 1963&lt;/head&gt;
    &lt;p&gt;This essay can be read as a complement to last year’s “How to think in writing.”&lt;/p&gt;
    &lt;quote&gt;&lt;p&gt;Thoughts die the moment they are embodied in words.&lt;/p&gt;&lt;lb/&gt;—Schopenhauer&lt;/quote&gt;
    &lt;head rend="h4"&gt;1.&lt;/head&gt;
    &lt;p&gt;In the 1940s, when the French mathematician Jacques Hadamard asked good mathematicians how they came up with solutions to hard problems, they nearly universally answered that they didn’t think in words; neither did they think in images or equations. Rather, what passed through the mathematicians as they struggled with problems were such things as vibrations in their hands, nonsense words in their ears, or blurry shapes in their heads.1&lt;/p&gt;
    &lt;p&gt;Hadamard, who had the same types of experiences, wrote in The Psychology of Invention in the Mathematical Field that this mode of thinking was distinct from daydreaming, and that most people, though they often think wordlessly, have never experienced the kind of processing that the mathematicians did.&lt;/p&gt;
    &lt;p&gt;When I read this, in December 2024, all sorts of questions arose in me. First of all, what does it even mean? Do they not think in words and equations at all? And secondly, how do I square this with my personal experience, which is that whenever I write what I think about a subject, it always turns out that my thoughts do not hold up on paper? No matter how confident I am in my thoughts, they reveal themselves on the page as little but logical holes, contradictions, and non sequiturs.&lt;/p&gt;
    &lt;p&gt;I recognize myself when Paul Graham writes:&lt;/p&gt;
    &lt;quote&gt;
      &lt;p&gt;The reason I’ve spent so long establishing [that writing helps you refine your thinking] is that it leads to another [point] that many people will find shocking. If writing down your ideas always makes them more precise and more complete, then no one who hasn’t written about a topic has fully formed ideas about it. And someone who never writes has no fully formed ideas about anything nontrivial.&lt;/p&gt;
    &lt;/quote&gt;
    &lt;p&gt;How come Hadamard’s colleagues are able to have productive thoughts, working in their heads, without words, sometimes, for days on end?&lt;/p&gt;
    &lt;head rend="h2"&gt;Tense subconscious processing&lt;/head&gt;
    &lt;p&gt;Hadamard’s book is most famous for its detailed discussion of what Henri Poincaré called the “sudden illumination”—the moment when the solution to a problem emerges “in the shower” unexpectedly after a long period of unconscious incubation.&lt;/p&gt;
    &lt;p&gt;The hypothesis here is that if you work hard on a problem, you soak your subconscious with it. Wrestling with a problem helps you build a mental model of what you know and what you don’t—providing the subconscious with building blocks to work with. (You can’t have genuine intuition and inspiration in areas where you lack knowledge.) Then, once you drop the problem from conscious thought and go take care of the dishes or something, the subconscious begins a silent and parallelized search, trying many, many alternatives (in a somewhat random fashion), until something snaps in place. When this happens, the solution bubbles back up to the conscious mind, as if out of nowhere, making you freeze mid-motion with a stack of dirty plates in your hands.&lt;/p&gt;
    &lt;p&gt;This is a very useful thing to know about the mind, because it means you can steer your subconscious towards the particular problems you want it to work on. By priming yourself with important problems before doing the dishes or going for walks or sleeping, you make sure your mental resources are used on what matters for you, instead of, for example, the open loops in a Netflix series you watched before bed. It is free labor.&lt;/p&gt;
    &lt;p&gt;But—this is not what Hadamard is talking about when he describes the wordless thought of the mathematicians and researchers he has surveyed. Instead, what they seem to be doing is something similar to this subconscious, parallelized search, except they do it in a “tensely” focused way.&lt;/p&gt;
    &lt;p&gt;The impression I get is that Hadamard loads a question into his mind (either in a non-verbal way, or by reading a mathematical problem that has been written by himself or someone else), and then he holds the problem effortfully centered in his mind. Effortfully, but wordlessly, and without clear visualizations. Describing the mental image that filled his mind while working on a problem concerning infinite series for his thesis, Hadamard writes that his mind was occupied by an image of a ribbon which was thicker in certain places (corresponding to possibly important terms). He also saw something that looked like equations, but as if seen from a distance, without glasses on: he was unable to make out what they said.&lt;/p&gt;
    &lt;p&gt;I’m not sure what is going on here. But here’s a speculation. As I understand it, when one part of our brain is working, it often inhibits another—if you put words to distressing feelings, for example, the language-oriented parts of your brain inhibit the amygdala, which reduces the emotional distress. Similarly, when you are focused on a task at hand, the executive control network of your brain will tend to inhibit the default mode network which is responsible for mind wandering. (This might explain why illuminations tend to occur mainly in the shower, when the executive control networks downregulate and the mind is allowed to wander.)&lt;/p&gt;
    &lt;p&gt;Here’s my speculation: perhaps Hadamard and the other great mathematicians are able to enter into a modality of thought where they are able to keep both the default mode network and the executive control network on at the same time. Perhaps this allows them to do a sort of subconscious, in-the-shower-type processing, while still maintaining enough conscious focus to ensure the thoughts don’t drift away from the problem and its constraints.&lt;/p&gt;
    &lt;p&gt;When I look into this, I notice that there is research indicating that when doing certain types of creative work, the default mode network and the executive control network are, indeed, active at the same time, which they usually aren’t. Individuals who are experienced in a creative field seem to have the capacity to keep the default mode network turned on, allowing them to generate many permutations of ideas, while steering it with the executive control network, ensuring their parallelized mindwandering is constrained by the facts of the problem. I suspect we are all capable of this to some extent, but doing it to the extent Hadamard’s subjects did is akin to a ballerina spinning on her toes: a mental posture that requires serious practice to develop the necessary muscles and coordination.&lt;/p&gt;
    &lt;p&gt;I’m not well-versed in neuroscience enough to know if I’m interpreting this right; I’m just speculating.&lt;/p&gt;
    &lt;p&gt;But what we do know is that Hadamard, as he worked, would pace up and down his room with what “witnesses to [his] daily life and work” called his “inside” look. (Others, like Poincaré and Helmholtz, seem to have sat at their desks, staring into nowhere.) And this type of deep, consciously-blurry concentration could go on for a long time: Hadamard mentions that he only stopped walking if he needed to write down a proof (reluctantly). An acquaintance writes that a friend of his shared an office with one of the best now living physicists; this physicist’s work habit was to come into the office in the morning and then stare into the wall for 8 hours before going home. Imagine holding a productive thought for that long without writing any steps down and, presumably, without even compressing things into words inside your head!&lt;/p&gt;
    &lt;head rend="h2"&gt;The interplay between writing and non-linguistic thinking&lt;/head&gt;
    &lt;p&gt;Hadamard writes that he sometimes used algebraic signs when dealing with easy calculations, but adds that, “whenever the matter looks more difficult, they become too heavy a baggage for me.”&lt;/p&gt;
    &lt;p&gt;Why are words too heavy?&lt;/p&gt;
    &lt;p&gt;Reasoning from my experience, I suspect it is because words are laborious. When we put words to a thought, we have to compress something that is like a web in our mind, filled with connections and associations going in all directions, turning that web into a sequential string of words; we have to compress what is high-dimensional into something low-dimensional. This has all sorts of advantages, which I will return to, but the point I want to emphasize here is that compression is effortful. It takes intense concentration to find the right words (rather than the sloppy ones that first come to mind), and then to put them in the proper order. As James Joyce said to his friend when he was asked why he looked so gloomy, “I’ve only written seven words today…” “But why then are you in despair—seven words is a lot for you!” “I don’t know in which order to put them…”&lt;/p&gt;
    &lt;p&gt;If we can avoid the compression step, and do the manipulations directly in the high-dimensional, non-linguistic, conceptual space, we can move much faster.2&lt;/p&gt;
    &lt;p&gt;But this is a big if. Most people, myself included, have too weak mental models to do this kind of processing for complex problems, and so, our thoughts are riddled with contradictions and holes that we often don’t notice unless we try to write them down. We can move faster in wordless thought, but we’re moving at random. If, however, you have deep expertise in an area, like the mathematicians, it is possible to let go of the language compression and do a much faster search. M, who started his career as a physicist, tells me that when he was 13 and read that Einstein thought without words, he felt disappointed since his mind didn’t work like that; then, “a decade and many thousands of hours of mathematics and physics later,” he reread the passage and recognized himself almost completely. I guess this was because the labor of learning mathematics, done largely through reading and writing his way through complex ideas and problems, had given him deep enough mental models to make words somewhat superfluous.&lt;/p&gt;
    &lt;p&gt;But even then, as Hadamard notes, writing is a necessary step of the process. The insights arrived at wordlessly need to be submitted to the rigor of mathematical notation and logic, to test their validity. It is a sort of feedback mechanism: unless the intuition holds up on the page, it is a false intuition.&lt;/p&gt;
    &lt;p&gt;The written results also work as relay results. By writing something down and making sure it is solid, we can offload that thought from working memory and instead use it as a building block for the next step of the thought. Or, to use a metaphor by the mathematician William Hamilton, deep thinking is like building a tunnel through a sandbank:&lt;/p&gt;
    &lt;quote&gt;
      &lt;p&gt;In this operation, it is impossible to succeed unless every foot, nay, almost every inch in our progress be secured by an arch of masonry before we attempt the excavation of another. Now, language is to the mind precisely what the arch is to the tunnel. The power of thinking and the power of excavation are not dependent on the words in the one case, on the mason-work in the other; but without these subsidiaries, neither process could be carried on beyond its rudimentary commencement.&lt;/p&gt;
    &lt;/quote&gt;
    &lt;p&gt;So writing—and reading, seriously, the writings of others—is a way to collect stepping stones: ideas that have been stabilized enough that they can carry us as we walk deeper into the thought space.&lt;/p&gt;
    &lt;p&gt;But this stabilization of meaning can go wrong, too, if we stabilize ideas that aren’t ready to be stabilized yet. When writing, there are all sorts of details that need to be specified for our paragraphs to make sense, and if we don’t know what should go into a sentence, it is all too easy to fill in the uncertain parts with guesses. At least my brain has the most miraculous autocomplete function and supplies me with credible endings to any sentence I start—often credible nonsense. But when the nonsense is there on the page, next to thoughts I’ve settled through hard work, it looks respectable! It often takes considerable work to realize I’ve fooled myself.&lt;/p&gt;
    &lt;p&gt;This was another reason Hadamard’s subjects gave for why they were reluctant to use words: they were afraid of the false precision writing forces onto thinking. They were afraid of premature precision and the confusion it breeds. By thinking in blurry images, or tensions of the hands, or sounds, they could keep their thoughts accurately vague in the areas where there was still uncertainty. They wrote down on paper, as settled, only mostly what was actually known. If you are disciplined, you can write in such a way that you avoid false precision.&lt;/p&gt;
    &lt;p&gt;To sum up: the relationship between verbal thinking and deep wordless concentration is complex.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;
        &lt;p&gt;Non-verbal, blurry thinking is faster and can search in a broader way, but it is more error-prone than verbal thought.&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Good writing tends to come from an attempt to capture in words something you understand wordlessly, rather than moving ideas around on the page; but, paradoxically, a generative subconscious is usually one that has been trained by writing and deep reading, which provides the subconscious with relay results and other mental structures necessary for deep thought.&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Writing forces precision, which can fool us into locking in details we have no reason to lock in, but written notes (or drawings) are a necessary aid when thinking long chains of thoughts.&lt;/p&gt;
      &lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Over the last nine months, as I’ve been thinking about this topic, I’ve become more mindful about when words hinder and when they help. I notice that I spend more time in wordless thoughts than I used to. But I’m also more deliberate about using writing to structure my brain so it feeds me better thoughts.&lt;/p&gt;
    &lt;p&gt;As always, a big thank you to the paying subscribers who fund the work on the public essays. I couldn’t do this without you! I also want to thank Johanna Karlsson and Michael Nielsen for discussion about the topic. Esha Rana helped me with the final edit.&lt;/p&gt;
    &lt;p&gt;I can think of examples of mathematicians and physicist for whom this is not true. The first one who comes to mind is Richard Feynman, who said in an interview:&lt;/p&gt;
    &lt;head rend="h5"&gt;Feynman:&lt;/head&gt;
    &lt;p&gt;I actually did the work on the paper.&lt;/p&gt;
    &lt;head rend="h5"&gt;Weiner:&lt;/head&gt;
    &lt;p&gt;That s right. It wasn’t a record of what you had done but it is the work.&lt;/p&gt;
    &lt;head rend="h5"&gt;Feynman:&lt;/head&gt;
    &lt;p&gt;It’s the doing it — it’s the scrap paper.&lt;/p&gt;
    &lt;head rend="h5"&gt;Weiner:&lt;/head&gt;
    &lt;p&gt;Well, the work was done in your head but the record of it is still here.&lt;/p&gt;
    &lt;head rend="h5"&gt;Feynman:&lt;/head&gt;
    &lt;p&gt;No, it’s not a record, not really, it’s working. You have to work on paper and this is the paper. OK?&lt;/p&gt;
    &lt;p&gt;A more technical way of saying this is that our (non-verbal) thoughts seem to behave as vectors; when a cluster of neurons fire together, that pattern is like an address pointing toward a point in a high dimensional space. But when we convert our thoughts to words, we convert that vector into a scalar. I’m not sure if this is true, but here is a paper laying out the argument for why it might be.&lt;/p&gt;
    &lt;p&gt;The discussion of vectors and dimension reduction also has an interesting parallel to an ongoing discussion in AI research. When a large language model calculates what to output, the “thinking” happens in high dimensional space where vectors are passed from layer to layer. At the final layer, that high dimensional representation is collapsed into a token—the written output. When this happens, enormous amounts of information is lost: the residual stream contains over a thousand times more information than gets encoded into the token! That lends some support to the idea that non-verbal (partly unconscious) thinking might be more information rich in humans, too.&lt;/p&gt;
    &lt;p&gt;In reasoning models, where the LLM is encouraged to think for longer, what happens is that this written output—this collapsed thought—is fed back into the model as input, so it can keep thinking about it. It is as if a person were to lose all of their memories and thoughts every few seconds and could only rely on whatever conclusions they had written on a slip of paper; this seems, potentially, like a limited way of thinking. To come around this problem—if it is a problem—one idea that is being explored is to feed the entire vector back into the model as a chain of thought, instead of the tokens on the scratch pad. This would be something like letting the models think in a non-verbal mental space, akin to what Hadamard described—thinking in the latent space, rather than on the scratch pad.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://www.henrikkarlsson.xyz/p/wordless-thought"/><published>2025-10-23T21:26:57+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45687458</id><title>/dev/null is an ACID compliant database</title><updated>2025-10-24T20:38:46.411564+00:00</updated><content>&lt;doc fingerprint="8812dd1940f64a11"&gt;
  &lt;main&gt;
    &lt;head rend="h2"&gt;Atomicity&lt;/head&gt;
    &lt;p&gt;Operations are "all or nothing."&lt;/p&gt;
    &lt;p&gt;Anything you write to &lt;code&gt;/dev/null&lt;/code&gt; disappears entirely. There's no partial write problem: it’s either written (and discarded) or not written at all. ✅&lt;/p&gt;
    &lt;head rend="h2"&gt;Consistency&lt;/head&gt;
    &lt;p&gt;The system transitions from one valid state to another.&lt;/p&gt;
    &lt;p&gt;&lt;code&gt;/dev/null&lt;/code&gt; always stays in a consistent state (empty). No matter what you write, the invariant "file contains nothing" always holds. ✅&lt;/p&gt;
    &lt;head rend="h2"&gt;Isolation&lt;/head&gt;
    &lt;p&gt;Concurrent transactions don’t interfere with each other.&lt;/p&gt;
    &lt;p&gt;Multiple processes can write to &lt;code&gt;/dev/null&lt;/code&gt; at the same time, and their outputs never conflict, because nothing is ever stored. ✅&lt;/p&gt;
    &lt;head rend="h2"&gt;Durability&lt;/head&gt;
    &lt;p&gt;Once a transaction is committed, it remains so, even after crashes.&lt;/p&gt;
    &lt;p&gt;&lt;code&gt;/dev/null&lt;/code&gt; "durably" commits your data into nothingness. After a crash or reboot, it still contains exactly what it always has: nothing. ✅&lt;/p&gt;
    &lt;p&gt;There is only 1 small problem though, it only comes with 0b of free storage. For more space, you will have to contact entreprise sales, which is actually just me!&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://jyu.dev/blog/why-dev-null-is-an-acid-compliant-database/"/><published>2025-10-23T21:28:02+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45689241</id><title>Counter-Strike's player economy is in a multi-billion dollar freefall</title><updated>2025-10-24T20:38:45.952960+00:00</updated><content>&lt;doc fingerprint="b660f151878bcf98"&gt;
  &lt;main&gt;
    &lt;p&gt;Counter-Strike has long been known for two things: tight tactical FPS gameplay and a thriving player marketplace effectively valued at literal billions of dollars. Now, thanks to a recent update from Valve, the latter is in a downward spiral, having lost 25% of its value — or $1.75 billion — overnight.&lt;/p&gt;
    &lt;p&gt;First, some context. Counter-Strike is a free-to-play multiplayer shooter. As with most other F2P games, it generates revenue from selling cosmetics. They arrive in lootbox-like Cases, which are opened by Keys purchased with real-world currency. They can also be obtained through trading with other players and purchasing from Steam Community Market. Beyond Steam, unofficial third-party marketplaces for CS cosmetics have also popped up as channels for buying and selling items.&lt;/p&gt;
    &lt;p&gt;Because items are obtained at random through opening Cases, rarer items fetch the highest value on the open marketplaces. Items of lower-rarity tiers can also be traded in at volume for an item of a higher tier via trade up contracts. Previously, Knives and Gloves could not be obtained through trade up contracts, exponentially increasing their value as highly sought-after items. Prior to the most recent update, some Knives, like a Doppler Ruby Butterfly Knife, could fetch around $20,000 on third-party storefronts like CSFloat.&lt;/p&gt;
    &lt;p&gt;Following Valve's Oct. 22 update to Counter-Strike, the second-highest-tier, Covert (Red), can now be traded up and turned into Knives and Gloves. Essentially, this means that a previously extremely rare and highly sought-after cosmetic is going to be much more obtainable for those who increasingly want it, reducing the value of Knives and Gloves on the open marketplace.&lt;/p&gt;
    &lt;p&gt;And this is where the market descends into a freefall. Now, that Butterfly Knife mentioned above? It's going for around $12,000, as people are essentially dumping their stock, with 15 sold over the past 16 hours at the time of this writing.&lt;/p&gt;
    &lt;p&gt;Bloomberg reported the market for Counter-Strike cosmetic items dropped 25% overnight from Wednesday evening into Thursday morning. It's lost about $1.84 billion in value, according to Pricempire, which tracks and analyses the market for CS items. "This completely changes the supply of Counter-Strike’s most sought-after and expensive tier of items," Pricempire marketing manager Ethan MacDonald told Bloomberg.&lt;/p&gt;
    &lt;p&gt;As sellers attempt to recoup their investments, similar fire sales like the one happening at CSFloat are occurring at other sites. One such site, Skin Port, even put us in a waiting room to access it; traffic was overwhelming its servers.&lt;/p&gt;
    &lt;p&gt;Just like how NFT or cryptocurrency values can drastically shift, Counter-Strike item traders are seeing their stock rapidly change in value, and not for the best. While some items of lower-rarity tiers have gone up in value, and Reds might see a bump now that they can be traded up into Knives and Gloves, that can't make up for the sudden drop at the top of the cosmetics market.&lt;/p&gt;
    &lt;p&gt;We'll have to wait and see if the market levels out or if it continues to crash. Plenty of players and CS traders must be eagerly awaiting more news: As of this writing, Pricempire's servers had crashed.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://www.polygon.com/counter-strike-cs-player-economy-multi-billion-dollar-freefall/"/><published>2025-10-24T00:24:11+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45690251</id><title>Roc Camera</title><updated>2025-10-24T20:38:45.499924+00:00</updated><content>&lt;doc fingerprint="d8c40a7031a4502f"&gt;
  &lt;main&gt;
    &lt;head rend="h2"&gt;Photos used to be magic&lt;/head&gt;
    &lt;head rend="h2"&gt;Photosusedtobemagic&lt;/head&gt;
    &lt;p&gt;There was a time when cameras captured magic. Photos told stories of a certain moment in time, a reflection of reality, a physical artifact of lives.&lt;/p&gt;
    &lt;head rend="h2"&gt;AI has blurred the line&lt;/head&gt;
    &lt;head rend="h2"&gt;AIhasblurredtheline&lt;/head&gt;
    &lt;p&gt;Now, how we take, share, and create images has changed. Social media has made sharing images easy. Generative AI now creates any image we can imagine.&lt;/p&gt;
    &lt;head rend="h2"&gt;Lost sight of what is real&lt;/head&gt;
    &lt;head rend="h2"&gt;Lostsightofwhatisreal&lt;/head&gt;
    &lt;p&gt;We've started to lose sight of what is real. We've lost our ability to find our bearings in an endless sea of copies and AI-generated noise.&lt;/p&gt;
    &lt;head rend="h2"&gt;It's time for Roc Camera&lt;/head&gt;
    &lt;head rend="h2"&gt;It'stimeforRocCamera&lt;/head&gt;
    &lt;p&gt;By combining attested sensor data, zero-knowledge proofs, and a tamper-proof environment, we've built Roc Camera to capture verifiably real photos.&lt;/p&gt;
    &lt;head rend="h3"&gt;Camera Components:&lt;/head&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;â¢ 4-inch IPS LCD Screen 720x720 with Capacitive Touch&lt;/item&gt;
      &lt;item&gt;â¢ 16MP Sony IMX519 CMOS with 122Â° FOV lens&lt;/item&gt;
      &lt;item&gt;â¢ Raspberry Pi 4 4GB RAM ARM Cortex-A72 1.5 Ghz&lt;/item&gt;
      &lt;item&gt;â¢ LiPo 4000mAh Battery&lt;/item&gt;
      &lt;item&gt;â¢ Uninterruptible Power Supply Board&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h3"&gt;Capture&lt;/head&gt;
    &lt;p&gt;Capture a photo that only this Camera can uniquely take&lt;/p&gt;
    &lt;head rend="h3"&gt;Prove&lt;/head&gt;
    &lt;p&gt;Creates a Zero Knowledge (ZK) Proof of the camera sensor data and other metadatas&lt;/p&gt;
    &lt;head rend="h3"&gt;Verify&lt;/head&gt;
    &lt;p&gt;Verify that the photo is real by checking the ZK proof via the Roc Photo SDK&lt;/p&gt;
    &lt;head rend="h2"&gt;Capture verifiably real moments&lt;/head&gt;
    &lt;p&gt;Accepting orders now â (Batch 2)&lt;/p&gt;
    &lt;p&gt;Ships in 2~3 weeks&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://roc.camera/"/><published>2025-10-24T02:54:29+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45690840</id><title>'Attention is all you need' coauthor says he's 'sick' of transformers</title><updated>2025-10-24T20:38:45.435738+00:00</updated><content/><link href="https://venturebeat.com/ai/sakana-ais-cto-says-hes-absolutely-sick-of-transformers-the-tech-that-powers"/><published>2025-10-24T04:40:31+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45692585</id><title>Interstellar Mission to a Black Hole</title><updated>2025-10-24T20:38:45.057771+00:00</updated><content>&lt;doc fingerprint="b6467ad31861cbdb"&gt;
  &lt;main&gt;
    &lt;p&gt;We normally think of interstellar flight in terms of reaching a single target. The usual destination is one of the Alpha Centauri stars, and because we know of a terrestrial-mass planet there, Proxima Centauri emerges as the best candidate. I don’t recall Proxima ever being named as the destination Breakthrough Starshot officially had in mind, but there is such a distance between it (4.2 light years) and the next target, Barnard’s Star at some 5.96 light years, that it seems evident we will give the nod to Proxima. If, that is, we decide to go interstellar.&lt;/p&gt;
    &lt;p&gt;Let’s not forget, though, that if we build a beaming infrastructure either on Earth or in space that can accelerate a sail to a significant percentage of lightspeed, we can use it again and again. That means many possible targets. I like the idea of exploring other possibilities, which is why Cosimo Bambi’s ideas on black holes interest me. Associated with Fudan University in Shanghai as well as New Uzbekistan University in Tashkent, Bambi has been thinking about the proliferation of black holes in the galaxy, and the nearest one to us. I’ve been pondering his notions ever since reading about them last August.&lt;/p&gt;
    &lt;p&gt;Black holes are obviously hard to find as we scale down to solar mass objects, and right now the closest one to us is GAIA-BH1, some 1560 light years out. But reading Bambi’s most recent paper, I see that one estimate of the number of stellar mass black holes in our galaxy is 1.4 X 109. Bambi uses this number, but as we might expect, estimates vary widely, from 10 million to 1 billion. These numbers are extrapolated from the population of massive stars and to a very limited extent on clues from observational astronomy.&lt;/p&gt;
    &lt;p&gt;Image: The first image of Sagittarius A*, or Sgr A*, the supermassive black hole at the center of our galaxy. Given how hard it was to achieve this image, can we find ways to locate far smaller solar-mass black holes, and possibly send a mission to one? Credit: Event Horizon Telescope Collaboration.&lt;/p&gt;
    &lt;p&gt;Bambi calculates a population of 1 black hole and 10 white dwarfs for every 100 stars in the general population. If he’s anywhere close to right, a black hole might well exist within 20 to 25 light years, conceivably detected in future observations by its effects upon the orbital motion of a companion star, assuming we are so lucky as to find a black hole in a binary system. The aforementioned GAIA-BH1 is in such a system, orbiting a companion star.&lt;/p&gt;
    &lt;p&gt;Most black holes, though, are thought to be isolated. One black hole (OGLE-2011-BLG-0462) has been detected through microlensing, and perhaps LIGO A+, the upgrade to the two LIGO facilities in Hanford, Washington, and Livingston, Louisiana, can help us find more as we increase our skills at detecting gravitational waves. There are other options as well, as Bambi notes:&lt;/p&gt;
    &lt;quote&gt;
      &lt;p&gt;Murchikova &amp;amp; Sahu (2025) proposed to use observational facilities like the Square Kilometer Array (SKA), the Atacama Large Millimiter/Submillimiter Array (ALMA), and James Webb Space Telescope (JWST). Isolated black holes moving through the interstellar medium can accrete from the interstellar medium itself and such an accretion process produces electromagnetic radiation. Murchikova &amp;amp; Sahu (2025) showed that current observational facilities can already detect the radiation from isolated black holes in the warm medium of the Local Interstellar Cloud within 50 pc of Earth, but their identification as accreting black holes is challenging and requires multi-telescope observations.&lt;/p&gt;
    &lt;/quote&gt;
    &lt;p&gt;If we do find a black hole out there at, say, 10 light years, we now have a target for future beamed sailcraft that offers an entirely different mission concept. We’re now probing not simply an unknown planet, but an astrophysical object so bizarre that observing its effects on spacetime will be a primary task. Sending two nanocraft, one could observe the other as it approaches the black hole. A signal sent from one to the other will be affected by the spacetime metric – the ‘geometry’ of spacetime – which would give us information about the Kerr solution to the phenomenon. The latter assumes a rotating black hole, whereas other solutions, like that of Schwarzschild, describe a non-rotating black hole.&lt;/p&gt;
    &lt;p&gt;Also intriguing is Bambi’s notion of testing fundamental constants. Does atomic physics change in gravitational fields this strong? There have been some papers exploring possible variations in fundamental constants over time, but little by way of observation studying gravitational fields much stronger than white dwarf surfaces. Two nanocraft in the vicinity of a black hole may offer a way to emit photons whose energies can probe the nature of the fine structure constant. The latter sets the interactions between elementary charged particles.&lt;/p&gt;
    &lt;p&gt;For that matter, is a black hole inevitably possessed of an event horizon, or is it best described as an ‘horizonless compact object’ (Bambi’s term)?&lt;/p&gt;
    &lt;quote&gt;
      &lt;p&gt;In the presence of an event horizon, the signal from nanocraft B should be more and more redshifted (formally without disappearing, as an observer should never see a test-particle crossing the event horizon in a finite time, but, in practice, at some point the signal leaves the sensitivity band of the receiver on nanocraft A). If the compact object is a Kerr black hole, we can make clear predictions on the temporal evolution of the signal emitted by nanocraft B. If the compact object is a fuzzball [a bound state without event horizon], the temporal evolution of the signal should be different and presumably stop instantly when nanocraft B is converted into fuzzball degrees of freedom.&lt;/p&gt;
    &lt;/quote&gt;
    &lt;p&gt;There are so many things to learn about black holes that it is difficult to know where to begin, and I suspect that if many of our space probes have returned surprising results (think of the remarkable ‘heart’ on Pluto), a mission to a black hole would uncover mysteries and pose questions we have yet to ask. What an intriguing idea, and to my knowledge, no one else has made the point that if we ever reach the level of launching a mission to Proxima Centauri, we should be capable of engineering the same sort of flyby of a nearby black hole.&lt;/p&gt;
    &lt;p&gt;And on the matter of small black holes, be aware of a just released paper examining the role of dark matter in their formation. This one considers black holes on a much smaller scale, possibly making the chances of finding a nearby one that much greater. Let me quote the abstract (the italics are mine). The citation is below:&lt;/p&gt;
    &lt;quote&gt;
      &lt;p&gt;Exoplanets, with their large volumes and low temperatures, are ideal celestial detectors for probing dark matter (DM) interactions. DM particles can lose energy through scattering with the planetary interior and become gravitationally captured if their interaction with the visible sector is sufficiently strong. In the absence of annihilation, the captured DM thermalizes and accumulates at the planet’s center, eventually collapsing into black holes (BHs). Using gaseous exoplanets as an example, we demonstrate that BH formation can occur within an observable timescale for superheavy DM with masses greater than 106 GeV and nuclear scattering cross sections. The BHs may either accrete the planetary medium or evaporate via Hawking radiation, depending on the mass of the DM that formed them. We explore the possibility of periodic BH formation within the unconstrained DM parameter space and discuss potential detection methods, including observations of planetary-mass objects, pulsed high-energy cosmic rays, and variations in exoplanet temperatures. Our findings suggest that future extensive exoplanet observations could provide complementary opportunities to terrestrial and cosmological searches for superheavy DM.&lt;/p&gt;
    &lt;/quote&gt;
    &lt;p&gt;The paper is Bambi, “An interstellar mission to test astrophysical black holes,” iScience Volume 28, Issue 8113142 (August 15, 2025). Full text. The paper on black holes and dark matter is Phoroutan-Mehr &amp;amp; Fetherolf, “Probing superheavy dark matter with exoplanets,” Physical Review D Vol. 112 (20 August 2025), 036012 (full text).&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://www.centauri-dreams.org/2025/10/23/interstellar-mission-to-a-black-hole/"/><published>2025-10-24T09:17:24+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45692915</id><title>Debian Technical Committee overrides systemd change</title><updated>2025-10-24T20:38:44.465841+00:00</updated><content>&lt;doc fingerprint="decb083ff8077df8"&gt;
  &lt;main&gt;
    &lt;head rend="h1"&gt;Debian Technical Committee overrides systemd change&lt;/head&gt;
    &lt;quote&gt;Ready to give LWN a try?&lt;p&gt;With a subscription to LWN, you can stay current with what is happening in the Linux and free-software community and take advantage of subscriber-only site features. We are pleased to offer you a free trial subscription, no credit card required, so that you can see for yourself. Please, join us!&lt;/p&gt;&lt;/quote&gt;
    &lt;p&gt;Debian packagers have a great deal of latitude when it comes to the configuration of the software they package; they may opt, for example, to disable default features in software that they feel are a security hazard. However, packagers are expected to ensure that their packages comply with Debian Policy, regardless of the upstream's preferences. If a packager fails to comply with the policy, the Debian Technical Committee (TC) can step in to override them, which it has done in the case of a recent systemd change that broke several programs that depend on a world-writable /run/lock directory.&lt;/p&gt;
    &lt;p&gt;The Filesystem Hierarchy Standard (FHS) specifies that the /var/lock directory should be used to store lock files for devices and other resources shared by multiple applications. On Debian, /var/lock is a symbolic link to /run/lock. The /run directory is created as a tmpfs filesystem specifically for run-time files by systemd-tmpfiles during system startup.&lt;/p&gt;
    &lt;p&gt;Debian Policy still cites the FHS, even though the FHS has gone unmaintained for more than a decade. The specification was not so much finished as abandoned after FHS 3.0 was released—though there is a slow-moving effort to revive and revise the standard as FHS 4.0, it has not yet produced any results. Meanwhile, in the absence of a current standard, systemd has spun off its file-hierarchy documentation to the Linux Userspace API (UAPI) Group as a specification. LWN covered that development in August, related to Fedora's search for an FHS successor.&lt;/p&gt;
    &lt;head rend="h4"&gt;Locking up /run/lock&lt;/head&gt;
    &lt;p&gt;The /run/lock directory was deprecated in Systemd v258; rather than dropping the directory entirely, though, the project has changed the default to making /run/lock writable only by root, which is stricter than the permissions Debian had shipped with previously &lt;del&gt;rather than making it world-writable as in the past&lt;/del&gt;. The plan is to get rid of /run/lock entirely in the v259 release, though users (or distributions) can still retain the legacy behavior by adding a configuration file in /etc/tmpfiles.d to override systemd's defaults and create the directory with the desired permissions.&lt;/p&gt;
    &lt;p&gt;The Debian project just released a new stable version, Debian 13 ("trixie"), in August, and work has begun on Debian 14 ("forky"). The current stable version of Debian shipped with systemd v257, so users on stable will not be affected by these changes. But v258 has entered Debian unstable where the change to /run/lock broke other software, such as the Unix-to-Unix Copy program (UUCP) and the cu utility. Use of the directory is not limited to vintage utilities; Zbigniew Jędrzejewski-Szmek objected to removing /var/lock in v259 as it would break alsa-utils and create additional work for distributions:&lt;/p&gt;
    &lt;quote&gt;Doing this would this way just creat a foottrap for distributions: if they notice the change, they'll just create a local override, so we get a more complicated system in total with zero benefit to anyone. If they miss it, things will be broken for a while until users report it. And then they'll add the override.&lt;/quote&gt;
    &lt;p&gt;On August 13, Marco d'Itri—who is listed as a maintainer of the systemd package—filed a bug against the uucp package reporting that systemd v258-rc1-1 had broken uucico, along with filing a bug against the systemd package, which cited the FHS entry for /var/lock. He said that a compromise might be to make the directory writable by the dialout group rather than world-writable. He also mentioned that there was a previous effort in 2014 to modernize software that uses UUCP-style locks to use flock() instead, but it stalled out.&lt;/p&gt;
    &lt;head rend="h4"&gt;"Dead and severely outdated"&lt;/head&gt;
    &lt;p&gt;Rather than temporarily reverting the behavior, systemd maintainer Luca Boccassi argued that a world-writable directory in /run is a security risk. Any process could write as much as it wanted to /run, which could effectively DoS the system by exhausting space or inodes; filling up /run would then cause critical services, such as udev, to stop working. The FHS, he said, is "&lt;quote&gt;dead and severely outdated&lt;/quote&gt;".&lt;/p&gt;
    &lt;p&gt;The issue had already been discussed by the systemd project; Lennart Poettering had responded that he did not see the point of /var/lock "&lt;quote&gt;in the modern world&lt;/quote&gt;", but distributions were free to do as they see fit:&lt;/p&gt;
    &lt;quote&gt;
      &lt;p&gt;Consider this more a passing of the baton from upstream systemd to downstreams: if your distro wants this kind of legacy interface, then just add this via a distro-specific tmpfiles drop-in. But there's no point really in forcing anyone who has a more forward-looking view of the world to still carry that dir.&lt;/p&gt;
    &lt;/quote&gt;
    &lt;p&gt;Poettering argued that distributions could make their own choices, though it made him shudder to think of allowing unprivileged programs to fill up a directory. Boccassi echoed that sentiment in his response to the Debian systemd bug. Any package could ship a configuration for tmpfiles.d to create the directory and assume responsibility for it as well:&lt;/p&gt;
    &lt;quote&gt;
      &lt;p&gt;I certainly won't try to stop anyone wishing to do it, but also I do not wish for these old workarounds to ship in this package either.&lt;/p&gt;
      &lt;p&gt;There's ~2 years time until Forky ships, and that should be plenty of time to either add this workaround elsewhere, or fix remaining programs to use BSD locks, or both, so I'm not going to hold back the new version from testing for this niche case, sorry.&lt;/p&gt;
    &lt;/quote&gt;
    &lt;p&gt;Boccassi closed the bug with the "WONTFIX" tag.&lt;/p&gt;
    &lt;head rend="h4"&gt;Debian Policy&lt;/head&gt;
    &lt;p&gt;On September 1, d'Itri responded that upstream systemd's opinion was not relevant in this case. Debian policy requires the directory for lock files of serial devices, though he had also opened a bug to revisit that, since the practice of using /var/lock for serial-device locks dates back to the 1980s. However, /var/lock is provided by systemd, so he reasoned that it is a systemd bug unless another package was identified to take ownership of creating the directory. "&lt;quote&gt;But you cannot just decide that the policy violation does not exist.&lt;/quote&gt;"&lt;/p&gt;
    &lt;p&gt;Thorsten Alteholz opened a bug with Debian's Technical Committee on September 15. He asked for advice on how to proceed since the systemd bug had been marked WONTFIX.&lt;/p&gt;
    &lt;quote&gt;So what do you recommend how to go on from here? Change Debian policy (as asked in #1111839), revert the change in systemd, find a Debian wide solution or let every package maintainer implement their own solution?&lt;/quote&gt;
    &lt;p&gt;Bdale Garbee weighed in on the bug as well. He said that he uses cu "&lt;quote&gt;almost constantly for interacting with embedded serial consoles on devices a USB connection away from my laptop&lt;/quote&gt;". He was frustrated with the change imposed by systemd "&lt;quote&gt;with no warning&lt;/quote&gt;", and looked forward to the TC's response.&lt;/p&gt;
    &lt;p&gt;On September 24, Matthew Vernon responded to the bug, with a CC to the systemd maintainer alias. He said that it seemed that Debian Policy required FHS compliance, "&lt;quote&gt;at least until we come up with a transition plan&lt;/quote&gt;", and asked if systemd would please revert the change. There was no response from any of the systemd maintainers.&lt;/p&gt;
    &lt;head rend="h4"&gt;Override&lt;/head&gt;
    &lt;p&gt;Vernon updated the bug on September 29, and said that the TC had discussed the situation at its last meeting. The conclusion was that systemd should comply with policy, and thus FHS. He included a draft ballot text that the TC would vote on, which noted that the committee was "&lt;quote&gt;sympathetic&lt;/quote&gt;" to the argument that flock() would be a better solution, but that "&lt;quote&gt;an important part of the role of a Debian Developer is ensuring that software in Debian complies with Debian Policy&lt;/quote&gt;". A final ballot for the committee to consider was posted on October 2.&lt;/p&gt;
    &lt;p&gt;The ballot contained three options; all three required that the systemd package provide /var/lock "&lt;quote&gt;with relaxed enough permissions that existing Debian software that uses /var/lock for system-wide locks of serial devices (and similar purposes) works again&lt;/quote&gt;". The committee would exercise its power under the Debian Constitution to override the systemd maintainers. The options were:&lt;/p&gt;
    &lt;quote&gt;
      &lt;p&gt;1) This change to systemd must persist until a satisfactory migration of impacted software has occurred and Policy updated accordingly.&lt;/p&gt;
      &lt;p&gt;2) This change to systemd must persist until Policy has been updated to allow otherwise.&lt;/p&gt;
      &lt;p&gt;3) This change to systemd must persist until the TC allows otherwise, which the TC expects to do once a suitable transition plan has been agreed.&lt;/p&gt;
    &lt;/quote&gt;
    &lt;p&gt;Vernon replied on October 6 to say that a decision had been reached and that option one had won.&lt;/p&gt;
    &lt;head rend="h4"&gt;Unlocking&lt;/head&gt;
    &lt;p&gt;Debian's continued use of UUCP-style locking does seem to be more than a little bit dated. The FHS 3.0 is clearly reaching the end of its useful life, if not actually expired.&lt;/p&gt;
    &lt;p&gt;As a comparison, Fedora's uucp package has a patch to use lockdev instead. The upcoming Fedora 43 release includes systemd v258, and /run/lock is not world-writable. It seems like Debian could borrow Fedora's approach for the uucp package, though that would not solve the problem for any other Debian packages affected by the /run/lock change. There is also third-party software to consider, of course.&lt;/p&gt;
    &lt;p&gt;To date, Boccassi has not responded to the conversation; I emailed d'Itri to ask why he did not make the change himself, since he was aware of the bug. He replied on October 13 and said that "&lt;quote&gt;a maintainer cannot force a decision on another maintainer&lt;/quote&gt;." Since he and Boccassi disagreed about the change it was left to the TC to decide. He said that he planned to prepare a merge request to implement the TC's decision, "&lt;quote&gt;as I have already agreed with Luca&lt;/quote&gt;", within the week.&lt;/p&gt;
    &lt;p&gt; Posted Oct 13, 2025 19:34 UTC (Mon) by honschu (subscriber, #61008) [Link] (12 responses) Posted Oct 13, 2025 20:49 UTC (Mon) by mb (subscriber, #50428) [Link] (10 responses) That is not possible for users without source code. Posted Oct 13, 2025 21:49 UTC (Mon) by edgewood (subscriber, #1123) [Link] (7 responses) There's a difference between slowing down a reasonable change to give open source programs a chance to get updates and never making it because closed source programs can't update. Posted Oct 14, 2025 0:41 UTC (Tue) by smurf (subscriber, #17840) [Link] Posted Oct 14, 2025 1:25 UTC (Tue) by mjg59 (subscriber, #23239) [Link] (4 responses) Posted Oct 14, 2025 1:32 UTC (Tue) by josh (subscriber, #17465) [Link] (3 responses) Posted Oct 15, 2025 2:38 UTC (Wed) by Hello71 (subscriber, #103412) [Link] (2 responses) Posted Oct 15, 2025 3:12 UTC (Wed) by josh (subscriber, #17465) [Link] (1 responses) 1) Modern flock, modern traditional lock, legacy traditional lock: The modern program has the lock, the legacy program waits until the modern program is done. 2) Modern flock, legacy traditional lock, modern traditional lock: the legacy program has the lock, the modern program is waiting on the traditional lock before it can run. 3) Legacy traditional lock, modern flock, modern traditional lock: The legacy program has the lock, the modern program is waiting on the traditional lock before it can run. Posted Oct 16, 2025 13:17 UTC (Thu) by edeloget (subscriber, #88392) [Link] Posted Oct 19, 2025 7:20 UTC (Sun) by thoeme (subscriber, #2871) [Link] &amp;gt;add "a configuration file in /etc/tmpfiles.d to override systemd's defaults Posted Oct 13, 2025 21:58 UTC (Mon) by tux3 (subscriber, #101245) [Link] (1 responses) There are also historical artifacts that don't receive updates, don't have a source to patch, and don't have a community fixing the binary directly. The kernel doesn't break those too often, so for containers have worked nicely, as a little time capsule. But third-party binaries aren't really participating in this whole free software distribution project. You can't really plan around people who are doing their own thing and throwing opaque blobs over the wall every so often. Posted Oct 14, 2025 5:02 UTC (Tue) by notriddle (subscriber, #130608) [Link] You can, but you end up heavily limiting the amount of shared data that different subsystems/services/apps can see. Mere blocking isn't enough, because (1) this tends to result in systems that don't work when the permission is turned off, because that code path isn't tested (2) the existence of the file might be sensitive information in and of itself (3) what happens if two systems both think they should be able to use the same name for their things? This also means any change of behavior that's visible to the blob has to be opt-in. That's not how UNIX was designed. That's not even how Windows was designed, though MS has haphazardly added application-level namespacing features to patch around specific, widespread breakages. Hardened web browsers like Tor actually go in the right direction, but they only try to protect sites from each other: new APIs provided by the browser itself are dumped directly into the global namespace, and though they avoid adding anything that will cause widespread breakage, it's still possible for new browser-provided APIs to break a site by existing. Other than hardware virtualization systems like MAME, does anything actually do better on backwards compat than web browsers? Posted Oct 13, 2025 21:38 UTC (Mon) by dmv (subscriber, #168800) [Link] Posted Oct 13, 2025 22:22 UTC (Mon) by skissane (subscriber, #38675) [Link] (1 responses) Maybe I'm reading it wrong, but I came away from this article unclear what the final decision was. Posted Oct 13, 2025 22:38 UTC (Mon) by mjg59 (subscriber, #23239) [Link] Posted Oct 14, 2025 6:59 UTC (Tue) by stephanlachnit (subscriber, #151361) [Link] Posted Oct 14, 2025 7:36 UTC (Tue) by rgb (subscriber, #57129) [Link] (4 responses) Posted Oct 14, 2025 7:59 UTC (Tue) by MaZe (subscriber, #53908) [Link] (3 responses) Posted Oct 14, 2025 9:27 UTC (Tue) by rgb (subscriber, #57129) [Link] Posted Oct 14, 2025 11:14 UTC (Tue) by aragilar (subscriber, #122569) [Link] Posted Oct 14, 2025 12:38 UTC (Tue) by Jonno (subscriber, #49613) [Link] And if there is any problematic tmpfs mount in your typical Linux system it would be /dev/shm, as it has the same fs permissions, but mounted without noexec or any significant size restriction... Posted Oct 14, 2025 12:16 UTC (Tue) by eru (subscriber, #2753) [Link] Wouldn't setting a quota for /run/lock be a solution to this concern? Same for other shared directories for temporaries. Posted Oct 14, 2025 12:27 UTC (Tue) by gray_-_wolf (subscriber, #131074) [Link] (2 responses) Posted Oct 14, 2025 20:46 UTC (Tue) by fw (subscriber, #26023) [Link] (1 responses) The revert did not bring back the separate mount point, though: https://salsa.debian.org/systemd-team/systemd/-/commit/92... I don't know why things are done this way. Posted Oct 15, 2025 3:19 UTC (Wed) by lutchann (subscriber, #8872) [Link] Posted Oct 15, 2025 3:49 UTC (Wed) by raven667 (subscriber, #5198) [Link] (1 responses) Posted Oct 15, 2025 4:01 UTC (Wed) by mjg59 (subscriber, #23239) [Link] Posted Oct 16, 2025 7:44 UTC (Thu) by gdt (subscriber, #6284) [Link] (3 responses) The device /dev/ttyS0 is open()ed and flock(, LOCK_EX) applied. The terminal program now has exclusive use of the modem and proceeds to use it. Later a line condition causes Data Carrier Detect to drop. The way to reinitiate the modem link is to close() and re-open() the device file: this will drop and then re-assert the Data Terminal Ready line, which makes the modem re-attempt a connection. So with flock() there is a race condition which does not exist with a lock file: can the terminal program re-open() and re-flock() the device faster than the competition? The semantics of the lock file is "This program desires to use the serial device". That desire can remain even if the serial port is close()ed. The semantics of flock()ing the device cannot survive a close(). Posted Oct 16, 2025 12:31 UTC (Thu) by chris_se (subscriber, #99706) [Link] (2 responses) You can set the status of the DTR line via TIOCM_DTR on an open device, see also &amp;lt;https://man7.org/linux/man-pages/man2/TIOCMSET.2const.html&amp;gt;. There is no need to close the serial device. This is completely race-free. I don't think lockfiles are a good idea in any way, shape or form, because especially with modern containerization solutions, the only guarantee you have as a program is that if you can open() and flock() the device, you are allowed access to it. With containers you might not even see the same lock directory as the rest of the system (or another container), whereas you might have access to the same serial device. Hence I completely agree that getting rid of /var/lock and /run/lock is the right thing to do, it's just that in the current state of affairs this change should be coordinated with other software before the lock directory is phased out, so I do agree with Debian's TC's decision here. Side note: Actually, flock(, LOCK_EX) by itself is not sufficient to properly lock a serial port: every time a port is opened on Linux, at least some of the port's settings are reset to their defaults, even if it's already open. So the proper thing to do in my opinion is: 1) First flock(fd, LOCK_EX) it to avoid races You need both LOCK_EX and TIOCEXCL: TIOCEXCL prevents the open() command from other processes from working, so that other programs can't open the same device while your program is handling it, preventing some settings to be reset. flock() is still needed regardless, because otherwise you might have a race condition where process A calls open(), then process B calls open(), then process A calls ioctl(), and then process B calls ioctl(), and they both succeed (they would only prevent a process C from calling open() thereafter, the ioctls will both succeed), so use the flock() to avoid that specific race as well. (Caveat: TIOCEXCL doesn't help against root, but ideally you should run as little stuff as possible as root anyway.) Posted Oct 20, 2025 2:45 UTC (Mon) by gdt (subscriber, #6284) [Link] (1 responses) That changes the semantics of the end of a login session from a dial-in modem. The user terminates the shell, and that file close brings down DTR, clearing down the call. To adjust to this behaviour every shell will need to be updated. Whereas currently the system boot can create a lock file for every dial-in line to prevent its use by programs looking for a dial-out line. Posted Oct 20, 2025 16:11 UTC (Mon) by hmh (subscriber, #3838) [Link] It is worth considering that using /var/lock to ensure dial-in and dial-out separation, or any other "reservation" can, in the end, be decently implemented by naming the serial devices you want for dial-out differently from the ones for dial-in, etc (udev/mdev/etc are perfectly capable of being configured to do so). Giving it a good UX might not be that easy, though, and going distro-specific here is a major loss. The point about how classical tty-like devices behave ties in with the way other components (like the shells) work when plugged to a tty is very valuable. &lt;head&gt;Progress with a Plan&lt;/head&gt;&lt;head&gt;Progress with a Plan&lt;/head&gt;&lt;lb/&gt; What is your plan for those?&lt;head&gt;Progress with a Plan&lt;/head&gt;&lt;head&gt;Progress with a Plan&lt;/head&gt;&lt;head&gt;Progress with a Plan&lt;/head&gt;&lt;head&gt;Progress with a Plan&lt;/head&gt;&lt;head&gt;Progress with a Plan&lt;/head&gt;&lt;head&gt;Progress with a Plan&lt;/head&gt;&lt;head&gt;Progress with a Plan&lt;/head&gt;&lt;head&gt;Progress with a Plan&lt;/head&gt;&lt;lb/&gt; I wasn't aware of that possibility, something to check next monday at work.&lt;head&gt;Progress with a Plan&lt;/head&gt;&lt;lb/&gt; If you get updates from your third-party vendor, I suppose you'd talk to them to learn what the plan is.&lt;lb/&gt; More times than I'd like I've been held back from updating the distribution for the sake of enterprise-quality vendor tools.&lt;head&gt;Re: Progress with a Plan&lt;/head&gt;&lt;head&gt;Progress with a Plan&lt;/head&gt;&lt;head&gt;What is the actual technical solution here?&lt;/head&gt;&lt;head&gt;What is the actual technical solution here?&lt;/head&gt;&lt;head&gt;New Package&lt;/head&gt;&lt;head&gt;Single partition setups&lt;/head&gt;&lt;head&gt;Single partition setups&lt;/head&gt;&lt;lb/&gt; At least on my Fedora, /var/lock is -&amp;gt; /run/lock, and /run is tmpfs.&lt;head&gt;Single partition setups&lt;/head&gt;&lt;head&gt;Single partition setups&lt;/head&gt;&lt;head&gt;Single partition setups&lt;/head&gt;&lt;head&gt;Quota?&lt;/head&gt;&lt;quote&gt; shudder to think of allowing unprivileged programs to fill up a directory &lt;/quote&gt;&lt;head&gt;Why not a separate tmpfs?&lt;/head&gt;&lt;head&gt;Why not a separate tmpfs?&lt;/head&gt;&lt;head&gt;Why not a separate tmpfs?&lt;/head&gt;&lt;head&gt;Why was this a policy debate at all?&lt;/head&gt;&lt;head&gt;Why was this a policy debate at all?&lt;/head&gt;&lt;head&gt;flock() versus lock file semantics&lt;/head&gt;&lt;head&gt;flock() versus lock file semantics&lt;/head&gt;&lt;lb/&gt; 2) second ioctl(fd, TIOCEXCL) to prevent further opens&lt;head&gt;flock() versus lock file semantics&lt;/head&gt;&lt;head&gt;flock() versus lock file semantics&lt;/head&gt;&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://lwn.net/Articles/1041316/"/><published>2025-10-24T10:07:34+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45692984</id><title>Twake Drive – An open-source alternative to Google Drive</title><updated>2025-10-24T20:38:43.873190+00:00</updated><content>&lt;doc fingerprint="cb16d4485c6376c3"&gt;
  &lt;main&gt;
    &lt;p&gt; The open-source alternative to Google Drive. &lt;lb/&gt; Learn more » &lt;lb/&gt; Telegram | Website | Issues | Roadmap &lt;/p&gt;
    &lt;p&gt;To get a local copy up and running, please follow these simple steps.&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Clone the repo &lt;quote&gt;git clone https://github.com/linagora/twake-drive&lt;/quote&gt;&lt;/item&gt;
      &lt;item&gt;Run it with Docker &lt;code&gt;cd tdrive docker compose -f docker-compose.minimal.yml up&lt;/code&gt;&lt;/item&gt;
      &lt;item&gt;Open http://localhost/ in a browser&lt;/item&gt;
    &lt;/list&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Node.js (Version: &amp;gt;=18.x)&lt;/item&gt;
      &lt;item&gt;MongoDB&lt;/item&gt;
      &lt;item&gt;Yarn (recommended)&lt;/item&gt;
    &lt;/list&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;
        &lt;p&gt;Launch MongoDB using&lt;/p&gt;
        &lt;quote&gt;docker run -p 27017:27017 -d mongo&lt;/quote&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Launch frontend with&lt;/p&gt;
        &lt;quote&gt;cd tdrive/frontend/; yarn dev:start&lt;/quote&gt;
      &lt;/item&gt;
      &lt;item&gt;&lt;p&gt;Launch backend with&lt;/p&gt;&lt;quote&gt;cd tdrive/backend/node/; SEARCH_DRIVER=mongodb DB_DRIVER=mongodb PUBSUB_TYPE=local \ DB_MONGO_URI=mongodb://localhost:27017 STORAGE_LOCAL_PATH=/[full-path-to-store-documents]/documents \ NODE_ENV=development yarn dev&lt;/quote&gt;&lt;p&gt;If you need more parameters, create/edit&lt;/p&gt;&lt;code&gt;tdrive/backend/node/config/development.json&lt;/code&gt;file&lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;The app will be running on port 3000&lt;/p&gt;
      &lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Twake Drive is licensed under Affero GPL v3&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://github.com/linagora/twake-drive"/><published>2025-10-24T10:16:25+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45693325</id><title>Mesh2Motion – Open-source web application to animate 3D models</title><updated>2025-10-24T20:38:43.637390+00:00</updated><content>&lt;doc fingerprint="a9753601cfb2d489"&gt;
  &lt;main&gt;
    &lt;head rend="h3"&gt;ð¥³ Human &amp;amp; Animal rigs&lt;/head&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Supports importing GLB, GLTF, and FBX models&lt;/item&gt;
      &lt;item&gt;Human and animal skeleton options&lt;/item&gt;
      &lt;item&gt;Intuitive skeleton positioning&lt;/item&gt;
      &lt;item&gt;Undo/Redo system when you make mistakes&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h3"&gt;âï¸ Export Animations&lt;/head&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Export multiple animations at once&lt;/item&gt;
      &lt;item&gt;Uses widely-supported GLB format&lt;/item&gt;
      &lt;item&gt;Human animation library from Quaternius&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h2"&gt;Video Walkthrough&lt;/head&gt;
    &lt;head rend="h2"&gt;FREE &amp;amp; Open-Source&lt;/head&gt;
    &lt;p&gt;Mesh2Motion is an open-source project. With the way 3d animations and modeling tools are progressing, there just needs to be some tool like this that is open-source that can evolve. The goal of this project is to provide a free and easy way to animate 3D models for web and game engines. Everything should be freely available for both personal and commercial projects. Check out the GitHub repository for all the code.&lt;/p&gt;
    &lt;head rend="h2"&gt;Contact&lt;/head&gt;
    &lt;p&gt;The best place for bug reports and feedback is on the GitHub page. If you don't have GitHub, you could also try my socials:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;github.com/scottpetrovic/mesh2motion-app&lt;/item&gt;
      &lt;item&gt;@scottpetrovic&lt;/item&gt;
      &lt;item&gt;@scottpetrovic.bsky.social&lt;/item&gt;
    &lt;/list&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://mesh2motion.org/"/><published>2025-10-24T11:01:23+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45693591</id><title>ChunkLLM: A Lightweight Pluggable Framework for Accelerating LLMs Inference</title><updated>2025-10-24T20:38:43.506999+00:00</updated><content>&lt;doc fingerprint="8d9c1c23d1f186ae"&gt;
  &lt;main&gt;&lt;head rend="h1"&gt;Computer Science &amp;gt; Computation and Language&lt;/head&gt;&lt;p&gt; [Submitted on 28 Sep 2025]&lt;/p&gt;&lt;head rend="h1"&gt;Title:ChunkLLM: A Lightweight Pluggable Framework for Accelerating LLMs Inference&lt;/head&gt;View PDF HTML (experimental)&lt;quote&gt;Abstract:Transformer-based large models excel in natural language processing and computer vision, but face severe computational inefficiencies due to the self-attention's quadratic complexity with input tokens. Recently, researchers have proposed a series of methods based on block selection and compression to alleviate this problem, but they either have issues with semantic incompleteness or poor training-inference efficiency. To comprehensively address these challenges, we propose ChunkLLM, a lightweight and pluggable training framework. Specifically, we introduce two components: QK Adapter (Q-Adapter and K-Adapter) and Chunk Adapter. The former is attached to each Transformer layer, serving dual purposes of feature compression and chunk attention acquisition. The latter operates at the bottommost layer of the model, functioning to detect chunk boundaries by leveraging contextual semantic information. During the training phase, the parameters of the backbone remain frozen, with only the QK Adapter and Chunk Adapter undergoing training. Notably, we design an attention distillation method for training the QK Adapter, which enhances the recall rate of key chunks. During the inference phase, chunk selection is triggered exclusively when the current token is detected as a chunk boundary, thereby accelerating model inference. Experimental evaluations are conducted on a diverse set of long-text and short-text benchmark datasets spanning multiple tasks. ChunkLLM not only attains comparable performance on short-text benchmarks but also maintains 98.64% of the performance on long-context benchmarks while preserving a 48.58% key-value cache retention rate. Particularly, ChunkLLM attains a maximum speedup of 4.48x in comparison to the vanilla Transformer in the processing of 120K long texts.&lt;/quote&gt;&lt;head rend="h3"&gt;References &amp;amp; Citations&lt;/head&gt;&lt;p&gt; export BibTeX citation Loading... &lt;/p&gt;&lt;head rend="h1"&gt;Bibliographic and Citation Tools&lt;/head&gt;&lt;p&gt; Bibliographic Explorer (What is the Explorer?) &lt;/p&gt;&lt;p&gt; Connected Papers (What is Connected Papers?) &lt;/p&gt;&lt;p&gt; Litmaps (What is Litmaps?) &lt;/p&gt;&lt;p&gt; scite Smart Citations (What are Smart Citations?) &lt;/p&gt;&lt;head rend="h1"&gt;Code, Data and Media Associated with this Article&lt;/head&gt;&lt;p&gt; alphaXiv (What is alphaXiv?) &lt;/p&gt;&lt;p&gt; CatalyzeX Code Finder for Papers (What is CatalyzeX?) &lt;/p&gt;&lt;p&gt; DagsHub (What is DagsHub?) &lt;/p&gt;&lt;p&gt; Gotit.pub (What is GotitPub?) &lt;/p&gt;&lt;p&gt; Hugging Face (What is Huggingface?) &lt;/p&gt;&lt;p&gt; Papers with Code (What is Papers with Code?) &lt;/p&gt;&lt;p&gt; ScienceCast (What is ScienceCast?) &lt;/p&gt;&lt;head rend="h1"&gt;Demos&lt;/head&gt;&lt;head rend="h1"&gt;Recommenders and Search Tools&lt;/head&gt;&lt;p&gt; Influence Flower (What are Influence Flowers?) &lt;/p&gt;&lt;p&gt; CORE Recommender (What is CORE?) &lt;/p&gt;&lt;head rend="h1"&gt;arXivLabs: experimental projects with community collaborators&lt;/head&gt;&lt;p&gt;arXivLabs is a framework that allows collaborators to develop and share new arXiv features directly on our website.&lt;/p&gt;&lt;p&gt;Both individuals and organizations that work with arXivLabs have embraced and accepted our values of openness, community, excellence, and user data privacy. arXiv is committed to these values and only works with partners that adhere to them.&lt;/p&gt;&lt;p&gt;Have an idea for a project that will add value for arXiv's community? Learn more about arXivLabs.&lt;/p&gt;&lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://arxiv.org/abs/2510.02361"/><published>2025-10-24T11:41:26+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45693743</id><title>Padlet (YC W13) Is Hiring in San Francisco and Singapore</title><updated>2025-10-24T20:38:42.617488+00:00</updated><content>&lt;doc fingerprint="28684c070fcc5eec"&gt;
  &lt;main&gt;
    &lt;head rend="h1"&gt;LET'S GET TO WORK&lt;/head&gt;
    &lt;p&gt;Your morning cup of coffee.&lt;lb/&gt;The song you'll play at your wedding.&lt;lb/&gt;Football, either one.&lt;lb/&gt;The camera that recorded your first steps.&lt;lb/&gt;Air conditioning in the living room, hot water in the bathroom.&lt;lb/&gt;Your every comfort, every joy, every memory.&lt;lb/&gt;You have them because of someone's work,&lt;lb/&gt;because of a world at work,&lt;lb/&gt;because of generations that worked before us.&lt;lb/&gt;Making.&lt;lb/&gt;Saving.&lt;lb/&gt;Breaking.&lt;lb/&gt;Moving.&lt;lb/&gt;Wrestling inboxes that never tap out.&lt;lb/&gt;Five minutes to finish a ziplocked ham sandwich.&lt;lb/&gt;Trying to find parking. Always trying to find parking.&lt;lb/&gt;Knots in the gut before the lights turn on.&lt;lb/&gt;Blisters on fingers where the pencil meets the skin.&lt;lb/&gt;Snowfall or heatwave.&lt;lb/&gt;Stardust to sunrise.&lt;lb/&gt;They showed up for us.&lt;lb/&gt;Let's show up for them.&lt;lb/&gt;Let's move.&lt;lb/&gt;Let's break.&lt;lb/&gt;Let's save.&lt;lb/&gt;Let's make.&lt;lb/&gt;Let's get to work.&lt;/p&gt;
    &lt;p&gt;The song you'll play at your wedding.&lt;/p&gt;
    &lt;p&gt;Football, either one.&lt;/p&gt;
    &lt;p&gt;The camera that recorded your first steps.&lt;/p&gt;
    &lt;p&gt;Air conditioning in the living room, hot water in the bathroom.&lt;/p&gt;
    &lt;p&gt;Your every comfort, every joy, every memory.&lt;/p&gt;
    &lt;p&gt;You have them because of someone's work,&lt;/p&gt;
    &lt;p&gt;because of a world at work,&lt;/p&gt;
    &lt;p&gt;because of generations that worked before us.&lt;/p&gt;
    &lt;p&gt;Making.&lt;/p&gt;
    &lt;p&gt;Saving.&lt;/p&gt;
    &lt;p&gt;Breaking.&lt;/p&gt;
    &lt;p&gt;Moving.&lt;/p&gt;
    &lt;p&gt;Wrestling inboxes that never tap out.&lt;/p&gt;
    &lt;p&gt;Five minutes to finish a ziplocked ham sandwich.&lt;/p&gt;
    &lt;p&gt;Trying to find parking. Always trying to find parking.&lt;/p&gt;
    &lt;p&gt;Knots in the gut before the lights turn on.&lt;/p&gt;
    &lt;p&gt;Blisters on fingers where the pencil meets the skin.&lt;/p&gt;
    &lt;p&gt;Snowfall or heatwave.&lt;/p&gt;
    &lt;p&gt;Stardust to sunrise.&lt;/p&gt;
    &lt;p&gt;They showed up for us.&lt;/p&gt;
    &lt;p&gt;Let's show up for them.&lt;/p&gt;
    &lt;p&gt;Let's move.&lt;/p&gt;
    &lt;p&gt;Let's break.&lt;/p&gt;
    &lt;p&gt;Let's save.&lt;/p&gt;
    &lt;p&gt;Let's make.&lt;/p&gt;
    &lt;p&gt;Let's get to work.&lt;/p&gt;
    &lt;p&gt;Nitesh&lt;/p&gt;
    &lt;p&gt;Founder and CEO&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://padlet.jobs"/><published>2025-10-24T12:01:08+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45693978</id><title>Typst 0.14</title><updated>2025-10-24T20:38:41.316992+00:00</updated><content>&lt;doc fingerprint="7e9e51106fe534cc"&gt;
  &lt;main&gt;
    &lt;p&gt;Typst 0.14 is out now. With accessibility by default, PDFs as images, character-level justification, and more, it has everything you need to move from draft to production.&lt;/p&gt;
    &lt;p&gt;Typst's origins lie in academia, but over the past year, we've seen it expand to so much more. It's increasingly being used in the industry: For manually written documents, partially automated reports, and in fully automated batch PDF generation pipelines. Across these use cases, it's being used in production for critical documents.&lt;/p&gt;
    &lt;p&gt;In August, we launched a new website to reflect Typst's expanding scope, and now, with Typst 0.14, we're shipping crucial features that make Typst even more widely applicable.&lt;/p&gt;
    &lt;p&gt;If you need to comply with accessibility-related regulations, Typst 0.14 has your back. Typst now generates accessible documents by default, with opt-in support for stricter checks. For those working with complex illustrations, PDFs are now supported as a native image format. In case you're typesetting a book, the new character-level justification will give your layout the final touch. And if you're building a website or blog, many improvements to Typst's HTML export are waiting for you.&lt;/p&gt;
    &lt;head rend="h2"&gt;Contents&lt;/head&gt;
    &lt;p&gt;In this blog post, we'll take a closer look at the highlights of this release:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Accessibility&lt;/item&gt;
      &lt;item&gt;PDF standards&lt;/item&gt;
      &lt;item&gt;PDFs as images&lt;/item&gt;
      &lt;item&gt;Character-level justification&lt;/item&gt;
      &lt;item&gt;Richer HTML export&lt;/item&gt;
      &lt;item&gt;Migrating to Typst 0.14&lt;/item&gt;
      &lt;item&gt;Community Call&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;To get started with Typst 0.14…&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;…in the web app: Just open any of your projects! You'll get a prompt offering you to upgrade to the latest version.&lt;/item&gt;
      &lt;item&gt;…on the command line: Run &lt;code&gt;typst update&lt;/code&gt;in your terminal or, if you haven't installed Typst previously, download the latest version of the CLI.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;For a comprehensive overview of all changes in the release, visit the changelog. If you're looking to upgrade your document to Typst 0.14, you can also skip ahead to the Migration section.&lt;/p&gt;
    &lt;head rend="h2"&gt;Accessibility&lt;/head&gt;
    &lt;p&gt;Not everyone reads PDF documents the same. Some people read on large screens or print; others use small phones or screen readers to have documents read aloud. To cater to all these uses, a file must contain tags that allow Assistive Technology (AT) like screen readers to learn about the reading order and semantic meaning of each piece of text. Tags allow AT users to learn which text is &lt;code&gt;*strongly emphasized*&lt;/code&gt;, enable navigation of the document by skipping between headings, and more.&lt;/p&gt;
    &lt;p&gt;Tagging requires no additional work from you: If you are using the built-in markup and elements, Typst will automatically select the right tags! Unlike many other tools, PDF files created with Typst 0.14 are tagged by default, raising the bar for accessibility.&lt;/p&gt;
    &lt;p&gt;But tags are not enough to make a file accessible: To reach everyone, you need to design for universal accessibility from the start. The new features in Typst 0.14 can help you with that. Consider diagrams created with shapes or packages like cetz—their visual meaning is invisible to assistive technology. The new &lt;code&gt;alt&lt;/code&gt; parameter on figures solves this:&lt;/p&gt;
    &lt;code&gt;#figure(
  stack(
    dir: ltr,
    spacing: 0.5em,
    rect[Tagged PDF],
    text(2em, sym.arrow.long),
    rect[Accessibility],
  ),
  alt: "Diagram with two rectangles. The first is labelled 'Tagged PDF'. An arrow points to the second, labelled 'Accessibility'",
  caption: [
    Tags enable PDF accessibility
  ],
)
&lt;/code&gt;
    &lt;p&gt;With this change, AT users hear the alternative description and can grasp the figure's purpose just like sighted users—no information is lost. We have put together a new Accessibility Guide that contains more tips on how to create accessible documents, including how to write good alternative descriptions, when to use the figure's vs. the image's &lt;code&gt;alt&lt;/code&gt; parameter, and more.&lt;/p&gt;
    &lt;p&gt;To make sure you got everything right, you can enable the new PDF/UA-1 export. PDF/UA is an international standard that helps to create universally accessible PDF files. When it is enabled, Typst will run additional checks against your document to find accessibility issues and optimize for accessibility rather than compatibility. It will find issues such as missing document titles, wrong heading hierarchies, and missing alternative descriptions.&lt;/p&gt;
    &lt;p&gt;PDF/UA-1 helps you comply with existing and upcoming international accessibility regulation like the European Accessibility Act (EAA) in the EU and the new Americans with Disabilities Act's (ADA) Title II guidance by the DOJ. The former applies to many businesses active in the European Union since 28 June 2025 while the deadline for the latter is set for April 24, 2026. If you are using Typst in your business for customer- or government-facing documents, you should adopt Typst 0.14 as soon as possible.&lt;/p&gt;
    &lt;head rend="h2"&gt;PDF standards&lt;/head&gt;
    &lt;p&gt;Alongside PDF/UA-1 support, we've also generally expanded Typst's support for PDF standards. Instead of just PDF 1.7, you can now choose between the PDF versions 1.4, 1.5, 1.6, 1.7, and 2.0. And for PDF/A, we've expanded support from just two specific substandards to all four parts with all their conformance levels. While Typst's defaults are perfectly fine for most use cases, choosing a standard can optimize your document specifically for your use case. Consult the expanded PDF documentation in the reference for guidance on which standards you should pick under which circumstances.&lt;/p&gt;
    &lt;head rend="h2"&gt;PDFs as images&lt;/head&gt;
    &lt;p&gt;Staying with the PDF theme, there are exciting news for authors that have a lot of complex illustrations. Typst now supports PDF as a native image format. What I personally find most exciting about it, is that PDF images are supported across all export targets, and for each export target in the most suitable format. In PDF export, PDFs are naturally directly embedded. Meanwhile, in HTML and SVG export, PDFs are converted to an embedded SVG on-the-fly. And, finally, in PNG export and the web app preview, PDFs are rasterized. All of this PDF processing functionality lives right in the Typst compiler, with no system dependencies. This is only possible thanks to the amazing work of community member @LaurenzV, who created a new PDF processing library called &lt;code&gt;hayro&lt;/code&gt; from scratch. The library is 100% written in the programming language Rust (which is also the language we use for the Typst compiler) and is thus highly portable.&lt;/p&gt;
    &lt;code&gt;#figure(
  image(
    "throwing-success.pdf",
    alt: "A diagram titled 'Throwing Success' that .."
  ),
  caption: [
    Effect of normalized thrust
    on X and Y position of
    thrown emojis
  ],
)
&lt;/code&gt;
    &lt;head rend="h2"&gt;Character-level justification&lt;/head&gt;
    &lt;p&gt;Producing a visually balanced paragraph was once a fine art, when professional typesetters still carefully set paragraphs with movable type. Nowadays, you could hope that optimal paragraph typesetting is a solved problem across all our software. But, alas, it is not!&lt;/p&gt;
    &lt;p&gt;There are different strategies we can employ to produce a well-justified paragraph. Of course, to justify the paragraph, we need to stretch each line to the width of the measure. There are different ways to do this: Most obviously, we can adjust the spacing between words. This is what most software does. But we can also adjust the spacing between characters. This is now implemented in Typst.&lt;/p&gt;
    &lt;p&gt;Other methods to do this (which we want to explore in the future) include stretching the width of characters (this is best done with variable fonts) or, for some scripts, inserting special textual elements. For example, in Arabic, there are Kashida, which allow spacing out glyphs in words by extending the connectors between individual glyphs.&lt;/p&gt;
    &lt;p&gt;But that's just part of the recipe. Arguably, the even more crucial part is how this interplays with which linebreaks we chose to insert. Naively, we can choose our break points based on how much text fits and then perform the stretching. But we can do much better by taking into account each line's potential for stretching with the various mechanisms discussed above! We can then choose the break points that minimize the amount of bad-looking stretching.&lt;/p&gt;
    &lt;p&gt;I was initially skeptical about supporting character-level justification because I've seen it done poorly in some books. But that's actually not the fault of character-level justification per se; it's just excessive use of it. Tastefully chosen maxima—together with an algorithm that minimizes displeasing typography—make it bring out the best in justification.&lt;/p&gt;
    &lt;p&gt;We hear a lot about microtypography when people compare Typst with LaTeX. And even though Typst uses the same fundamental algorithm as LaTeX does to optimize paragraphs, it's true that LaTeX has some extra tricks up its sleeve. Now we do too though, as character-level justification is a feature that LaTeX does not support.&lt;/p&gt;
    &lt;head rend="h2"&gt;Richer HTML Export&lt;/head&gt;
    &lt;p&gt;In Typst 0.13, we shipped a first, highly experimental version of HTML export. This very minimal version already introduced the primitives for flexible HTML generation. With these primitives, the mapping of Typst elements to HTML can be expressed through show rules, just like the mapping to visual elements is performed in paged export.&lt;/p&gt;
    &lt;p&gt;What was lacking though were show rules for many built-in elements, including elements like footnotes, outlines, and citations. Typst 0.14 makes good progress in this regard. Most semantic elements (those from the Model category) are now properly mapped to semantic HTML. We've also improved handling of textual content in HTML export. The more visualization- and styling-focused parts of Typst's standard library remain largely unsupported, but we plan to add support for those (to the extent possible) in the future.&lt;/p&gt;
    &lt;p&gt;Below, you can see an example of a small, but non-trivial Typst document exported to HTML with Typst 0.14.&lt;/p&gt;
    &lt;code&gt;#set heading(numbering: "1.")

= Introduction &amp;lt;intro&amp;gt;
In @intro, let's cite @netwok.

#bibliography("works.bib")
&lt;/code&gt;
    &lt;quote&gt;&amp;lt;!-- html, head, and body omitted for brevity --&amp;gt; &amp;lt;h2 id="intro"&amp;gt;1. Introduction&amp;lt;/h2&amp;gt; &amp;lt;p&amp;gt; In &amp;lt;a href="#intro"&amp;gt;Section 1&amp;lt;/a&amp;gt;, let’s cite &amp;lt;a id="loc-1" href="#loc-2" role="doc-biblioref"&amp;gt;[1]&amp;lt;/a&amp;gt;. &amp;lt;/p&amp;gt; &amp;lt;section role="doc-bibliography"&amp;gt; &amp;lt;h2&amp;gt;Bibliography&amp;lt;/h2&amp;gt; &amp;lt;ul style="list-style-type: none"&amp;gt; &amp;lt;li id="loc-2"&amp;gt; &amp;lt;span class="prefix"&amp;gt;&amp;lt;a href="#loc-1" role="doc-backlink"&amp;gt;[1]&amp;lt;/a&amp;gt;&amp;lt;/span&amp;gt; R. Astley and L. Morris, “At-scale impact of the Net Wok: A culinarically holistic investigation of distributed dumplings,” &amp;lt;em&amp;gt;Armenian Journal of Proceedings&amp;lt;/em&amp;gt;, vol. 61, pp. 192–219, 2020. &amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;/section&amp;gt;&lt;/quote&gt;
    &lt;p&gt;Another exciting addition to HTML export is the new typed HTML interface. Typst's &lt;code&gt;html&lt;/code&gt; module now includes functions for constructing HTML elements with strongly-typed attributes. This means you can now write&lt;/p&gt;
    &lt;code&gt;#html.video(
  autoplay: true,
  width: 1280,
  height: 720,
  src: "sunrise.mp4",
)
&lt;/code&gt;
    &lt;p&gt;instead of&lt;/p&gt;
    &lt;code&gt;#html.elem("video", attrs: (
  autoplay: "",
  width: "1280",
  height: "720",
  src: "sunrise.mp4",
))
&lt;/code&gt;
    &lt;p&gt;As you can see, attributes are mapped to idiomatic Typst-native types.&lt;/p&gt;
    &lt;p&gt;Last but not least, we're happy to announce that HTML export will soon come to the Typst web app. We're still polishing up the implementation, but plan to ship it in the coming weeks.&lt;/p&gt;
    &lt;p&gt;Please note that HTML export remains experimental. To enable it in the CLI, pass &lt;code&gt;--features html&lt;/code&gt; or set &lt;code&gt;TYPST_FEATURES=html&lt;/code&gt;. In the web app, support for HTML export will also need to be enabled on a per-project basis.&lt;/p&gt;
    &lt;head rend="h2"&gt;Migrating to Typst 0.14&lt;/head&gt;
    &lt;p&gt;As far as breaking changes and deprecations go, this is a pretty calm release. Most documents should continue to work as before. There are a few minor breaking changes that make certain validations more strict. For instance, labels, link URLs, and font lists may not be empty anymore. To learn about all breaking changes, consult the changelog and search for "breaking change".&lt;/p&gt;
    &lt;p&gt;The release also contains a few deprecations. In particular, you'll need to replace any use of &lt;code&gt;pdf.embed&lt;/code&gt; with &lt;code&gt;pdf.attach&lt;/code&gt;. Moreover, two bibliography styles were renamed and the &lt;code&gt;--make-deps&lt;/code&gt; CLI flag was deprecated in favor of the new, more flexible &lt;code&gt;--deps&lt;/code&gt; flag with &lt;code&gt;--deps-format make&lt;/code&gt;. There are also a few deprecated symbols. The compiler will warn you about all use of deprecated functionality.&lt;/p&gt;
    &lt;head rend="h3"&gt;In the web app&lt;/head&gt;
    &lt;p&gt;With this release, we're also bringing a better version upgrade experience to the web app. Previously, projects would always use the latest compiler version unless explicitly pinned to a specific version in the settings side panel.&lt;/p&gt;
    &lt;p&gt;We are now phasing out the "Latest" option. Instead, the web app detects when a new version is available since you've last edited a project, and offers you to upgrade. The upgrade assistant includes an automatic compatibility check that compiles your document with both versions, makes a verdict, and lists new errors and warnings.&lt;/p&gt;
    &lt;head rend="h2"&gt;Community Call&lt;/head&gt;
    &lt;p&gt;Typst 0.14 is the result of 8 months of hard work by us and the community. We hope you are as excited about it as we are!&lt;/p&gt;
    &lt;p&gt;Speaking of the community—We're hosting a community call on Discord on Friday, November 7th. Join us to share your experiences with the new version and to chat with the community!&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://typst.app/blog/2025/typst-0.14/"/><published>2025-10-24T12:33:10+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45694111</id><title>Traffic Light Protocol</title><updated>2025-10-24T20:38:41.093689+00:00</updated><content>&lt;doc fingerprint="e6926b83d677835f"&gt;
  &lt;main&gt;
    &lt;p&gt;TLP version 2.0 is the current version of TLP standardized by FIRST. It is authoritative from August 2022 onwards&lt;/p&gt;
    &lt;p&gt;a. The Traffic Light Protocol (TLP) was created to facilitate greater sharing of potentially sensitive information and more effective collaboration. Information sharing happens from an information source, towards one or more recipients. TLP is a set of four labels used to indicate the sharing boundaries to be applied by the recipients. Only labels listed in this standard are considered valid by FIRST.&lt;/p&gt;
    &lt;p&gt;b. The four TLP labels are: TLP:RED, TLP:AMBER, TLP:GREEN, and TLP:CLEAR. In written form, they MUST not contain spaces and SHOULD be in capitals. TLP labels MUST remain in their original form, even when used in other languages: content can be translated, but the labels cannot.&lt;/p&gt;
    &lt;p&gt;c. TLP provides a simple and intuitive schema for indicating with whom potentially sensitive information can be shared. TLP is not a formal classification scheme. TLP was not designed to handle licensing terms, nor information handling or encryption rules. TLP labels and their definitions are not intended to have any effect on freedom of information or “sunshine” laws in any jurisdiction.&lt;/p&gt;
    &lt;p&gt;d. TLP is optimized for ease of adoption, human readability and person-to-person sharing; it may be used in automated information exchange systems, such as MISP or IEP.&lt;/p&gt;
    &lt;p&gt;e. TLP is distinct from the Chatham House Rule, but may be used in conjunction when appropriate. When a meeting is held under the Chatham House Rule, participants are free to use the information received, but neither the identity nor the affiliation of the speaker(s), nor that of any other participant, may be revealed.&lt;/p&gt;
    &lt;p&gt;f. The source is responsible for ensuring that recipients of TLP-labeled information understand and can follow TLP sharing guidance.&lt;/p&gt;
    &lt;p&gt;g. The source is at liberty to specify additional sharing restrictions. These must be adhered to by recipients.&lt;/p&gt;
    &lt;p&gt;h. If a recipient needs to share information more widely than indicated by the TLP label it came with, they must obtain explicit permission from the source.&lt;/p&gt;
    &lt;p&gt;a. How to use TLP in messaging (such as email and chat)&lt;lb/&gt; TLP-labeled messaging MUST indicate the TLP label of the information, as well as any additional restrictions, directly prior to the information itself. The TLP label SHOULD be in the subject line of email. Where needed, also make sure to designate the end of the text to which the TLP label applies.&lt;/p&gt;
    &lt;p&gt;b. How to use TLP in documents TLP-labeled documents MUST indicate the TLP label of the information, as well as any additional restrictions, in the header and footer of each page. The TLP label SHOULD be in 12-point type or greater for users with low vision. It is recommended to right-justify TLP labels.&lt;/p&gt;
    &lt;p&gt;c. How to use TLP in automated information exchanges TLP usage in automated information exchanges is not defined: this is left to the designers of such exchanges, but MUST be in accordance with this standard.&lt;/p&gt;
    &lt;p&gt;d. TLP color-coding in RGB, CMYK and Hex&lt;/p&gt;
    &lt;table&gt;
      &lt;row span="17"&gt;
        &lt;cell&gt;RGB:&lt;p&gt;font&lt;/p&gt;&lt;/cell&gt;
        &lt;cell&gt;RGB:&lt;p&gt;background&lt;/p&gt;&lt;/cell&gt;
        &lt;cell&gt;CMYK:&lt;p&gt;font&lt;/p&gt;&lt;/cell&gt;
        &lt;cell&gt;CMYK:&lt;p&gt;background&lt;/p&gt;&lt;/cell&gt;
        &lt;cell&gt;Hex:&lt;p&gt;font&lt;/p&gt;&lt;/cell&gt;
        &lt;cell&gt;Hex:&lt;p&gt;background&lt;/p&gt;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="17"&gt;
        &lt;cell&gt;R&lt;/cell&gt;
        &lt;cell&gt;G&lt;/cell&gt;
        &lt;cell&gt;B&lt;/cell&gt;
        &lt;cell&gt;R&lt;/cell&gt;
        &lt;cell&gt;G&lt;/cell&gt;
        &lt;cell&gt;B&lt;/cell&gt;
        &lt;cell&gt;C&lt;/cell&gt;
        &lt;cell&gt;M&lt;/cell&gt;
        &lt;cell&gt;Y&lt;/cell&gt;
        &lt;cell&gt;K&lt;/cell&gt;
        &lt;cell&gt;C&lt;/cell&gt;
        &lt;cell&gt;M&lt;/cell&gt;
        &lt;cell&gt;Y&lt;/cell&gt;
        &lt;cell&gt;K&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="17"&gt;
        &lt;cell&gt;TLP:RED&lt;/cell&gt;
        &lt;cell&gt;255&lt;/cell&gt;
        &lt;cell&gt;43&lt;/cell&gt;
        &lt;cell&gt;43&lt;/cell&gt;
        &lt;cell&gt;0&lt;/cell&gt;
        &lt;cell&gt;0&lt;/cell&gt;
        &lt;cell&gt;0&lt;/cell&gt;
        &lt;cell&gt;0&lt;/cell&gt;
        &lt;cell&gt;83&lt;/cell&gt;
        &lt;cell&gt;83&lt;/cell&gt;
        &lt;cell&gt;0&lt;/cell&gt;
        &lt;cell&gt;0&lt;/cell&gt;
        &lt;cell&gt;0&lt;/cell&gt;
        &lt;cell&gt;0&lt;/cell&gt;
        &lt;cell&gt;100&lt;/cell&gt;
        &lt;cell&gt;#FF2B2B&lt;/cell&gt;
        &lt;cell&gt;#000000&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="17"&gt;
        &lt;cell&gt;TLP:AMBER&lt;/cell&gt;
        &lt;cell&gt;255&lt;/cell&gt;
        &lt;cell&gt;192&lt;/cell&gt;
        &lt;cell&gt;0&lt;/cell&gt;
        &lt;cell&gt;0&lt;/cell&gt;
        &lt;cell&gt;0&lt;/cell&gt;
        &lt;cell&gt;0&lt;/cell&gt;
        &lt;cell&gt;0&lt;/cell&gt;
        &lt;cell&gt;25&lt;/cell&gt;
        &lt;cell&gt;100&lt;/cell&gt;
        &lt;cell&gt;0&lt;/cell&gt;
        &lt;cell&gt;0&lt;/cell&gt;
        &lt;cell&gt;0&lt;/cell&gt;
        &lt;cell&gt;0&lt;/cell&gt;
        &lt;cell&gt;100&lt;/cell&gt;
        &lt;cell&gt;#FFC000&lt;/cell&gt;
        &lt;cell&gt;#000000&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="17"&gt;
        &lt;cell&gt;TLP:GREEN&lt;/cell&gt;
        &lt;cell&gt;51&lt;/cell&gt;
        &lt;cell&gt;255&lt;/cell&gt;
        &lt;cell&gt;0&lt;/cell&gt;
        &lt;cell&gt;0&lt;/cell&gt;
        &lt;cell&gt;0&lt;/cell&gt;
        &lt;cell&gt;0&lt;/cell&gt;
        &lt;cell&gt;79&lt;/cell&gt;
        &lt;cell&gt;0&lt;/cell&gt;
        &lt;cell&gt;100&lt;/cell&gt;
        &lt;cell&gt;0&lt;/cell&gt;
        &lt;cell&gt;0&lt;/cell&gt;
        &lt;cell&gt;0&lt;/cell&gt;
        &lt;cell&gt;0&lt;/cell&gt;
        &lt;cell&gt;100&lt;/cell&gt;
        &lt;cell&gt;#33FF00&lt;/cell&gt;
        &lt;cell&gt;#000000&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;cell&gt;TLP:CLEAR&lt;/cell&gt;
        &lt;cell&gt;255&lt;/cell&gt;
        &lt;cell&gt;255&lt;/cell&gt;
        &lt;cell&gt;255&lt;/cell&gt;
        &lt;cell&gt;0&lt;/cell&gt;
        &lt;cell&gt;0&lt;/cell&gt;
        &lt;cell&gt;0&lt;/cell&gt;
        &lt;cell&gt;0&lt;/cell&gt;
        &lt;cell&gt;0&lt;/cell&gt;
        &lt;cell&gt;0&lt;/cell&gt;
        &lt;cell&gt;0&lt;/cell&gt;
        &lt;cell&gt;0&lt;/cell&gt;
        &lt;cell&gt;0&lt;/cell&gt;
        &lt;cell&gt;0&lt;/cell&gt;
        &lt;cell&gt;100&lt;/cell&gt;
        &lt;cell&gt;#FFFFFF&lt;/cell&gt;
        &lt;cell&gt;#000000&lt;/cell&gt;
      &lt;/row&gt;
    &lt;/table&gt;
    &lt;p&gt;Note on color-coding: when there is too little color contrast between text and background, those with low vision struggle to read text or cannot see it at all. TLP is designed to accommodate those with low vision. Sources SHOULD adhere to the TLP color-coding to ensure enough color contrast for such readers.&lt;/p&gt;
    &lt;p&gt;Community: Under TLP, a community is a group who share common goals, practices, and informal trust relationships. A community can be as broad as all cybersecurity practitioners in a country (or in a sector or region).&lt;/p&gt;
    &lt;p&gt;Organization: Under TLP, an organization is a group who share a common affiliation by formal membership and are bound by common policies set by the organization. An organization can be as broad as all members of an information sharing organization, but rarely broader.&lt;/p&gt;
    &lt;p&gt;Clients: Under TLP, clients are those people or entities that receive cybersecurity services from an organization. Clients are by default included in TLP:AMBER so that the recipients may share information further downstream in order for clients to take action to protect themselves. For teams with national responsibility this definition includes stakeholders and constituents.&lt;/p&gt;
    &lt;p&gt;a. TLP:RED = For the eyes and ears of individual recipients only, no further disclosure. Sources may use TLP:RED when information cannot be effectively acted upon without significant risk for the privacy, reputation, or operations of the organizations involved. Recipients may therefore not share TLP:RED information with anyone else. In the context of a meeting, for example, TLP:RED information is limited to those present at the meeting.&lt;/p&gt;
    &lt;p&gt;b. TLP:AMBER = Limited disclosure, recipients can only spread this on a need-to-know basis within their organization and its clients. Note that TLP:AMBER+STRICT restricts sharing to the organization only. Sources may use TLP:AMBER when information requires support to be effectively acted upon, yet carries risk to privacy, reputation, or operations if shared outside of the organizations involved. Recipients may share TLP:AMBER information with members of their own organization and its clients, but only on a need-to-know basis to protect their organization and its clients and prevent further harm. Note: if the source wants to restrict sharing to the organization only, they must specify TLP:AMBER+STRICT.&lt;/p&gt;
    &lt;p&gt;c. TLP:GREEN = Limited disclosure, recipients can spread this within their community. Sources may use TLP:GREEN when information is useful to increase awareness within their wider community. Recipients may share TLP:GREEN information with peers and partner organizations within their community, but not via publicly accessible channels. TLP:GREEN information may not be shared outside of the community. Note: when “community” is not defined, assume the cybersecurity/defense community.&lt;/p&gt;
    &lt;p&gt;d. TLP:CLEAR = Recipients can spread this to the world, there is no limit on disclosure. Sources may use TLP:CLEAR when information carries minimal or no foreseeable risk of misuse, in accordance with applicable rules and procedures for public release. Subject to standard copyright rules, TLP:CLEAR information may be shared without restriction.&lt;/p&gt;
    &lt;p&gt;Notes:&lt;lb/&gt; 1. This document uses MUST and SHOULD as defined by RFC-2119.&lt;lb/&gt; 2. Comments or suggestions on this document can be sent to tlp-sig@first.org.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://www.first.org/tlp/"/><published>2025-10-24T12:52:22+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45694122</id><title>A sharded DuckDB on 63 nodes runs 1T row aggregation challenge in 5 sec</title><updated>2025-10-24T20:38:40.721546+00:00</updated><link href="https://gizmodata.com/blog/gizmoedge-one-trillion-row-challenge"/><published>2025-10-24T12:54:47+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45694767</id><title>Asahi Linux Still Working on Apple M3 Support, M1n1 Bootloader Going Rust</title><updated>2025-10-24T20:38:40.613092+00:00</updated><content>&lt;doc fingerprint="8f41bb17d99430ec"&gt;
  &lt;main&gt;
    &lt;head rend="h1"&gt;Asahi Linux Still Working On Apple M3 Support, m1n1 Bootloader Going Rust&lt;/head&gt;
    &lt;p&gt; The Asahi Linux developers involved with working on Linux support for Apple Silicon M-Series devices have put out a new progress report on their development efforts. &lt;lb/&gt;Asahi Linux developers have kept working on new kernel patches and some being upstreamed for Linux 6.17 and 6.18 cycles, as previously covered on Phoronix. Notably with Linux 6.18 is the Device Trees for the Apple M2 Pro / Max / Ultra devices albeit more driver code is still working its way upstream.&lt;lb/&gt;Asahi Linux developers are also working on moving toward the Rust programming language with their important m1n1 bootloader for Apple Silicon. They feel going to Rust is important for such a critical piece of software for better maintainability, safety, and ensuring the correct logic.&lt;lb/&gt;Asahi Linux developers have also made progress on getting more games working on Apple Silicon devices. Wine is also now working outside of muvm and their graphics driver support continues maturing:&lt;lb/&gt;With the upstream Linux kernel work around Apple Silicon so far being focused on Apple M1 and M2, you may be wondering about M3 and M4 or the recently announced M5... They still are battling Apple M3 bring-up. Today's progress report comments:&lt;lb/&gt;See the progress report in full over on AsahiLinux.org.&lt;/p&gt;
    &lt;p&gt;Asahi Linux developers have kept working on new kernel patches and some being upstreamed for Linux 6.17 and 6.18 cycles, as previously covered on Phoronix. Notably with Linux 6.18 is the Device Trees for the Apple M2 Pro / Max / Ultra devices albeit more driver code is still working its way upstream.&lt;/p&gt;
    &lt;p&gt;Asahi Linux developers are also working on moving toward the Rust programming language with their important m1n1 bootloader for Apple Silicon. They feel going to Rust is important for such a critical piece of software for better maintainability, safety, and ensuring the correct logic.&lt;/p&gt;
    &lt;p&gt;Asahi Linux developers have also made progress on getting more games working on Apple Silicon devices. Wine is also now working outside of muvm and their graphics driver support continues maturing:&lt;/p&gt;
    &lt;p&gt;With the upstream Linux kernel work around Apple Silicon so far being focused on Apple M1 and M2, you may be wondering about M3 and M4 or the recently announced M5... They still are battling Apple M3 bring-up. Today's progress report comments:&lt;/p&gt;
    &lt;quote&gt;"It may be surprising to learn that very basic, low-level support for M3 has existed for quite some time now. m1n1 is capable of initialising the CPU cores, turning on some critical peripheral devices, and booting the Asahi kernel. However, the level of support right now begins and ends with being able to boot to a blinking cursor. Naturally, this level of support is not at all useful for anything but low-level reverse engineering, but we of course plan on rectifying this in due time..."&lt;/quote&gt;
    &lt;p&gt;See the progress report in full over on AsahiLinux.org.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://www.phoronix.com/news/Asahi-Linux-M3-m1n1-Update"/><published>2025-10-24T14:03:22+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45694856</id><title>First shape found that can't pass through itself</title><updated>2025-10-24T20:38:40.309309+00:00</updated><content>&lt;doc fingerprint="a390899286a00301"&gt;
  &lt;main&gt;
    &lt;head rend="h1"&gt;First Shape Found That Can’t Pass Through Itself&lt;/head&gt;
    &lt;head rend="h2"&gt;Introduction&lt;/head&gt;
    &lt;p&gt;Imagine you’re holding two equal-size dice. Is it possible to bore a tunnel through one die that’s big enough for the other to slide through?&lt;/p&gt;
    &lt;p&gt;Perhaps your instinct is to say “Surely not!” If so, you’re not alone. In the late 1600s, an unidentified person placed a bet to that effect with Prince Rupert of the Rhine. Rupert — a nephew of Charles I of England who commanded the Royalist forces in the English Civil War — spent his sunset years studying metallurgy and glassmaking in his laboratory at Windsor Castle.&lt;/p&gt;
    &lt;p&gt;Rupert won the bet. The mathematician John Wallis, recounting the story in 1693, didn’t say whether Rupert wrote a proof or bored a hole through an actual cube. But Wallis himself proved mathematically that, if you drill a straight tunnel in the direction of one of the cube’s inner diagonals, it can be made wide enough to allow another cube through. It’s a tight squeeze: If you make the second cube just 4% larger, it will no longer fit.&lt;/p&gt;
    &lt;p&gt;It’s natural to wonder which other shapes have this property. “I think of this problem as being quite canonical,” said Tom Murphy, a software engineer at Google who has explored the question extensively in his free time. It “would have gotten rediscovered and rediscovered — aliens would have come to this one.”&lt;/p&gt;
    &lt;p&gt;Mark Belan/Quanta Magazine&lt;/p&gt;
    &lt;p&gt;The full menagerie of shapes is too diverse to get a handle on, so mathematicians tend to focus on convex polyhedra: shapes, like the cube, that have flat sides and no protrusions or indentations. When such a shape is much wider in some directions than others, it’s usually easy to find a straight tunnel that will allow another copy of the shape to pass through. But many famous convex polyhedra — for instance the dodecahedron, or the truncated icosahedron, the shape that forms a soccer ball — are highly symmetric and difficult to analyze. Among these, “for hundreds of years we only knew of the cube,” said Jakob Steininger, a mathematician at Statistics Austria, Austria’s federal statistics organization.&lt;/p&gt;
    &lt;p&gt;Then, in 1968, Christoph Scriba proved that the tetrahedron and octahedron also have the “Rupert property,” as mathematicians now call it. And in a burst of activity over the past decade, professional mathematicians and hobbyists have found Rupert tunnels through many of the most widely studied convex polyhedra, including the dodecahedron, icosahedron and soccer ball.&lt;/p&gt;
    &lt;p&gt;The Rupert property appeared to be so widespread that mathematicians conjectured a general rule: Every convex polyhedron will have the Rupert property. No one could find one that didn’t — until now.&lt;/p&gt;
    &lt;p&gt;In a paper posted online in August, Steininger and Sergey Yurkevich — a researcher at A&amp;amp;R Tech, an Austrian transportation systems company — describe a shape with 90 vertices and 152 faces that they’ve named the Noperthedron (after “Nopert,” a coinage by Murphy that combines “Rupert” and “nope”). Steininger and Yurkevich proved that no matter how you bore a straight tunnel through a Noperthedron, a second Noperthedron cannot fit through.&lt;/p&gt;
    &lt;p&gt;The proof required a mix of theoretical advances and massive computer calculations, and relies on a delicate property of the Noperthedron’s vertices. “It’s a miracle that it works,” Steininger said.&lt;/p&gt;
    &lt;head rend="h2"&gt;Passing Through the Shadows&lt;/head&gt;
    &lt;p&gt;To see how one cube can pass through another, imagine holding a cube over a table and examining its shadow (assuming it’s illuminated from above). If you hold the cube in the standard position, the shadow is a square. But if you point one of the corners directly upward, the shadow is a regular hexagon.&lt;/p&gt;
    &lt;p&gt;In 1693, Wallis showed that the square shadow fits inside the hexagon, leaving a thin margin. That means that if you point a cube’s corner upward, you can bore a vertical tunnel that’s big enough for a second cube to pass through. About a century later, Pieter Nieuwland showed that a different orientation casts an even better shadow — one that can accommodate a cube more than 6% larger than the cube with the tunnel.&lt;/p&gt;
    &lt;p&gt;Mark Belan/Quanta Magazine&lt;/p&gt;
    &lt;p&gt;Every subsequent analysis of more complicated shapes has relied on this process of turning the shape in different directions and looking for one shadow that fits inside another. With the aid of computers, mathematicians have found Rupert passages through a wide variety of shapes. Some are incredibly tight fits — for instance, the passage in a “triakis tetrahedron” has a margin that’s only about 0.000002 times the length of the shape’s radius. “The world of mixing computation and discrete geometry has flowered to make these kinds of calculations possible,” said Joseph O’Rourke, an emeritus professor at Smith College.&lt;/p&gt;
    &lt;p&gt;Researchers who have written algorithms to find Rupert passages have noticed a curious dichotomy: For any given convex polyhedron, the algorithm seems to either find a passage almost immediately, or not find one at all. In the past five years, mathematicians have accumulated a small collection of holdout shapes for which no passage has been found.&lt;/p&gt;
    &lt;p&gt;“I’ve had my desktop churn for two weeks on trying the rhombicosidodecahedron,” said Benjamin Grimmer, an applied mathematician at Johns Hopkins University, referring to a solid made of 62 regular triangles, squares and pentagons. “That one just seems to resist any attempt.”&lt;/p&gt;
    &lt;p&gt;But such resistance doesn’t prove that a shape is a Nopert. There are infinitely many ways to orient a shape, and a computer can only check finitely many. Researchers don’t know whether the holdouts are true Noperts or just shapes whose Rupert passages are hard to find.&lt;/p&gt;
    &lt;p&gt;What they do know is that candidate Noperts are incredibly rare. Starting last year, Murphy began to construct hundreds of millions of shapes. These include random polyhedra, polyhedra whose vertices lie on a sphere, polyhedra with special symmetries, and polyhedra in which he moved one vertex to intentionally mess up a previous Rupert passage. His algorithm easily found Rupert tunnels for nearly every one.&lt;/p&gt;
    &lt;p&gt;The contrast between these quick results and the stubbornness of the Nopert holdouts made some mathematicians suspect that true Noperts do exist. But until August, all they had were suspicions.&lt;/p&gt;
    &lt;head rend="h2"&gt;No Passage&lt;/head&gt;
    &lt;p&gt;Steininger, now 30, and Yurkevich, 29, have been friends since they participated together as teenagers in mathematics Olympiad competitions. Even though both eventually left academia (after a doctorate for Yurkevich and a master’s for Steininger), they have continued to explore unsolved problems together.&lt;/p&gt;
    &lt;p&gt;“We just had pizza three hours ago, and we talked about math almost the whole time,” Steininger told Quanta. “That’s what we do.”&lt;/p&gt;
    &lt;p&gt;Five years ago, the pair happened upon a YouTube video of one cube passing through another, and they were instantly smitten. They developed an algorithm to search for Rupert tunnels and soon became convinced that some shapes were Noperts. In a 2021 paper, they conjectured that the rhombicosidodecahedron is not Rupert. Their work, which preceded Murphy’s and Grimmer’s recent explorations, was, “I think, the first to conjecture that there might be solids that don’t have this property,” Steininger said.&lt;/p&gt;
    &lt;p&gt;If you want to prove that a shape is a Nopert, you must rule out Rupert tunnels for every possible orientation of the two shapes. Each orientation can be written down as a collection of rotation angles. This collection of angles can then be represented as a point in a higher-dimensional “parameter space.”&lt;/p&gt;
    &lt;p&gt;Florentina Stadlbauer; Courtesy of Jakob Steininger&lt;/p&gt;
    &lt;p&gt;Suppose you choose an orientation for your two shapes, and the computer tells you that the second shadow sticks out past the border of the first shadow. This rules out one point in the parameter space.&lt;/p&gt;
    &lt;p&gt;But you may be able to rule out much more than a single point. If the second shadow sticks out significantly, it would require a big change to move it inside the first shadow. In other words, you can rule out not just your initial orientation but also “nearby” orientations — an entire block of points in the parameter space. Steininger and Yurkevich came up with a result they called their global theorem, which quantifies precisely how large a block you can rule out in these cases. By testing many different points, you can potentially rule out block after block in the parameter space.&lt;/p&gt;
    &lt;p&gt;If these blocks cover the entire parameter space, you’ll have proved that your shape is a Nopert. But the size of each block depends on how far the second shadow sticks out beyond the first, and sometimes it doesn’t stick out very far. For instance, suppose you start with the two shapes in exactly the same position, and then you slightly rotate the second shape. Its shadow will at most stick out just a tiny bit past the first shadow, so the global theorem will only rule out a tiny box. These boxes are too small to cover the whole parameter space, leaving the possibility that some point you’ve missed might correspond to a Rupert tunnel.&lt;/p&gt;
    &lt;p&gt;To deal with these small reorientations, the pair came up with a complement to their global theorem that they called the local theorem. This result deals with cases where you can find three vertices (or corner points) on the boundary of the original shadow that satisfy some special requirements. For instance, if you connect those three vertices to form a triangle, it must contain the shadow’s center point. The researchers showed that if these requirements are met, then any small reorientation of the shape will create a shadow that pushes at least one of the three vertices further outward. So the new shadow can’t lie inside the original shadow, meaning it doesn’t create a Rupert tunnel.&lt;/p&gt;
    &lt;p&gt;If your shape casts a shadow that lacks three appropriate vertices, the local theorem won’t apply. And all the previously identified Nopert candidates have at least one shadow with this problem. Steininger and Yurkevich sifted through a database of hundreds of the most symmetric and beautiful convex polyhedra, but they couldn’t find any shape whose shadows all worked. So they decided to generate a suitable shape themselves.&lt;/p&gt;
    &lt;p&gt;They developed an algorithm to construct shapes and test them for the three-vertices property. Eventually, the algorithm produced the Noperthedron, which is made of 150 triangles and two regular 15-sided polygons. It looks like a rotund crystal vase with a wide base and top; one fan of the work has already 3D-printed a copy to use as a pencil holder.&lt;/p&gt;
    &lt;p&gt;Peter Lely&lt;/p&gt;
    &lt;p&gt;Steininger and Yurkevich then divided the parameter space of orientations into approximately 18 million tiny blocks, and tested the center point of each block to see if its corresponding orientation produced a Rupert passage. None of them did. Next, the researchers showed that each block satisfied either the local or global theorem, allowing them to rule out the entire block. Since these blocks fill out the entire parameter space, this meant that there is no Rupert passage through the Noperthedron.&lt;/p&gt;
    &lt;p&gt;The “natural conjecture has been proved false,” O’Rourke said.&lt;/p&gt;
    &lt;p&gt;It remains to be seen whether mathematicians can use the new method to generate other Noperts, or if they can find a different local theorem that can handle candidates like the rhombicosidodecahedron. But now that mathematicians know that Noperts do exist, “we’re on sound footing to study other shapes,” Murphy said.&lt;/p&gt;
    &lt;p&gt;Murphy, who like Steininger and Yurkevich has been exploring the question for its own sake, independent of his day job, feels a kinship across the centuries with Prince Rupert. “I like that he chose to use his retirement to do math and science in his castle,” he said.&lt;/p&gt;
    &lt;p&gt;Meanwhile, Steininger and Yurkevich are on the lookout for new questions to tackle. “We’re just humble mathematicians — we love working on such problems,” Steininger said. “We’ll keep doing that.”&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://www.quantamagazine.org/first-shape-found-that-cant-pass-through-itself-20251024/"/><published>2025-10-24T14:12:00+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45696838</id><title>How to make a Smith chart</title><updated>2025-10-24T20:38:40.129221+00:00</updated><content>&lt;doc fingerprint="1d0b6d028f79c1a2"&gt;
  &lt;main&gt;
    &lt;p&gt;The Smith chart from electrical engineering is the image of a Cartesian grid under the function&lt;/p&gt;
    &lt;p&gt;f(z) = (z − 1)/(z + 1).&lt;/p&gt;
    &lt;p&gt;More specifically, it’s the image of a grid in the right half-plane.&lt;/p&gt;
    &lt;p&gt;This post will derive the basic mathematical properties of this graph but will not go into the applications. Said another way, I’ll explain how to make a Smith chart, not how to use one.&lt;/p&gt;
    &lt;p&gt;We will use z to denote points in the right half-plane and w to denote the image of these points under f. We will speak of lines in the z plane and the circles they correspond to in the w plane.&lt;/p&gt;
    &lt;head rend="h2"&gt;Möbius transformations&lt;/head&gt;
    &lt;p&gt;Our function f is a special case of a Möbius transformation. There is a theorem that says Möbius transformation map generalized circles to generalized circles. Here a generalized circle means a circle or a line; you can think of a line as a circle with infinite radius. We’re going to get a lot of mileage out of that theorem.&lt;/p&gt;
    &lt;head rend="h2"&gt;Image of the imaginary axis&lt;/head&gt;
    &lt;p&gt;The function f maps the imaginary axis in the z plane to the unit circle in the w plane. We can prove this using the theorem above. The imaginary axis is a line, so it’s image is either a line or a circle. We can take three points on the imaginary axis in the z plane and see where they go.&lt;/p&gt;
    &lt;p&gt;When we pick z equal to 0, i, and −i from the imaginary axis we get w values of −1, i, and −i. These three w values do not line on a line, so the image of the imaginary axis must be a circle. Furthermore, three points uniquely determine a circle, so the image of the imaginary axis is the circle containing −1, i, and −i, i.e. the unit circle.&lt;/p&gt;
    &lt;head rend="h2"&gt;Image of the right half-plane&lt;/head&gt;
    &lt;p&gt;The imaginary axis is the boundary of the right half-plane. Since it is mapped to the unit circle, the right half-plane is either mapped to the interior of the unit circle or the exterior of the unit circle. The point z = 1 goes to w = 0, and so the right half-plane is mapped inside the unit circle.&lt;/p&gt;
    &lt;head rend="h2"&gt;Images of vertical lines&lt;/head&gt;
    &lt;p&gt;Let’s think about what happens to vertical lines in the z plane, lines with constant positive real part. The images of these lines in the w plane must be either lines or circles. And since the right-half plane gets mapped inside the unit circle, these lines must get mapped to circles.&lt;/p&gt;
    &lt;p&gt;We can say a little more. All lines contain the point ∞, and f(∞) = 1, so the image of every vertical line in the z plane is a circle in the w plane, inside the unit circle and tangent to the unit circle at w = 1. (Tossing around ∞ is a bit informal, but it’s easy to make rigorous.)&lt;/p&gt;
    &lt;p&gt;The vertical lines in the z plane&lt;/p&gt;
    &lt;p&gt;map to tangent circles in the w plane.&lt;/p&gt;
    &lt;head rend="h2"&gt;Images of horizontal lines&lt;/head&gt;
    &lt;p&gt;Next, let’s think about horizontal lines in the z plane, lines with constant imaginary part. The image of these lines is either a line or a circle. Which is it? The image of a line is a line if it contains ∞, otherwise it’s a circle. Now f(z) = ∞ if and only if z = −1, and so the image of the real axis is a line, but the image of every other horizontal line is a circle.&lt;/p&gt;
    &lt;p&gt;Since f(∞) = 1, the image of every horizontal line passes through 1, just as the images of all the vertical lines passes through 1.&lt;/p&gt;
    &lt;p&gt;Since horizontal lines extend past the right half-plane, the image circles extend past the unit circle. The part of the line with positive real part gets mapped inside the unit circle, and the part of the line with negative real part gets mapped outside the unit circle. In particular, the image of the positive real axis is the interval [−1, 1].&lt;/p&gt;
    &lt;p&gt;Möbius transformations are conformal maps, and so they preserve angles of intersection. Since horizontal lines are perpendicular to vertical lines, the circles that are the images of the horizontal lines meet the circles that are the images of vertical lines at right angles.&lt;/p&gt;
    &lt;p&gt;The horizontal rays in the z plane&lt;/p&gt;
    &lt;p&gt;become partial circles in the w plane.&lt;/p&gt;
    &lt;p&gt;If we were to look at horizontal lines rather than rays, i.e. if we extended the lines into the left half-plane, the images in the w plane would be full circles.&lt;/p&gt;
    &lt;p&gt;Now let’s put our images together. The grid&lt;/p&gt;
    &lt;p&gt;in the z plane becomes the following in the w plane.&lt;/p&gt;
    &lt;p&gt;An evenly spaced grid in the z plane becomes a very unevenly spaced graph in the w plane. Things are crowded on the right hand side and sparse on the left. A useable Smith chart needs to be roughly evenly filled in, which means it has to be the image of an unevenly filled in grid in the z plane. For example, you’d need more vertical lines in the z plane with small real values than with large real values.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://www.johndcook.com/blog/2025/10/23/smith-chart/"/><published>2025-10-24T17:18:17+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45698554</id><title>Harnessing America's Heat Pump Moment</title><updated>2025-10-24T20:38:38.611255+00:00</updated><content>&lt;doc fingerprint="676f107f6a85b4ba"&gt;
  &lt;main&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Heat Pumped&lt;/item&gt;
      &lt;item&gt;Posts&lt;/item&gt;
      &lt;item&gt;Harnessing America’s Heat Pump Moment&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h1"&gt;Harnessing America’s Heat Pump Moment&lt;/head&gt;
    &lt;head rend="h2"&gt;The tech works. The policy’s in place. So why are heat pumps still a hard sell?&lt;/head&gt;
    &lt;p&gt;Editor’s note: This is a guest post by Joseph DeNatale, an entrepreneur and project coordinator at Jetson Home. It originally appeared in Climate Drift earlier this year, and is republished on Heat Pumped with permission.&lt;/p&gt;
    &lt;p&gt;Joseph interviewed me when he was researching the piece, and I was excited to see that the final product touched many topics that I've been wanting to write about.&lt;/p&gt;
    &lt;p&gt;A big thank you to Joseph and Climate Drift for sharing with the Heat Pumped community - it's incredibly in-depth. Since there’s so much to digest, we’re splitting it up into 5 parts that we'll be sharing over the next few weeks.&lt;/p&gt;
    &lt;head rend="h2"&gt;Why Execution Is Everything: A Personal Perspective&lt;/head&gt;
    &lt;p&gt;As a small business owner, I’ve built a career not around inventing new things, but around making things happen: making sure systems run smoothly, projects get completed on time, and clients feel taken care of.&lt;/p&gt;
    &lt;p&gt;My work has been rooted in the real-world, hands-on, often chaotic rhythm of operations, logistics, and direct client service. Whether it’s organizing teams to execute live events, refining workflows to scale a growing business, or managing the delicate art of closing a sale, I’ve learned one simple truth: the hardest part is never the idea. It’s the execution.&lt;/p&gt;
    &lt;p&gt;So when I began diving into the world of home electrification—particularly heat pumps—that same truth surfaced again, just with higher stakes.&lt;/p&gt;
    &lt;p&gt;The technology isn’t the issue. In fact, the technology is there. It’s been there for decades, and it is continuing to improve. We’re not waiting on some magical breakthrough or futuristic device.&lt;/p&gt;
    &lt;p&gt;We’re waiting on people—mostly homeowners and home contractors, but also manufacturers and policy makers—to embrace, understand, and implement what already works.&lt;/p&gt;
    &lt;p&gt;This piece isn’t about reinventing the wheel. It’s about understanding why we’re not using the wheel we already have—and what it’s going to take, from the human side of the equation, to make heat pumps the obvious, accessible, and default choice for millions of American homes.&lt;/p&gt;
    &lt;head rend="h3"&gt;Heat Pumps Aren’t New—But This Moment Is&lt;/head&gt;
    &lt;p&gt;In the world of climate solutions, it’s easy to get distracted by what’s shiny and new—sleek devices, breakthrough technologies, futuristic models of sustainability.&lt;/p&gt;
    &lt;p&gt;But not every climate solution is some new-fangled wonder gadget. Some of them already exist. Some of them are sitting in basements and behind houses, quietly doing the work.&lt;/p&gt;
    &lt;p&gt;The heat pump is one of them.&lt;/p&gt;
    &lt;p&gt;Heat pumps are not new. In fact, the idea has been around for well over a century, and the technology has been used widely for decades—mostly in Europe and Asia, but also in pockets of the U.S.—for everything from water heating to whole-home climate control.&lt;/p&gt;
    &lt;p&gt;Modern heat pumps are highly efficient—anywhere from 2-4x more efficient than a furnace—and capable of replacing both a furnace and an air conditioner with a single system in virtually every climate. For millions of homes across the country, they offer a cleaner, quieter, and more precise way to stay comfortable year-round.&lt;/p&gt;
    &lt;p&gt;Importantly, heat pumps have also been shown to match or beat the operating costs of even the cheapest heating option—natural gas—in many cases. This has been demonstrated through both local and national studies. One study showed that over 90% of American households would save on energy bills by replacing worn-out heating equipment with the right-sized heat pump.&lt;/p&gt;
    &lt;p&gt;Installation costs vary wildly depending on many factors in a home, but with the introduction of generous incentives via the Inflation Reduction Act (IRA) and additional state programs, even these costs can be on-par with fossil fuel alternatives.&lt;/p&gt;
    &lt;p&gt;So why aren’t they everywhere?&lt;/p&gt;
    &lt;p&gt;The answer isn’t technical. It’s cultural, economic, and human.&lt;/p&gt;
    &lt;head rend="h3"&gt;TL;DR&lt;/head&gt;
    &lt;p&gt;Heat pumps are proven, efficient, and climate-friendly—but adoption is still slow.&lt;/p&gt;
    &lt;p&gt;The barrier isn’t the tech. It’s people:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;
        &lt;p&gt;Contractors who default to what they know&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Homeowners who need education and guidance&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;A fragmented market full of noise and misinformation&lt;/p&gt;
      &lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;This piece discusses these challenges, and then explores five keys to accelerating adoption:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;
        &lt;p&gt;Educate homeowners so heat pumps feel familiar and trustworthy.&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Train the next-gen workforce and upskill legacy HVAC pros.&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Leverage better tools and data to size and install systems right.&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Prioritize quality and trust to build social proof and demand.&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Align policy to phase out one-way ACs and normalize heat pumps.&lt;/p&gt;
      &lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Execution—not invention—is what will move the needle.&lt;/p&gt;
    &lt;head rend="h2"&gt;Hold On.. What’s A Heat Pump Again?&lt;/head&gt;
    &lt;p&gt;If you’re reading this piece, you probably know what a heat pump is (and you can feel free to skip this section).&lt;/p&gt;
    &lt;p&gt;But if you’re among the uninitiated – like, believe it or not, most people – here’s a (very) quick primer. (Editor’s note: check out Heat Pumps 101 if you want to dive deeper)&lt;/p&gt;
    &lt;p&gt;A heat pump works by drawing thermal energy (heat) out of the atmosphere and “pumping” it into the home. This process works in reverse for cooling. (Source)&lt;/p&gt;
    &lt;head rend="h3"&gt;The 2-Way AC&lt;/head&gt;
    &lt;p&gt;The term “heat pump”, it turns out, is a fairly unhelpful name for most people. In fact, there are some leaders in the home electrification industry who believe the name itself is one of the barriers to adoption. It’s one of many ways that the heat pump is misunderstood.&lt;/p&gt;
    &lt;p&gt;Think of a heat pump as a “2-way AC.” An air conditioner cools your home by pulling heat from inside an enclosed space and transferring it outside. Your refrigerator works the same way.&lt;/p&gt;
    &lt;p&gt;A heat pump does the same thing, but can also reverse the process to bring heat into the home. It uses a few key components to make this happen:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;
        &lt;p&gt;The fan pulls air across the system’s coils to help move heat in or out of the space.&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;The evaporator coil absorbs heat from the air inside your home (in cooling mode) or from the outside air (in heating mode).&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;The compressor pressurizes and moves a fluid called refrigerant through the system, enabling the heat transfer process.&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;The refrigerant is the working fluid that captures and carries heat from one place to another—either out of your home or into it.&lt;/p&gt;
      &lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;What’s important to understand is that a heat pump does not create heat. It also doesn’t create cold (cold is the absence of heat, just like darkness is the absence of light). A heat pump simply transfers – pumps! – heat from one place to another.&lt;/p&gt;
    &lt;p&gt;“The difference between a heat pump and a one-way AC is just one valve. It still works perfectly fine as an air conditioner—there’s no difference. That’s why we’ve started calling them “two-way ACs” as an education tool. It helps people compare a two-way AC, which has a reverse gear, with a one-way AC—which, in my mind, is basically broken.”&lt;/p&gt;
    &lt;p&gt;But what about in the winter when it’s below freezing? In any environment where the temperature is above absolute zero (remember the Kelvin scale?) there is still a significant amount of heat in the air in the form of thermal energy.&lt;/p&gt;
    &lt;p&gt;That’s why a heat pump can still heat your home even on the coldest day of the year.&lt;/p&gt;
    &lt;head rend="h2"&gt;Why Heat Pumps Matter&lt;/head&gt;
    &lt;p&gt;The fact that heat pumps simply transfer heat—and do not create it—gives them the potential to heat homes without doing the thing that humans have done since time immemorial to keep warm: burn stuff.&lt;/p&gt;
    &lt;p&gt;In the U.S., over half of all homes still rely on burning fossil fuels for heat. Replacing those systems with electric, air source heat pumps (ASHPs) can significantly reduce household emissions, especially as the grid gets cleaner and moves towards a higher percentage of renewable energy (i.e. not burning stuff).&lt;/p&gt;
    &lt;p&gt;And, because they’re so efficient, heat pumps can lower operating costs over time—although this is highly dependent on where you live, as the cost of fuel and electricity varies widely. They’re also safer (no burning stuff), can improve indoor air quality (again, no burning), and create healthier, more comfortable homes.&lt;/p&gt;
    &lt;p&gt;Finally, heat pumps are a crucial component of an energy-independent home. Paired with solar panels and battery storage, a homeowner can heat and cool their home entirely with energy they generate on their own. Try that with a furnace!&lt;/p&gt;
    &lt;table&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;
          &lt;p&gt;Metric&lt;/p&gt;
        &lt;/cell&gt;
        &lt;cell&gt;
          &lt;p&gt;Gas Furnace&lt;/p&gt;
        &lt;/cell&gt;
        &lt;cell&gt;
          &lt;p&gt;Air-Source Heat Pump (ASHP)&lt;/p&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;
          &lt;p&gt;Fuel Source&lt;/p&gt;
        &lt;/cell&gt;
        &lt;cell&gt;
          &lt;p&gt;Natural gas, propane, or oil&lt;/p&gt;
        &lt;/cell&gt;
        &lt;cell&gt;
          &lt;p&gt;Electricity&lt;/p&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;
          &lt;p&gt;Heating/Cooling&lt;/p&gt;
        &lt;/cell&gt;
        &lt;cell&gt;
          &lt;p&gt;Heating only&lt;/p&gt;
        &lt;/cell&gt;
        &lt;cell&gt;
          &lt;p&gt;Heats and cools (dual function)&lt;/p&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;
          &lt;p&gt;Air Quality&lt;/p&gt;
        &lt;/cell&gt;
        &lt;cell&gt;
          &lt;p&gt;Can introduce combustion byproducts; potential for CO&lt;/p&gt;
        &lt;/cell&gt;
        &lt;cell&gt;
          &lt;p&gt;No combustion; generally better indoor air quality&lt;/p&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;
          &lt;p&gt;Health/Safety&lt;/p&gt;
        &lt;/cell&gt;
        &lt;cell&gt;
          &lt;p&gt;Risk of gas leaks, carbon monoxide&lt;/p&gt;
        &lt;/cell&gt;
        &lt;cell&gt;
          &lt;p&gt;No combustion risk; safer for indoor environments&lt;/p&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;
          &lt;p&gt;Comfort&lt;/p&gt;
        &lt;/cell&gt;
        &lt;cell&gt;
          &lt;p&gt;Delivers blasts of hot air; on/off “short cycles”&lt;/p&gt;
        &lt;/cell&gt;
        &lt;cell&gt;
          &lt;p&gt;More consistent, even heating/cooling with variable-speed options&lt;/p&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;
          &lt;p&gt;Initial Cost&lt;/p&gt;
        &lt;/cell&gt;
        &lt;cell&gt;
          &lt;p&gt;Typically lower (although the cost of a furnace + AC if replaced at the same time is often higher)&lt;/p&gt;
        &lt;/cell&gt;
        &lt;cell&gt;
          &lt;p&gt;Often higher upfront, especially for cold-climate models. Costs can be lowered via incentive programs.&lt;/p&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;
          &lt;p&gt;Operating Cost&lt;/p&gt;
        &lt;/cell&gt;
        &lt;cell&gt;
          &lt;p&gt;Depends on gas prices; cheaper where gas is low&lt;/p&gt;
        &lt;/cell&gt;
        &lt;cell&gt;
          &lt;p&gt;Can be lower, especially with efficient models + incentives and/or when paired with solar + battery storage&lt;/p&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;
          &lt;p&gt;Emissions&lt;/p&gt;
        &lt;/cell&gt;
        &lt;cell&gt;
          &lt;p&gt;Emits CO₂ and other GHGs&lt;/p&gt;
        &lt;/cell&gt;
        &lt;cell&gt;
          &lt;p&gt;Zero onsite emissions; cleaner with a green grid&lt;/p&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;
          &lt;p&gt;Climate Suitability&lt;/p&gt;
        &lt;/cell&gt;
        &lt;cell&gt;
          &lt;p&gt;Performs well in all climates&lt;/p&gt;
        &lt;/cell&gt;
        &lt;cell&gt;
          &lt;p&gt;Cold-climate models now perform down to -15 to -20°F&lt;/p&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;cell&gt;
          &lt;p&gt;Incentives/Rebates&lt;/p&gt;
        &lt;/cell&gt;
        &lt;cell&gt;
          &lt;p&gt;Limited (varies by region)&lt;/p&gt;
        &lt;/cell&gt;
        &lt;cell&gt;
          &lt;p&gt;Significant federal/state incentives available&lt;/p&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
    &lt;/table&gt;
    &lt;p&gt;This is not a marginal climate solution. According to the IEA, global heat pump adoption could reduce carbon emissions by half a billion tons annually—roughly equivalent to the annual emissions of all cars in Europe.&lt;/p&gt;
    &lt;head rend="h2"&gt;The Heat Pump Moment Has Arrived&lt;/head&gt;
    &lt;p&gt;For years, heat pumps were a niche topic, something discussed by green building enthusiasts, early adopters, or homeowners with unusually high energy awareness.&lt;/p&gt;
    &lt;p&gt;But that’s no longer the case. Here are four reasons why:&lt;/p&gt;
    &lt;head rend="h3"&gt;Cultural Momentum Is Building&lt;/head&gt;
    &lt;p&gt;The electrification movement is no longer a fringe concept. The push to “electrify everything” has gained traction among policymakers, climate advocates, startups, utilities, and even popular media.&lt;/p&gt;
    &lt;p&gt;From Substack newsletters to YouTube explainers, there’s growing awareness that building decarbonization—and especially heating and cooling—is one of the most practical, scalable ways for regular people to cut their emissions. Campaigns like Rewiring America’s “Go Electric” initiative frame heat pumps not just as energy-efficient appliances, but as a gateway to modern, climate-aligned homes.&lt;/p&gt;
    &lt;p&gt;This momentum is turning into real action. Heat pumps have now outsold gas furnaces in the U.S. every year since 2022.&lt;/p&gt;
    &lt;head rend="h3"&gt;Federal and State Policy Is Aligned (For Now)&lt;/head&gt;
    &lt;p&gt;For the time being (Republicans’ “One Big, Beautiful Bill” notwithstanding), both federal and state governments are backing this transition with significant financial and structural support. Editor’s note: Ouch. Since this piece was originally written, OBBB passed, and most tax credits at the federal level phase out at the end of this year. If you’ve been on the fence about getting a heat pump, now might be a good time to act!&lt;/p&gt;
    &lt;p&gt;The Inflation Reduction Act (IRA) has introduced a suite of rebates, tax credits, and grant programs designed to make heat pumps more affordable and accessible. Single-family households can receive up to $8,000 in upfront rebates for heat pump installations and up to $2,000 in federal tax credits, not to mention additional support for electrical panel upgrades and home energy audits. Editor’s note: the IRA rebates are federally funded, but implemented at the state level. Not all states are participating, and some that are haven’t rolled out their programs yet. In other states like California, the funds are already exhausted.&lt;/p&gt;
    &lt;p&gt;State and local governments are also leading the way in the transition away from fossil fuels on both the demand and supply sides. Programs like Efficiency Maine, TECH Clean California, and Mass Save offer generous incentives and no-interest financing to homeowners that drive the cost of electrification upgrades down even further. Meanwhile, New York City has banned gas in new construction, and Massachusetts has ordered public utilities to begin phasing out natural gas, a move which is being studied in at least 11 other states.&lt;/p&gt;
    &lt;head rend="h3"&gt;Private Capital Is Following&lt;/head&gt;
    &lt;p&gt;The heat pump space is no longer just a niche for contractors and utilities—it’s attracting serious private investment. VC-backed companies like Quilt are reimagining the user experience with sleek, design-forward equipment and app-based controls. Others, like Elephant Energy and Forge, are building “heat pump concierge” platforms that manage the customer journey end-to-end—from sales to install to rebate navigation.&lt;/p&gt;
    &lt;head rend="h3"&gt;The Cold-Climate Performance Myth Has Been Fully Debunked&lt;/head&gt;
    &lt;p&gt;One of the biggest myths about heat pumps—that they can’t handle cold weather—is now being debunked at scale. While older, single-speed models may have struggled in colder temperatures, especially when size and installed incorrectly, modern cold-climate, variable-speed air-source heat pumps can provide reliable heating even at outdoor temperatures of -20°F.&lt;/p&gt;
    &lt;p&gt;These systems are already in use in northern New England, the upper Midwest, and Canada. In Nordic countries—some of the coldest climates in the word—the technology has been viable for decades.&lt;/p&gt;
    &lt;p&gt;And yet, despite all this momentum, heat pump adoption is still slow.&lt;/p&gt;
    &lt;p&gt;Why? Because the hardest part isn’t scaling the technology. It’s aligning the people—contractors, homeowners, policymakers, and market actors—who need to make it happen.&lt;/p&gt;
    &lt;p&gt;“We’ve had the technology dialed for 20, 30, 40 years, depending on how you’re arguing it—but it’s not being applied. It’s a human problem. It’s not a technical one. The technical one has been solved.”&lt;/p&gt;
    &lt;p&gt;That’s where we go next.&lt;/p&gt;
    &lt;p&gt;This is part 1 in a 5 part series about challenges and solutions in accelerating heat pump adoption across the US. Stay tuned for the next issue!&lt;/p&gt;
    &lt;head rend="h2"&gt;Want a heat pump in your own home?&lt;/head&gt;
    &lt;p&gt;The first Heat Pumped group buy generated lots of enthusiasm! There are still a handful of slots left, but you’ll have to act fast if you’re interested. Sign-ups close later this month (or when all the slots fill, whichever comes first).&lt;/p&gt;
    &lt;table&gt;
      &lt;row&gt;
        &lt;cell&gt;
          &lt;head&gt;Do you want to participate in this group buy?&lt;/head&gt;
          &lt;p&gt;Fair &amp;amp; transparent heat pump pricing in the SF Bay Area and LA&lt;/p&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
    &lt;/table&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://www.heatpumped.org/p/harnessing-america-s-heat-pump-moment"/><published>2025-10-24T20:05:07+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=45698570</id><title>The Swift SDK for Android</title><updated>2025-10-24T20:38:38.359399+00:00</updated><content>&lt;doc fingerprint="360e51139294ee0b"&gt;
  &lt;main&gt;
    &lt;head rend="h1"&gt;Announcing the Swift SDK for Android&lt;/head&gt;
    &lt;p&gt;Swift has matured significantly over the past decade — extending from cloud services to Windows applications, browser apps, and microcontrollers. Swift powers apps and services of all kinds, and thanks to its great interoperability, you can share code across platforms.&lt;/p&gt;
    &lt;p&gt;The Android workgroup is an open group, free for anyone to join, that aims to expand Swift to Android. Today, we are pleased to announce nightly preview releases of the Swift SDK for Android.&lt;/p&gt;
    &lt;p&gt;This milestone reflects months of effort by the Android workgroup, building on many years of grassroots community effort. With the SDK, developers can begin developing Android applications in Swift, opening new avenues for cross-platform development and accelerating innovation across the mobile ecosystem.&lt;/p&gt;
    &lt;p&gt;The Swift SDK for Android is available today, bundled with the Windows installer or downloadable separately for use on Linux or macOS.&lt;/p&gt;
    &lt;head rend="h2"&gt;Getting Started&lt;/head&gt;
    &lt;p&gt;We’ve published a Getting Started guide to help you set up your first native Swift code on an Android device. The Swift for Android Examples help demonstrate end‑to‑end application workflows on Android.&lt;/p&gt;
    &lt;p&gt;With the Swift SDK for Android, you can now start porting your Swift packages to Android. Over 25% of packages in the Swift Package Index already build for Android, and the Community Showcase now indicates Android compatibility.&lt;/p&gt;
    &lt;p&gt;The swift-java project enables you to interoperate between Java and Swift. It is both a library and a code generator, enabling you to integrate Swift and Java in both directions by automatically generating safe and performant bindings. To learn about generating bindings to bring your business logic to Android, check out the recent Swift Server Side meetup talk by Mads Odgaard.&lt;/p&gt;
    &lt;head rend="h2"&gt;Next Steps&lt;/head&gt;
    &lt;p&gt;This preview release opens many new opportunities to continue improving these tools. We encourage you to discuss your experiences, ideas, tools and apps on the Swift Forums in the Android Category.&lt;/p&gt;
    &lt;p&gt;The Android workgroup is drafting a vision document, currently under review, for directing future work regarding Swift on Android. This vision will outline priority areas and guide community efforts to maximize impact across the ecosystem. In addition, we maintain a project board that tracks the status of major efforts, as well as official CI for the Swift SDK for Android.&lt;/p&gt;
    &lt;p&gt;If you’re as excited as we are, join us and help make this ecosystem even better!&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://www.swift.org/blog/nightly-swift-sdk-for-android/"/><published>2025-10-24T20:06:52+00:00</published></entry></feed>