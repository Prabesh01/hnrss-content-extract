<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><id>hnrss.org/frontpage</id><title>Hacker News: Front Page</title><updated>2026-01-28T21:19:23.654104+00:00</updated><link href="https://news.ycombinator.com/" rel="alternate"/><link href="https://raw.githubusercontent.com/Prabesh01/hnrss-content-extract/refs/heads/main/out/rss.xml" rel="self"/><generator uri="https://lkiesow.github.io/python-feedgen" version="1.0.0">python-feedgen</generator><subtitle>Hacker News RSS</subtitle><entry><id>https://news.ycombinator.com/item?id=46795584</id><title>Show HN: Sandbox Agent SDK – unified API for automating coding agents</title><updated>2026-01-28T21:19:31.562546+00:00</updated><content>&lt;doc fingerprint="a6b58ed9e9cba8f6"&gt;
  &lt;main&gt;
    &lt;p&gt;Universal API for automatic coding agents in sandboxes. Supports Claude Code, Codex, OpenCode, and Amp.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Any coding agent: Universal API to interact with all agents with full feature coverage&lt;/item&gt;
      &lt;item&gt;Server or SDK mode: Run as an HTTP server or with the TypeScript SDK&lt;/item&gt;
      &lt;item&gt;Universal session schema: Universal schema to store agent transcripts&lt;/item&gt;
      &lt;item&gt;Supports your sandbox provider: Daytona, E2B, Vercel Sandboxes, and more&lt;/item&gt;
      &lt;item&gt;Lightweight, portable Rust binary: Install anywhere with 1 curl command&lt;/item&gt;
      &lt;item&gt;Automatic agent installation: Agents are installed on-demand when first used&lt;/item&gt;
      &lt;item&gt;OpenAPI spec: Well documented and easy to integrate&lt;/item&gt;
    &lt;/list&gt;
    &lt;table&gt;
      &lt;row span="5"&gt;
        &lt;cell role="head"&gt;Feature&lt;/cell&gt;
        &lt;cell role="head"&gt;Claude Code*&lt;/cell&gt;
        &lt;cell role="head"&gt;Codex&lt;/cell&gt;
        &lt;cell role="head"&gt;OpenCode&lt;/cell&gt;
        &lt;cell role="head"&gt;Amp&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="5"&gt;
        &lt;cell&gt;Stability&lt;/cell&gt;
        &lt;cell&gt;Stable&lt;/cell&gt;
        &lt;cell&gt;Stable&lt;/cell&gt;
        &lt;cell&gt;Experimental&lt;/cell&gt;
        &lt;cell&gt;Experimental&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="5"&gt;
        &lt;cell&gt;Text Messages&lt;/cell&gt;
        &lt;cell&gt;✓&lt;/cell&gt;
        &lt;cell&gt;✓&lt;/cell&gt;
        &lt;cell&gt;✓&lt;/cell&gt;
        &lt;cell&gt;✓&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="5"&gt;
        &lt;cell&gt;Tool Calls&lt;/cell&gt;
        &lt;cell&gt;—*&lt;/cell&gt;
        &lt;cell&gt;✓&lt;/cell&gt;
        &lt;cell&gt;✓&lt;/cell&gt;
        &lt;cell&gt;✓&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="5"&gt;
        &lt;cell&gt;Tool Results&lt;/cell&gt;
        &lt;cell&gt;—*&lt;/cell&gt;
        &lt;cell&gt;✓&lt;/cell&gt;
        &lt;cell&gt;✓&lt;/cell&gt;
        &lt;cell&gt;✓&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="5"&gt;
        &lt;cell&gt;Questions (HITL)&lt;/cell&gt;
        &lt;cell&gt;—*&lt;/cell&gt;
        &lt;cell&gt;✓&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="5"&gt;
        &lt;cell&gt;Permissions (HITL)&lt;/cell&gt;
        &lt;cell&gt;—*&lt;/cell&gt;
        &lt;cell&gt;✓&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="5"&gt;
        &lt;cell&gt;Images&lt;/cell&gt;
        &lt;cell&gt;✓&lt;/cell&gt;
        &lt;cell&gt;✓&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="5"&gt;
        &lt;cell&gt;File Attachments&lt;/cell&gt;
        &lt;cell&gt;✓&lt;/cell&gt;
        &lt;cell&gt;✓&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="5"&gt;
        &lt;cell&gt;Session Lifecycle&lt;/cell&gt;
        &lt;cell&gt;✓&lt;/cell&gt;
        &lt;cell&gt;✓&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="5"&gt;
        &lt;cell&gt;Error Events&lt;/cell&gt;
        &lt;cell&gt;✓&lt;/cell&gt;
        &lt;cell&gt;✓&lt;/cell&gt;
        &lt;cell&gt;✓&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="5"&gt;
        &lt;cell&gt;Reasoning/Thinking&lt;/cell&gt;
        &lt;cell&gt;✓&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="5"&gt;
        &lt;cell&gt;Command Execution&lt;/cell&gt;
        &lt;cell&gt;✓&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="5"&gt;
        &lt;cell&gt;File Changes&lt;/cell&gt;
        &lt;cell&gt;✓&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="5"&gt;
        &lt;cell&gt;MCP Tools&lt;/cell&gt;
        &lt;cell&gt;✓&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;cell&gt;Streaming Deltas&lt;/cell&gt;
        &lt;cell&gt;✓&lt;/cell&gt;
        &lt;cell&gt;✓&lt;/cell&gt;
      &lt;/row&gt;
    &lt;/table&gt;
    &lt;p&gt;* Coming imminently&lt;/p&gt;
    &lt;p&gt;Want support for another agent? Open an issue to request it.&lt;/p&gt;
    &lt;p&gt;The Sandbox Agent acts as a universal adapter between your client application and various coding agents (Claude Code, Codex, OpenCode, Amp). Each agent has its own adapter (e.g., &lt;code&gt;claude_adapter.rs&lt;/code&gt;) that handles the translation between the universal API and the agent-specific interface.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Embedded Mode: Runs agents locally as subprocesses&lt;/item&gt;
      &lt;item&gt;Server Mode: Runs as HTTP server from any sandbox provider&lt;/item&gt;
    &lt;/list&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Server: Rust daemon (&lt;code&gt;sandbox-agent server&lt;/code&gt;) exposing the HTTP + SSE API.&lt;/item&gt;
      &lt;item&gt;SDK: TypeScript client with embedded and server modes.&lt;/item&gt;
      &lt;item&gt;Inspector: &lt;code&gt;https://inspect.sandboxagent.dev&lt;/code&gt;for browsing sessions and events.&lt;/item&gt;
      &lt;item&gt;CLI: &lt;code&gt;sandbox-agent&lt;/code&gt;(same binary, plus npm wrapper) mirrors the HTTP endpoints.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Install skill with:&lt;/p&gt;
    &lt;code&gt;npx skills add https://sandboxagent.dev/docs
&lt;/code&gt;
    &lt;p&gt;Install&lt;/p&gt;
    &lt;code&gt;npm install sandbox-agent&lt;/code&gt;
    &lt;p&gt;Setup&lt;/p&gt;
    &lt;p&gt;Local (embedded mode):&lt;/p&gt;
    &lt;code&gt;import { SandboxAgent } from "sandbox-agent";

const client = await SandboxAgent.start();&lt;/code&gt;
    &lt;p&gt;Remote (server mode):&lt;/p&gt;
    &lt;code&gt;import { SandboxAgent } from "sandbox-agent";

const client = await SandboxAgent.connect({
  baseUrl: "http://127.0.0.1:2468",
  token: process.env.SANDBOX_TOKEN,
});&lt;/code&gt;
    &lt;p&gt;API Overview&lt;/p&gt;
    &lt;code&gt;const agents = await client.listAgents();

await client.createSession("demo", {
  agent: "codex",
  agentMode: "default",
  permissionMode: "plan",
});

await client.postMessage("demo", { message: "Hello from the SDK." });

for await (const event of client.streamEvents("demo", { offset: 0 })) {
  console.log(event.type, event.data);
}&lt;/code&gt;
    &lt;p&gt;Documentation — Building a Chat UI — Managing Sessions&lt;/p&gt;
    &lt;p&gt;Install the binary (fastest installation, no Node.js required):&lt;/p&gt;
    &lt;code&gt;# Install it
curl -fsSL https://releases.rivet.dev/sandbox-agent/latest/install.sh | sh
# Run it
sandbox-agent server --token "$SANDBOX_TOKEN" --host 127.0.0.1 --port 2468&lt;/code&gt;
    &lt;p&gt;Optional: preinstall agent binaries (no server required; they will be installed lazily on first use if you skip this):&lt;/p&gt;
    &lt;code&gt;sandbox-agent install-agent claude
sandbox-agent install-agent codex
sandbox-agent install-agent opencode
sandbox-agent install-agent amp&lt;/code&gt;
    &lt;p&gt;To disable auth locally:&lt;/p&gt;
    &lt;code&gt;sandbox-agent server --no-token --host 127.0.0.1 --port 2468&lt;/code&gt;
    &lt;p&gt;Documentation - Integration guides&lt;/p&gt;
    &lt;p&gt;Install the CLI wrapper (optional but convenient):&lt;/p&gt;
    &lt;code&gt;npm install -g @sandbox-agent/cli&lt;/code&gt;
    &lt;p&gt;Create a session and send a message:&lt;/p&gt;
    &lt;code&gt;sandbox-agent api sessions create my-session --agent codex --endpoint http://127.0.0.1:2468 --token "$SANDBOX_TOKEN"
sandbox-agent api sessions send-message my-session --message "Hello" --endpoint http://127.0.0.1:2468 --token "$SANDBOX_TOKEN"
sandbox-agent api sessions send-message-stream my-session --message "Hello" --endpoint http://127.0.0.1:2468 --token "$SANDBOX_TOKEN"&lt;/code&gt;
    &lt;p&gt;You can also use npx like:&lt;/p&gt;
    &lt;code&gt;npx sandbox-agent --help&lt;/code&gt;
    &lt;p&gt;Debug sessions and events with the Inspector UI.&lt;/p&gt;
    &lt;p&gt;Explore API — View Specification&lt;/p&gt;
    &lt;p&gt;All events follow a universal schema that normalizes differences between agents.&lt;/p&gt;
    &lt;p&gt;Often you need to use your personal API tokens to test agents on sandboxes:&lt;/p&gt;
    &lt;code&gt;sandbox-agent credentials extract-env --export&lt;/code&gt;
    &lt;p&gt;This prints environment variables for your OpenAI/Anthropic/etc API keys to test with Sandbox Agent SDK.&lt;/p&gt;
    &lt;head&gt;Does this replace the Vercel AI SDK?&lt;/head&gt;
    &lt;p&gt;No, they're complementary. AI SDK is for building chat interfaces and calling LLMs. This SDK is for controlling autonomous coding agents that write code and run commands. Use AI SDK for your UI, use this when you need an agent to actually code.&lt;/p&gt;
    &lt;head&gt;Which coding agents are supported?&lt;/head&gt;
    &lt;p&gt;Claude Code, Codex, OpenCode, and Amp. The SDK normalizes their APIs so you can swap between them without changing your code.&lt;/p&gt;
    &lt;head&gt;How is session data persisted?&lt;/head&gt;
    &lt;p&gt;This SDK does not handle persisting session data. Events stream in a universal JSON schema that you can persist anywhere. See Managing Sessions for patterns using Postgres or Rivet Actors.&lt;/p&gt;
    &lt;head&gt;Can I run this locally or does it require a sandbox provider?&lt;/head&gt;
    &lt;p&gt;Both. Run locally for development, deploy to E2B, Daytona, or Vercel Sandboxes for production.&lt;/p&gt;
    &lt;head&gt;Does it support [platform]?&lt;/head&gt;
    &lt;p&gt;The server is a single Rust binary that runs anywhere with a curl install. If your platform can run Linux binaries (Docker, VMs, etc.), it works. See the deployment guides for E2B, Daytona, and Vercel Sandboxes.&lt;/p&gt;
    &lt;head&gt;Can I use this with my personal API keys?&lt;/head&gt;
    &lt;p&gt;Yes. Use &lt;code&gt;sandbox-agent credentials extract-env&lt;/code&gt; to extract API keys from your local agent configs (Claude Code, Codex, OpenCode, Amp) and pass them to the sandbox environment.&lt;/p&gt;
    &lt;head&gt;Why Rust and not [language]?&lt;/head&gt;
    &lt;p&gt;Rust gives us a single static binary, fast startup, and predictable memory usage. That makes it easy to run inside sandboxes or in CI without shipping a large runtime, such as Node.js.&lt;/p&gt;
    &lt;p&gt;This project aims to solve 3 problems with agents:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Universal Agent API: Claude Code, Codex, Amp, and OpenCode all have put a lot of work in to the agent scaffold. Each have respective pros and cons and need to be easy to be swapped between.&lt;/item&gt;
      &lt;item&gt;Agent Transcript: Maintaining agent transcripts is difficult since the agent manages its own sessions. This provides a simpler way to read and retrieve agent transcripts in your system.&lt;/item&gt;
      &lt;item&gt;Agents In Sandboxes: There are many complications with running agents inside of sandbox providers. This lets you run a simple curl command to spawn an HTTP server for using any agent from within the sandbox.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Features out of scope:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Storage of sessions on disk: Sessions are already stored by the respective coding agents on disk. It's assumed that the consumer is streaming data from this machine to an external storage, such as Postgres, ClickHouse, or Rivet.&lt;/item&gt;
      &lt;item&gt;Direct LLM wrappers: Use the Vercel AI SDK if you want to implement your own agent from scratch.&lt;/item&gt;
      &lt;item&gt;Git Repo Management: Just use git commands or the features provided by your sandbox provider of choice.&lt;/item&gt;
      &lt;item&gt;Sandbox Provider API: Sandbox providers have many nuanced differences in their API, it does not make sense for us to try to provide a custom layer. Instead, we opt to provide guides that let you integrate this project with sandbox providers.&lt;/item&gt;
    &lt;/list&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Python SDK&lt;/item&gt;
      &lt;item&gt;Automatic MCP &amp;amp; skill &amp;amp; hook configuration&lt;/item&gt;
      &lt;item&gt;Todo lists&lt;/item&gt;
    &lt;/list&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://github.com/rivet-dev/sandbox-agent"/><published>2026-01-28T14:06:48+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=46795864</id><title>Microsoft forced me to switch to Linux</title><updated>2026-01-28T21:19:31.344860+00:00</updated><content>&lt;doc fingerprint="3c17b9573b05fcde"&gt;
  &lt;main&gt;
    &lt;head rend="h1"&gt;From Microsoft to Microslop to Linux: Why I Made the Switch&lt;/head&gt;
    &lt;p&gt;January 26, 2026&lt;/p&gt;
    &lt;head rend="h2"&gt;What's better than a devil you don't know?&lt;lb/&gt;The devil you do.&lt;/head&gt;
    &lt;p&gt;I've used Windows for as long as I've been alive. At 6 years old, my first computer was a Windows 98 machine, with an Athlon XP 1900+ (Palomino core) and a GeForce 440 MX, blessed with a generous 256 megabytes of RAM.&lt;/p&gt;
    &lt;p&gt;Looking back, I kinda got scammed with that graphics card, but what could I do? I was a silly kid. (The missing shader support came back to bite me in the ass)&lt;/p&gt;
    &lt;p&gt;Also, is it weird that I still remember the specs of my first computer, 22 years later?&lt;/p&gt;
    &lt;p&gt;Anyway, Windows has been familiar and comfortable. I knew all the workarounds and how to extract maximum efficiency from it.&lt;/p&gt;
    &lt;p&gt;I was a happy user, for over 20 years, and Windows has been my go-to for everything computer-related.&lt;/p&gt;
    &lt;p&gt;Even after becoming a software developer and using a macbook, I'd still find myself reaching for Windows at times.&lt;/p&gt;
    &lt;p&gt;That is, until Microsoft decided to turn it into something completely unrecognizable and unusable.&lt;/p&gt;
    &lt;head rend="h2"&gt;It all came crashing down&lt;/head&gt;
    &lt;p&gt;I think it started with the Windows 10 full-screen ads.&lt;/p&gt;
    &lt;p&gt;You know, those friendly suggestions telling you to try OneDrive or to "use the recommended browser settings" (reads as "please try Edge and OneDrive, we're desperate").&lt;/p&gt;
    &lt;p&gt;Actually, scratch that, I think it really started with the non-consensual updates:&lt;/p&gt;
    &lt;quote&gt;
      &lt;p&gt;Oh you're doing work? That's so cute... we're gonna close whatever apps you had open, because we're updating now. We own your computer.&lt;/p&gt;
    &lt;/quote&gt;
    &lt;quote&gt;
      &lt;p&gt;You had unsaved work? Too bad, it's gone, get bent.&lt;/p&gt;
    &lt;/quote&gt;
    &lt;p&gt;At first I ignored it, and carried on as normal. Sure, I'd get mad from time to time and I'd complain.&lt;/p&gt;
    &lt;p&gt;But hey, nothing beats the convenience of being able to have all of your applications in one place&lt;/p&gt;
    &lt;head rend="h4"&gt;Right? Right?&lt;/head&gt;
    &lt;p&gt;My breaking point came with the 24H2 update. It installed on my system without my consent, like any other major update. I knew there were problems with it, people were already complaining on Reddit, so I just postponed it, and kept postponing it.&lt;/p&gt;
    &lt;p&gt;All it took was for me to leave my computer on and unattended for a while, and BOOM, just like that - the major OS update that nobody wanted, it was on my computer.&lt;/p&gt;
    &lt;head rend="h2"&gt;The Chrome Seizure Incident&lt;/head&gt;
    &lt;p&gt;As soon as 24H2 landed on my machine, I encountered a bug so bizarre I thought I was losing my marbles.&lt;lb/&gt; If Chrome was positioned under any other window, it would start having what I can only describe as a visual seizure.&lt;lb/&gt; Here's Ableton Live with Chrome (Reddit) under it:&lt;/p&gt;
    &lt;p&gt;Worse, there was a decent chance this would trigger a full system lock, leaving me smashing my desk in impotent rage. I shit you not.&lt;/p&gt;
    &lt;p&gt;I tried to rollback. The rollback failed with an error. I reinstalled Windows. The bug persisted.&lt;lb/&gt; Like digital herpes, I just couldn't get rid of it.&lt;lb/&gt; The solution? Installing an Insider build. Yes, the solution to Microsoft's broken stable release was to use their unstable release.&lt;/p&gt;
    &lt;quote&gt;
      &lt;p&gt;For the Windows Defenders (see what I did there?), I tried uninstalling the display drivers with DDU, and testing other versions. It didn't help.&lt;/p&gt;
      &lt;p&gt;Either I stayed forever on the older build, or I'd have to deal with this. And don't tell me to forever disable updates, I'll completely lose it.&lt;/p&gt;
    &lt;/quote&gt;
    &lt;head rend="h2"&gt;The Sequel I Never Wanted&lt;/head&gt;
    &lt;p&gt;The Insider build worked...sort of. But now I had a new bug: Chrome would randomly lock up for about 30 seconds when a video was playing. My options were to wait it out or press Ctrl+Alt+Delete and Esc to force my way back to a working browser. After some digging, I discovered this was caused by an NVIDIA-Microsoft driver incompatibility.&lt;/p&gt;
    &lt;p&gt;Links here:&lt;/p&gt;
    &lt;p&gt;I've found out that the flickers and the chrome lock-up issues are likely caused by the Multiplane Overlay (MPO) pipeline. Microsoft blamed NVIDIA for not correctly implementing it in their drivers. NVIDIA blamed Microsoft. What's clear is that if you were facing this issue, you were essentially screwed because these 2 companies would just pass the hot potato to each other.&lt;/p&gt;
    &lt;p&gt;I should mention that this bug persisted even after I went off the Insider build and on 25H2. And when I posted on r/Microsoft, they just deleted it.&lt;/p&gt;
    &lt;p&gt;The latest and greatest OS surely cannot be broken beyond repair, surely I'm using my PC wrong.&lt;/p&gt;
    &lt;p&gt;So there I was, finally grasping the reality of what you're up against, as a Windows user:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Random bugs that break basic functionality&lt;/item&gt;
      &lt;item&gt;Updates that install without permission and brick my system&lt;/item&gt;
      &lt;item&gt;Copilot and OneDrive ads appearing in every corner of the OS&lt;/item&gt;
      &lt;item&gt;Copilot buttons everywhere, coming for every application&lt;/item&gt;
      &lt;item&gt;Can't even make a local account without hacking the setup with Rufus (they even removed the terminal workaround)&lt;/item&gt;
      &lt;item&gt;Zero actionable fixes or even an aknowledgment of their fuckups&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;People often say Linux is "too much work.".&lt;/p&gt;
    &lt;p&gt;And I agree. They're completely justified to complain. There's the documentation page diving, the forums, the reddit threads. And, most importantly, you have to basically rewire your brain and stop expecting it to behave like Windows used to.&lt;/p&gt;
    &lt;p&gt;But I looked at the list above and realized: Windows is now also too much work.&lt;lb/&gt; And the difference with Windows is that you're going to do all that work while actively fighting your computer only for it to be undone when the next surprise update comes and ruins everything.&lt;/p&gt;
    &lt;p&gt;You might be thinking "just disable updates, man" or "just install LTSC", or "just run some random debloat script off of GitHub". Why? Why would I jump through all these hoops? I'd rather put in the effort for an OS that knows what consent is and respects me as a user.&lt;/p&gt;
    &lt;head rend="h2"&gt;Could the grass actually be greener on the other side?&lt;/head&gt;
    &lt;p&gt;To set the stage: I'm a software developer and a musician.&lt;/p&gt;
    &lt;p&gt;As you can imagine, I was legitimately worried about app support on Linux, and how it would distrupt my workflow.&lt;/p&gt;
    &lt;p&gt;But after Chrome crashing for the 10000th time, I said "enough is enough", and decided to go big. I installed CachyOS, a performance-focused Arch-based distribution, on my main machine (9800X3D, RTX 5080).&lt;/p&gt;
    &lt;p&gt;It wasn't a painless process. In fact, sleep mode was broken from the start, and my system would fail to detect the monitor after waking up.&lt;/p&gt;
    &lt;p&gt;What's more, Ableton Live does not have a native Linux build, only Windows and macOS. So I couldn't use it anymore, at least not without fucking around with Wine (which doesn't fully support it), or without keeping a Windows VM and taking an L on audio latency.&lt;/p&gt;
    &lt;p&gt;But unlike Windows, on CachyOS I could actually fix my NVIDIA woes by following this thread on their forum.&lt;/p&gt;
    &lt;p&gt;All I had to do was add the NVIDIA modules to mkinitcpio. One config change, a command to rebuild the initramfs, and problem solved.&lt;/p&gt;
    &lt;p&gt;I also found a good native alternative to Ableton Live - Bitwig Studio, which bothered to release a native Linux Build.&lt;/p&gt;
    &lt;p&gt;Thanks to the constant progress that was made with Pipewire, I'm getting audio latency on par with Mac OS, and lower than Windows. And my workflow didn't even change that much, since Bitwig is made by ex-Ableton developers that seem to give a shit.&lt;/p&gt;
    &lt;p&gt;As for my development tools, on Windows you already accept the fact that you WILL use WSL or docker, so realistically I just cut the broken middleman.&lt;/p&gt;
    &lt;p&gt;Now compare that to the Windows fuckery above.&lt;/p&gt;
    &lt;head rend="h2"&gt;What You're Signing Up For&lt;/head&gt;
    &lt;p&gt;If 3 years ago you would have told me that Microsoft would singlehandedly sabotage their own OS, doing more Linux marketing than the most neckbearded Linux fanboy (or the most femboy Thinkpad enjoyer), I'd have laughed in your face, called you delusional, and then hurled some more insults your way.&lt;/p&gt;
    &lt;p&gt;Yet here we are, I've been dual-booting CachyOS for over a year, and in the last month I've been using it exclusively.&lt;/p&gt;
    &lt;p&gt;So what is the actual state of Linux in 2026, from my honest perspective?&lt;/p&gt;
    &lt;head rend="h5"&gt;Web Browsing&lt;/head&gt;
    &lt;p&gt;All major browsers (Chrome, Firefox, Edge, Brave) have native Linux builds. Full support. No compromises.&lt;lb/&gt; Video playback works flawlessly, with hardware acceleration even. On AMD, on NVidia and yes, on Intel too.&lt;/p&gt;
    &lt;head rend="h5"&gt;Software Development&lt;/head&gt;
    &lt;p&gt;Linux is the preferred platform for development.&lt;/p&gt;
    &lt;p&gt;Better terminal support, native package managers, Docker runs natively without the WSL overhead, and your production servers are probably running Linux anyway.&lt;/p&gt;
    &lt;p&gt;Hell, even Microsoft has their own Linux distro, Azure Linux (Formerly CBL-Mariner).&lt;/p&gt;
    &lt;head rend="h5"&gt;Content Creation&lt;/head&gt;
    &lt;p&gt;This is where people assume Linux falls short. And they're right, but not completely:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Adobe Suite: Runs via Winboat. Far from perfect (no video acceleration, laggy at times), but functional&lt;/item&gt;
      &lt;item&gt;DaVinci Resolve: Native Linux app. Professional-grade video editing, free tier available&lt;/item&gt;
      &lt;item&gt;Kdenlive: Native Linux app, completely free and open source&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h5"&gt;Music Production&lt;/head&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Bitwig Studio: Incredible DAW that runs natively on Linux&lt;/item&gt;
      &lt;item&gt;Ardour: Native, free, open-source DAW&lt;/item&gt;
      &lt;item&gt;Audio latency: Thanks to PipeWire, Linux audio latency is actually lower than Windows&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h5"&gt;Gaming&lt;/head&gt;
    &lt;p&gt;Here's where things get interesting. The perception is that gaming on Linux is a compromise. In 2026, that's increasingly untrue:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Proton/Wine: Pretty much all games without kernel-level anti-cheat work out of the box through Steam's Proton compatibility layer&lt;/item&gt;
      &lt;item&gt;Performance: For AMD GPUs, gaming performance is on par with Windows, on average&lt;/item&gt;
      &lt;item&gt;NVIDIA: There was a 10-30% performance penalty on Intel/NVIDIA GPU setups, but recent Vulkan extensions are taking care of that.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;NVIDIA has released beta drivers making use of these improvements, and once Wine/DXVK/Proton are updated to make use of the extensions, the performance delta should be essentially gone&lt;/p&gt;
    &lt;p&gt;The only real limitation is that some games with anti-cheat like Valorant, Call of Duty or League of Legends won't run. But honestly I think not being able to launch League of Legends is actually a feature - one final reason to install Linux.&lt;/p&gt;
    &lt;p&gt;It's not all bad, though. Arc Raiders makes use of Easy Anti-Cheat, yet runs flawlessly. In fact, I've been playing it like a madman. It goes to show that if the developers want to, it's possible.&lt;/p&gt;
    &lt;head rend="h5"&gt;3D Modeling&lt;/head&gt;
    &lt;p&gt;Still falls short compared to Windows and Mac OS (Autodesk, I'm looking at you).&lt;/p&gt;
    &lt;p&gt;The silver lining is that Blender has a native build. So if it's your main application, you're good to go.&lt;/p&gt;
    &lt;head rend="h5"&gt;General Usage&lt;/head&gt;
    &lt;p&gt;Basic operations are so much faster on Linux. Opening directories, launching applications, system responsiveness. It's like your computer took a line of coke, and is now ready to work.&lt;/p&gt;
    &lt;p&gt;No more waiting for the Start menu to decide it wants to open. No more File Explorer hanging when you need it the most.&lt;/p&gt;
    &lt;p&gt;Since we're on the topic of Linux improvements, I want to address the elephant in the room - people who keep saying "I want to switch", but keep moving the goalposts:&lt;/p&gt;
    &lt;quote&gt;
      &lt;p&gt;"I'll switch when Linux supports X."&lt;/p&gt;
    &lt;/quote&gt;
    &lt;quote&gt;
      &lt;p&gt;Linux supports X.&lt;/p&gt;
    &lt;/quote&gt;
    &lt;quote&gt;
      &lt;p&gt;"Okay, but what about Y?"&lt;/p&gt;
    &lt;/quote&gt;
    &lt;quote&gt;
      &lt;p&gt;Linux supports Y.&lt;/p&gt;
    &lt;/quote&gt;
    &lt;quote&gt;
      &lt;p&gt;"Well, Z is still missing..."&lt;/p&gt;
    &lt;/quote&gt;
    &lt;p&gt;If you're always finding the next reason not to switch, you're not looking for solutions, you're looking for excuses to stay complacent.&lt;/p&gt;
    &lt;p&gt;I was that person, so I would know.&lt;/p&gt;
    &lt;p&gt;At the same time, I want to take it down a notch and say that there are still plenty of use cases (Especially creative work, and like stated previously, 3D modelling and also Game Dev) where it simply doesn't make sense to switch.&lt;/p&gt;
    &lt;p&gt;So if you're in that scenario, don't feel pressured, just wait for things to improve.&lt;/p&gt;
    &lt;p&gt;And if you don't plan on ever switching, more power to you.&lt;/p&gt;
    &lt;p&gt;I'm not here to judge, just here to vent my Microsoft frustrations.&lt;/p&gt;
    &lt;p&gt;And I didn't really want to switch either, because who wants to re-learn how their computer should be operated from scratch? What I really wanted was for Windows to work, but Microsoft didn't.&lt;/p&gt;
    &lt;head rend="h2"&gt;The Windows Retrospective&lt;/head&gt;
    &lt;p&gt;While I'm enjoying my new Linux setup, Windows 11 is having a miserable year, and we're only a month in!&lt;/p&gt;
    &lt;p&gt;According to Windows Latest, there were over 20 major update problems in 2025 alone, and 2026 is starting off strong, with the January update causing black screens and Outlook crashes.&lt;/p&gt;
    &lt;p&gt;Here's a quick 2025 Spotify Wrapped of the bugs Windows users dealt with:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;USB audio devices randomly stopped working&lt;/item&gt;
      &lt;item&gt;Webcams failed to be detected&lt;/item&gt;
      &lt;item&gt;BitLocker settings became inaccessible&lt;/item&gt;
      &lt;item&gt;Adobe Premiere Pro couldn't drag clips on the timeline&lt;/item&gt;
      &lt;item&gt;Cursor constantly spinning for no reason&lt;/item&gt;
      &lt;item&gt;Remote Desktop sessions randomly disconnecting&lt;/item&gt;
      &lt;item&gt;The Copilot app accidentally getting deleted (okay, this is actually a good change for once)&lt;/item&gt;
      &lt;item&gt;Blue screens of death in mandatory security updates&lt;/item&gt;
      &lt;item&gt;Windows Hello face recognition broken&lt;/item&gt;
      &lt;item&gt;File Explorer becoming unresponsive&lt;/item&gt;
      &lt;item&gt;FPS drops and system reboots while gaming&lt;/item&gt;
      &lt;item&gt;Task Manager spawning infinite copies of itself&lt;/item&gt;
      &lt;item&gt;Dark mode breaking with white flashes&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;And the company's response? Crickets. They're busy boasting that 30% of their code is currently being written by AI. Don't worry, Microsoft, we can definitely tell.&lt;/p&gt;
    &lt;p&gt;For the remainder of 2026, Microsoft is cooking up a big one: replacing more and more native apps with React Native. But don't let the name fool you, there's nothing "native" about it. These are projects designed to be easily ported across any machine and architecture, because underneath it all, it's just JavaScript.&lt;/p&gt;
    &lt;p&gt;And each one spawns its own Chromium process, gobbling up your RAM so you can enjoy the privilege of opening the Settings app.&lt;/p&gt;
    &lt;p&gt;I could maybe understand this for a weather widget. But when it's coming for core system apps, it's LAZY!&lt;/p&gt;
    &lt;p&gt;I'm gonna go full conspiracy nut here, but I bet it's because the LLM understands JavaScript better, and Microsoft can't be asked to pay actual humans to write proper native code.&lt;/p&gt;
    &lt;p&gt;Meanwhile, entire governments are abandoning Windows for Linux, the term "Microslop" is trending on social media, and Windows 11's reputation is at its lowest point ever.&lt;/p&gt;
    &lt;head rend="h2"&gt;Not Because I Wanted To, But Because Microsoft Forced My Hand&lt;/head&gt;
    &lt;p&gt;So here I am. Fully switched to Linux.&lt;/p&gt;
    &lt;p&gt;Not because I'm some open-source idealist or command-line warrior (I'm just some guy), but because Microsoft turned into Microslop.&lt;/p&gt;
    &lt;p&gt;Recently, Microsoft CEO Satya Nadella wrote a blog post asking people to stop calling AI-generated content "slop" and to think of AI as "bicycles for the mind."&lt;/p&gt;
    &lt;p&gt;Well, Mr Satya, I have a couple of bicycles that will blow your mind:&lt;/p&gt;
    &lt;p&gt;You are the biggest Linux evangelist there ever was, you single-handedly convinced countless people to ditch your buggy, ad-ridden, bloated, slop-infested mess of an OS.&lt;/p&gt;
    &lt;p&gt;And worst of all, you're like a pit bull that has lock-jawed onto OpenAI's ballsack, and you're not letting go, no matter how much we tell you to.&lt;/p&gt;
    &lt;p&gt;So we're calling slop for what it is: disgusting slop.&lt;/p&gt;
    &lt;p&gt;You're chasing profit like your life depends on it, yet you've completely forgotten the very thing that generates profit: user satisfaction.&lt;/p&gt;
    &lt;p&gt;Now you're stuck in a circlejerk of fake value in a fake bubble, and OpenAI's hand is so far up your ass they're playing shadow puppets with your tonsils.&lt;/p&gt;
    &lt;p&gt;The time to switch is now. The tools are ready. The only question is: are you?&lt;/p&gt;
    &lt;p&gt;Satya came down from his cloud in the sky,&lt;/p&gt;
    &lt;p&gt;With Copilot dreams and a gleam in his eye,&lt;/p&gt;
    &lt;p&gt;He sprinkled AI on each app, every field,&lt;/p&gt;
    &lt;p&gt;Till users cried "Fuck!", and the slop was revealed.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://www.himthe.dev/blog/microsoft-to-linux"/><published>2026-01-28T14:28:21+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=46795908</id><title>Airfoil (2024)</title><updated>2026-01-28T21:19:30.544890+00:00</updated><content>&lt;doc fingerprint="b77d1a2b09aeb189"&gt;
  &lt;main&gt;
    &lt;head rend="h1"&gt;Airfoil&lt;/head&gt;
    &lt;p&gt;The dream of soaring in the sky like a bird has captivated the human mind for ages. Although many failed, some eventually succeeded in achieving that goal. These days we take air transportation for granted, but the physics of flight can still be puzzling.&lt;/p&gt;
    &lt;p&gt;In this article we’ll investigate what makes airplanes fly by looking at the forces generated by the flow of air around the aircraft’s wings. More specifically, we’ll focus on the cross section of those wings to reveal the shape of an airfoil â you can see it presented in yellow below:&lt;/p&gt;
    &lt;p&gt;We’ll find out how the shape and the orientation of the airfoil helps airplanes remain airborne. We’ll also learn about the behavior and properties of air and other flowing matter. In the demonstration below, you can see a fluid flowing around a gray cube. Using the slider to change just one property of this substance, we can end up with vastly different effects on the liveliness of that flow:&lt;/p&gt;
    &lt;p&gt;Over the course of this blog post we’ll build some intuitions for why these different effects happen to airfoils and other objects placed in flowing air. We’ll start this journey by looking at some of the methods we can use to visualize the motion of the air.&lt;/p&gt;
    &lt;head rend="h1"&gt;Visualizing Flow&lt;/head&gt;
    &lt;p&gt;If you’ve ever been outside in a grassy area on a windy fall day, you may have witnessed something similar to the little scene seen below. The slider lets you control the speed of time to observe in detail how the falling leaves and the bending blades of grass are visibly affected by the wind sweeping through this area:&lt;/p&gt;
    &lt;p&gt;We intuitively understand that it’s the flowing air that pushes the vegetation around, but note that we only observe the effects that the wind has on other objects â we can’t see the motion of the air itself. I could show you a similarly windy scene without the grass and leaves, and I could try to convince you that there is something going on there, but that completely empty demonstration wouldn’t be very gratifying.&lt;/p&gt;
    &lt;p&gt;Since the air’s transparency prevents us from tracking its movement directly, we have to come up with some other ways that can help us see its motion. Thankfully, the little outdoor scene already provides us with some ideas.&lt;/p&gt;
    &lt;p&gt;Notice that as the wind hits a blade of grass, that blade naturally bends in the direction of the blowing gust, and the faster that gust, the stronger the bending. AÂ single blade indicates the direction and speed of the flow of air in that area.&lt;/p&gt;
    &lt;p&gt;In the next demonstration we’re looking at the same grassy field from above. When seen from this perspective, all the blades form short lines that are locally aligned with the wind. The more leaned over a blade of grass is, the longer the line it forms. We can mimic this behavior with a collection of small arrows placed all over the area, as seen on the right side:&lt;/p&gt;
    &lt;p&gt;Each arrow represents the direction and the speed of the flow of air at that location â the longer the arrow, the faster the flow. In these windy conditions the flow varies from place to place and it also changes over time, which we can clearly see in the motion of the arrows.&lt;/p&gt;
    &lt;p&gt;Note that we have some flexibility in how the speed of wind corresponds to the length of an arrow. I adjusted the lengths of the arrows to prevent them from visually overlapping, but I also made sure to maintain their relative lengths â if one arrow is twice as long as the other, then the flow at that location is also twice as fast.&lt;/p&gt;
    &lt;p&gt;For visual clarity I’m also not packing the arrows as densely as the blades of grass are placed, but it’s important to note that every point in the flow has its own velocity which contributes to the complete velocity field present in this area. If we wanted to, we could draw a velocity arrow at any of the seemingly empty spots on the right side.&lt;/p&gt;
    &lt;p&gt;The arrows are convenient, but the grassy scene also has another aid for visualizing flows. Many light objects like leaves, flower petals, dust, or smoke are very easily influenced by the motion of the surrounding air. They quickly change their velocity to match the flow of the wind. We can replicate the behavior of these light objects with little markers that are pushed around by that flow. You can see them on the right side:&lt;/p&gt;
    &lt;p&gt;These little markers also show us the motion of the air. Each marker represents an object so small and light that it instantly picks up the speed of the surrounding airflow. We’d have a hard time seeing these miniscule specks at their actual sizes, so I’m drawing the markers as visible dots.&lt;/p&gt;
    &lt;p&gt;In fact, the motion of each marker is equivalent to the motion of the parcel of air right around it. If you slow down time, you’ll be able to see how each marker just moves in the direction of the arrows underneath it. I also made each marker leave a little ghost trail behind it â this lets us track the path the air, as represented by the marker, took on the way to its current position.&lt;/p&gt;
    &lt;p&gt;Let’s pause for a second to emphasize what the grass-like arrows and leaf-like markers represent âÂ they both show the velocity of the flow of air, but in slightly different ways. An arrow is attached to its fixed point in space, so it represents the current direction and speed of the flow at that location. The whole collection of arrows lets us easily see what the entire flow is doing at the moment.&lt;/p&gt;
    &lt;p&gt;On the other hand, the little markers are actively following the flow, letting us see how the air is actually moving through space, with the ghosty trails giving us some historical overview of where this parcel of air has come from.&lt;/p&gt;
    &lt;p&gt;The two methods we’ve seen so far are very versatile, but sometimes we don’t care about the local direction of the flow, only its speed â in the middle of this grassy field one might get cold from a fast blowing wind regardless of the direction from which that wind is coming. This brings us the third way of visualizing flow:&lt;/p&gt;
    &lt;p&gt;In this method we show the speed of the airflow using colors of varying brightness â the faster the wind, the brighter the color. You can see the whole spectrum of colors in the scale below the plot.&lt;/p&gt;
    &lt;p&gt;This method shows the speed of the flow at all locations giving us a more fine-grained insight into the motion of air at the cost of the directional information. To help with that I’ll sometimes overlay the regular arrows on top to let us know where the flow is going as well.&lt;/p&gt;
    &lt;p&gt;You may have noticed that all these methods present a flat, two dimensional view of the flow. It’s based on the assumption that the wind in our little scene doesn’t change with elevation, and that it also doesn’t blow towards or away from the ground.&lt;/p&gt;
    &lt;p&gt;In reality, the air velocity could vary in all three dimensions, and that air could also flow upwards or downwards. Thankfully, the air flows we’ll consider in this article will be two dimensional and the simple flat drawings will suffice.&lt;/p&gt;
    &lt;p&gt;Before we finish this section, let me bring up visualization of a simple airflow, but this time I’ll give you some control over its direction, which you can change using the second slider. The first one once more controls the speed of time:&lt;/p&gt;
    &lt;p&gt;Don’t be misled by the frozen arrows, the wind is actually blowing there. Remember that the arrows represent the local velocity of the flow of air, so while the velocity doesn’t change, the position of each packet of air does. You can see those changes by tracking the markers moving around with the flow. This demonstration represents a steady flow, which means that its properties don’t change over time.&lt;/p&gt;
    &lt;p&gt;So far we’ve been exploring the notion of airflow’s velocity on a more intuitive level, with a general understanding that’s it’s “the air” moving around in some direction and at some speed. I illustrated that concept using simple arrowsâ, markersÂ â¢, and varying colors, but we’re now ready to investigate the details hiding behind those straightforward graphical representations.&lt;/p&gt;
    &lt;p&gt;To do that, we have to look at individual particles of air. Although I briefly discussed the particle nature of air before, this time around we’re going to take a closer look at the motion of these molecules, and what it means for airflow as a whole.&lt;/p&gt;
    &lt;head rend="h1"&gt;Velocity&lt;/head&gt;
    &lt;p&gt;Let’s take a look at the air particles in a small, marked out volume of space seen in the demonstration below â you can drag the cube around to change the viewing angle. The slider controls the speed of time:&lt;/p&gt;
    &lt;p&gt;You’re witnessing the motion of over twelve thousand air particles. It may seem like a lot, but this cube is extremely tiny, its sides are only 80 nanometers long. To put this in perspective using more familiar sizes, if that cube’s side measured just 1 inch1 centimeter, it would contain around 410 quintillion, or 4.1Ã102025 quintillion, or 2.5Ã1019 particles.&lt;/p&gt;
    &lt;p&gt;The particles are zipping around in random directions, constantly entering and leaving this region. However, despite all this motion what you’re seeing here is a simulation of still air.&lt;/p&gt;
    &lt;p&gt;To understand how all this movement ends up creating still conditions, we first have to look at the velocity of each particle â I’ll visualize it with a small arrow in the direction of motion. To make things a easier to see, I’ll also highlight a few of the particles while fading out the rest of them:&lt;/p&gt;
    &lt;p&gt;The length of an arrow is proportional to the speed of a particle, so when you freeze the time you should be able to see how some particles are slower and some are faster. This speed variation follows a certain distribution that’s related to temperature â the warmer the air, the faster the motion of its particles.&lt;/p&gt;
    &lt;p&gt;At room temperature the average speed of a particle in air is an astonishing 1030Â mph1650Â km/h, which is many times higher than even the most severe hurricanes. Given the size of the cube, this means that even at the fastest speed of simulation everything happens 11 billion times slower than in real life.&lt;/p&gt;
    &lt;p&gt;If you paid close attention, you may have also noticed that sometimes the particles randomly change direction and speed of their motion â this happens when molecules collide. Each particle experiences roughly ten billion collisions per second. We’ll get back to these interactions later on, but for now let’s try to figure out how all this turmoil creates still air.&lt;/p&gt;
    &lt;p&gt;Having just seen the small velocity arrows of individual particles, let’s calculate the average velocity of a group of three particles, using the process shown below. We first take the velocity arrows from each particle and place them head to toe, one after another. Then we connect the start of the first arrow with the end of the last arrow to create the sum of all velocities. Finally, we divide, or scale down, the length of this sum by the number of particles to get the average velocity:&lt;/p&gt;
    &lt;p&gt;In the next demonstration we’re repeating this whole procedure by tallying up all the particles inside the red box. You can change the size of that region with the second slider. The large arrow in the middle shows the average velocity of particles in the box. To make that central arrow visible, I’m making it much larger than the tiny arrows tied to particles:&lt;/p&gt;
    &lt;p&gt;The counter in the bottom part of the demonstration tracks the current number of particles in the red cube. That value fluctuates as the molecules enter and leave that region. While aggregating over a small number of particles creates a very noisy readout, it doesn’t take that many particles to get a much steadier measure.&lt;/p&gt;
    &lt;p&gt;Recall that the scale of the large central arrow is much larger than the scale of individual tiny arrows attached to each particle. Despite that increase in size, the arrow practically disappears when we average out a larger number of particles and we can clearly see that the average velocity of particles is more or less zero even in this extremely small volume.&lt;/p&gt;
    &lt;p&gt;In still conditions, all these motions in different directions average out to nothing. As some particles enter the area from a random direction, the others also leave it in a random way. The bulk of air doesn’t really go anywhere and the particles just meander in a random fashion.&lt;/p&gt;
    &lt;p&gt;An imperfect, but convenient analogy is to imagine a swarm of bees flying in the air. While all the individual insects are actively roaming around at different speeds, the group as a whole may steadily stay in one place.&lt;/p&gt;
    &lt;p&gt;All these experiments form the key to understanding what happens when wind sweeps through an area. In the demonstration below, we’re once again watching a small volume of space, but this time you can control the speed of the blowing wind:&lt;/p&gt;
    &lt;p&gt;Notice the mphkm/h speedometer in the bottom of the demonstration. This is not a mistake âÂ even with hurricane-level wind speeds it’s very hard to see any difference in the motion of the particles. Perhaps you’ve managed to see the tiniest shifts in the small particle arrows as you drag the second slider around with time paused, but it’s difficult to even perceive from which direction the wind is blowing.&lt;/p&gt;
    &lt;p&gt;However, when we use the procedure of averaging the velocity of all the particles, we can reveal the motion of their group in the box of a given size, at a specific speed of the flow:&lt;/p&gt;
    &lt;p&gt;Because the motion of each individual particle is so disordered, we have to look at many of them at once to discern any universal characteristics. And when we do just that, from all the chaos emerges order.&lt;/p&gt;
    &lt;p&gt;It’s important to note that with this approach we’re tracking the velocity of the flow within the same region of space outlined by the red box â the molecules keep entering and leaving this area as the flow moves and the arrow in the middle shows the average velocity of the air’s particles in that area.&lt;/p&gt;
    &lt;p&gt;This is exactly what the grass-like arrows we’ve played with in the previous section represent â each one shows the average velocity of air particles in that local region of space. The big arrow we just saw in the middle of the swarm in the averaging red box is equivalent to each of the arrows seen below:&lt;/p&gt;
    &lt;p&gt;Naturally, the averaging box needs to be large enough to avoid the jitteriness related to aggregation of too few particles, but at any scale that we could care about the noisy readout completely disappears.&lt;/p&gt;
    &lt;p&gt;The average motion of particles is very different than the motion of each individual molecule. Even in very fast flows, many of the molecules move in the opposite direction than what the arrow indicates, but if we tally up all the particle motion, the air as a whole does make forward progress in the direction of velocity.&lt;/p&gt;
    &lt;p&gt;Up to this point, we’ve mostly looked at the flow of air by looking at wind and the way it moves through space, but what we consider a motion of air is relative. Let’s see how, by merely changing the point of view, we can create a motion of air in otherwise windless conditions.&lt;/p&gt;
    &lt;head rend="h1"&gt;Relative Velocity&lt;/head&gt;
    &lt;p&gt;Let’s zoom away from the world of microscopic particles to look at the motion of larger bodies. In the demonstration below, you can see two different views of the same car driving in the left direction. In the top part, the camera stays firmly on the ground, but in the bottom part, the camera tracks the motion of the vehicle. If needed, you can restart the scene with the button in the bottom left corner or tweak the speed of time with the slider:&lt;/p&gt;
    &lt;p&gt;These two views show the exact same scene â we’re just changing what the camera is focusing on. As seen in the top part, from the perspective of the static camera, it’s only the car that has some velocity in the left direction.&lt;/p&gt;
    &lt;p&gt;On the other hand, from the perspective of the camera focused on the vehicle, the car doesn’t move, but everything else does. The poles and road markings all move to the right with a speed equal to that of the car. This shouldn’t come as a surprise from daily experience in any form of transportation â when you’re sitting in a moving vehicle, static things in the surrounding environment seem to move towards and past you.&lt;/p&gt;
    &lt;p&gt;The very same rules apply to any region of air â I’ve outlined some of them with dashed boxes up in the sky. For the observer on the ground that air is still, but from the car’s perspective, that air is moving.&lt;/p&gt;
    &lt;p&gt;With that in mind, let’s see the same scene, but this time I’ll add the familiar small arrows showing the air’s velocity as “seen” by the camera:&lt;/p&gt;
    &lt;p&gt;From the point of view of the car, as seen in the bottom view, the air is moving to the right, as if there was some wind blowing right at the vehicle. You’ve probably felt this many times by sticking your hand out the window â it feels no different than if you were standing still on the ground with the wind hitting your fingers.&lt;/p&gt;
    &lt;p&gt;In fact, there is absolutely no difference between “regular” wind and wind experienced by the car or your hand sticking out the window â both are simply a motion of air relative to some object. This means that we can use our arrows to represent any motion of air, as long as we note what that motion is relative to.&lt;/p&gt;
    &lt;p&gt;You may have also noticed that the moving car affects the motion of air in its vicinity. Let me bring up the previous demonstration one more time:&lt;/p&gt;
    &lt;p&gt;In the top view, we can see how the front of the vehicle pushes the air forward, and how the air “bends” and speeds up around the shape of the car to roughly follow its shape, only to end up circling right behind the machine.&lt;/p&gt;
    &lt;p&gt;The same effects are seen in the bottom view â they’re just experienced differently. For example, the air right in front of the car slows down, while the air on top moves even faster than the rest of the undisturbed, distant air.&lt;/p&gt;
    &lt;p&gt;We’ll soon explore why the air behaves this way when flowing around an object, but for now let’s raise above the ground to see the motion of an airplane flying in the sky. We’ll use the familiar setup of a camera kept steady relative the ground, as seen in the top part, and a camera that follows the airplane, seen in the bottom part:&lt;/p&gt;
    &lt;p&gt;Before we continue, notice that it’s getting a little hard to pay close attention to what happens to the moving objects in the ground-fixed camera view â the bodies quickly leave the field of view of the demonstrations. For the rest of this article I’ll stick to the camera style seen in the bottom part of the demonstration â this will let us directly track the interaction between the object and the air that flows around that object.&lt;/p&gt;
    &lt;p&gt;From the point of view of the airplane, it also experiences a flow of incoming air as seen by the air “boxes” approaching the plane, which is very similar to the car example. What’s completely different from the car example is the fact that the airplane somehow stays suspended in the air, despite gravity pulling it down towards the ground. This means that there must be some other force acting on it to prevent the plane from falling from the sky.&lt;/p&gt;
    &lt;p&gt;Let’s compare these two vehicles by looking at the basic forces affecting their motion, starting with the diagram of forces acting on the car:&lt;/p&gt;
    &lt;p&gt;The down-pulling gravity force is counteracted by the reaction forces from the ground â they act through the car’s tires to prevent the car from sinking. The air drag and other forms of resistance push the car back, but the car’s tires powered by the engine keep propelling the car forward.&lt;/p&gt;
    &lt;p&gt;In my previous article I presented a more elaborate description of the interplay between forces and objects, but to briefly recap here, if forces acting on an object are balanced, then that object will maintain its current velocity.&lt;/p&gt;
    &lt;p&gt;All forces on the car are balanced and the vehicle moves forward with constant speed, and it doesn’t move at all in the up or down direction â the object’s velocity is indeed constant.&lt;/p&gt;
    &lt;p&gt;Let’s draw a similar diagram of forces for the flying plane:&lt;/p&gt;
    &lt;p&gt;We still have the air drag that pushes the vehicle back, and the plane’s propeller powered by the engine keeps pushing it forward. As a result the plane moves forward with constant speed.&lt;/p&gt;
    &lt;p&gt;We also have the down-pulling gravity. This time, however, that gravity is not countered by the reaction forces from the ground, but instead it’s balanced by lift, a force that pushes the plane up. When gravity and lift are equalized, the plane doesn’t move up or down either.&lt;/p&gt;
    &lt;p&gt;Airplanes create most of their lift with wings, which are carefully designed to generate that force. While length, area, and the overall geometry of the wings are very important, in this article we’ll focus on the shape of the cross-section of a wing which I highlighted below in yellow:&lt;/p&gt;
    &lt;p&gt;This is an airfoil, the protagonist of this article. This airfoil has a smooth, rounded front and a sharp trailing edge. Let’s take a closer look at the flow of air around this airfoil using the grass-like arrows that show the velocity of air at that location:&lt;/p&gt;
    &lt;p&gt;These arrows paint an interesting picture, but in the demonstration below I’ve also added the little leaf-like markers that track the motion of air parcels in the flow. IÂ steadily release a whole line of them from the left side, but you can also clicktap anywhere in the flow to drop a marker at that location. You can do this in any demonstration that has a little hand symbol in the bottom right corner:&lt;/p&gt;
    &lt;p&gt;The markers show that the flow splits ahead of the airfoil, then it gently changes direction to glide above and below the shape. Moreover, the markers right in front of the airfoil gradually slow down and lag behind their neighbors. The air somehow senses the presence of the body.&lt;/p&gt;
    &lt;p&gt;It may be hard to see, but the top and bottom sections of this airfoil aren’t symmetric. This asymmetric design is very important, but right now it will needlessly complicate our discussion on how the flow around this shape arises.&lt;/p&gt;
    &lt;p&gt;To simplify things a little, let’s use a less complicated shape of a symmetric airfoil â you can see it in the demonstration below. I overlay the previous asymmetric shape with a dashed outline to show the difference between the two:&lt;/p&gt;
    &lt;p&gt;The motion of air around this airfoil is very similar â the flow changes its direction and speed when it passes around an object. Until now we’ve simply been observing that the flow changes to adapt to the shape of the body, but it’s finally time to understand why it happens. To explain that behavior we need to go back to the world of air particles to discuss the concept of pressure.&lt;/p&gt;
    &lt;head rend="h1"&gt;Pressure&lt;/head&gt;
    &lt;p&gt;As we’ve discussed, even in the seemingly steady conditions the particles of air are zipping around at high speeds colliding with each other at an incredible rate. The surface of any object placed in the air will also experience these bounces.&lt;/p&gt;
    &lt;p&gt;In the demonstration below, you can see air particles bombarding a small box. Every time a collision happens I briefly mark it with a dark spot on the surface of that cube:&lt;/p&gt;
    &lt;p&gt;To understand the implications of these collisions, let’s first take a look at objects with more ordinary sizes. In the demonstration below, tennis balls are hitting a large cardboard box from the left and right side. By dragging the slider you can change the intensity of both streams of balls:&lt;/p&gt;
    &lt;p&gt;When a tennis ball hits the box, the collision imparts some force on it, causing the box to move. However, in this simulation the collisions from all the balls on each side balance each other out, so the box doesn’t make any consistent progress in either direction.&lt;/p&gt;
    &lt;p&gt;In real air, the situation is similar, but at vastly different scales. The mass of each particle constituting air is absolutely miniscule, so the impact of an individual collision on any object of meaningful size is completely imperceptible.&lt;/p&gt;
    &lt;p&gt;Moreover, each air particle hitting an object has a different speed, and it strikes the surface of that object at a different angle â some hit the object straight on, but some barely graze it. Due to the enormous number of these collisions happening at every instant of time, all these variations average out, and even a small section of surface of any body experiences uniform bombardment.&lt;/p&gt;
    &lt;p&gt;In aggregate, we say that the air exerts pressure on any object present in that air. The magnitude of this pressure depends on the intensity of these collisions across an area.&lt;/p&gt;
    &lt;p&gt;Let’s see how this pressure manifests on our tiny cube. In the demonstration below, you can use the second slider to control the number of air molecules present in this volume:&lt;/p&gt;
    &lt;p&gt;The black arrows you see on the sides of the cube symbolize the magnitude of pressure on these walls. As we uniformly increase the number of particles in this volume, the intensity of collisions, and thus the pressure, also increases. Because the collisions happen at more or less the same rate on every side of the box, the net balance of forces is also maintained and the cube doesn’t move, regardless of how big or small the overall pressure is.&lt;/p&gt;
    &lt;p&gt;This is exactly what happens in the Earth’s atmosphere â everything is constantly squeezed by relatively high pressure caused by the barrage of countless air particles. That pressure is typically balanced either by an object’s material, which resists compression like a spring, or by the air itself that fills the insides of the object. When that inner air is removed, the seemingly innocuous atmospheric pressure reveals its might.&lt;/p&gt;
    &lt;p&gt;The underlying particle nature also shows us that pressure is never negative. Without any particle collisions, we reach the lowest possible pressure of zero. Beyond that, any impacts on the surface of an object create some amount of positive pressure.&lt;/p&gt;
    &lt;p&gt;In the demonstrations we’ve seen so far, the balanced number of collisions on each wall was very important for keeping the objects steady. Unsurprisingly, more interesting things happen when this harmony isn’t maintained. Let’s first investigate this scenario using the tennis balls. In the demonstration below, the slider controls if it’s the left side or the right side that’s shooting more balls:&lt;/p&gt;
    &lt;p&gt;As you can see, if one of the sides has a higher number of collisions, the forces acting on the box are no longer balanced and the box starts to move.&lt;/p&gt;
    &lt;p&gt;The very same situation happens in air, which you can witness in the simulation below. Notice that the volume in which the tiny cube exists has more particles on one side than the other. Observe what happens to cube once you let the time run using the slider:&lt;/p&gt;
    &lt;p&gt;The higher number of particle collisions on one side of the cube creates higher pressure forces on that wall. The uneven forces end up pushing the block to the side. In this demonstration, the pressure re-balances after a while and the cube stops moving.&lt;/p&gt;
    &lt;p&gt;Intuitively, the air exerts an imbalanced net force on the cube only when different parts of that object experience different pressure â it’s the spatial variation in pressure that creates an acting net force. When the difference in pressure between any two points increases, the net force acting on the object also grows.&lt;/p&gt;
    &lt;p&gt;It’s easy to see that a larger number of collisions on the left side of an object would start to exert a net force pushing that object to the right, but, perhaps surprisingly, the same rules apply to any chunk of air itself.&lt;/p&gt;
    &lt;p&gt;In the demonstration below, I once again made one half of the test volume contain more particles than the other half. As you unpause the demonstration, observe the average velocity of molecules in the marked out section of air:&lt;/p&gt;
    &lt;p&gt;The particles on the more occupied side can easily travel to the less crowded side, because there are fewer particles there to collide with and bounce back from. Additionally, each particle in the less populated section is more likely to hit a particle in the more populated section, which will typically cause that particle from the desolate side to bounce back where it came from.&lt;/p&gt;
    &lt;p&gt;The particles end up, on average, traveling from the area of high pressure to the area of lower pressure. Even though we don’t have any clean borders between different sections, we can still see the bulk of particles getting accelerated towards the less dense section.&lt;/p&gt;
    &lt;p&gt;Once again, the initial pressure differences in the test volume dissipate after a while. On their own, these freely suspended pressure variations quickly disappear, but we will soon see how, with the aid of airflow, these areas of different pressure can be sustained indefinitely.&lt;/p&gt;
    &lt;p&gt;In the examples we’ve been playing with, the notion of increased pressure came from an increased number of collisions, which in turn came from an increased number of particles in the area. This shows that, all other things being equal, pressure is tied to the local density of the air, which was very easy to perceive in an increased concentration of molecules.&lt;/p&gt;
    &lt;p&gt;However, the pressure can also grow due to increased average speed of the particles, which in turn comes with increased temperature. As particles get faster, each collision gets more impactful and it pushes on an object or other particles a bit harder, causing the overall pressure to also increase. In the demonstration below, we can simulate this with tennis balls hitting the cardboard box at the same rate, but with different speeds, which you can control with the slider:&lt;/p&gt;
    &lt;p&gt;As we make the balls on one side of the box faster, their impacts also become stronger and the package starts moving to the right, even though the number of collisions per second is equal on both sides.&lt;/p&gt;
    &lt;p&gt;The important point from these discussions is that air pressure exerts force on everything inside it, be it a solid object or any parcel of air. It’s a little unintuitive that the air itself both exerts the pressure and it also “feels” the pressure, but it’s all just a consequence of very rapid motions of particles and the collisions between them happening at an enormous rate.&lt;/p&gt;
    &lt;p&gt;Recall that even in small volumes of air there are billions of billions of particles, and each particle experiences roughly ten billion collisions per second. What we’ve simulated at a micro scale and in slow motion as countable, individual interactions, very quickly smooths out into a uniform and uninterrupted notion of force-exerting pressure.&lt;/p&gt;
    &lt;p&gt;This fact lets us abandon the molecules and their collisions yet again. It’s not a big loss, since counting the number and intensity of collisions was never convenient in the first place, but we can now investigate some other ways of visualizing pressure in a region of air.&lt;/p&gt;
    &lt;head rend="h1"&gt;Visualizing Pressure&lt;/head&gt;
    &lt;p&gt;As we’ve seen in the particle simulations, pressure can vary from place to place. One of the most convenient ways to express this variation is to use colors of different intensities. Let’s see how that simple approach could work here. In the demonstration below, the dashed circles represent regions of high and low pressure â you can drag them around to change their position:&lt;/p&gt;
    &lt;p&gt;This map of pressure is colored with varying shades of red as indicated by the scale below â the redder the color, the higher the pressure. The small triangle â¼ in the middle of the scale indicates the location of the base, static pressure present in the atmosphere.&lt;/p&gt;
    &lt;p&gt;In this simulation we have complete control over where the different locations of lower and higher pressure are. To make things more interesting, each draggable pressure circle has a different strength and range. You can infer this variation from color changes around these points.&lt;/p&gt;
    &lt;p&gt;Let’s put an airfoil in this area to see how it’s affected by the pressure of the surrounding air. The arrows seen below symbolize the force that pressure exerts on the surface of the airfoil at that location. They’re the exact same arrows that we’ve seen acting on the walls of the tiny yellow cube, here we just see them at a larger scale:&lt;/p&gt;
    &lt;p&gt;As you move around the locations of lower and higher pressure, the forces acting on the surface of the airfoil also change, matching what we’ve seen with little cubes bombarded by air particles. The static pressure always exerts some base load, but in the areas of higher pressure the surface forces are higher, and in the areas of lower pressure the surface forces are lower than these base forces.&lt;/p&gt;
    &lt;p&gt;Note that you can also move the pressure circles into the airfoil, but it only serves as a convenience to let you customize the shape of the air pressure field around that body â we don’t particularly care about the pressure inside the solid itself.&lt;/p&gt;
    &lt;p&gt;When we tally up all the pressure forces acting on each piece of the airfoil’s surface, we end up with the net force acting on that object. In the demonstration below, I’m showing it with the big arrow at the center of the airfoil:&lt;/p&gt;
    &lt;p&gt;By changing the distribution of pressure around the airfoil, we can affect the total force that this object feels.&lt;/p&gt;
    &lt;p&gt;The reddish plots we’ve been looking at are correct, but a little inconvenient. Recall that final net force on the object depends only on the differences of pressure â when we uniformly increased the number of collisions on the walls of the tiny cube, it steadily remained in place.&lt;/p&gt;
    &lt;p&gt;This means that the static background pressure doesn’t matter for the cumulative forces acting on an object. It’s only the differences relative to that static pressure that affect the overall balance. This lets us overhaul our visual representation of pressure â we can use no color where the pressure has the static value, use blue color when the pressure is lower than the static pressure, and use red color when the pressure is higher than the static pressure:&lt;/p&gt;
    &lt;p&gt;This is the exact same distribution of pressure that we’ve just seen. All the pressure demos in this section are connected, and here we simply changed the reference point against which we present the pressure variation.&lt;/p&gt;
    &lt;p&gt;If we then throw in the airfoil back into the mix we can now also adjust the arrows representing the forces that the pressure exerts on the surface of that object:&lt;/p&gt;
    &lt;p&gt;The areas of higher pressure still seem to push on the surface of the airfoil, but the areas of lower pressure now seem to pull it. However, I need to emphasize once more that pressure always pushes on the object, and we can only talk about a pulling force when we discard that uniform, pushing contribution coming from the static pressure. In those “pulling” areas the pressure is still pushing, it just pushes less intensely.&lt;/p&gt;
    &lt;p&gt;I will also use the convenient terms of positive and negative pressure, but remember that this refers to their difference from the static pressure. The phrase “pressure lower than static pressure” is a mouthful, so the expression “negative pressure” is very handy, even when it hides the fact that pressure is always positive.&lt;/p&gt;
    &lt;p&gt;While the color variations used here show the true nature of the smoothly varying pressure changes, they make it a little hard to see how quickly those changes happen. To fix this, I’ll also draw the contour lines that join the locations of the same pressure â they’re very similar to lines of the same altitude you may have seen on maps:&lt;/p&gt;
    &lt;p&gt;Every point on one of those contour lines has the same value of pressure, and each subsequent line is drawn at the same increment of pressure â you can see this in the scale placed below the plot. This means that the closer the lines are together, the more quickly the pressure changes in that area.&lt;/p&gt;
    &lt;p&gt;The mathematical concept that describes the direction and rapidness of these changes is known as a gradient. Informally, gradient describes how some property changes from one point to another, and, thankfully, this notion tracks closely with how this word is used in graphic design to describe smooth color changes. Wherever you see a color gradient , this also implies that there is a pressure gradient â the pressure changes from place to place.&lt;/p&gt;
    &lt;p&gt;This spatial variation is particularly important for the motion of air. Recall that the air pressure differences don’t just exert forces on solid objects, but also on the air itself â any small parcel of air is subject to the same whims of pressure forces.&lt;/p&gt;
    &lt;p&gt;Those spatial variations in pressure end up pushing the air around, changing its velocity. Let’s see this in action using the little leaf-like markers that are moved around by pressure differences. In the demonstration below, I’m steadily releasing the markers from the left side âÂ notice how their trajectory changes when you modify the pressure field:&lt;/p&gt;
    &lt;p&gt;You may still find it a little difficult to grasp how pressure differences affect the motion of a parcel of air. Luckily, we can draw parallels between the contour lines of pressure seen on these pressure maps and the contour lines of elevation seen on traditional maps. This lets us build a little pressure-landscape analogy.&lt;/p&gt;
    &lt;p&gt;In the demonstration below, the very same distribution of pressure is expressed as a mountainy landscape. Positive pressure lifts the ground above the base level and negative pressure depresses it below the base level. A parcel of air moves like a marble that loses speed when climbing uphill and accelerates when rolling downhill. You can drag the demo around to change the viewing angle:&lt;/p&gt;
    &lt;p&gt;Notice that when the pressure changes more rapidly and the contour lines are closer, the steepness of the corresponding hill or valley also increases, and so do the forces acting on a parcel of air. If the pressure is increasing by a large amount, it may even make the marker go back. This landscape analogy also shows that the static pressure doesn’t matter for the motion of air parcels, as any changes in static pressure would just lift all the areas by the same amount without changing their steepness.&lt;/p&gt;
    &lt;p&gt;When watching these air parcels move around, you may have noticed that things were a little bit off. For example, it’s possible for air parcels coming from different directions to arrive at the same location, and then continue to travel in different directions. You can see an example of that on the left side of the demonstration below, with the slider letting you scrub back and forth in time:&lt;/p&gt;
    &lt;p&gt;Recall that the markers always follow the local velocity of air, so the motion seen in the left part implies that the air at the location of the meetup of the two markers has two different velocities at the same time, which is not realistic.&lt;/p&gt;
    &lt;p&gt;It’s worth pointing out that the situation seen on right side, where one marker merely intersects the historical path of the other, can be realistic, as long as we’re dealing with an unsteady flow, where the velocity of the air at the crossing location has changed since the first marker was there. For steady conditions in which no changes occur over time, the scenario seen on the right is also not physically correct.&lt;/p&gt;
    &lt;p&gt;We’ll look at some unsteady flows later in the article, but for now we’re interested in steady conditions so the crossing paths of our markers indicate implausible velocities. Even more dubious result happen when we simulate the motion of these markers with an airfoil present in the flow:&lt;/p&gt;
    &lt;p&gt;For most distributions of pressure, the air markers will flow right through the body. This is clearly wrong! The demonstrations we’ve seen so far correctly represent what would happen to individual air parcels and bodies placed in these pressure fields, but those pressure fields themselves were completely made up and didn’t correspond to any physical reality. Our mistake was that we completely ignored any interactions between the pressure of the air and the motion of that air.&lt;/p&gt;
    &lt;p&gt;The flow of air, the pressure of air, and the shape of the objects placed in that air are all tied together â for a given incoming flow speed and the shape of the object, we can’t just arbitrarily arrange the pressure field like we did in our artificial demonstrations. Instead, that pressure field will arise on its own.&lt;/p&gt;
    &lt;p&gt;Let’s see a real distribution of pressure around this airfoil and witness how it affects the motion of air parcels around it:&lt;/p&gt;
    &lt;p&gt;The behavior of air parcels now matches our intuitive expectations â the markers don’t go through the body, and in these steady conditions they also don’t cross paths.&lt;/p&gt;
    &lt;p&gt;We’re now one step closer to understanding how the flow of air takes its shape to move around an airfoil â it’s the pressure differences that cause the flow to change its direction and speed.&lt;/p&gt;
    &lt;p&gt;The pressure field we’ve just seen clearly works â regions of lower and higher pressure guide the air around the airfoil. However, it’s still unclear how these areas emerged in the first place. Let’s try to follow nature’s path to see how this pressure distribution is created and sustained in a flow.&lt;/p&gt;
    &lt;head rend="h1"&gt;Airfoil Flow&lt;/head&gt;
    &lt;p&gt;Before we start building the correct pressure field from scratch, let’s first establish two guiding principles that the flow around any object has to follow.&lt;/p&gt;
    &lt;p&gt;Firstly, the air can’t penetrate solid walls. A valid pressure field should either completely stop the flow at the surface of the object, or redirect that flow to make it travel in the direction perpendicular to the walls. This means that the markers that we track can never get inside the object.&lt;/p&gt;
    &lt;p&gt;Secondly, we also have the restrictions on the relative motion of the markers. For now we’ll only be interested in steady conditions, which means that the markers can’t cross their paths â we expect the ghostly historical trails to never intersect.&lt;/p&gt;
    &lt;p&gt;Let’s first focus on the pressure field in front of the airfoil. In the demonstration below, I created an artificial pressure field in that frontal region, you can control it using the slider:&lt;/p&gt;
    &lt;p&gt;It should quickly become clear that to prevent the approaching air from getting into the object, the pressure in the frontal region has to be positive, so that it pushes the incoming air away.&lt;/p&gt;
    &lt;p&gt;If that positive pressure in front is too low the air can still erroneously flow through the object. If that pressure is too high, the air parcels arriving at the airfoil will turn back and incorrectly cross paths with the incoming air. When the pressure is just right, the air parcels don’t go through the wall, and, at least in front of the object, they also don’t cross their paths.&lt;/p&gt;
    &lt;p&gt;The faster the incoming flow, the higher the pushing force required to slow down and redirect the incoming air. In the demonstration below, you can also control the speed of that incoming air using the second slider:&lt;/p&gt;
    &lt;p&gt;While for slow flows, only a small amount of positive pressure is enough to stop the incoming air, for fast flows, the pressure in front of the airfoil has to become much higher.&lt;/p&gt;
    &lt;p&gt;The pressure needed to stop air at a given velocity is known as stagnation pressure and it’s proportional to the square of that velocity â twice as high speed requires four times larger pressure. Naturally, when there is no flow, no pressure is required as the air no longer tries to flow through the object.&lt;/p&gt;
    &lt;p&gt;In the previous two demonstrations, we manually adjusted the pressure to get the correct result, but in nature this process happens on its own â it’s the flow itself that creates this region of increased pressure in front of the object.&lt;/p&gt;
    &lt;p&gt;As the incoming parcels of air arrive at the surface of the airfoil, they can’t continue going forward, but air parcels from further up ahead continuously want to keep flowing into this region. This compresses the air close to the object, which causes the pressure in front to increase, which then helps to slow down the incoming flow.&lt;/p&gt;
    &lt;p&gt;This mechanism is self-balancing â if the pressure is too low to push away the incoming air parcels, the air parcels will compact the existing air more, causing an increase in pressure. If the pressure is too high, it will easily push the incoming air away, which relieves the frontal area, causing the pressure to decrease. Any fluctuations quickly settle to an equilibrium that balances the pressure in the entire frontal region.&lt;/p&gt;
    &lt;p&gt;Let’s look at the distribution of the positive frontal pressure once more:&lt;/p&gt;
    &lt;p&gt;Notice that the positive pressure isn’t limited to just the close vicinity of the airfoil, but it spreads out much further ahead to gradually reach the value of the static pressure, far away from the airfoil itself.&lt;/p&gt;
    &lt;p&gt;All in all, we have a large area of increasing pressure that starts far away from the body and ends at its surface. Those pressure differences create a pressure “hill” that not only gradually slows the incoming air down, but it also redirects that air to flow around the object.&lt;/p&gt;
    &lt;p&gt;It seems that with our frontal pressure field we’ve easily completed our goal of preventing the air from flowing through the walls of the body. However, our second guideline of non-crossing marker paths is still not fulfilled â this condition is broken above and below the airfoil.&lt;/p&gt;
    &lt;p&gt;Let’s first try to rectify this manually. In the demonstration below, you can control the pressure in these two regions using the slider:&lt;/p&gt;
    &lt;p&gt;While positive values of pressure in those zones make the problem worse, negative values get us much closer to the expected behavior â in the top and bottom areas the markers no longer veer off into different directions. However, that pressure can’t be too low, otherwise it will pull the markers back into the body.&lt;/p&gt;
    &lt;p&gt;In real flow, these regions of lower pressure arise on their own, but the explanation for this phenomenon is a little less straightforward than what I’ve described for the area of positive pressure in the frontal region. We can get some, albeit a bit hand-wavy, understanding by observing what happens to the air markers when those negative regions are missing.&lt;/p&gt;
    &lt;p&gt;In that scenario, the incoming air parcels no longer reach those areas above and below the airfoil, causing some local depletion of air that has since left those zones. This decreases the pressure in those regions, and that lower pressure attracts the surrounding air to flow into those less occupied spaces.&lt;/p&gt;
    &lt;p&gt;If that lower pressure is too negative, more air will come in and the pressure will rise. If the pressure is not negative enough, those region will get depleted again. Once again, it’s the flow itself that creates the balancing system â without the flow no pressure differences would arise.&lt;/p&gt;
    &lt;p&gt;As we’ll see later on, in more extreme scenarios that negative pressure can alter the flow more dramatically, and the regions of “missing” air get filled through other means, but for now let’s close things up by tweaking the pressure in the rear part of the airfoil:&lt;/p&gt;
    &lt;p&gt;Some amount of positive pressure in the rear prevents the air parcels from smashing into each other after leaving the airfoil. Intuitively, this pressure arises naturally from the flow, because as the air slides off from the ends of the top and bottom sides, it all arrives into the same region, creating some compression.&lt;/p&gt;
    &lt;p&gt;If that compressive pressure in the rear is too low, more air will manage to get in, which will further increase the pressure. If that pressure is too high, it will push the incoming air away, which depletes the area and the pressure decreases. The system balances itself yet again.&lt;/p&gt;
    &lt;p&gt;The quite informal description of these balances that I’ve presented can be formalized mathematically using the NavierâStokes equations. These equations describe the motion of liquids and gasses, collectively known as fluids, subject to various forces like gravity, or, most importantly for us, pressure.&lt;/p&gt;
    &lt;p&gt;NavierâStokes equations are notoriously difficult to solve analytically, but a lot of insight about the behavior of fluids can be gained with computer simulations with various degrees of complexity.&lt;/p&gt;
    &lt;p&gt;In this article, I’m also employing simulations to investigate the flow of air around objects. However, the computer models used here are quite simplified and they don’t reflect the full richness of physics involved in the motion of air. These slow-motion demonstrations are intended to present the broad strokes of the delicate interaction between the air and the airfoil, but I would advise against relying on them when building an airworthy airplane.&lt;/p&gt;
    &lt;p&gt;With all of these caveats in place, let’s get back to the pressure distribution around a symmetric airfoil. We’re done recreating the nature-made pressure field, but there is one small aspect that we haven’t yet accounted for.&lt;/p&gt;
    &lt;p&gt;For our experiments, I kept the pressure steady in time so that we could focus on its general outlines. In practice, a pressure field imposed by a fast flow around any object will experience some degree of instability, which you can see in the demonstration below. You can once more drop the markers at any location to track the flow in the area:&lt;/p&gt;
    &lt;p&gt;As the pressure builds up on one side, it redirects the flow, which changes the pressure again. The pressure ends up oscillating back and forth like a swing. The pressure distribution and the flow direction are once again at the mercy of their mutual balance, one affecting the other. We’ll soon see some other examples of these unstable behaviors.&lt;/p&gt;
    &lt;p&gt;As we’ve just seen, the variation in pressure doesn’t just happen in the close vicinity of the airfoil, but it stretches quite far away from the body itself. This means that the velocity of the flow is also affected quite far away from the shape.&lt;/p&gt;
    &lt;p&gt;However, when it comes to the forces exerted on the airfoil, it’s only the pressure right at the surface of the airfoil that matters. Let’s bring back the two tools we’ve used before: surface arrows that show how the air pushes or “pulls” on the airfoil, and the net force arrow that tallies up the net results of these forces:&lt;/p&gt;
    &lt;p&gt;As the pressure field fluctuates, the resulting net force also moves around. Let’s decompose this force into two different components, one perpendicular to the flow, and one parallel to it:&lt;/p&gt;
    &lt;p&gt;The force acting in the direction perpendicular to the flow is known as lift, and the one acting in the direction of the flow is known as pressure drag, or form drag. As the name implies, this component of drag is created by the distribution of pressure around the shape.&lt;/p&gt;
    &lt;p&gt;For this airfoil, the pressure drag is very tiny. While airfoils are specifically designed to minimize the overall drag, most of that force hindering their motion comes from another source â we’ll discuss it soon enough.&lt;/p&gt;
    &lt;p&gt;Notice that as this flow fluctuates, the lift force jumps around, but averaged over time the upward and downward swings of that force end up balancing each other. This airfoil in this configuration doesn’t generate any continuous lift.&lt;/p&gt;
    &lt;p&gt;This shouldn’t come as a surprise since this situation is completely symmetric, so the pressure forces on the upper and lower sides of the airfoil are, on average, completely balanced. However, there is an easy way to disturb that symmetry. In the demonstration below, we’re once again meeting the plain, symmetric airfoil, but this time we can gently tilt it using the slider:&lt;/p&gt;
    &lt;p&gt;The slider controls the so-called angle of attack, which is spanned between some reference line on the body, like the one joining the front and back, and the direction of the incoming flow. I’m showing this angle right in the middle of the airfoil.&lt;/p&gt;
    &lt;p&gt;As we change the angle of attack, the shape that the airflow “sees” is no longer symmetrical relative to the incoming direction of that flow. The velocity and pressure fields adapt in their mutual push and pull to form a new, asymmetric distribution. Notice that the stagnation point of high pressure has moved around, and the little markers that indicate the motion of air now travel on very different paths below and above and below the airfoil.&lt;/p&gt;
    &lt;p&gt;If we then put the pressure arrows back in, we can tally them all up to get the resulting lift and pressure drag. When compared to the previous simulation, I’m scaling down all the arrows to make them fit in the bounds of the demonstration:&lt;/p&gt;
    &lt;p&gt;When this symmetric airfoil is tilted up, the asymmetric pressure distribution generates a lift force that pushes the object up. Conversely, for a downward tilted airfoil, the pressure forces push the airfoil down.&lt;/p&gt;
    &lt;p&gt;Naturally, we’re typically interested in upward-pointing forces, and when the lift generated by the wings is equal to the weight of the plane, the plane will stay in the air without raising or falling to the ground â we’re finally flying.&lt;/p&gt;
    &lt;p&gt;Let’s plot the dependence between the lifting force and the angle of attack of an airfoil â you can see it in the right side of the demonstration below. Note that this plot presents time-averaged and settled values, so you may have to wait a little for the flow to normalize and the lift to start oscillating around the expected value:&lt;/p&gt;
    &lt;p&gt;Clearly, as the angle of attack increases, so does the generated lift. The same thing happens on the other end of the spectrum, where a more negative angle of attack creates more negative lift. Note that for this symmetric airfoil the positive and negative sides of the diagram are just mirror images of each other, so let’s focus only on positive angles of attack.&lt;/p&gt;
    &lt;p&gt;One could naively hope that we could keep increasing the angle of attack to generate more and more lift. Let’s see what happens in practice:&lt;/p&gt;
    &lt;p&gt;Initially, the lift force indeed keeps increasing with the angle of attack, but at some point it plateaus. Once that critical angle of attack is surpassed, the lift force starts to fall after the flow fully develops.&lt;/p&gt;
    &lt;p&gt;What we’re witnessing here is known as a stall. The onset of a stall imposes limits on how much lift the wings of an airplane can generate from merely increasing the angle of attack.&lt;/p&gt;
    &lt;p&gt;Notice that when the stall happens, the pressure distribution on the upper part of the airfoil becomes very erratic â it’s not only the surface pressure arrows that are changing rapidly, but the whole pressure field in that area is very disturbed.&lt;/p&gt;
    &lt;p&gt;Let’s bring in the velocity arrows and markers to get a better feel on what’s going on in that region:&lt;/p&gt;
    &lt;p&gt;At high angles of attack, the flow above the upper part of the airfoil becomes very complicated. If you clicktap in that region to drop a few markers, you’ll notice that the air is trapped in various swirling eddies that are eventually shed to fly away with rest of the flow.&lt;/p&gt;
    &lt;p&gt;We’re witnessing flow separation, where the main part of the flow detaches from the surface and doesn’t follow its shape anymore. The interactions in the complicated flow right above the airfoil affect the pressure field, which then decreases lift.&lt;/p&gt;
    &lt;p&gt;There is a lot going on there, but to understand how these effects arise we have to talk about a property that affects the flow of every fluid: viscosity.&lt;/p&gt;
    &lt;head rend="h1"&gt;Viscosity&lt;/head&gt;
    &lt;p&gt;You might have heard the term viscosity used to describe “thickness” of different liquids, with a classic example that contrasts the slowness of the flow of honey to the rapidness of the flow of water.&lt;/p&gt;
    &lt;p&gt;Viscosity is also a property of gasses like air, but before I describe this concept more formally, we’ll first build an intuitive understanding of what viscosity is and what it does to the flow of different fluids.&lt;/p&gt;
    &lt;p&gt;In the demonstration below, the fluid flows in from the left side, but note that the flow in the top half is faster than the flow in the bottom half, which is reflected by the different lengths of the arrows. Dragging the slider to the left decreases the viscosity of the fluid, and dragging the slider to the right increases viscosity:&lt;/p&gt;
    &lt;p&gt;While we can see some changes to the arrows as we move the slider around, you probably agree that, for this flow, the arrow-based visualization isn’t very rewarding. Let’s add the color-based visualization of speed distribution in this flow:&lt;/p&gt;
    &lt;p&gt;We can now see how viscosity blends the speed variation between different sections of the fluid. For highly viscous fluids, this mixing behavior spreads very easily and the initially distinct velocities of the two layers average out quite rapidly.&lt;/p&gt;
    &lt;p&gt;At lower viscosity these two layers with different speeds remain quite separated. If you make the viscosity low enough, you may even notice that, after a while, the flow develops some interesting wave-like phenomena â we’ll get back to these soon.&lt;/p&gt;
    &lt;p&gt;All this mixing behavior may remind you of a diffusion process, where some quantity, like temperature or concentration, evens out over time. Let’s see some basic diffusion in action. In the simulation below, I filled half of the bottle with with red-dyed water, while the other half is filled with blue-dyed water. The slider lets you control the speed of time:&lt;/p&gt;
    &lt;p&gt;As time passes, the sharp difference between the two layer blends more and more to eventually completely disappear. Clearly, there is some similarity between the diffusion of differently colored dyes and the averaging of velocity that we’ve seen in the earlier example.&lt;/p&gt;
    &lt;p&gt;In our flow demonstrations, viscosity seemed to have controlled the diffusion of velocity. To define it more precisely, viscosity controls the diffusion of momentum, which is a product of velocity and mass. The simplified fluids we’re looking at have more or less constant density, so each equally-sized parcel of those fluids has the same mass. Therefore, if it makes things easier for you, wherever you see the word momentum you can think of velocity, but in more complex scenarios these differences can matter.&lt;/p&gt;
    &lt;p&gt;Let me bring in the previous flow simulation one more time:&lt;/p&gt;
    &lt;p&gt;You’ve probably noticed that, as the flow moves to the right, the size of this blended region increases. When the regions of fluid with different momentums meet for the first time, they barely have any time to average out, and the blending is minimal. As time passes, these regions of fluid get to average out more, similarly to how two different layers of dyed water mix more over time.&lt;/p&gt;
    &lt;p&gt;However, as time is passing, these parcels also keep moving, and that stronger blending happens further to the right. The downstream regions had more time to mix and average out, so the visible thickness of the blended region on the right side is also larger.&lt;/p&gt;
    &lt;p&gt;With higher viscosity, the size of blended region grows much more quickly, which lets us be more precise about our working definition â viscosity controls the rate of the diffusion of momentum.&lt;/p&gt;
    &lt;p&gt;So far we’ve only observed flows with nicely separated horizontal layers, but viscosity averages momentum between any two regions of fluids. In the demonstration below, you can witness how viscosity affects a swirly motion of fluid in a vortex:&lt;/p&gt;
    &lt;p&gt;Notice that with high viscosity any differences in velocity are very quickly diluted out into nothing, but with low viscosity the revolving motion can survive for quite a while.&lt;/p&gt;
    &lt;p&gt;Viscosity has a damping or smoothing effect that makes it much harder to sustain any large variation in a velocity field. Let’s see how this affects the motion of objects in fluids of various viscosity. In the demonstration below, we’re tracking a velocity field close to a very thin plate put directly in the stream of an incoming fluid of adjustable viscosity:&lt;/p&gt;
    &lt;p&gt;With high viscosity, there is a large region of slow down around the plate that regains its speed fairly quickly behind the object. At lower viscosity that surrounding region is much smaller, but it extends much further behind the plate. For very low viscosity we’re once again seeing some more unusual behavior that we’ll get back to in a minute.&lt;/p&gt;
    &lt;p&gt;From the dark colors we can easily see that right by the surface of the plate the fluid doesn’t move at all â it sticks to that surface. This velocity difference between the halted flow at the wall and the moving outer flow gets smoothed out over time by viscosity, similar to how it blended in the flow between two different layers of fluid.&lt;/p&gt;
    &lt;p&gt;As before, with higher viscosity, the velocity averaging process becomes more rapid, and the blended region becomes more widespread. This averaging effect doesn’t just alter the velocity of fluid, but it also affects the plate. In some sense, the viscosity also wants to make the velocity of the surface of the plate to be more like the velocity of the surrounding flow.&lt;/p&gt;
    &lt;p&gt;The viscosity makes the flow want to pull the plate with it, which creates a shearing force that tries to slide the surface of this object away. The net effect is that that viscosity creates additional drag known as skin friction drag that wants to slow down any object moving in it.&lt;/p&gt;
    &lt;p&gt;All of these effects underline why highly viscous fluids are “thick”. Viscosity not only quickly averages any local differences in velocity, which prevents those fluids from flowing easily, but it also represses motion of objects in those fluids â you’ve likely experienced the difficulty of moving a spoon through a jar of honey.&lt;/p&gt;
    &lt;p&gt;The flow of any fluid exhibits tiny, random disturbances. In fluids with high viscosity, these variations are very quickly dispersed, so their motion is rarely erratic. Fluids with low viscosity aren’t as effective at damping motion, and these disturbances can grow to create oscillatory patterns. We’ve seen glimpses of them in the previous simulations, but here is another example:&lt;/p&gt;
    &lt;p&gt;At lower viscosity the flow becomes quite wave-y. Those instabilities happen at the border of regions of fluid with different velocities, like where the slow wake behind a plate is in contact with the fast external flow. In those regions, any tiny random intrusion of slower flow into the faster flow can get magnified and rolled over like a wave.&lt;/p&gt;
    &lt;p&gt;In our discussion of the motion of air around an airfoil, we’ve seen how the flow, the pressure field, and the shape of the body have effects on each other. These influences can be quite dynamic in nature, with distributions of velocity and pressure swinging back and forth in a never-ending fight for dominance.&lt;/p&gt;
    &lt;p&gt;In the demonstration below, we can see a more dramatic example of these battles, where, depending on the viscosity, the flow around a gray cube can take many different forms:&lt;/p&gt;
    &lt;p&gt;With very high viscosity, the flow is completely stable, but as viscosity decreases, it starts to regularly oscillate from side to side, shedding vortices in the process. At very low viscosity, the motion becomes even more erratic.&lt;/p&gt;
    &lt;p&gt;While I can’t easily simulate it here, with further decrease in viscosity, the flow can develop full featured turbulence in which highly irregular and chaotic mixing motions occur at different scales. Turbulent flow stands in contrast to laminar flow, in which neighboring areas of fluid move in an orderly way past each other without any varying fluctuations.&lt;/p&gt;
    &lt;p&gt;Although we’ve put most of our focus on viscosity, which is often denoted with the Greek letter Î¼, the general behavior of the flow also depends on its velocity u, density Ï, and the size L of the body or container involved in the flow. These parameters are tied together by the Reynolds number Re:&lt;/p&gt;
    &lt;p&gt;Flows with the same Reynolds numbers exhibit similar behavior, which means that if we make the obstacle size L twice as large and we halve the speed of the flow u, the Reynolds number won’t change and neither will the characteristics of the flow â it will exhibit the same smooth or oscillatory motion.&lt;/p&gt;
    &lt;p&gt;The Reynolds number also “predicts” the onset of turbulence. When we increase the speed of the flow u, or decrease the viscosity Î¼, the Reynolds number rises. When it reaches a high enough value, turbulence is likely to occur.&lt;/p&gt;
    &lt;p&gt;Let’s quantify the difference in viscosity between different fluids. The precise values aren’t that important to us, but to briefly be a bit more formal, viscosity is expressed in units of pascal-seconds, or PaÂ·s. To let us use more manageable numbers, the following table uses millipascal-seconds, or mPaÂ·s:&lt;/p&gt;
    &lt;table&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;honey&lt;/cell&gt;
        &lt;cell&gt;~10000 mPa·s&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;olive oil&lt;/cell&gt;
        &lt;cell&gt;~100 mPa·s&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;water&lt;/cell&gt;
        &lt;cell&gt;1.0 mPa·s&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;cell&gt;air&lt;/cell&gt;
        &lt;cell&gt;0.018 mPa·s&lt;/cell&gt;
      &lt;/row&gt;
    &lt;/table&gt;
    &lt;p&gt;These values are measured at 68 Â°F20 Â°C, but many fluids like oil get much less viscous with increased temperature. As expected, honey is significantly more viscous than water. Compared to water, the viscosity of air is around 50 times less still, but even a very low viscosity has effects on flow and its interaction with solid walls.&lt;/p&gt;
    &lt;p&gt;To understand how viscosity arises in gasses like air, we have to once more get back to the world of particles. So far we’ve been watching them from a distance, with individual collisions barely perceptible in the moving swarm. This time we’re going take a closer look at these interactions.&lt;/p&gt;
    &lt;p&gt;In the demonstration below, you can experience a simplified simulation of two molecules colliding in space. Each molecule represents nitrogen or oxygen â these two elements constitute the vast majority of air, and, in normal conditions, each one consists of two atoms.&lt;/p&gt;
    &lt;p&gt;You can drag the orange particle around, and once you let go I’ll automatically aim it so that it hits the blue particle. The speed of the orange molecule is four times larger than the speed of the blue one:&lt;/p&gt;
    &lt;p&gt;Notice that after the collision, it’s the orange molecule that’s slow, and it’s the blue one that’s fast. In this demonstration the two particles have the same mass and they collide straight on, so they simply end up trading velocities.&lt;/p&gt;
    &lt;p&gt;More generally, particles of different masses that strike each other at different angles will exchange some amount of momentum. Recall that the heavier the particle, or the faster it moves, the higher its momentum.&lt;/p&gt;
    &lt;p&gt;Let’s see how this behavior ends up affecting the average velocities of larger quantities of molecules. In the paused demonstration below, air molecules are grouped into two different parts. The air in the blue region has higher velocity than the air in the red region, which you can see in the black arrows showing the average velocity in those regions. Notice what happens to these averages as you let time flow by dragging the slider:&lt;/p&gt;
    &lt;p&gt;At the very beginning, the average velocities in these two sections are visibly different, but they quickly even out when fast particles from the blue region flow into the slower red region, and the slower particles from the red region move into the faster blue region, balancing the initial velocity differences.&lt;/p&gt;
    &lt;p&gt;Moreover, some of the faster particles collide with slower particles in the red region and some of the slower particles collide with faster particles from above. The faster particles lose some of their higher momentum, while the slower particles gain some of the momentum. All of these effects “dilute” some of those average velocity differences between the two regions.&lt;/p&gt;
    &lt;p&gt;You may also remember that when we observed a flow of fluid around a flat plate, that fluid wasn’t moving at all right on the surface of that plate, because it was stuck to it. Let’s see how this behavior may arise on a microscopic scale.&lt;/p&gt;
    &lt;p&gt;In the demonstration below, we’re watching the familiar air particles right next to the surface of an object. To make tracking easier, I’m highlighting some of the particles in the vicinity of this surface:&lt;/p&gt;
    &lt;p&gt;When seen at a very large magnification, this surface, like almost all surfaces, isn’t perfectly smooth and has various peaks and valleys. The particles hitting these irregularities get bounced in more or less random directions. Some of the unlucky molecules can even get stuck for a while in these local crevices.&lt;/p&gt;
    &lt;p&gt;Close to the surface, the random collisions with peaks and valleys prevent the particles from making bulk progress in any direction. The average velocity of the air flow by the wall is more or less zero. Some molecular interactions between the particles and the surface can also prevent the fluid from moving.&lt;/p&gt;
    &lt;p&gt;This sticking behavior is known as the noâslip condition and it holds true for most typical flows of fluids that we experience day to day. It’s only in extreme conditions of very rarified gasses in the upper parts of the atmosphere or flows in microscopic capillaries that can break this assumption.&lt;/p&gt;
    &lt;p&gt;Let’s leave the world of particles behind for the last time and see how these two effects play an important role of influencing the airflow close to the surface of any object.&lt;/p&gt;
    &lt;head rend="h1"&gt;Boundary Layer&lt;/head&gt;
    &lt;p&gt;Let’s take another look at a thin plate placed in the stream of incoming fluid:&lt;/p&gt;
    &lt;p&gt;From this broader perspective, it’s hard to see how the flow interacts with the surface of that plate, because the effects of viscosity are limited to the region close to that surface. Let’s focus our attention on the small area that I’ve outlined with a dashed line, right in the top part of the plate. Here it is zoomed up close:&lt;/p&gt;
    &lt;p&gt;We can once more see that, due to the no-slip condition, the velocity is zero at the wall, and then it grows to meet the velocity of the flow further away from the surface itself. What we’re seeing here is known as the boundary layer, which spans the region between the surface of the object and the “outer” flow, which is mostly unaffected by the presence of the object.&lt;/p&gt;
    &lt;p&gt;Because the velocity in the boundary layer smoothly approaches the speed of the outer flow, it doesn’t have a well-defined end point. One of the choices is to agree that the boundary layer ends where the speed reaches 99% of the speed of the surrounding flow far away from the solid surface. Let me visualize this boundary in the flow using a dashed line:&lt;/p&gt;
    &lt;p&gt;As we move with the flow along the distance of the plate, the viscosity keeps averaging out the velocity differences, making the boundary layer thicker â this is similar to what we’ve seen at larger scales with highly viscous flows around objects.&lt;/p&gt;
    &lt;p&gt;Let’s quantify the distribution of speed in the boundary layer a little more precisely. In the demonstration below, I put the velocity arrows back in. I then connected the ends of these arrows with a thin line to show a profile of velocity at that location along the surface:&lt;/p&gt;
    &lt;p&gt;Notice that, initially, the velocity close to the wall increases almost linearly, but then it smoothly tapers to reach the speed of the external flow. The velocity profile close to the surface has a certain steepness, which I’m showing with the white dotted line. This line determines the amount of skin friction drag at that spot â the closer to the surface, or more horizontal, the line is, the higher the skin drag.&lt;/p&gt;
    &lt;p&gt;As the differences in velocity become less severe, the force with which viscosity wants to drag the surface with the flow also decreases. In the conditions present in the demonstration, the skin friction drag decreases over distance.&lt;/p&gt;
    &lt;p&gt;At this point you hopefully have an intuitive grasp of how viscosity affects the flow close to the surface of the object. From our earlier discussion, you may also remember that pressure differences also affect how the flow behaves, with parcels of air slowing down when climbing the hill of increasing pressure and accelerating on the downhill of the decreasing pressure.&lt;/p&gt;
    &lt;p&gt;In the boundary layer flows we played with, the pressure distribution was more or less constant in the investigated region. Let’s see how the flow changes when we vary that pressure.&lt;/p&gt;
    &lt;p&gt;In the top part of the demonstration below we see the exact same view of velocity we’ve experimented with so far. In the bottom part of the demonstration below you can see the pressure distribution in the boundary layer, which you can change using the slider below.&lt;/p&gt;
    &lt;p&gt;If the pressure decreases in the direction of the flow in the boundary layer, we say that the pressure gradient is favorable. Favorable pressure gradient accelerates the air, and the boundary layer doesn’t grow as quickly, since the slowdown caused by viscosity is opposed by that acceleration.&lt;/p&gt;
    &lt;p&gt;When the pressure increases in the direction of the flow, we say that the pressure gradient is adverse. Adverse pressure gradient pushes against the direction of motion of the air. Far away from the surface, the air has enough momentum that the adverse pressure merely slows the flow down. However, close to the surface, the flow in the boundary layer was slow in the first place, so a pushing adverse pressure gradient may even reverse the direction of the flow.&lt;/p&gt;
    &lt;p&gt;When the flow in the boundary layer gets reversed, we say that the boundary layer separates. This region of reversed flow can form a sort of wedge that can lift the rest of the flow away from the surface.&lt;/p&gt;
    &lt;p&gt;Let’s take a step back from the subtleties of boundary layers to see how what we’ve learned corresponds to behavior of a flow around an airfoil. Let me once more bring up the demonstration that brought us here in the first place:&lt;/p&gt;
    &lt;p&gt;As we move across the surface of the airfoil, the high pressure at the stagnation point up front gradually decreases to reach minimum close to the “peak” of that curved surface. Across this transition the pressure gradient is favorable, and that distribution works in our favor â the boundary layer stays nicely attached to the surface.&lt;/p&gt;
    &lt;p&gt;However, as the air reaches the valley of the lowest pressure, it then has to start climbing back up to reach the slightly positive pressure in the rear of the airfoil. For small values of the angle of attack, the pressure pit from which the air has to climb out is not very deep and the adverse pressure gradient isn’t very strong, so the boundary layer remains attached.&lt;/p&gt;
    &lt;p&gt;As we increase the angle of attack of the airfoil, the pressure on top becomes lower and lower. For even higher angles, the adverse pressure gradient becomes so strong that it eventually reverses the flow in the boundary layer, creating separation. Let’s look at this region up close to see how the arrows of velocity in the separated region point in the other direction:&lt;/p&gt;
    &lt;p&gt;If you clicktap to add markers in the bottom right corner of the simulation you’ll notice that many of them move against the bulk of the flow â the boundary layer and the flow have separated.&lt;/p&gt;
    &lt;p&gt;We’ll get back to looking at airfoils soon enough, but we still have a few things to wrap up in the world of boundary layers.&lt;/p&gt;
    &lt;p&gt;The boundary layers we’ve looked at so far were laminar â the layers of fluid with different velocities flowed in an orderly way on top of each other. However, at higher flow speeds and over larger distances, or at high Reynolds numbers, the flow in the boundary layer transitions to a turbulent flow:&lt;/p&gt;
    &lt;p&gt;Be aware that what you’re seeing here is a very simplified simulation of a turbulent boundary layer. Turbulence is inherently three dimensional and it contains various evolving structures of different sizes that are extremely computationally expensive to evaluate in detail. Thankfully, you can find many videos of computer simulations and real flows showing turbulent boundary layers.&lt;/p&gt;
    &lt;p&gt;While the laminar boundary layers we’ve seen in the past exhibited very organized flows, the turbulent one is very chaotic, with large and small swirls causing the flow to mix very rapidly. The transition from laminar to turbulent boundary layer happens spontaneously, but for a given flow speed, the location of the transition depends on surface roughness, steadiness of the flow outside of the boundary layer, and presence of pressure gradients.&lt;/p&gt;
    &lt;p&gt;At any given moment, the velocity profile in the turbulent boundary layer is very unsteady, but it can be averaged over time to get the mean distribution of speed. Let’s compare the time-averaged profiles of the laminar and turbulent boundary layers:&lt;/p&gt;
    &lt;p&gt;In the dynamic simulation of the turbulent boundary layer, we saw how the slower flow close to the surface rapidly mixed with the upper regions of the flow. This slows down those faster sections, and we need to go farther away from the surface for these sluggish intrusions to stop affecting the flow. For this reason, the turbulent boundary layer is thicker and grows faster than a laminar boundary layer.&lt;/p&gt;
    &lt;p&gt;On the other hand, the strong turbulent mixing causes the fast external flow to get close to the body, so the overall velocity profile by the surface increases much more quickly in the turbulent case as opposed to laminar case â I’m showing that with white dotted lines.&lt;/p&gt;
    &lt;p&gt;Recall that the more horizontal the velocity profile at the surface of the object, the bigger the skin friction drag â a turbulent boundary layer has higher skin friction drag than a laminar layer. Despite the cost of increased friction drag, a turbulent boundary layer is often beneficial.&lt;/p&gt;
    &lt;p&gt;Because of that higher velocity closer to the surface, a turbulent boundary layer is more resistant to adverse pressure gradients and it can stay attached to the surface of an object for longer distances.&lt;/p&gt;
    &lt;p&gt;For some objects like golf balls, which purposefully make their boundary layer turbulent by roughing up the surface with little dimples, the delayed separation also decreases the pressure drag caused by uneven pressure distribution. That reduction more than compensates for the increased skin friction drag, making the dimply golf balls fly farther than equivalent smooth balls.&lt;/p&gt;
    &lt;p&gt;For airfoils, a turbulent boundary layer delays separation of the flow, which can help prevent stall at higher angles of attack, but at normal cruising conditions the increased skin friction becomes an important drawback. For many aerodynamic shapes in typical conditions, the skin friction drag is the primary contributor to the total drag that these objects experience.&lt;/p&gt;
    &lt;p&gt;As we’ve seen, by increasing the angle of attack on an airfoil, the lift force grows up to a certain limit, at which the boundary layer separates over most of the upper surface. By staying under this limit, a symmetric airfoil can safely generate lift force.&lt;/p&gt;
    &lt;p&gt;However, when it comes to angle of attack and lift, the shape of an airfoil isn’t particularly unique in its lift-creation capabilities. Most simple elongated shapes generate lift when put in a flow at an angle of attack. In the demonstration below, you can tilt a flat plate and see the forces exerted by the pressure field around it:&lt;/p&gt;
    &lt;p&gt;You may be surprised to see that, at small angles of attack, this flat plate also generates lift. An airfoil-like shape is not a requirement for lift generation. After all, paper airplanes with their flat wings can fly just fine. Lift is just an outcome of the pressure distribution created and sustained by the flow.&lt;/p&gt;
    &lt;p&gt;Although it doesn’t take a sophisticated shape to generate lift at an angle of attack, a well-designed airfoil can often create more lift and with lower drag. In the last section of this article, we’ll explore how other variations to the shape of an airfoil can affect its characteristics.&lt;/p&gt;
    &lt;head rend="h1"&gt;Airfoil Shapes&lt;/head&gt;
    &lt;p&gt;Let’s go back to the simple symmetric airfoil we’ve been playing with thus far. This time, however, we’re able to control its thickness using the slider:&lt;/p&gt;
    &lt;p&gt;Notice that as we increase the thickness of the airfoil, the pressure on the top and bottom sections of the shape becomes more negative. For this symmetric airfoil at 0Â° angle of attack the thickness doesn’t change much other than increasing the pressure drag.&lt;/p&gt;
    &lt;p&gt;However, if we break the symmetry of the shape, we can use thickness-dependence to make one side of the airfoil have a higher negative pressure than the other. In the demonstration below, you can control the “thickness” of the upper surface of the airfoil using the slider:&lt;/p&gt;
    &lt;p&gt;Notice that an asymmetric shape creates an asymmetric pressure distribution, which ends up creating lift without any changes to angle of attack. With some slight tweaking of this shape we finally recreated the asymmetric shape we first saw on the airplane in the early sections of this article.&lt;/p&gt;
    &lt;p&gt;Naturally, when combined with an increasing angle of attack, this airfoil will generate even more lift until it eventually reaches stalling conditions:&lt;/p&gt;
    &lt;p&gt;While symmetric airfoils are sometimes used in acrobatic airplanes, which often find themselves flying upside down, most typical planes use an asymmetric airfoil shape.&lt;/p&gt;
    &lt;p&gt;The underlying mechanism of lift generation by changing the angle of attack or by shaping the object differently is ultimately the same â we’re changing the placement and orientation of the surface of the body relative to the incoming flow. The flow reacts by changing the velocity and pressure distribution, and the resulting pressure field creates the forces on that object.&lt;/p&gt;
    &lt;p&gt;This all means that we have a lot of flexibility in how an airfoil is shaped, as long as the resulting pressure distribution fulfills the design goals of achieving a certain amount of lift while minimizing drag.&lt;/p&gt;
    &lt;p&gt;For example, in some applications it’s important to minimize the skin friction drag caused by a turbulent boundary layer. Some laminar flow airfoils achieve this by shaping the airfoil to move the “pit” of negative pressure further to the back of the airfoil:&lt;/p&gt;
    &lt;p&gt;The favorable pressure gradient between the front and the lowest pressure point extends over a longer distance across the surface of this airfoil, which, at least in principle, helps to keep the boundary layer laminar to keep the skin friction low.&lt;/p&gt;
    &lt;p&gt;Notice that even this unusual airfoil had a rounded front and a sharp back. The roundness of the front helps the air smoothly flow around this area at different angles of attack, and the sharp back reduces the pressure drag by avoiding the separation of the flow.&lt;/p&gt;
    &lt;p&gt;The velocity of the flow around the airfoil is also a contributing factor to the design of the shape. Let’s look at the speed distribution in the flow around a simple asymmetric airfoil using the varying colors and markers:&lt;/p&gt;
    &lt;p&gt;The flow above the airfoil is faster than the incoming flow as indicated by brighter colors. The markers that start in the same line don’t end up sliding off the airfoil in the same formation â the ones on top are further ahead. This is particularly visible for larger values of the angles of attack.&lt;/p&gt;
    &lt;p&gt;This acceleration in the upper part becomes another point of consideration for airfoil design. While commercial airliners don’t fly faster than the speed of sound, the accelerated flow in the top part of an airfoil can break that barrier. This creates a shockwave that can sometimes be seen in flight. Modern airliners use supercritical airfoils that are designed to reduce these drag-causing shockwaves by carefully controlling the speed of the flow around the wing.&lt;/p&gt;
    &lt;p&gt;Planes designed to fly above the speed of sound use supersonic airfoils that are quite different from the shapes we’ve seen. These airfoils have a thin profile and their front edge is sharp and not rounded. Supersonic flows of air are more complicated than what we’ve explored in this article, as variations in density and temperature become an important component of the behavior of the flow.&lt;/p&gt;
    &lt;p&gt;Many of the airfoils used today are designed specifically for the plane they’ll be used in. Moreover, that cross-sectional shape may change across the length of the wing. Real airplanes are three dimensional and the overall shape of the wings also significantly affects the lift and drag of an airplane, but ultimately all the resulting forces are an outcome of interactions between the flow and the body.&lt;/p&gt;
    &lt;head rend="h1"&gt;Further Reading and Watching&lt;/head&gt;
    &lt;p&gt;John Anderson’s Fundamentals of Aerodynamics is a very well-written textbook on aerodynamics. Over the course of over a thousand pages, the author presents a classic exposition of the motion of fluids and their interactions with bodies put in those flows.&lt;/p&gt;
    &lt;p&gt;Understanding Aerodynamics by Doug McLean is a great textbook that takes a different approach of explaining aerodynamic phenomena using physical reasoning. For me, the crowning achievement of the publication is showing that many popular explanations of the origins of lift are either incorrect or they’re based on merely mathematically convenient theorems. The author’s video lecture gives an overview of some of these misconceptions.&lt;/p&gt;
    &lt;p&gt;In this article, I’m using computational fluid dynamics to simulate the flow of air around different objects. For an approachable introduction to these methods I enjoyed Tony Saad’s series of lectures on the topic. For an alternative, and slightly more rigorous approach, Lorena Barba created 12 steps to Navier-Stokes. That website is also accompanied by video lectures.&lt;/p&gt;
    &lt;p&gt;Finally, YouTuber braintruffle created a series of beautiful videos that start with the behavior of fluids on a quantum scale and build up increasingly abstract models that can be used in more practical applications. The videos are packed with interesting takes on fluid mechanics, and they’re worth watching for their visuals alone.&lt;/p&gt;
    &lt;head rend="h1"&gt;Final Words&lt;/head&gt;
    &lt;p&gt;If you were to sit on a flying airplane and look out the window to glance at its wings, you’d often have a hard time seeing anything going on. However, in that crisp clearness of air whose invisible flow sustains the varied pressure field, lies the hidden source of lift that overcomes the might of gravity to keep the plane safely above the ground.&lt;/p&gt;
    &lt;p&gt;Since the first human flight, we’ve now mastered the art of soaring in the skies by bending the flow of air to our will, using physical quantities like pressure and velocity to help shape our designs. These tangible concepts are ultimately just a manifestation of motions and collisions of billions of inanimate air particles that somehow conspire to assemble the forces we need.&lt;/p&gt;
    &lt;p&gt;I hope this deeper, technical exploration of airfoils hasn’t diminished your appreciation of the greatness of flight. Perhaps paradoxically, by seeing how all the pieces fit together, you’ll find the whole thing even more magical.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://ciechanow.ski/airfoil/"/><published>2026-01-28T14:32:30+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=46796745</id><title>Amazon cuts 16k jobs</title><updated>2026-01-28T21:19:30.141302+00:00</updated><content/><link href="https://www.reuters.com/legal/litigation/amazon-cuts-16000-jobs-globally-broader-restructuring-2026-01-28/"/><published>2026-01-28T15:39:11+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=46796825</id><title>Show HN: Config manager for Claude Code (and others) – rules, MCPs, permissions</title><updated>2026-01-28T21:19:29.435956+00:00</updated><content>&lt;doc fingerprint="3e35c65f95a7a87e"&gt;
  &lt;main&gt;
    &lt;p&gt;A configuration manager for AI coding tools. Works with Claude Code, Gemini CLI, Codex CLI, and Antigravity.&lt;/p&gt;
    &lt;quote&gt;&lt;p&gt;Migration note: This package was renamed from&lt;/p&gt;&lt;code&gt;@regression-io/claude-config&lt;/code&gt;to&lt;code&gt;coder-config&lt;/code&gt;. The&lt;code&gt;claude-config&lt;/code&gt;command still works as an alias.&lt;/quote&gt;
    &lt;p&gt;AI coding assistants are powerful, but managing their configuration across projects is tedious. Each tool has its own config format. MCP servers need to be set up per-project. Context gets lost between sessions. Working across multiple repos means re-explaining relationships every time.&lt;/p&gt;
    &lt;p&gt;Workstreams Group related repos together. When a workstream is active, Claude automatically knows which directories it can access and receives your custom context. Useful for microservices, monorepos, or any multi-repo workflow where projects relate to each other.&lt;/p&gt;
    &lt;p&gt;Unified MCP Registry Define your MCP servers once in a global registry. Enable them per-project with a toggle. Configuration inherits from global → workspace → project, so common tools are always available while project-specific ones stay scoped.&lt;/p&gt;
    &lt;p&gt;Hierarchical Rules Rules cascade from &lt;code&gt;~/.claude/rules/&lt;/code&gt; down to project-specific rules. Global conventions apply everywhere; project-specific instructions stay local.&lt;/p&gt;
    &lt;p&gt;Persistent Memory Store preferences, corrections, and patterns that persist across sessions. When you tell Claude "always use our logger instead of console.log," it remembers — not just for this session, but permanently.&lt;/p&gt;
    &lt;p&gt;Plugin System Install LSP servers, MCP tools, and custom commands from plugin marketplaces. Plugins can be scoped globally or per-project.&lt;/p&gt;
    &lt;p&gt;Multi-Tool Output Write one config, generate outputs for Claude Code (&lt;code&gt;.mcp.json&lt;/code&gt;), Gemini CLI (&lt;code&gt;settings.json&lt;/code&gt;), Codex CLI (&lt;code&gt;config.toml&lt;/code&gt;), and Antigravity. Switch tools without reconfiguring.&lt;/p&gt;
    &lt;p&gt;Web UI Visual interface for managing everything above. File explorer for &lt;code&gt;.claude&lt;/code&gt; folders, MCP toggles, memory editor, workstream management. Runs locally on port 3333.&lt;/p&gt;
    &lt;code&gt;npm install -g coder-config&lt;/code&gt;
    &lt;p&gt;Requires Node.js 18+.&lt;/p&gt;
    &lt;quote&gt;&lt;p&gt;Migrating from @regression-io/claude-config?&lt;/p&gt;npm uninstall -g @regression-io/claude-config npm install -g coder-config&lt;p&gt;Your settings in&lt;/p&gt;&lt;code&gt;~/.claude-config/&lt;/code&gt;are preserved automatically.&lt;/quote&gt;
    &lt;code&gt;# 1. Install
npm install -g coder-config

# 2. Set up auto-start (recommended)
coder-config ui install

# 3. Open the UI
open http://localhost:3333&lt;/code&gt;
    &lt;p&gt;The server starts automatically on login. Install as a PWA from your browser for app-like access.&lt;/p&gt;
    &lt;code&gt;coder-config update
# Then restart: coder-config ui stop &amp;amp;&amp;amp; coder-config ui&lt;/code&gt;
    &lt;code&gt;# Initialize a project
coder-config init

# Add MCPs to your project
coder-config add postgres github

# Generate .mcp.json for Claude Code
coder-config apply&lt;/code&gt;
    &lt;p&gt;Both &lt;code&gt;coder-config&lt;/code&gt; and &lt;code&gt;claude-config&lt;/code&gt; work identically.&lt;/p&gt;
    &lt;code&gt;coder-config init                        # Initialize project
coder-config apply                       # Generate .mcp.json from config
coder-config show                        # Show current project config
coder-config list                        # List available MCPs (✓ = active)
coder-config add &amp;lt;mcp&amp;gt; [mcp...]          # Add MCP(s) to project
coder-config remove &amp;lt;mcp&amp;gt; [mcp...]       # Remove MCP(s) from project&lt;/code&gt;
    &lt;code&gt;coder-config memory                         # Show memory status
coder-config memory init                    # Initialize project memory
coder-config memory add &amp;lt;type&amp;gt; "&amp;lt;content&amp;gt;"  # Add entry
coder-config memory search &amp;lt;query&amp;gt;          # Search all memory

# Types: preference, correction, fact (global)
#        context, pattern, decision, issue, history (project)&lt;/code&gt;
    &lt;code&gt;coder-config env                    # List environment variables
coder-config env set &amp;lt;KEY&amp;gt; &amp;lt;value&amp;gt;  # Set variable in .claude/.env
coder-config env unset &amp;lt;KEY&amp;gt;        # Remove variable&lt;/code&gt;
    &lt;code&gt;coder-config project                      # List registered projects
coder-config project add [path]           # Add project (defaults to cwd)
coder-config project add [path] --name X  # Add with custom display name
coder-config project remove &amp;lt;name|path&amp;gt;   # Remove from registry&lt;/code&gt;
    &lt;code&gt;coder-config workstream                   # List all workstreams
coder-config workstream create "Name"     # Create new workstream
coder-config workstream delete &amp;lt;name&amp;gt;     # Delete workstream
coder-config workstream use &amp;lt;name&amp;gt;        # Activate workstream (this terminal)
coder-config workstream active            # Show current active workstream
coder-config workstream deactivate        # Deactivate workstream (this terminal)
coder-config workstream add &amp;lt;ws&amp;gt; &amp;lt;path&amp;gt;   # Add project to workstream
coder-config workstream remove &amp;lt;ws&amp;gt; &amp;lt;path&amp;gt;  # Remove project from workstream
coder-config workstream inject [--silent] # Output restriction + context (for hooks)
coder-config workstream detect [path]     # Detect workstream for directory
coder-config workstream check-path &amp;lt;path&amp;gt; # Check if path is within workstream (exit 0/1)
coder-config workstream install-hook      # Install hook for Claude Code
coder-config workstream install-hook --gemini  # Install hook for Gemini CLI
coder-config workstream install-hook --codex   # Install hook for Codex CLI
coder-config workstream install-hook --all     # Install hooks for all supported tools

# Folder auto-activation
coder-config workstream add-trigger &amp;lt;ws&amp;gt; &amp;lt;folder&amp;gt;  # Add trigger folder
coder-config workstream remove-trigger &amp;lt;ws&amp;gt; &amp;lt;folder&amp;gt;  # Remove trigger folder
coder-config workstream auto-activate &amp;lt;ws&amp;gt; [on|off|default]  # Set auto-activate
coder-config workstream check-folder [path] [--json]  # Check folder for matches
coder-config workstream install-cd-hook    # Install cd hook for shell
coder-config workstream uninstall-cd-hook  # Remove cd hook
coder-config workstream cd-hook-status     # Check cd hook status&lt;/code&gt;
    &lt;p&gt;Per-terminal isolation: With shell integration, each terminal can have its own active workstream:&lt;/p&gt;
    &lt;code&gt;# Terminal 1
coder-config workstream use project-a

# Terminal 2
coder-config workstream use project-b&lt;/code&gt;
    &lt;p&gt;When active, the AI receives a restriction telling it to only work within the workstream's directories.&lt;/p&gt;
    &lt;p&gt;Multi-tool support: Workstreams work with Claude Code, Gemini CLI, and Codex CLI. Install hooks for your preferred tool(s):&lt;/p&gt;
    &lt;code&gt;# For Claude Code only
coder-config workstream install-hook

# For Gemini CLI only
coder-config workstream install-hook --gemini

# For Codex CLI only
coder-config workstream install-hook --codex

# For all supported tools
coder-config workstream install-hook --all&lt;/code&gt;
    &lt;p&gt;Folder auto-activation: Automatically activate workstreams when you cd into matching directories:&lt;/p&gt;
    &lt;code&gt;# Install the cd hook (adds function to ~/.zshrc or ~/.bashrc)
coder-config workstream install-cd-hook

# Now when you cd into a project folder:
cd ~/projects/my-app  # Auto-activates matching workstream
# Output: 📂 Workstream: My App

# If multiple workstreams match, you'll be prompted:
cd ~/projects
# Output: Multiple workstreams match this folder:
#   1) Frontend
#   2) Backend
#   0) Skip
# Choose [0-2]:&lt;/code&gt;
    &lt;p&gt;Trigger folders: Besides project paths, you can add extra trigger folders:&lt;/p&gt;
    &lt;code&gt;coder-config workstream add-trigger "My Work" ~/projects
coder-config workstream remove-trigger "My Work" ~/projects&lt;/code&gt;
    &lt;p&gt;Auto-activate setting: Control per-workstream or globally:&lt;/p&gt;
    &lt;code&gt;coder-config workstream auto-activate "My Work" on      # Always auto-activate
coder-config workstream auto-activate "My Work" off     # Never auto-activate
coder-config workstream auto-activate "My Work" default # Use global setting&lt;/code&gt;
    &lt;code&gt;coder-config registry                       # List MCPs in global registry
coder-config registry add &amp;lt;name&amp;gt; '&amp;lt;json&amp;gt;'   # Add MCP to global registry
coder-config registry remove &amp;lt;name&amp;gt;         # Remove MCP from registry&lt;/code&gt;
    &lt;code&gt;coder-config update             # Check npm and install updates if available
coder-config update --check     # Check for updates without installing
coder-config update /path/src   # Update from local development source&lt;/code&gt;
    &lt;p&gt;The UI checks for updates automatically and auto-updates when enabled in Preferences. After server updates, the UI auto-refreshes to load the new version.&lt;/p&gt;
    &lt;code&gt;coder-config ui                    # Start UI on port 3333
coder-config ui --port 8080        # Custom port
coder-config ui /path/to/project   # Specific project directory
coder-config ui --foreground       # Run in foreground (blocking)
coder-config ui status             # Check if daemon is running
coder-config ui stop               # Stop the daemon

# Auto-start on login (macOS)
coder-config ui install            # Install LaunchAgent for auto-start
coder-config ui uninstall          # Remove auto-start&lt;/code&gt;
    &lt;p&gt;Daemon Mode: By default, &lt;code&gt;coder-config ui&lt;/code&gt; runs as a background daemon.
The UI runs from your home directory and persists across terminal sessions.
Switch between registered projects using the dropdown in the header.&lt;/p&gt;
    &lt;p&gt;PWA / Auto-Start: Install the UI as a PWA in your browser, then run &lt;code&gt;coder-config ui install&lt;/code&gt;
to have the server start automatically on login. Your PWA will always connect instantly.&lt;/p&gt;
    &lt;p&gt;For full functionality, add to &lt;code&gt;~/.zshrc&lt;/code&gt;:&lt;/p&gt;
    &lt;code&gt;source /path/to/coder-config/shell/claude-config.zsh&lt;/code&gt;
    &lt;p&gt;This enables:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Per-terminal workstreams - &lt;code&gt;workstream use&lt;/code&gt;activates for current terminal only&lt;/item&gt;
      &lt;item&gt;Auto-generates &lt;code&gt;.mcp.json&lt;/code&gt;when entering a project with&lt;code&gt;.claude/mcps.json&lt;/code&gt;&lt;/item&gt;
      &lt;item&gt;Tab completion for all commands&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Settings merge from global to project to sub-project:&lt;/p&gt;
    &lt;code&gt;~/.claude/mcps.json                    # Global - applies everywhere
~/projects/.claude/mcps.json           # Workspace - applies to projects here
~/projects/my-app/.claude/             # Project - specific to this project
~/projects/my-app/server/.claude/      # Sub-project - inherits from parent
&lt;/code&gt;
    &lt;p&gt;Sub-projects are automatically detected (folders with &lt;code&gt;.git&lt;/code&gt;), or you can manually link any folder using "Add Sub-project" in the Web UI.&lt;/p&gt;
    &lt;p&gt;After &lt;code&gt;coder-config init&lt;/code&gt;:&lt;/p&gt;
    &lt;code&gt;your-project/
├── .claude/
│   ├── mcps.json       # MCP configuration
│   ├── settings.json   # Claude Code settings
│   ├── rules/          # Project rules (*.md)
│   └── commands/       # Custom commands (*.md)
└── .mcp.json           # Generated - Claude Code reads this
&lt;/code&gt;
    &lt;p&gt;&lt;code&gt;.claude/mcps.json&lt;/code&gt;:&lt;/p&gt;
    &lt;code&gt;{
  "mcpServers": {
    "filesystem": {
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-filesystem", "/path"]
    },
    "github": {
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-github"],
      "env": {
        "GITHUB_TOKEN": "${GITHUB_TOKEN}"
      }
    }
  }
}&lt;/code&gt;
    &lt;p&gt;Environment variables use &lt;code&gt;${VAR}&lt;/code&gt; syntax and load from &lt;code&gt;.claude/.env&lt;/code&gt;.&lt;/p&gt;
    &lt;p&gt;Persistent memory for Claude Code sessions.&lt;/p&gt;
    &lt;p&gt;Global (&lt;code&gt;~/.claude/memory/&lt;/code&gt;)&lt;/p&gt;
    &lt;table&gt;
      &lt;row span="2"&gt;
        &lt;cell role="head"&gt;File&lt;/cell&gt;
        &lt;cell role="head"&gt;Purpose&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;
          &lt;code&gt;preferences.md&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;User preferences and style&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;
          &lt;code&gt;corrections.md&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Mistakes to avoid&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;cell&gt;
          &lt;code&gt;facts.md&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Environment facts&lt;/cell&gt;
      &lt;/row&gt;
    &lt;/table&gt;
    &lt;p&gt;Project (&lt;code&gt;&amp;lt;project&amp;gt;/.claude/memory/&lt;/code&gt;)&lt;/p&gt;
    &lt;table&gt;
      &lt;row span="2"&gt;
        &lt;cell role="head"&gt;File&lt;/cell&gt;
        &lt;cell role="head"&gt;Purpose&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;
          &lt;code&gt;context.md&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Project overview&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;
          &lt;code&gt;patterns.md&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Code patterns&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;
          &lt;code&gt;decisions.md&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Architecture decisions&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;
          &lt;code&gt;issues.md&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Known issues&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;cell&gt;
          &lt;code&gt;history.md&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Session history&lt;/cell&gt;
      &lt;/row&gt;
    &lt;/table&gt;
    &lt;p&gt;Manage via Web UI or edit files directly.&lt;/p&gt;
    &lt;p&gt;Save context from a Claude Code session and restore it on the next session start.&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Save context - Use &lt;code&gt;/flush&lt;/code&gt;in Claude Code to write a context summary&lt;/item&gt;
      &lt;item&gt;Auto-restore - The &lt;code&gt;session-start&lt;/code&gt;hook injects saved context into your next session&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Context is stored per-project in &lt;code&gt;.claude/session-context.md&lt;/code&gt;.&lt;/p&gt;
    &lt;p&gt;From the UI: Go to System &amp;gt; Sessions and click "Install All"&lt;/p&gt;
    &lt;p&gt;From the CLI:&lt;/p&gt;
    &lt;code&gt;coder-config session install&lt;/code&gt;
    &lt;p&gt;This installs the SessionStart hook and the &lt;code&gt;/flush&lt;/code&gt; command.&lt;/p&gt;
    &lt;code&gt;coder-config session           # Show session status
coder-config session install   # Install hooks and /flush command
coder-config session clear     # Clear saved context&lt;/code&gt;
    &lt;p&gt;Session context is stored in each project at &lt;code&gt;.claude/session-context.md&lt;/code&gt;.&lt;/p&gt;
    &lt;p&gt;Workstreams are context sets for multi-project workflows. They group related projects and inject context rules into every Claude session.&lt;/p&gt;
    &lt;p&gt;When working on complex features that span multiple repos (e.g., REST API + UI + shared library), you need Claude to understand the broader context. Workstreams solve this by:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Grouping related projects together&lt;/item&gt;
      &lt;item&gt;Defining rules specific to that workflow&lt;/item&gt;
      &lt;item&gt;Automatically injecting those rules into every Claude session&lt;/item&gt;
    &lt;/list&gt;
    &lt;code&gt;# Create a workstream for user authentication feature
coder-config workstream create "User Auth"

# Add related projects
coder-config workstream add "User Auth" ~/projects/api
coder-config workstream add "User Auth" ~/projects/ui
coder-config workstream add "User Auth" ~/projects/shared

# Activate it
coder-config workstream use "User Auth"&lt;/code&gt;
    &lt;p&gt;Then in the Web UI, edit the workstream to add rules like:&lt;/p&gt;
    &lt;quote&gt;
      &lt;p&gt;Focus on user authentication flow. Use JWT tokens. React Query for state management. PostgreSQL for persistence.&lt;/p&gt;
    &lt;/quote&gt;
    &lt;p&gt;For rules to be injected automatically, install the pre-prompt hook:&lt;/p&gt;
    &lt;p&gt;Option 1: One-click install (recommended)&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Open Web UI → Workstreams → Click "Install Hook Automatically"&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Option 2: Manual&lt;/p&gt;
    &lt;code&gt;# Add to ~/.claude/hooks/pre-prompt.sh
coder-config workstream inject --silent&lt;/code&gt;
    &lt;p&gt;Once installed, your active workstream's rules are prepended to every Claude session.&lt;/p&gt;
    &lt;p&gt;Coder-config can track which files you work on and suggest workstreams based on patterns:&lt;/p&gt;
    &lt;p&gt;How it works:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;A post-response hook logs file paths accessed during Claude sessions&lt;/item&gt;
      &lt;item&gt;Co-activity patterns are detected (projects frequently worked on together)&lt;/item&gt;
      &lt;item&gt;Workstream suggestions appear in the UI based on these patterns&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Setup (optional):&lt;/p&gt;
    &lt;code&gt;# Install the activity tracking hook
# Add to ~/.claude/hooks/post-response.sh:
source /path/to/coder-config/hooks/activity-track.sh&lt;/code&gt;
    &lt;p&gt;In the Web UI:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Activity Insights panel shows sessions, files tracked, and active projects&lt;/item&gt;
      &lt;item&gt;Suggested Workstreams appear when patterns are detected&lt;/item&gt;
      &lt;item&gt;Click "Create" to open pre-filled dialog (tweak projects as needed)&lt;/item&gt;
      &lt;item&gt;Click "X" to dismiss suggestions you don't want&lt;/item&gt;
    &lt;/list&gt;
    &lt;table&gt;
      &lt;row span="2"&gt;
        &lt;cell role="head"&gt;Feature&lt;/cell&gt;
        &lt;cell role="head"&gt;Description&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;Project Explorer&lt;/cell&gt;
        &lt;cell&gt;Browse and edit &lt;code&gt;.claude/&lt;/code&gt; folders across your project hierarchy&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;Claude Code Settings&lt;/cell&gt;
        &lt;cell&gt;Visual editor for permissions, model, hooks, and behavior&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;Gemini CLI Settings&lt;/cell&gt;
        &lt;cell&gt;Configure model, display options, and sandbox mode&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;Codex CLI Settings&lt;/cell&gt;
        &lt;cell&gt;Configure model, security, MCP servers, and features&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;Antigravity Settings&lt;/cell&gt;
        &lt;cell&gt;Configure security policies, browser allowlist, and agent mode&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;MCP Registry&lt;/cell&gt;
        &lt;cell&gt;Search GitHub/npm, add and configure MCP servers&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;Plugins&lt;/cell&gt;
        &lt;cell&gt;Browse marketplaces, install plugins with scope control&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;Memory&lt;/cell&gt;
        &lt;cell&gt;Manage preferences, corrections, patterns, and decisions&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;cell&gt;Workstreams&lt;/cell&gt;
        &lt;cell&gt;Group related projects with shared context rules&lt;/cell&gt;
      &lt;/row&gt;
    &lt;/table&gt;
    &lt;p&gt;Additional features: project/workstream switchers in header, sub-project detection, dark mode, auto-updates.&lt;/p&gt;
    &lt;p&gt;Claude Code plugins extend functionality with LSP servers, MCP servers, commands, and always-on guidance. Plugins replace templates - instead of static files that can become stale, plugins are always active and update automatically.&lt;/p&gt;
    &lt;table&gt;
      &lt;row span="2"&gt;
        &lt;cell role="head"&gt;Aspect&lt;/cell&gt;
        &lt;cell role="head"&gt;Plugins&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;Delivery&lt;/cell&gt;
        &lt;cell&gt;Enable plugin once&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;Updates&lt;/cell&gt;
        &lt;cell&gt;Auto-refresh from marketplace&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;Freshness&lt;/cell&gt;
        &lt;cell&gt;Always current&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;Scope&lt;/cell&gt;
        &lt;cell&gt;Global, project, or local&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;cell&gt;Discovery&lt;/cell&gt;
        &lt;cell&gt;Browse marketplaces&lt;/cell&gt;
      &lt;/row&gt;
    &lt;/table&gt;
    &lt;p&gt;From CLI:&lt;/p&gt;
    &lt;code&gt;# Add the coder-config plugins marketplace
claude plugin marketplace add regression-io/claude-config-plugins

# Install framework-specific plugins
claude plugin install fastapi-support@claude-config-plugins
claude plugin install react-typescript@claude-config-plugins
claude plugin install python-support@claude-config-plugins&lt;/code&gt;
    &lt;p&gt;From Web UI:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Open Project Explorer&lt;/item&gt;
      &lt;item&gt;Click the + menu on any project folder&lt;/item&gt;
      &lt;item&gt;Select Install Plugins&lt;/item&gt;
      &lt;item&gt;Toggle plugins on/off with scope selection (Project/Global/Local)&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The Plugins page shows all available plugins:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Filter by marketplace, category, source type (Anthropic/Community), installed status&lt;/item&gt;
      &lt;item&gt;Search by name or description&lt;/item&gt;
      &lt;item&gt;View plugin details (LSP/MCP/Commands included)&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Plugins come from marketplaces (Git repositories):&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;claude-plugins-official - Anthropic's official plugins&lt;/item&gt;
      &lt;item&gt;regression-io/claude-config-plugins - Framework and language plugins&lt;/item&gt;
      &lt;item&gt;Add community marketplaces via "Manage Marketplaces" in the filter dropdown&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Supported marketplace formats:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;owner/repo&lt;/code&gt;— GitHub shorthand&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;https://github.com/owner/repo&lt;/code&gt;— Full URL&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;/local/path&lt;/code&gt;— Local directory&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The Web UI provides a visual editor for &lt;code&gt;~/.claude/settings.json&lt;/code&gt;:&lt;/p&gt;
    &lt;p&gt;Configure what Claude Code can do automatically:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Allow - Tools that run without asking&lt;/item&gt;
      &lt;item&gt;Ask - Tools that require confirmation&lt;/item&gt;
      &lt;item&gt;Deny - Tools that are blocked&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Pattern examples:&lt;/p&gt;
    &lt;code&gt;Bash(npm run build)      # Specific command
Bash(npm:*)              # Prefix match (npm anything)
Read(**)                 # All file reads
Edit(src/**)             # Edit files in src/
mcp__github__*           # All GitHub MCP tools
&lt;/code&gt;
    &lt;p&gt;Choose your preferred Claude model (Sonnet 4, Opus 4.5, etc.)&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Auto-accept edits&lt;/item&gt;
      &lt;item&gt;Verbose mode&lt;/item&gt;
      &lt;item&gt;Enable/disable MCP servers&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The Web UI provides a visual editor for &lt;code&gt;~/.gemini/settings.json&lt;/code&gt;:&lt;/p&gt;
    &lt;p&gt;Choose Gemini model (2.5 Pro, 2.5 Flash, etc.) and enable preview features.&lt;/p&gt;
    &lt;p&gt;Configure theme, token count display, diff view, and streaming.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Vim keybindings&lt;/item&gt;
      &lt;item&gt;Auto-save&lt;/item&gt;
      &lt;item&gt;Check for updates&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Control command execution safety (enabled/disabled).&lt;/p&gt;
    &lt;p&gt;The Web UI provides a visual editor for &lt;code&gt;~/.codex/config.toml&lt;/code&gt;:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Model - Select GPT-5.2 Codex, GPT-5, o3-mini, etc.&lt;/item&gt;
      &lt;item&gt;Reasoning Effort - Control thoroughness (minimal to xhigh)&lt;/item&gt;
    &lt;/list&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Approval Policy - When to ask for command approval (on-request, untrusted, on-failure, never)&lt;/item&gt;
      &lt;item&gt;Sandbox Mode - Filesystem access level (read-only, workspace-write, full-access)&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Configure MCP servers for Codex CLI with the same format as other tools.&lt;/p&gt;
    &lt;p&gt;Toggle feature flags like shell snapshots and web search.&lt;/p&gt;
    &lt;p&gt;Configure TUI animations, notifications, and session history persistence.&lt;/p&gt;
    &lt;p&gt;For full configuration options, see Codex CLI docs.&lt;/p&gt;
    &lt;p&gt;The Web UI provides a visual editor for &lt;code&gt;~/.gemini/antigravity/settings.json&lt;/code&gt;:&lt;/p&gt;
    &lt;table&gt;
      &lt;row span="2"&gt;
        &lt;cell role="head"&gt;Policy&lt;/cell&gt;
        &lt;cell role="head"&gt;Options&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;Terminal Execution&lt;/cell&gt;
        &lt;cell&gt;Off, Auto, Turbo&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;Code Review&lt;/cell&gt;
        &lt;cell&gt;Enabled, Disabled&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;cell&gt;JS Execution&lt;/cell&gt;
        &lt;cell&gt;Sandboxed, Direct&lt;/cell&gt;
      &lt;/row&gt;
    &lt;/table&gt;
    &lt;p&gt;Configure MCP servers for Antigravity. Note: Antigravity does NOT support &lt;code&gt;${VAR}&lt;/code&gt; interpolation - variables are resolved to actual values.&lt;/p&gt;
    &lt;p&gt;Control which URLs Antigravity can access during sessions.&lt;/p&gt;
    &lt;p&gt;Configure autonomous multi-step operations, iteration limits, and confirmation requirements.&lt;/p&gt;
    &lt;p&gt;User settings stored in &lt;code&gt;~/.claude-config/config.json&lt;/code&gt;:&lt;/p&gt;
    &lt;code&gt;{
  "toolsDir": "~/mcp-tools",
  "registryPath": "~/.claude/registry.json",
  "ui": {
    "port": 3333,
    "openBrowser": true
  }
}&lt;/code&gt;
    &lt;table&gt;
      &lt;row span="2"&gt;
        &lt;cell role="head"&gt;Key&lt;/cell&gt;
        &lt;cell role="head"&gt;Description&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;
          &lt;code&gt;toolsDir&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Directory for local MCP tools&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;
          &lt;code&gt;registryPath&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Path to custom MCP registry&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;
          &lt;code&gt;ui.port&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Default port for web UI&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;cell&gt;
          &lt;code&gt;ui.openBrowser&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Auto-open browser on &lt;code&gt;coder-config ui&lt;/code&gt;&lt;/cell&gt;
      &lt;/row&gt;
    &lt;/table&gt;
    &lt;quote&gt;
      &lt;p&gt;Note: Ralph Loops is an experimental feature, disabled by default. Enable it in the Web UI under Preferences &amp;gt; Experimental Features.&lt;/p&gt;
    &lt;/quote&gt;
    &lt;p&gt;Ralph Loops enable autonomous development - Claude Code runs continuously until a task is completed.&lt;/p&gt;
    &lt;code&gt;coder-config loop                           # List all loops
coder-config loop create "Task description" # Create new loop
coder-config loop create "Task" --workstream &amp;lt;name&amp;gt;  # Create loop in workstream context
coder-config loop start &amp;lt;id&amp;gt;                # Start/resume a loop
coder-config loop pause &amp;lt;id&amp;gt;                # Pause loop at next safe point
coder-config loop resume &amp;lt;id&amp;gt;               # Resume paused loop
coder-config loop cancel &amp;lt;id&amp;gt;               # Cancel loop
coder-config loop delete &amp;lt;id&amp;gt;               # Delete loop and its data
coder-config loop approve &amp;lt;id&amp;gt;              # Approve plan (when in plan phase)
coder-config loop complete &amp;lt;id&amp;gt;             # Mark loop as complete
coder-config loop status [id]               # Show status (active loop if no id)
coder-config loop active                    # Show current active loop
coder-config loop history                   # Show completed loops
coder-config loop config                    # Show loop configuration
coder-config loop config --max-iterations 50    # Set max iterations
coder-config loop config --auto-approve-plan    # Skip manual plan approval&lt;/code&gt;
    &lt;p&gt;Three-Phase Workflow:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Clarify - Claude asks questions to understand requirements&lt;/item&gt;
      &lt;item&gt;Plan - Claude creates an implementation plan (requires approval)&lt;/item&gt;
      &lt;item&gt;Execute - Claude implements the plan until complete&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Running a loop:&lt;/p&gt;
    &lt;code&gt;export CODER_LOOP_ID=&amp;lt;id&amp;gt;
claude --continue "Your task description"&lt;/code&gt;
    &lt;p&gt;Safety mechanisms:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Iteration limits (default: 50)&lt;/item&gt;
      &lt;item&gt;Phase gates (manual plan approval)&lt;/item&gt;
      &lt;item&gt;Graceful pause on limit exceeded&lt;/item&gt;
    &lt;/list&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Node.js 18+&lt;/item&gt;
      &lt;item&gt;Build tools (for newer Node.js versions without prebuilt binaries): &lt;list rend="ul"&gt;&lt;item&gt;macOS: Xcode Command Line Tools (&lt;code&gt;xcode-select --install&lt;/code&gt;)&lt;/item&gt;&lt;item&gt;Linux: &lt;code&gt;build-essential&lt;/code&gt;package&lt;/item&gt;&lt;item&gt;Windows: Visual Studio Build Tools&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;macOS: Xcode Command Line Tools (&lt;/item&gt;
    &lt;/list&gt;
    &lt;code&gt;git clone https://github.com/regression-io/coder-config.git
cd coder-config
npm install
npm run build
npm start&lt;/code&gt;
    &lt;p&gt;MIT&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://github.com/regression-io/coder-config"/><published>2026-01-28T15:44:24+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=46797594</id><title>Oban, the job processing framework from Elixir, has come to Python</title><updated>2026-01-28T21:19:29.168443+00:00</updated><content>&lt;doc fingerprint="2e18825df1a004c7"&gt;
  &lt;main&gt;
    &lt;head rend="h2"&gt;Setting the Stage&lt;/head&gt;
    &lt;p&gt;I’ve used Oban in Elixir for almost as long as I’ve been writing software in Elixir, and it has always been an essential tool for processing jobs. I always knew Oban was cool, but I never dug deeper. This article is a collection of my notes and observations on how the Python implementation of Oban works and what I’ve learned while exploring its codebase. I’ll also try to compare it with the Elixir version and talk about concurrency in general.&lt;/p&gt;
    &lt;head rend="h2"&gt;Surface Level&lt;/head&gt;
    &lt;p&gt;Oban allows you to insert and process jobs using only your database. You can insert the job to send a confirmation email in the same database transaction where you create the user. If one thing fails, everything is rolled back.&lt;/p&gt;
    &lt;p&gt;Additionally, like most job processing frameworks, Oban has queues with local and global queue limits. But unlike others, it stores your completed jobs and can even keep their results if needed. It has built-in cron scheduling and many more features to control how your jobs are processed.&lt;/p&gt;
    &lt;p&gt;Oban comes in two versions - Open Source Oban-py and commercial Oban-py-pro.&lt;/p&gt;
    &lt;p&gt;OSS Oban has a few limitations, which are automatically lifted in the Pro version:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Single-threaded asyncio execution - concurrent but not truly parallel, so CPU-bound jobs block the event loop.&lt;/item&gt;
      &lt;item&gt;No bulk inserts - each job is inserted individually.&lt;/item&gt;
      &lt;item&gt;No bulk acknowledgements - each job completion is persisted individually.&lt;/item&gt;
      &lt;item&gt;Inaccurate rescues - jobs that are long-running might get rescued even if the producer is still alive. Pro version uses smarter heartbeats to track producer liveness.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;In addition, Oban-py-pro comes with a few extra features you’d configure separately, like workflows, relay, unique jobs, and smart concurrency.&lt;/p&gt;
    &lt;p&gt;OSS Oban-py is a great start for your hobby project, or if you’d want to evaluate Oban philosophy itself, but for any bigger scale - I’d go with Oban Pro. The pricing seems very compelling, considering the amount of work put into making the above features work.&lt;/p&gt;
    &lt;p&gt;I obviously can’t walk you through the Pro version features, but let’s start with the basics. How Oban Py works under the hood, from the job insertion until the job execution. Stay tuned.&lt;/p&gt;
    &lt;head rend="h2"&gt;Going Deeper - Job Processing Path&lt;/head&gt;
    &lt;p&gt;Let’s get straight to it. You insert your job:&lt;/p&gt;
    &lt;code&gt;from oban import job

@job(queue="default")
async def send_email(to: str, subject: str, body: str):
    # Simple and clean, but no access to job context
    await smtp.send(to, subject, body)

await send_email.enqueue("[email protected]", "Hello", "World")
&lt;/code&gt;
    &lt;p&gt;After the insertion, the job lands in the &lt;code&gt;oban_jobs&lt;/code&gt; database table with &lt;code&gt;state = 'available'&lt;/code&gt;. Oban fires off a PostgreSQL &lt;code&gt;NOTIFY&lt;/code&gt; on the &lt;code&gt;insert&lt;/code&gt; channel:&lt;/p&gt;
    &lt;code&gt;# oban.py:414-419
# Single inserts go through bulk insert path
result = await self._query.insert_jobs(jobs)
queues = {job.queue for job in result if job.state == "available"}
await self._notifier.notify("insert", [{"queue": queue} for queue in queues])
&lt;/code&gt;
    &lt;p&gt;Every Oban node listening on that channel receives the notification. The Stager on each node gets woken up, but each Stager only cares about queues it’s actually running. Be aware that each node decides which queues it runs, so if the current node runs this queue, the producer is notified:&lt;/p&gt;
    &lt;code&gt;# _stager.py:95-99
async def _on_notification(self, channel: str, payload: dict) -&amp;gt; None:
    queue = payload["queue"]

    if queue in self._producers:
        self._producers[queue].notify()
&lt;/code&gt;
    &lt;p&gt;That &lt;code&gt;notify()&lt;/code&gt; call sets an &lt;code&gt;asyncio.Event&lt;/code&gt;, breaking the Producer out of its wait loop, so it can dispatch the jobs to the workers:&lt;/p&gt;
    &lt;code&gt;# _producer.py:244-262
async def _loop(self) -&amp;gt; None:
    while True:
        try:
            # &amp;lt;--- This is where the event is received ---&amp;gt;
            await asyncio.wait_for(self._notified.wait(), timeout=1.0)
        except asyncio.TimeoutError:
            continue
        except asyncio.CancelledError:
            break

        # &amp;lt;--- Reset the event so it can be triggered for the next batch ---&amp;gt;
        self._notified.clear()

        try:
            # &amp;lt;--- A little debounce to potentially process multiple jobs at once ---&amp;gt;
            await self._debounce()
            # &amp;lt;--- Dispatch (Produce) the jobs from the database to the workers ---&amp;gt;
            await self._produce()
        except asyncio.CancelledError:
            break
        except Exception:
            logger.exception("Error in producer for queue %s", self._queue)
&lt;/code&gt;
    &lt;p&gt;Before fetching the jobs, the producer persists all pre-existing job completions (acks) to the database to make sure queue limits are respected. Next, it fetches new jobs, transitioning their state to executing at the same time. A slightly more complex version of this SQL is used:&lt;/p&gt;
    &lt;code&gt;-- fetch_jobs.sql (simplified)
WITH locked_jobs AS (
  SELECT priority, scheduled_at, id
  FROM
  oban_jobs
  WHERE state = 'available' AND queue = %(queue)s
  ORDER BY priority ASC, scheduled_at ASC, id ASC
  LIMIT %(demand)s
  FOR UPDATE SKIP LOCKED
)
UPDATE oban_jobs oj
SET
  attempt = oj.attempt + 1,
  attempted_at = timezone('UTC', now()),
  attempted_by = %(attempted_by)s,
  state = 'executing'
FROM locked_jobs
WHERE oj.id = locked_jobs.id
&lt;/code&gt;
    &lt;p&gt;And this is the first really cool part.&lt;/p&gt;
    &lt;p&gt;Segue to FOR UPDATE SKIP LOCKED.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;FOR UPDATE&lt;/code&gt;- Locks the selected rows so no other transaction can modify them until this transaction completes. This prevents two producers from grabbing the same job.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;SKIP LOCKED&lt;/code&gt;- If a row is already locked by another transaction, skip it instead of waiting. This is crucial for concurrency.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Why this matters for job queues: Imagine two producer instances (A and B) trying to fetch jobs simultaneously:&lt;/p&gt;
    &lt;table&gt;
      &lt;row span="2"&gt;
        &lt;cell role="head"&gt;Without SKIP LOCKED&lt;/cell&gt;
        &lt;cell role="head"&gt;With SKIP LOCKED&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;A locks job #1&lt;/cell&gt;
        &lt;cell&gt;A locks job #1&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;B waits for job #1 to unlock&lt;/cell&gt;
        &lt;cell&gt;B skips job #1, takes job #2&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;cell&gt;Slow, sequential processing&lt;/cell&gt;
        &lt;cell&gt;Fast, parallel processing&lt;/cell&gt;
      &lt;/row&gt;
    &lt;/table&gt;
    &lt;p&gt;Back in Python, we know that the jobs we just fetched should be processed immediately. When we fetched the job, we already transitioned its state and respected the queue demand.&lt;/p&gt;
    &lt;p&gt;Each job gets dispatched as an async task:&lt;/p&gt;
    &lt;code&gt;jobs = await self._get_jobs()
for job in jobs:
    task = self._dispatcher.dispatch(self, job)
    task.add_done_callback(
        lambda _, job_id=job.id: self._on_job_complete(job_id)
    )

    self._running_jobs[job.id] = (job, task)
&lt;/code&gt;
    &lt;p&gt;&lt;code&gt;add_done_callback&lt;/code&gt; ensures that independent of success or failure, we can attach a callback to handle job completion.&lt;/p&gt;
    &lt;p&gt;The dispatcher controls how exactly the job is run. For the non-pro Oban version, it just uses &lt;code&gt;asyncio.create_task&lt;/code&gt; to run the job in the event loop:&lt;/p&gt;
    &lt;code&gt;# _producer.py:69-71
class LocalDispatcher:
    def dispatch(self, producer: Producer, job: Job) -&amp;gt; asyncio.Task:
        return asyncio.create_task(producer._execute(job))
&lt;/code&gt;
    &lt;p&gt;For pro version, local asyncio dispatcher is automatically replaced with a pool of processes, so you don’t need to do anything to have true parallelism across multiple cores.&lt;/p&gt;
    &lt;p&gt;After the job is dispatched, the Executor takes over. It resolves your worker class from the string name, runs it, and pattern-matches the result:&lt;/p&gt;
    &lt;code&gt;# _executor.py:73-83
async def _process(self) -&amp;gt; None:
  self.worker = resolve_worker(self.job.worker)()
  self.result = await self.worker.process(self.job)
&lt;/code&gt;
    &lt;code&gt;# _executor.py:95-133
match result:
    case Exception() as error:
        # Retry or discard based on attempt count
    case Cancel(reason=reason):
        # Mark cancelled
    case Snooze(seconds=seconds):
        # Reschedule with decremented attempt
    case _:
        # Completed successfully
&lt;/code&gt;
    &lt;p&gt;And that’s the second cool part! You see how similar it is to Elixir’s pattern matching? I love how it’s implemented!&lt;/p&gt;
    &lt;p&gt;When execution finishes, the result gets queued for acknowledgement:&lt;/p&gt;
    &lt;code&gt;# _producer.py:315
self._pending_acks.append(executor.action)
&lt;/code&gt;
    &lt;p&gt;The completion callback notifies the Producer to wake up again-fetch more jobs, and batch-ack the finished ones in a single query.&lt;/p&gt;
    &lt;p&gt;That’s the hot path: &lt;code&gt;Insert → Notify → Fetch (with locking) → Execute → Ack.&lt;/code&gt; Five hops from your code to completion. What about the background processes? What about errors and retries? What about periodic jobs, cron, and all these other pieces? Stay tuned.&lt;/p&gt;
    &lt;head rend="h2"&gt;The Undercurrents - Background Processes&lt;/head&gt;
    &lt;p&gt;Oban runs several background loops that keep the system healthy.&lt;/p&gt;
    &lt;head rend="h3"&gt;Leader Election&lt;/head&gt;
    &lt;p&gt;In a cluster, you don’t want every node pruning jobs or rescuing orphans. Oban elects a single leader:&lt;/p&gt;
    &lt;code&gt;# _leader.py:107-113
async def _election(self) -&amp;gt; None:
    self._is_leader = await self._query.attempt_leadership(
        self._name, self._node, int(self._interval), self._is_leader
    )
&lt;/code&gt;
    &lt;code&gt;-- Cleanup expired leaders first
DELETE FROM
  oban_leaders
WHERE
  expires_at &amp;lt; timezone('UTC', now())
&lt;/code&gt;
    &lt;code&gt;-- If current node is a leader, it re-elects itself
INSERT INTO oban_leaders (name, node, elected_at, expires_at)
VALUES (
  %(name)s,
  %(node)s,
  timezone('UTC', now()),
  timezone('UTC', now()) + interval '%(ttl)s seconds'
)
ON CONFLICT (name) DO UPDATE SET
  -- Only update if we're the same node (i.e. current leader re-electing itself).
  -- Other nodes can't overwrite an active leader's lease.
  expires_at = EXCLUDED.expires_at
WHERE
  oban_leaders.node = EXCLUDED.node
RETURNING node
&lt;/code&gt;
    &lt;code&gt;-- Try to insert as a new leader if no leader exists
INSERT INTO oban_leaders (
  name, node, elected_at, expires_at
) VALUES (
  %(name)s,
  %(node)s,
  timezone('UTC', now()),
  timezone('UTC', now()) + interval '%(ttl)s seconds'
)
ON CONFLICT (name) DO NOTHING
RETURNING node
&lt;/code&gt;
    &lt;p&gt;The leader refreshes twice as often to hold onto the role:&lt;/p&gt;
    &lt;code&gt;# _leader.py:101-105
# Sleep for half interval if leader (to boost their refresh interval and allow them to
# retain leadership), full interval otherwise
sleep_duration = self._interval / 2 if self._is_leader else self._interval
&lt;/code&gt;
    &lt;p&gt;When a node shuts down cleanly, it resigns and notifies the cluster:&lt;/p&gt;
    &lt;code&gt;# _leader.py:83-87
if self._is_leader:
    payload = {"action": "resign", "node": self._node, "name": self._name}

    await self._notifier.notify("leader", payload)
    await self._query.resign_leader(self._name, self._node)
&lt;/code&gt;
    &lt;p&gt;And that’s the third cool part! Leader election is delegated entirely to PostgreSQL. Oban uses &lt;code&gt;INSERT ... ON CONFLICT&lt;/code&gt; with a TTL-based lease - no Raft, no consensus protocol, no external coordination service. If the leader dies, its lease expires and the next node to run the election query takes over. Simple, effective, and zero additional infrastructure.&lt;/p&gt;
    &lt;head rend="h3"&gt;Lifeline: Rescuing Orphaned Jobs&lt;/head&gt;
    &lt;p&gt;Workers crash. Containers get killed. When that happens, jobs can get stuck executing indefinitely. The Lifeline process (leader-only) rescues them:&lt;/p&gt;
    &lt;code&gt;# _lifeline.py:73-77
async def _rescue(self) -&amp;gt; None:
    if not self._leader.is_leader:
        return

    await use_ext("lifeline.rescue", _rescue, self._query, self._rescue_after)
&lt;/code&gt;
    &lt;p&gt;Oban-py rescue mechanics are purely time-based - any job in &lt;code&gt;executing&lt;/code&gt; state longer than &lt;code&gt;rescue_after&lt;/code&gt; (default: 5 minutes) gets moved back. Unlike the Oban Pro version, it doesn’t check whether the producer that owns the job is still alive. This means legitimately long-running jobs could be rescued and executed a second time.&lt;/p&gt;
    &lt;p&gt;The takeaway is that you should set &lt;code&gt;rescue_after&lt;/code&gt; higher than your longest expected job duration, and design workers to be idempotent.&lt;/p&gt;
    &lt;p&gt;The SQL itself is straightforward - jobs stuck executing get moved back to available or discarded if they’ve exhausted retries:&lt;/p&gt;
    &lt;code&gt;-- rescue_jobs.sql (simplified)
UPDATE oban_jobs
SET
  state = CASE
    WHEN attempt &amp;gt;= max_attempts THEN 'discarded'
    ELSE 'available'
  END,
  meta = CASE
    WHEN attempt &amp;gt;= max_attempts THEN meta
    ELSE meta || jsonb_build_object('rescued', coalesce((meta-&amp;gt;&amp;gt;'rescued')::int, 0) + 1)
  END
WHERE
  state = 'executing'
  AND attempted_at &amp;lt; timezone('UTC', now()) - make_interval(secs =&amp;gt; %(rescue_after)s)
&lt;/code&gt;
    &lt;p&gt;The rescued counter in meta lets you track how often jobs needed saving.&lt;/p&gt;
    &lt;head rend="h3"&gt;Pruner: Cleaning Up Old Jobs&lt;/head&gt;
    &lt;p&gt;Without pruning, your oban_jobs table grows forever. The Pruner (also leader-only) deletes terminal jobs older than max_age (default: 1 day):&lt;/p&gt;
    &lt;code&gt;-- prune_jobs.sql
WITH jobs_to_delete AS (
SELECT id FROM oban_jobs
WHERE
(state = 'completed' AND completed_at &amp;lt;= timezone('UTC', now()) - make_interval(secs =&amp;gt; %(max_age)s)) OR
(state = 'cancelled' AND cancelled_at &amp;lt;= timezone('UTC', now()) - make_interval(secs =&amp;gt; %(max_age)s)) OR
(state = 'discarded' AND discarded_at &amp;lt;= timezone('UTC', now()) - make_interval(secs =&amp;gt; %(max_age)s))
ORDER BY id ASC
LIMIT %(limit)s
)
DELETE FROM oban_jobs WHERE id IN (SELECT id FROM jobs_to_delete)
&lt;/code&gt;
    &lt;p&gt;The LIMIT prevents long-running deletes from blocking other operations.&lt;/p&gt;
    &lt;head rend="h3"&gt;Retry &amp;amp; Backoff Mechanics&lt;/head&gt;
    &lt;p&gt;When a job raises an exception, the Executor decides its fate:&lt;/p&gt;
    &lt;code&gt;# _executor.py:96-109
match result:
    case Exception() as error:
        if self.job.attempt &amp;gt;= self.job.max_attempts:
            self.action = AckAction(
                job=self.job,
                state="discarded",
                error=self._format_error(error),
            )
        else:
            self.action = AckAction(
                job=self.job,
                state="retryable",
                error=self._format_error(error),
                schedule_in=self._retry_backoff(),
            )
&lt;/code&gt;
    &lt;p&gt;Simple rule: under &lt;code&gt;max_attempts&lt;/code&gt; - retry, otherwise - discard.&lt;/p&gt;
    &lt;p&gt;The default backoff uses jittery-clamped exponential growth with randomness to prevent thundering herds:&lt;/p&gt;
    &lt;code&gt;# _backoff.py:66-87
def jittery_clamped(attempt: int, max_attempts: int, *, clamped_max: int = 20) -&amp;gt; int:
    if max_attempts &amp;lt;= clamped_max:
        clamped_attempt = attempt
    else:
        clamped_attempt = round(attempt / max_attempts * clamped_max)

    time = exponential(clamped_attempt, mult=1, max_pow=100, min_pad=15)

    return jitter(time, mode="inc")
&lt;/code&gt;
    &lt;p&gt;And that’s the fourth cool thing! Backoff includes jitter to prevent thundering herds - without it, all failed jobs from the same batch would retry at the exact same moment, spiking load all over again.&lt;/p&gt;
    &lt;p&gt;The formula: 15 + 2^attempt seconds, with up to 10% added jitter. Attempt 1 waits ~17s. Attempt 5 waits ~47s. Attempt 10 waits ~1039s (~17 minutes).&lt;/p&gt;
    &lt;p&gt;The clamping handles jobs with high &lt;code&gt;max_attempts&lt;/code&gt; - if you set &lt;code&gt;max_attempts=100&lt;/code&gt;, it scales the attempt number down proportionally so you don’t wait years between retries.&lt;/p&gt;
    &lt;p&gt;Workers can override this with custom backoff:&lt;/p&gt;
    &lt;code&gt;@worker(queue="default")
class MyWorker:
    async def process(self, job: Job):
        ...

    def backoff(self, job: Job) -&amp;gt; int:
        # Linear backoff: 60s, 120s, 180s...
        return job.attempt * 60
&lt;/code&gt;
    &lt;head rend="h2"&gt;Surfacing - Takeaways&lt;/head&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;PostgreSQL does the heavy lifting. &lt;code&gt;FOR UPDATE SKIP LOCKED&lt;/code&gt;for concurrent job fetching,&lt;code&gt;LISTEN/NOTIFY&lt;/code&gt;for real-time signaling,&lt;code&gt;ON CONFLICT&lt;/code&gt;for leader election - the database isn’t just storage, it’s the coordination layer. There’s no Redis, no ZooKeeper, no external broker. One less thing to operate.&lt;/item&gt;
      &lt;item&gt;Oban-py is concurrent, but not parallel. Async IO allows multiple jobs to be in-flight, but the event loop is single-threaded. For I/O-bound workloads, this is fine. For CPU-bound tasks, consider using the Pro version with a process pool.&lt;/item&gt;
      &lt;item&gt;Leader election is simple and effective. No consensus protocol, no Raft - just an &lt;code&gt;INSERT ... ON CONFLICT&lt;/code&gt;with a TTL. The leader refreshes at 2x the normal rate to hold the lease. If it dies, the lease expires and another node takes over. Good enough for pruning and rescuing.&lt;/item&gt;
      &lt;item&gt;The codebase is a pleasure to read. Clear naming, consistent patterns, and well-separated concerns - exploring it felt more like reading a well-written book than understanding a library.&lt;/item&gt;
      &lt;item&gt;OSS gets you far, Pro fills the gaps. Bulk operations, smarter rescues, and true parallelism are all Pro-only - but for what you get, Pro license feels like a great deal.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Overall, Oban.py is a clean and well-structured port. If you’re coming from Elixir and miss Oban, or if you’re in Python and want a database-backed job queue that doesn’t require external infrastructure beyond PostgreSQL - it’s worth looking at.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://www.dimamik.com/posts/oban_py/"/><published>2026-01-28T16:32:00+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=46797865</id><title>Will AIs take all our jobs and end human history, or not? (2023)</title><updated>2026-01-28T21:19:28.712906+00:00</updated><content>&lt;doc fingerprint="3e05995eb7e385f0"&gt;
  &lt;main&gt;
    &lt;head rend="h2"&gt;The Shock of ChatGPT&lt;/head&gt;
    &lt;p&gt;Just a few months ago writing an original essay seemed like something only a human could do. But then ChatGPT burst onto the scene. And suddenly we realized that an AI could write a passable human-like essay. So now it’s natural to wonder: How far will this go? What will AIs be able to do? And how will we humans fit in?&lt;/p&gt;
    &lt;p&gt;My goal here is to explore some of the science, technology—and philosophy—of what we can expect from AIs. I should say at the outset that this is a subject fraught with both intellectual and practical difficulty. And all I’ll be able to do here is give a snapshot of my current thinking—which will inevitably be incomplete—not least because, as I’ll discuss, trying to predict how history in an area like this will unfold is something that runs straight into an issue of basic science: the phenomenon of computational irreducibility.&lt;/p&gt;
    &lt;p&gt;But let’s start off by talking about that particularly dramatic example of AI that’s just arrived on the scene: ChatGPT. So what is ChatGPT? Ultimately, it’s a computational system for generating text that’s been set up to follow the patterns defined by human-written text from billions of webpages, millions of books, etc. Give it a textual prompt and it’ll continue in a way that’s somehow typical of what it’s seen us humans write.&lt;/p&gt;
    &lt;p&gt;The results (which ultimately rely on all sorts of specific engineering) are remarkably “human like”. And what makes this work is that whenever ChatGPT has to “extrapolate” beyond anything it’s explicitly seen from us humans it does so in ways that seem similar to what we as humans might do.&lt;/p&gt;
    &lt;p&gt;Inside ChatGPT is something that’s actually computationally probably quite similar to a brain—with millions of simple elements (“neurons”) forming a “neural net” with billions of connections that have been “tweaked” through a progressive process of training until they successfully reproduce the patterns of human-written text seen on all those webpages, etc. Even without training the neural net would still produce some kind of text. But the key point is that it won’t be text that we humans consider meaningful. To get such text we need to build on all that “human context” defined by the webpages and other materials we humans have written. The “raw computational system” will just do “raw computation”; to get something aligned with us humans requires leveraging the detailed human history captured by all those pages on the web, etc.&lt;/p&gt;
    &lt;p&gt;But so what do we get in the end? Well, it’s text that basically reads like it was written by a human. In the past we might have thought that human language was somehow a uniquely human thing to produce. But now we’ve got an AI doing it. So what’s left for us humans? Well, somewhere things have got to get started: in the case of text, there’s got to be a prompt specified that tells the AI “what direction to go in”. And this is the kind of thing we’ll see over and over again. Given a defined “goal”, an AI can automatically work towards achieving it. But it ultimately takes something beyond the raw computational system of the AI to define what us humans would consider a meaningful goal. And that’s where we humans come in.&lt;/p&gt;
    &lt;p&gt;What does this mean at a practical, everyday level? Typically we use ChatGPT by telling it—using text—what we basically want. And then it’ll fill in a whole essay’s worth of text talking about it. We can think of this interaction as corresponding to a kind of “linguistic user interface” (that we might dub a “LUI”). In a graphical user interface (GUI) there’s core content that’s being rendered (and input) through some potentially elaborate graphical presentation. In the LUI provided by ChatGPT there’s instead core content that’s being rendered (and input) through a textual (“linguistic”) presentation.&lt;/p&gt;
    &lt;p&gt;You might jot down a few “bullet points”. And in their raw form someone else would probably have a hard time understanding them. But through the LUI provided by ChatGPT those bullet points can be turned into an “essay” that can be generally understood—because it’s based on the “shared context” defined by everything from the billions of webpages, etc. on which ChatGPT has been trained.&lt;/p&gt;
    &lt;p&gt;There’s something about this that might seem rather unnerving. In the past, if you saw a custom-written essay you’d reasonably be able to conclude that a certain irreducible human effort was spent in producing it. But with ChatGPT this is no longer true. Turning things into essays is now “free” and automated. “Essayification” is no longer evidence of human effort.&lt;/p&gt;
    &lt;p&gt;Of course, it’s hardly the first time there’s been a development like this. Back when I was a kid, for example, seeing that a document had been typeset was basically evidence that someone had gone to the considerable effort of printing it on a printing press. But then came desktop publishing, and it became basically free to make any document be elaborately typeset.&lt;/p&gt;
    &lt;p&gt;And in a longer view, this kind of thing is basically a constant trend in history: what once took human effort eventually becomes automated and “free to do” through technology. There’s a direct analog of this in the realm of ideas: that with time higher and higher levels of abstraction are developed, that subsume what were formerly laborious details and specifics.&lt;/p&gt;
    &lt;p&gt;Will this end? Will we eventually have automated everything? Discovered everything? Invented everything? At some level, we now know that the answer is a resounding no. Because one of the consequences of the phenomenon of computational irreducibility is that there’ll always be more computations to do—that can’t in the end be reduced by any finite amount of automation, discovery or invention.&lt;/p&gt;
    &lt;p&gt;Ultimately, though, this will be a more subtle story. Because while there may always be more computations to do, it could still be that we as humans don’t care about them. And that somehow everything we care about can successfully be automated—say by AIs—leaving “nothing more for us to do”.&lt;/p&gt;
    &lt;p&gt;Untangling this issue will be at the heart of questions about how we fit into the AI future. And in what follows we’ll see over and over again that what might at first essentially seem like practical matters of technology quickly get enmeshed with deep questions of science and philosophy.&lt;/p&gt;
    &lt;head rend="h2"&gt;Intuition from the Computational Universe&lt;/head&gt;
    &lt;p&gt;I’ve already mentioned computational irreducibility a couple of times. And it turns out that this is part of a circle of rather deep—and at first surprising—ideas that I believe are crucial to thinking about the AI future.&lt;/p&gt;
    &lt;p&gt;Most of our existing intuition about “machinery” and “automation” comes from a kind of “clockwork” view of engineering—in which we specifically build systems component by component to achieve objectives we want. And it’s the same with most software: we write it line by line to specifically do—step by step—whatever it is we want. And we expect that if we want our machinery—or software—to do complex things then the underlying structure of the machinery or software must somehow be correspondingly complex.&lt;/p&gt;
    &lt;p&gt;So when I started exploring the whole computational universe of possible programs in the early 1980s it was a big surprise to discover that things work quite differently there. And indeed even tiny programs—that effectively just apply very simple rules repeatedly—can generate great complexity. In our usual practice of engineering we haven’t seen this, because we’ve always specifically picked programs (or other structures) where we can readily foresee how they’ll behave, so that we can explicitly set them up to do what we want. But out in the computational universe it’s very common to see programs that just “intrinsically generate” great complexity, without us ever having to explicitly “put it in”.&lt;/p&gt;
    &lt;p&gt;And having discovered this, we realize that there’s actually a big example that’s been around forever: the natural world. And indeed it increasingly seems as if the “secret” that nature uses to make the complexity it so often shows is exactly to operate according to the rules of simple programs. (For about three centuries it seemed as if mathematical equations were the ultimate way to describe the natural world—but in the past few decades, and particularly poignantly with our recent Physics Project, it’s become clear that simple programs are in general a more powerful approach.)&lt;/p&gt;
    &lt;p&gt;How does all this relate to technology? Well, technology is about taking what’s out there in the world, and harnessing it for human purposes. And there’s a fundamental tradeoff here. There may be some system out in nature that does amazingly complex things. But the question is whether we can “slice off” certain particular things that we humans happen to find useful. A donkey has all sorts of complex things going on inside. But at some point it was discovered that we can use it “technologically” to do the rather simple thing of pulling a cart.&lt;/p&gt;
    &lt;p&gt;And when it comes to programs out in the computational universe it’s extremely common to see ones that do amazingly complex things. But the question is whether we can find some aspect of those things that’s useful to us. Maybe the program is good at making pseudorandomness. Or distributedly determining consensus. Or maybe it’s just doing its complex thing, and we don’t yet know any “human purpose” that this achieves.&lt;/p&gt;
    &lt;p&gt;One of the notable features of a system like ChatGPT is that it isn’t constructed in an “understand-every-step” traditional engineering way. Instead one basically just starts from a “raw computational system” (in the case of ChatGPT, a neural net), then progressively tweaks it until its behavior aligns with the “human-relevant” examples one has. And this alignment is what makes the system “technologically useful”—to us humans.&lt;/p&gt;
    &lt;p&gt;Underneath, though, it’s still a computational system, with all the potential “wildness” that implies. And free from the “technological objective” of “human-relevant alignment” the system might do all sorts of sophisticated things. But they might not be things that (at least at this time in history) we care about. Even though some putative alien (or our future selves) might.&lt;/p&gt;
    &lt;p&gt;OK, but let’s come back to the “raw computation” side of things. There’s something very different about computation from all other kinds of “mechanisms” we’ve seen before. We might have a cart that can move forward. And we might have a stapler that can put staples in things. But carts and staplers do very different things; there’s no equivalence between them. But for computational systems (at least ones that don’t just always behave in obviously simple ways) there’s my Principle of Computational Equivalence—which implies that all these systems are in a sense equivalent in the kinds of computations they can do.&lt;/p&gt;
    &lt;p&gt;This equivalence has many consequences. One of them is that one can expect to make something equally computationally sophisticated out of all sorts of different kinds of things—whether brain tissue or electronics, or some system in nature. And this is effectively where computational irreducibility comes from.&lt;/p&gt;
    &lt;p&gt;One might think that given, say, some computational system based on a simple program it would always be possible for us—with our sophisticated brains, mathematics, computers, etc.—to “jump ahead” and figure out what the system will do before it’s gone through all the steps to do it. But the Principle of Computational Equivalence implies that this won’t in general be possible—because the system itself can be as computationally sophisticated as our brains, mathematics, computers, etc. are. So this means that the system will be computationally irreducible: the only way to find out what it does is effectively just to go through the same whole computational process that it does.&lt;/p&gt;
    &lt;p&gt;There’s a prevailing impression that science will always eventually be able do better than this: that it’ll be able to make “predictions” that allow us to work out what will happen without having to trace through each step. And indeed over the past three centuries there’s been lots of success in doing this, mainly by using mathematical equations. But ultimately it turns out that this has only been possible because science has ended up concentrating on particular systems where these methods work (and then these systems have been used for engineering). But the reality is that many systems show computational irreducibility. And in the phenomenon of computational irreducibility science is in effect “deriving its own limitedness”.&lt;/p&gt;
    &lt;p&gt;Contrary to traditional intuition, try as we might, in many systems we’ll never be able find “formulas” (or other “shortcuts”) that describe what’s going to happen in the systems—because the systems are simply computationally irreducible. And, yes, this represents a limitation on science, and on knowledge in general. But while at first this might seem like a bad thing, there’s also something fundamentally satisfying about it. Because if everything were computationally reducible, we could always “jump ahead” and find out what will happen in the end, say in our lives. But computational irreducibility implies that in general we can’t do that—so that in some sense “something irreducible is being achieved” by the passage of time.&lt;/p&gt;
    &lt;p&gt;There are a great many consequences of computational irreducibility. Some—that I have particularly explored recently—are in the domain of basic science (for example, establishing core laws of physics as we perceive them from the interplay of computational irreducibility and our computational limitations as observers). But computational irreducibility is also central in thinking about the AI future—and in fact I increasingly feel that it adds the single most important intellectual element needed to make sense of many of the most important questions about the potential roles of AIs and humans in the future.&lt;/p&gt;
    &lt;p&gt;For example, from our traditional experience with engineering we’re used to the idea that to find out why something happened in a particular way we can just “look inside” a machine or program and “see what it did”. But when there’s computational irreducibility, that won’t work. Yes, we could “look inside” and see, say, a few steps. But computational irreducibility implies that to find out what happened, we’d have to trace through all the steps. We can’t expect to find a “simple human narrative” that “says why something happened”.&lt;/p&gt;
    &lt;p&gt;But having said this, one feature of computational irreducibility is that within any computationally irreducible systems there must always be (ultimately, infinitely many) “pockets of computational reducibility” to be found. So for example, even though we can’t say in general what will happen, we’ll always be able to identify specific features that we can predict. (“The leftmost cell will always be black”, etc.) And as we’ll discuss later we can potentially think of technological (as well as scientific) progress as being intimately tied to the discovery of these “pockets of reducibility”. And in effect the existence of infinitely many such pockets is the reason that “there’ll always be inventions and discoveries to be made”.&lt;/p&gt;
    &lt;p&gt;Another consequence of computational irreducibility has to do with trying to ensure things about the behavior of a system. Let’s say one wants to set up an AI so it’ll “never do anything bad”. One might imagine that one could just come up with particular rules that ensure this. But as soon as the behavior of the system (or its environment) is computationally irreducible one will never be able to guarantee what will happen in the system. Yes, there may be particular computationally reducible features one can be sure about. But in general computational irreducibility implies that there’ll always be a “possibility of surprise” or the potential for “unintended consequences”. And the only way to systematically avoid this is to make the system not computationally irreducible—which means it can’t make use of the full power of computation.&lt;/p&gt;
    &lt;head rend="h2"&gt;“AIs Will Never Be Able to Do That”&lt;/head&gt;
    &lt;p&gt;We humans like to feel special, and feel as if there’s something “fundamentally unique” about us. Five centuries ago we thought we lived at the center of the universe. Now we just tend to think that there’s something about our intellectual capabilities that’s fundamentally unique and beyond anything else. But the progress of AI—and things like ChatGPT—keep on giving us more and more evidence that that’s not the case. And indeed my Principle of Computational Equivalence says something even more extreme: that at a fundamental computational level there’s just nothing fundamentally special about us at all—and that in fact we’re computationally just equivalent to lots of systems in nature, and even to simple programs.&lt;/p&gt;
    &lt;p&gt;This broad equivalence is important in being able to make very general scientific statements (like the existence of computational irreducibility). But it also highlights how significant our specifics—our particular history, biology, etc.—are. It’s very much like with ChatGPT. We can have a generic (untrained) neural net with the same structure as ChatGPT, that can do certain “raw computation”. But what makes ChatGPT interesting—at least to us—is that it’s been trained with the “human specifics” described on billions of webpages, etc. In other words, for both us and ChatGPT there’s nothing computationally “generally special”. But there is something “specifically special”—and it’s the particular history we’ve had, particular knowledge our civilization has accumulated, etc.&lt;/p&gt;
    &lt;p&gt;There’s a curious analogy here to our physical place in the universe. There’s a certain uniformity to the universe, which means there’s nothing “generally special” about our physical location. But at least to us there’s still something “specifically special” about it, because it’s only here that we have our particular planet, etc. At a deeper level, ideas based on our Physics Project have led to the concept of the ruliad: the unique object that is the entangled limit of all possible computational processes. And we can then view our whole experience as “observers of the universe” as consisting of sampling the ruliad at a particular place.&lt;/p&gt;
    &lt;p&gt;It’s a bit abstract (and a long story, which I won’t go into in any detail here), but we can think of different possible observers as being both at different places in physical space, and at different places in rulial space—giving them different “points of view” about what happens in the universe. Human minds are in effect concentrated in a particular region of physical space (mostly on this planet) and a particular region of rulial space. And in rulial space different human minds—with their different experiences and thus different ways of thinking about the universe—are in slightly different places. Animal minds might be fairly close in rulial space. But other computational systems (like, say, the weather, which is sometimes said to “have a mind of its own”) are further away—as putative aliens might also be.&lt;/p&gt;
    &lt;p&gt;So what about AIs? It depends what we mean by “AIs”. If we’re talking about computational systems that are set up to do “human-like things” then that means they’ll be close to us in rulial space. But insofar as “an AI” is an arbitrary computational system it can be anywhere in rulial space, and it can do anything that’s computationally possible—which is far broader than what we humans can do, or even think about. (As we’ll talk about later, as our intellectual paradigms—and ways of observing things—expand, the region of rulial space in which we humans operate will correspondingly expand.)&lt;/p&gt;
    &lt;p&gt;But, OK, just how “general” are the computations that we humans (and the AIs that follow us) are doing? We don’t know enough about the brain to be sure. But if we look at artificial neural net systems—like ChatGPT—we can potentially get some sense. And in fact the computations really don’t seem to be that “general”. In most neural net systems data that’s given as input just “ripples once through the system” to produce output. It’s not like in a computational system like a Turing machine where there can be arbitrary “recirculation of data”. And indeed without such “arbitrary recirculation” the computation is necessarily quite “shallow” and can’t ultimately show computational irreducibility.&lt;/p&gt;
    &lt;p&gt;It’s a bit of a technical point, but one can ask whether ChatGPT, with its “re-feeding of text produced so far” can in fact achieve arbitrary (“universal”) computation. And I suspect that in some formal sense it can (or at least a sufficiently expanded analog of it can)—though by producing an extremely verbose piece of text that for example in effect lists successive (self-delimiting) states of a Turing machine tape, and in which finding “the answer” to a computation will take a bit of effort. But—as I’ve discussed elsewhere—in practice ChatGPT is presumably almost exclusively doing “quite shallow” computation.&lt;/p&gt;
    &lt;p&gt;It’s an interesting feature of the history of practical computing that what one might consider “deep pure computations” (say in mathematics or science) were done for decades before “shallow human-like computations” became feasible. And the basic reason for this is that for “human-like computations” (like recognizing images or generating text) one needs to capture lots of “human context”, which requires having lots of “human-generated data” and the computational resources to store and process it.&lt;/p&gt;
    &lt;p&gt;And, by the way, brains also seem to specialize in fundamentally shallow computations. And to do the kind of deeper computations that allow one to take advantage of more of what’s out there in the computational universe, one has to turn to computers. As we’ve discussed, there’s plenty out in the computational universe that we humans don’t (yet) care about: we just consider it “raw computation”, that doesn’t seem to be “achieving human purposes”. But as a practical matter it’s important to make a bridge between the things we humans do care about and think about, and what’s possible in the computational universe. And in a sense that’s at the core of the project I’ve put so much effort into in the Wolfram Language of creating a full-scale computational language that describes in computational terms the things we think about, and experience in the world.&lt;/p&gt;
    &lt;p&gt;OK, people have been saying for years: “It’s nice that computers can do A and B, but only humans can do X”. What X is supposed to be has changed—and narrowed—over the years. And ChatGPT provides us with a major unexpected new example of something more that computers can do.&lt;/p&gt;
    &lt;p&gt;So what’s left? People might say: “Computers can never show creativity or originality”. But—perhaps disappointingly—that’s surprisingly easy to get, and indeed just a bit of randomness “seeding” a computation can often do a pretty good job, as we saw years ago with our WolframTones music-generation system, and as we see today with ChatGPT’s writing. People might also say: “Computers can never show emotions”. But before we had a good way to generate human language we wouldn’t really have been able to tell. And now it already works pretty well to ask ChatGPT to write “happily”, “sadly”, etc. (In their raw form emotions in both humans and other animals are presumably associated with rather simple “global variables” like neurotransmitter concentrations.)&lt;/p&gt;
    &lt;p&gt;In the past people might have said: “Computers can never show judgement”. But by now there are endless examples of machine learning systems that do well at reproducing human judgement in lots of domains. People might also say: “Computers don’t show common sense”. And by this they typically mean that in a particular situation a computer might locally give an answer, but there’s a global reason why that answer doesn’t make sense, that the computer “doesn’t notice”, but a person would.&lt;/p&gt;
    &lt;p&gt;So how does ChatGPT do on this? Not too badly. In plenty of cases it correctly recognizes that “that’s not what I’ve typically read”. But, yes, it makes mistakes. Some of them have to do with it not being able to do—purely with its neural net—even slightly “deeper”computations. (And, yes, that’s something that can often be fixed by it calling Wolfram|Alpha as a tool.) But in other cases the problem seems to be that it can’t quite connect different domains well enough.&lt;/p&gt;
    &lt;p&gt;It’s perfectly capable of doing simple (“SAT-style”) analogies. But when it comes to larger-scale ones it doesn’t manage them. My guess, though, is that it won’t take much scaling up before it starts to be able to make what seem like very impressive analogies (that most of us humans would never even be able to make)—at which point it’ll probably successfully show broader “common sense”.&lt;/p&gt;
    &lt;p&gt;But so what’s left that humans can do, and AIs can’t? There’s—almost by definition—one fundamental thing: define what we would consider goals for what to do. We’ll talk more about this later. But for now we can note that any computational system, once “set in motion”, will just follow its rules and do what it does. But what “direction should it be pointed in”? That’s something that has to come from “outside the system”.&lt;/p&gt;
    &lt;p&gt;So how does it work for us humans? Well, our goals are in effect defined by the whole web of history—both from biological evolution and from our cultural development—in which we are embedded. But ultimately the only way to truly participate in that web of history is to be part of it.&lt;/p&gt;
    &lt;p&gt;Of course, we can imagine technologically emulating every “relevant” aspect of a brain—and indeed things like the success of ChatGPT may suggest that that’s easier to do than we might have thought. But that won’t be enough. To participate in the “human web of history” (as we’ll discuss later) we’ll have to emulate other aspects of “being human”—like moving around, being mortal, etc. And, yes, if we make an “artificial human” we can expect it (by definition) to show all the features of us humans.&lt;/p&gt;
    &lt;p&gt;But while we’re still talking about AIs as—for example—“running on computers” or “being purely digital” then, at least as far as we’re concerned, they’ll have to “get their goals from outside”. One day (as we’ll discuss) there will no doubt be some kind of “civilization of AIs”—which will form its own web of history. But at this point there’s no reason to think that we’ll still be able to describe what’s going on in terms of goals that we recognize. In effect the AIs will at that point have left our domain of rulial space. And—as we’ll discuss—they’ll be operating more like the kind of systems we see in nature, where we can tell there’s computation going on, but we can’t describe it, except rather anthropomorphically, in terms of human goals and purposes.&lt;/p&gt;
    &lt;head rend="h2"&gt;Will There Be Anything Left for the Humans to Do?&lt;/head&gt;
    &lt;p&gt;It’s been an issue that’s been raised—with varying degrees of urgency—for centuries: with the advance of automation (and now AI), will there eventually be nothing left for humans to do? Back in the early days of our species, there was lots of hard work of hunting and gathering to do, just to survive. But at least in the developed parts of the world, that kind of work is now at best a distant historical memory.&lt;/p&gt;
    &lt;p&gt;And yet at each stage in history—at least so far—there always seem to be other kinds of work that keep people busy. But there’s a pattern that increasingly seems to repeat. Technology in some way or another enables some new occupation. And eventually that occupation becomes widespread, and lots of people do it. But then there’s a technological advance, and the occupation gets automated—and people aren’t needed to do it anymore. But now there’s a new level of technology, that enables new occupations. And the cycle continues.&lt;/p&gt;
    &lt;p&gt;A century ago the increasingly widespread use of telephones meant that more and more people worked as switchboard operators. But then telephone switching was automated—and those switchboard operators weren’t needed anymore. But with automated switching there could be huge development of telecommunications infrastructure, opening up all sorts of new types of jobs, that in aggregate employ vastly more people than were ever switchboard operators.&lt;/p&gt;
    &lt;p&gt;Something somewhat similar happened with accounting clerks. Before there were computers, one needed to have people laboriously tallying up numbers. But with computers, that was all automated away. But with that automation came the ability to do more complex financial computations—which allowed for more complex financial transactions, more complex regulations, etc., which in turn led to all sorts of new types of jobs.&lt;/p&gt;
    &lt;p&gt;And across a whole range of industries, it’s been the same kind of story. Automation obsoletes some jobs, but enables others. There’s quite often a gap in time, and a change in the skills that are needed. But at least so far there always seems to have been a broad frontier of jobs that have been made possible—but haven’t yet been automated.&lt;/p&gt;
    &lt;p&gt;Will this at some point end? Will there come a time when everything we humans want (or at least need) is delivered automatically? Well, of course, that depends on what we want, and whether, for example, that evolves with what technology has made possible. But could we just decide that “enough is enough”; let’s stop here, and just let everything be automated?&lt;/p&gt;
    &lt;p&gt;I don’t think so. And the reason is ultimately because of computational irreducibility. We try to get the world to be “just so”, say set up so we’re “predictably comfortable”. Well, the problem is that there’s inevitably computational irreducibility in the way things develop—not just in nature, but in things like societal dynamics too. And that means that things won’t stay “just so”. There’ll always be something unpredictable that happens; something that the automation doesn’t cover.&lt;/p&gt;
    &lt;p&gt;At first we humans might just say “we don’t care about that”. But in time computational irreducibility will affect everything. So if there’s anything at all we care about (including, for example, not going extinct), we’ll eventually have to do something—and go beyond whatever automation was already set up.&lt;/p&gt;
    &lt;p&gt;It’s easy to find practical examples. We might think that when computers and people are all connected in a seamless automated network, there’d be nothing more to do. But what about the “unintended consequence” of computer security issues? What might have seemed like a case where “technology finished things” quickly creates a new kind of job for people to do. And at some level, computational irreducibility implies that things like this must always happen. There must always be a “frontier”. At least if there’s anything at all we want to preserve (like not going extinct).&lt;/p&gt;
    &lt;p&gt;But let’s come back to the situation here and now with AI. ChatGPT just automated all sorts of text-related tasks. It used to take lots of effort—and people—to write customized reports, letters, etc. But (at least so long as one’s dealing with situations where one doesn’t need 100% “correctness”) ChatGPT just automated a lot of that, so people aren’t needed for it anymore. But what will this mean? Well, it means that there’ll be a lot more customized reports, letters, etc. that can be produced. And that will lead to new kinds of jobs—managing, analyzing, validating etc. all that mass-customized text. Not to mention the need for prompt engineers (a job category that just didn’t exist until a few months ago), and what amount to AI wranglers, AI psychologists, etc.&lt;/p&gt;
    &lt;p&gt;But let’s talk about today’s “frontier” of jobs that haven’t been “automated away”. There’s one category that in many ways seems surprising to still be “with us”: jobs that involve lots of mechanical manipulation, like construction, fulfillment, food preparation, etc. But there’s a missing piece of technology here: there isn’t yet good general-purpose robotics (as there is general-purpose computing), and we humans still have the edge in dexterity, mechanical adaptability, etc. But I’m quite sure that in time—and perhaps quite suddenly—the necessary technology will be developed (and, yes, I have ideas about how to do it). And this will mean that most of today’s “mechanical manipulation” jobs will be “automated away”—and won’t need people to do them.&lt;/p&gt;
    &lt;p&gt;But then, just as in our other examples, this will mean that mechanical manipulation will become much easier and cheaper to do, and more of it will be done. Houses might routinely be built and dismantled. Products might routinely be picked up from wherever they’ve ended up, and redistributed. Vastly more ornate “food constructions” might become the norm. And each of these things—and many more—will open up new jobs.&lt;/p&gt;
    &lt;p&gt;But will every job that exists in the world today “on the frontier” eventually be automated? What about jobs where it seems like a large part of the value is just “having a human be there”? Jobs like flying a plane where one wants the “commitment” of the pilot being there in the plane. Caregiver jobs where one wants the “connection” of a human being there. Sales or education jobs where one wants “human persuasion” or “human encouragement”. Today one might think “only a human can make one feel that way”. But that’s typically based on the way the job is done now. And maybe there’ll be different ways found that allow the essence of the task to be automated, almost inevitably opening up new tasks to be done.&lt;/p&gt;
    &lt;p&gt;For example, something that in the past needed “human persuasion” might be “automated” by something like gamification—but then more of it can be done, with new needs for design, analytics, management, etc.&lt;/p&gt;
    &lt;p&gt;We’ve been talking about “jobs”. And that term immediately brings to mind wages, economics, etc. And, yes, plenty of what people do (at least in the world as it is today) is driven by issues of economics. But plenty is also not. There are things we “just want to do”—as a “social matter”, for “entertainment”, for “personal satisfaction”, etc.&lt;/p&gt;
    &lt;p&gt;Why do we want to do these things? Some of it seems intrinsic to our biological nature. Some of it seems determined by the “cultural environment” in which we find ourselves. Why might one walk on a treadmill? In today’s world one might explain that it’s good for health, lifespan, etc. But a few centuries ago, without modern scientific understanding, and with a different view of the significance of life and death, that explanation really wouldn’t work.&lt;/p&gt;
    &lt;p&gt;What drives such changes in our view of what we “want to do”, or “should do”? Some seems to be driven by the pure “dynamics of society”, presumably with its own computational irreducibility. But some has to do with our ways of interacting with the world—both the increasing automation delivered by the advance of technology, and the increasing abstraction delivered by the advance of knowledge.&lt;/p&gt;
    &lt;p&gt;And there seem to be similar “cycles” seen here as in the kinds of things we consider to be “occupations” or “jobs”. For a while something is hard to do, and serves as a good “pastime”. But then it gets “too easy” (“everybody now knows how to win at game X”, etc.), and something at a “higher level” takes its place.&lt;/p&gt;
    &lt;p&gt;About our “base” biologically driven motivations it doesn’t seem like anything has really changed in the course of human history. But there are certainly technological developments that could have an effect in the future. Effective human immortality, for example, would change many aspects of our motivation structure. As would things like the ability to implant memories or, for that matter, implant motivations.&lt;/p&gt;
    &lt;p&gt;For now, there’s a certain element of what we want to do that’s “anchored” by our biological nature. But at some point we’ll surely be able to emulate with a computer at least the essence of what our brains are doing (and indeed the success of things like ChatGPT makes it seems like the moment when that will happen is closer at hand than we might have thought). And at that point we’ll have the possibility of what amount to “disembodied human souls”.&lt;/p&gt;
    &lt;p&gt;To us today it’s very hard to imagine what the “motivations” of such a “disembodied soul” might be. Looked at “from the outside” we might “see the soul” doing things that “don’t make much sense” to us. But it’s like asking what someone from a thousand years ago would think about many of our activities today. These activities make sense to us today because we’re embedded in our whole “current framework”. But without that framework they don’t make sense. And so it will be for the “disembodied soul”. To us, what it does may not make sense. But to it, with its “current framework”, it will.&lt;/p&gt;
    &lt;p&gt;Could we “learn how to make sense of it”? There’s likely to be a certain barrier of computational irreducibility: in effect the only way to “understand the soul of the future” is to retrace its steps to get to where it is. So from our vantage point today, we’re separated by a certain “irreducible distance”, in effect in rulial space.&lt;/p&gt;
    &lt;p&gt;But could there be some science of the future that will at least tell us general things about how such “souls” behave? Even when there’s computational irreducibility we know that there will always be pockets of computational reducibility—and thus features of behavior that are predictable. But will those features be “interesting”, say from our vantage point today? Maybe some of them will be. Maybe they’ll show us some kind of metapsychology of souls. But inevitably they can only go so far. Because in order for those souls to even experience the passage of time there has to be computational irreducibility. If too much of what happens is too predictable, it’s as if “nothing is happening”—or at least nothing “meaningful”.&lt;/p&gt;
    &lt;p&gt;And, yes, this is all tied up with questions about “free will”. Even when there’s a disembodied soul that’s operating according to some completely deterministic underlying program, computational irreducibility means its behavior can still “seem free”—because nothing can “outrun it” and say what it’s going to be. And the “inner experience” of the disembodied soul can be significant: it’s “intrinsically defining its future”, not just “having its future defined for it”.&lt;/p&gt;
    &lt;p&gt;One might have assumed that once everything is just “visibly operating” as “mere computation” it would necessarily be “soulless” and “meaningless”. But computational irreducibility is what breaks out of this, and what allows there to be something irreducible and “meaningful” achieved. And it’s the same phenomenon whether one’s talking about our life now in the physical universe, or a future “disembodied” computational existence. Or in other words, even if absolutely everything—even our very existence—has been “automated by computation”, that doesn’t mean we can’t have a perfectly good “inner experience” of meaningful existence.&lt;/p&gt;
    &lt;head rend="h2"&gt;Generalized Economics and the Concept of Progress&lt;/head&gt;
    &lt;p&gt;If we look at human history—or, for that matter, the history of life on Earth—there’s a certain pervasive sense that there’s some kind of “progress” happening. But what fundamentally is this “progress”? One can view it as the process of things being done at a progressively “higher level”, so that in effect “more of what’s important” can happen with a given effort. This idea of “going to a higher level” takes many forms—but they’re all fundamentally about eliding details below, and being able to operate purely in terms of the “things one cares about”.&lt;/p&gt;
    &lt;p&gt;In technology, this shows up as automation, in which what used to take lots of detailed steps gets packaged into something that can be done “with the push of a button”. In science—and the intellectual realm in general—it shows up as abstraction, where what used to involve lots of specific details gets packaged into something that can be talked about “purely collectively”. And in biology it shows up as some structure (ribosome, cell, wing, etc.) that can be treated as a “modular unit”.&lt;/p&gt;
    &lt;p&gt;That it’s possible to “do things at a higher level” is a reflection of being able to find “pockets of computational reducibility”. And—as we mentioned above—the fact that (given underlying computational irreducibility) there are necessarily an infinite number of such pockets means that “progress can always go on forever”.&lt;/p&gt;
    &lt;p&gt;When it comes to human affairs we tend to value such progress highly, because (at least for now) we live finite lives, and insofar as we “want more to happen”, “progress” makes that possible. It’s certainly not self-evident that having more happen is “good”; one might just “want a quiet life”. But there is one constraint that in a sense originates from the deep foundations of biology.&lt;/p&gt;
    &lt;p&gt;If something doesn’t exist, then nothing can ever “happen to it”. So in biology, if one’s going to have anything “happen” with organisms, they’d better not be extinct. But the physical environment in which biological organisms exist is finite, with many resources that are finite. And given organisms with finite lives, there’s an inevitability to the process of biological evolution, and to the “competition” for resources between organisms.&lt;/p&gt;
    &lt;p&gt;Will there eventually be an “ultimate winning organism”? Well, no, there can’t be—because of computational irreducibility. There’ll in a sense always be more to explore in the computational universe—more “raw computational material for possible organisms”. And given any “fitness criterion” (like—in a Turing machine analog—“living longer before halting”) there’ll always be a way to “do better” with it.&lt;/p&gt;
    &lt;p&gt;One might still wonder, however, whether perhaps biological evolution—with its underlying process of random genetic mutation—could “get stuck” and never be able to discover some “way to do better”. And indeed simple models of evolution might give one the intuition that this would happen. But actual evolution seems more like deep learning with a large neural net—where one’s effectively operating in an extremely high-dimensional space where there’s typically always a “way to get there from here”, at least given enough time.&lt;/p&gt;
    &lt;p&gt;But, OK, so from our history of biological evolution there’s a certain built-in sense of “competition for scarce resources”. And this sense of competition has (so far) also carried over to human affairs. And indeed it’s the basic driver for most of the processes of economics.&lt;/p&gt;
    &lt;p&gt;But what if resources aren’t “scarce” anymore? What if progress—in the form of automation, or AI—makes it easy to “get anything one wants”? We might imagine robots building everything, AIs figuring everything out, etc. But there are still things that are inevitably scarce. There’s only so much real estate. Only one thing can be “the first ___”. And, in the end, if we have finite lives, we only have so much time.&lt;/p&gt;
    &lt;p&gt;Still, the more efficient—or high level—the things we do (or have) are, the more we’ll be able to get done in the time we have. And it seems as if what we perceive as “economic value” is intimately connected with “making things higher level”. A finished phone is “worth more” than its raw materials. An organization is “worth more” than its separate parts. But what if we could have “infinite automation”? Then in a sense there’d be “infinite economic value everywhere”, and one might imagine there’d be “no competition left”.&lt;/p&gt;
    &lt;p&gt;But once again computational irreducibility stands in the way. Because it tells us there’ll never be “infinite automation”, just as there’ll never be an ultimate winning biological organism. There’ll always be “more to explore” in the computational universe, and different paths to follow.&lt;/p&gt;
    &lt;p&gt;What will this look like in practice? Presumably it’ll lead to all sorts of diversity. So that, for example, a chart of “what the components of an economy are” will become more and more fragmented; it won’t just be “the single winning economic activity is ___”.&lt;/p&gt;
    &lt;p&gt;There is one potential wrinkle in this picture of unending progress. What if nobody cares? What if the innovations and discoveries just don’t matter, say to us humans? And, yes, there is of course plenty in the world that at any given time in history we don’t care about. That piece of silicon we’ve been able to pick out? It’s just part of a rock. Well, until we start making microprocessors out of it.&lt;/p&gt;
    &lt;p&gt;But as we’ve discussed, as soon as we’re “operating at some level of abstraction” computational irreducibility makes it inevitable that we’ll eventually be exposed to things that “require going beyond that level”.&lt;/p&gt;
    &lt;p&gt;But then—critically—there will be choices. There will be different paths to explore (or “mine”) in the computational universe—in the end infinitely many of them. And whatever the computational resources of AIs etc. might be, they’ll never be able to explore all of them. So something—or someone—will have to make a choice of which ones to take.&lt;/p&gt;
    &lt;p&gt;Given a particular set of things one cares about at a particular point, one might successfully be able to automate all of them. But computational irreducibility implies there will always be a “frontier”, where choices have to be made. And there’s no “right answer”; no “theoretically derivable” conclusion. Instead, if we humans are involved, this is where we get to define what’s going to happen.&lt;/p&gt;
    &lt;p&gt;How will we do that? Well, ultimately it’ll be based on our history—biological, cultural, etc. We’ll get to use all that irreducible computation that went into getting us to where we are to define what to do next. In a sense it’ll be something that goes “through us”, and that uses what we are. It’s the place where—even when there’s automation all around—there’s still always something us humans can “meaningfully” do.&lt;/p&gt;
    &lt;head rend="h2"&gt;How Can We Tell the AIs What to Do?&lt;/head&gt;
    &lt;p&gt;Let’s say we want an AI (or any computational system) to do a particular thing. We might think we could just set up its rules (or “program it”) to do that thing. And indeed for certain kinds of tasks that works just fine. But the deeper the use we make of computation, the more we’re going to run into computational irreducibility, and the less we’ll be able to know how to set up particular rules to achieve what we want.&lt;/p&gt;
    &lt;p&gt;And then, of course, there’s the question of defining what “we want” in the first place. Yes, we could have specific rules that say what particular pattern of bits should occur at a particular point in a computation. But that probably won’t have much to do with the kind of overall “human-level” objective that we typically care about. And indeed for any objective we can even reasonably define, we’d better be able to coherently “form a thought” about it. Or, in effect, we’d better have some “human-level narrative” to describe it.&lt;/p&gt;
    &lt;p&gt;But how can we represent such a narrative? Well, we have natural language—probably the single most important innovation in the history of our species. And what natural language fundamentally does is to allow us to talk about things at a “human level”. It’s made of words that we can think of as representing “human-level packets of meaning”. And so, for example, the word “chair” represents the human-level concept of a chair. It’s not referring to some particular arrangement of atoms. Instead, it’s referring to any arrangement of atoms that we can usefully conflate into the single human-level concept of a chair, and from which we can deduce things like the fact that we can expect to sit on it, etc.&lt;/p&gt;
    &lt;p&gt;So, OK, when we’re “talking to an AI” can we expect to just say what we want using natural language? We can definitely get a certain distance—and indeed ChatGPT helps us get further than ever before. But as we try to make things more precise we run into trouble, and the language we need rapidly becomes increasingly ornate, as in the “legalese” of complex legal documents. So what can we do? If we’re going to keep things at the level of “human thoughts” we can’t “reach down” into all the computational details. But yet we want a precise definition of how what we might say can be implemented in terms of those computational details.&lt;/p&gt;
    &lt;p&gt;Well, there’s a way to deal with this, and it’s one that I’ve personally devoted many decades to: it’s the idea of computational language. When we think about programming languages, they’re things that operate solely at the level of computational details, defining in more or less the native terms of a computer what the computer should do. But the point of a true computational language (and, yes, in the world today the Wolfram Language is the sole example) is to do something different: to define a precise way of talking in computational terms about things in the world (whether concretely countries or minerals, or abstractly computational or mathematical structures).&lt;/p&gt;
    &lt;p&gt;Out in the computational universe, there’s immense diversity in the “raw computation” that can happen. But there’s only a thin sliver of it that we humans (at least currently) care about and think about. And we can view computational language as defining a bridge between the things we think about and what’s computationally possible. The functions in our computational language (7000 or so of them in the Wolfram Language) are in effect like words in a human language—but now they have a precise grounding in the “bedrock” of explicit computation. And the point is to design the computational language so it’s convenient for us humans to think and express ourselves in (like a vastly expanded analog of mathematical notation), but so it can also be precisely implemented in practice on a computer.&lt;/p&gt;
    &lt;p&gt;Given a piece of natural language it’s often possible to give a precise, computational interpretation of it—in computational language. And indeed this is exactly what happens in Wolfram|Alpha. Give a piece of natural language and the Wolfram|Alpha NLU system will try to find an interpretation of it as computational language. And from this interpretation, it’s then up to the Wolfram Language to do the computation that’s specified, and give back the results—and potentially synthesize natural language to express them.&lt;/p&gt;
    &lt;p&gt;As a practical matter, this setup is useful not only for humans, but also for AIs—like ChatGPT. Given a system that produces natural language, the Wolfram|Alpha NLU system can “catch” natural language it is “thrown”, and interpret it as computational language that precisely specifies a potentially irreducible computation to do.&lt;/p&gt;
    &lt;p&gt;With both natural language and computational language one’s basically “directly saying what one wants”. But an alternative approach—more aligned with machine learning—is just to give examples, and (implicitly or explicitly) say “follow these”. Inevitably there has to be some underlying model for how to do that following—typically in practice just defined by “what a neural net with a certain architecture will do”. But will the result be “right”? Well, the result will be whatever the neural net gives. But typically we’ll tend to consider it “right” if it’s somehow consistent with what we humans would have concluded. And in practice this often seems to happen, presumably because the actual architecture of our brains is somehow similar enough to the architecture of the neural nets we’re using.&lt;/p&gt;
    &lt;p&gt;But what if we want to “know for sure” what’s going to happen—or, for example, that some particular “mistake” can never be made? Well then we’re presumably thrust back into computational irreducibility, with the result that there’s no way to know, for example, whether a particular set of training examples can lead to a system that’s capable of doing (or not doing) some particular thing.&lt;/p&gt;
    &lt;p&gt;OK, but let’s say we’re setting up some AI system, and we want to make sure it “doesn’t do anything bad”. There are several levels of issues here. The first is to decide what we mean by “anything bad”. And, as we’ll discuss below, that in itself is very hard. But even if we could abstractly figure this out, how should we actually express it? We could give examples—but then the AI will inevitably have to “extrapolate” from them, in ways we can’t predict. Or we could describe what we want in computational language. It might be difficult to cover “every case” (as it is in present-day human laws, or complex contracts). But at least we as humans can read what we’re specifying. Though even in this case, there’s an issue of computational irreducibility: that given the specification it won’t be possible to work out all its consequences.&lt;/p&gt;
    &lt;p&gt;What does all this mean? In essence it’s just a reflection of the fact that as soon as there’s “serious computation” (i.e. irreducible computation) involved, one isn’t going to be immediately able to say what will happen. (And in a sense that’s inevitable, because if one could say, it would mean the computation wasn’t in fact irreducible.) So, yes, we can try to “tell AIs what to do”. But it’ll be like many systems in nature (or, for that matter, people): you can set them on a path, but you can’t know for sure what will happen; you just have to wait and see.&lt;/p&gt;
    &lt;head rend="h2"&gt;A World Run by AIs&lt;/head&gt;
    &lt;p&gt;In the world today, there are already plenty of things that are being done by AIs. And, as we’ve discussed, there’ll surely be more in the future. But who’s “in charge”? Are we telling the AIs what to do, or are they telling us? Today it’s at best a mixture: AIs suggest content for us (for example from the web), and in general make all sorts of recommendations about what we should do. And no doubt in the future those recommendations will be even more extensive and tightly coupled to us: we’ll be recording everything we do, processing it with AI, and continually annotating with recommendations—say through augmented reality—everything we see. And in some sense things might even go beyond “recommendations”. If we have direct neural interfaces, then we might be making our brains just “decide” they want to do things, so that in some sense we become pure “puppets of the AI”.&lt;/p&gt;
    &lt;p&gt;And beyond “personal recommendations” there’s also the question of AIs running the systems we use, or in fact running the whole infrastructure of our civilization. Today we ultimately expect people to make large-scale decisions for our world—often operating in systems of rules defined by laws, and perhaps aided by computation, and even what one might call AI. But there may well come a time when it seems as if AIs could just “do a better job than humans”, say at running a central bank or waging a war.&lt;/p&gt;
    &lt;p&gt;One might ask how one would ever know if the AI would “do a better job”. Well, one could try tests, and run examples. But once again one’s faced with computational irreducibility. Yes, the particular tests one tries might work fine. But one can’t ultimately predict everything that could happen. What will the AI do if there’s suddenly a never-before-seen seismic event? We basically won’t know until it happens.&lt;/p&gt;
    &lt;p&gt;But can we be sure the AI won’t do anything “crazy”? Could we—with some definition of “crazy”—effectively “prove a theorem” that the AI can never do that? For any realistically nontrivial definition of crazy we’ll again run into computational irreducibility—and this won’t be possible.&lt;/p&gt;
    &lt;p&gt;Of course, if we’ve put a person (or even a group of people) “in charge” there’s also no way to “prove” that they won’t do anything “crazy”—and history shows that people in charge quite often have done things that, at least in retrospect, we consider “crazy”. But even though at some level there’s no more certainty about what people will do than about what AIs might do, we still get a certain comfort when people are in charge if we think that “we’re in it together”, and that if something goes wrong those people will also “feel the effects”.&lt;/p&gt;
    &lt;p&gt;But still, it seems inevitable that lots of decisions and actions in the world will be taken directly by AIs. Perhaps it’ll be because this will be cheaper. Perhaps the results (based on tests) will be better. Or perhaps, for example, things will just have to be done too quickly and in numbers too large for us humans to be in the loop.&lt;/p&gt;
    &lt;p&gt;But, OK, if a lot of what happens in our world is happening through AIs, and the AIs are effectively doing irreducible computations, what will this be like? We’ll be in a situation where things are “just happening” and we don’t quite know why. But in a sense we’ve very much been in this situation before. Because it’s what happens all the time in our interaction with nature.&lt;/p&gt;
    &lt;p&gt;Processes in nature—like, for example, the weather—can be thought of as corresponding to computations. And much of the time there’ll be irreducibility in those computations. So we won’t be able to readily predict them. Yes, we can do natural science to figure out some aspects of what’s going to happen. But it’ll inevitably be limited.&lt;/p&gt;
    &lt;p&gt;And so we can expect it to be with the “AI infrastructure” of the world. Things are happening in it—as they are in the weather—that we can’t readily predict. We’ll be able to say some things—though perhaps in ways that are closer to psychology or social science than to traditional exact science. But there’ll be surprises—like maybe some strange AI analog of a hurricane or an ice age. And in the end all we’ll really be able to do is to try to build up our human civilization so that such things “don’t fundamentally matter” to it.&lt;/p&gt;
    &lt;p&gt;In a sense the picture we have is that in time there’ll be a whole “civilization of AIs” operating—like nature—in ways that we can’t readily understand. And like with nature, we’ll coexist with it.&lt;/p&gt;
    &lt;p&gt;But at least at first we might think there’s an important difference between nature and AIs. Because we imagine that we don’t “pick our natural laws”—yet insofar as we’re the ones building the AIs we imagine we can “pick their laws”. But both parts of this aren’t quite right. Because in fact one of the implications of our Physics Project is precisely that the laws of nature that we perceive are the way they are because we are observers who are the way we are. And on the AI side, computational irreducibility implies that we can’t expect to be able to determine the final behavior of the AIs just from knowing the underlying laws we gave them.&lt;/p&gt;
    &lt;p&gt;But what will the “emergent laws” of the AIs be? Well, just like in physics, it’ll depend on how we “sample” the behavior of the AIs. If we look down at the level of individual bits, it’ll be like looking at molecular dynamics (or the behavior of atoms of space). But typically we won’t do this. And just like in physics, we’ll operate as computationally bounded observers—measuring only certain aggregated features of an underlying computationally irreducible process. But what will the “overall laws of AIs” be like? Maybe they’ll show close analogies to physics. Or maybe they’ll seem more like psychological theories (superegos for AIs?). But we can expect them in many ways to be like large-scale laws of nature of the kind we know.&lt;/p&gt;
    &lt;p&gt;Still, there’s one more difference between at least our interaction with nature and with AIs. Because we have in effect been “co-evolving” with nature for billions of years—yet AIs are “new on the scene”. And through our co-evolution with nature we’ve developed all sorts of structural, sensory and cognitive features that allow us to “interact successfully” with nature. But with AIs we don’t have these. So what does this mean?&lt;/p&gt;
    &lt;p&gt;Well, our ways of interacting with nature can be thought of as leveraging pockets of computational reducibility that exist in natural processes—to make things seem at least somewhat predictable to us. But without having found such pockets for AIs, we’re likely to be faced with much more “raw computational irreducibility”—and thus much more unpredictability. It’s been a conceit of modern times that—particularly with the help of science—we’ve been able to make more and more of our world predictable to us, though in practice a large part of what’s led to this is the way we’ve built and controlled the environment in which we live, and the things we choose to do.&lt;/p&gt;
    &lt;p&gt;But for the new “AI world”, we’re effectively starting from scratch. And to make things predictable in that world may be partly a matter of some new science, but perhaps more importantly a matter of choosing how we set up our “way of life” around the AIs there. (And, yes, if there’s lots of unpredictability we may be back to more ancient points of view about the importance of fate—or we may view AIs as a bit like the Olympians of Greek mythology, duking it out among themselves and sometimes having an effect on mortals.)&lt;/p&gt;
    &lt;head rend="h2"&gt;Governance in an AI World&lt;/head&gt;
    &lt;p&gt;Let’s say the world is effectively being run by AIs, but let’s assume that we humans have at least some control over what they do. Then what principles should we have them follow? And what, for example, should their “ethics” be?&lt;/p&gt;
    &lt;p&gt;Well, the first thing to say is that there’s no ultimate, theoretical “right answer” to this. There are many ethical and other principles that AIs could follow. And it’s basically just a choice which ones should be followed.&lt;/p&gt;
    &lt;p&gt;When we talk about “principles” and “ethics” we tend to think more in terms of constraints on behavior than in terms of rules for generating behavior. And that means we’re dealing with something more like mathematical axioms, where we ask things like what theorems are true according to those axioms, and what are not. And that means there can be issues like whether the axioms are consistent—and whether they’re complete, in the sense that they can “determine the ethics of anything”. But now, once again, we’re face to face with computational irreducibility, here in the form of Gödel’s theorem and its generalizations.&lt;/p&gt;
    &lt;p&gt;And what this means is that it’s in general undecidable whether any given set of principles is inconsistent, or incomplete. One might “ask an ethical question”, and find that there’s a “proof chain” of unbounded length to determine what the answer to that question is within one’s specified ethical system, or whether there is even a consistent answer.&lt;/p&gt;
    &lt;p&gt;One might imagine that somehow one could add axioms to “patch up” whatever issues there are. But Gödel’s theorem basically says that it’ll never work. It’s the same story as so often with computational irreducibility: there’ll always be “new situations” that can arise, that in this case can’t be captured by a finite set of axioms.&lt;/p&gt;
    &lt;p&gt;OK, but let’s imagine we’re picking a collection of principles for AIs. What criteria could we use to do it? One might be that these principles won’t inexorably lead to a simple state—like one where the AIs are extinct, or have to keep looping doing the same thing forever. And there may be cases where one can readily see that some set of principles will lead to such outcomes. But most of the time, computational irreducibility (here in the form of things like the halting problem) will once again get in the way, and one won’t be able to tell what will happen, or successfully pick “viable principles” this way.&lt;/p&gt;
    &lt;p&gt;So this means that there are going to be a wide range of principles that we could in theory pick. But presumably what we’ll want is to pick ones that make AIs give us humans some sort of “good time”, whatever that might mean.&lt;/p&gt;
    &lt;p&gt;And a minimal idea might be to get AIs just to observe what we humans do, and then somehow imitate this. But most people wouldn’t consider this the right thing. They’d point out all the “bad” things people do. And they’d perhaps say “let’s have the AIs follow not what we actually do, but what we aspire to do”.&lt;/p&gt;
    &lt;p&gt;But where should we get these aspirations from? Different people, and different cultures, can have very different aspirations—with very different resulting principles. So whose should we pick? And, yes, there are pitifully few—if any—principles that we truly find in common everywhere. (Though, for example, the major religions all tend to share things like respect for human life, the Golden Rule, etc.)&lt;/p&gt;
    &lt;p&gt;But do we in fact have to pick one set of principles? Maybe some AIs can have some principles, and some can have others. Maybe it should be like different countries, or different online communities: different principles for different groups or in different places.&lt;/p&gt;
    &lt;p&gt;Right now that doesn’t seem plausible, because technological and commercial forces have tended to make it seem as if powerful AIs always have to be centralized. But I expect that this is just a feature of the present time, and not something intrinsic to any “human-like” AI.&lt;/p&gt;
    &lt;p&gt;So could everyone (and maybe every organization) have “their own AI” with its own principles? For some purposes this might work OK. But there are many situations where AIs (or people) can’t really act independently, and where there have to be “collective decisions” made.&lt;/p&gt;
    &lt;p&gt;Why is this? In some cases it’s because everyone is in the same physical environment. In other cases it’s because if there’s to be social cohesion—of the kind needed to support even something like a language that’s useful for communication—then there has to be certain conceptual alignment.&lt;/p&gt;
    &lt;p&gt;It’s worth pointing out, though, that at some level having a “collective conclusion” is effectively just a way of introducing certain computational reducibility to make it “easier to see what to do”. And potentially it can be avoided if one has enough computation capability. For example, one might assume that there has to be a collective conclusion about which side of the road cars should drive on. But that wouldn’t be true if every car had the computation capability to just compute a trajectory that would for example optimally weave around other cars using both sides of the road.&lt;/p&gt;
    &lt;p&gt;But if we humans are going to be in the loop, we presumably need a certain amount of computational reducibility to make our world sufficiently comprehensible to us that we can operate in it. So that means there’ll be collective—“societal”—decisions to make. We might want to just tell the AIs to “make everything as good as it can be for us”. But inevitably there will be tradeoffs. Making a collective decision one way might be really good for 99% of people, but really bad for 1%; making it the other way might be pretty good for 60%, but pretty bad for 40%. So what should the AI do?&lt;/p&gt;
    &lt;p&gt;And, of course, this is a classic problem of political philosophy, and there’s no “right answer”. And in reality the setup won’t be as clean as this. It may be fairly easy to work out some immediate effects of different courses of action. But inevitably one will eventually run into computational irreducibility—and “unintended consequences”—and so one won’t be able to say with certainty what the ultimate effects (good or bad) will be.&lt;/p&gt;
    &lt;p&gt;But, OK, so how should one actually make collective decisions? There’s no perfect answer, but in the world today, democracy in one form or another is usually viewed as the best option. So how might AI affect democracy—and perhaps improve on it? Let’s assume first that “humans are still in charge”, so that it’s ultimately their preferences that matter. (And let’s also assume that humans are more or less in their “current form”: unique and unreplicable discrete entities that believe they have independent minds.)&lt;/p&gt;
    &lt;p&gt;The basic setup for current democracy is computationally quite simple: discrete votes (or perhaps rankings) are given (sometimes with weights of various kinds), and then numerical totals are used to determine the winner (or winners). And with past technology this was pretty much all that could be done. But now there are some new elements. Imagine not casting discrete votes, but instead using computational language to write a computational essay to describe one’s preferences. Or imagine having a conversation with a linguistically enabled AI that can draw out and debate one’s preferences, and eventually summarize them in some kind of feature vector. Then imagine feeding computational essays or feature vectors from all “voters” to some AI that “works out the best thing to do”.&lt;/p&gt;
    &lt;p&gt;Well, there are still the same political philosophy issues. It’s not like 60% of people voted for A and 40% for B, so one chose A. It’s much more nuanced. But one still won’t be able to make everyone happy all the time, and one has to have some base principles to know what to do about that.&lt;/p&gt;
    &lt;p&gt;And there’s a higher-order problem in having an AI “rebalance” collective decisions all the time based on everything it knows about people’s detailed preferences (and perhaps their actions too): for many purposes—like us being able to “keep track of what’s going on”—it’s important to maintain consistency over time. But, yes, one could deal with this by having the AI somehow also weigh consistency in figuring out what to do.&lt;/p&gt;
    &lt;p&gt;But while there are no doubt ways in which AI can “tune up” democracy, AI doesn’t seem—in and of itself—to deliver any fundamentally new solution for making collective decisions, and for governance in general.&lt;/p&gt;
    &lt;p&gt;And indeed, in the end things always seem to come down to needing some fundamental set of principles about how one wants things to be. Yes, AIs can be the ones to implement these principles. But there are many possibilities for what the principles could be. And—at least if we humans are “in charge”—we’re the ones who are going to have to come up with them.&lt;/p&gt;
    &lt;p&gt;Or, in other words, we need to come up with some kind of “AI constitution”. Presumably this constitution should basically be written in precise computational language (and, yes, we’re trying to make it possible for the Wolfram Language to be used), but inevitably (as yet another consequence of computational irreducibility) there’ll be “fuzzy” definitions and distinctions, that will rely on things like examples, “interpolated” by systems like neural nets. Maybe when such a constitution is created, there’ll be multiple “renderings” of it, which can all be applied whenever the constitution is used, with some mechanism for picking the “overall conclusion”. (And, yes, there’s potentially a certain “observer-dependent” multicomputational character to this.)&lt;/p&gt;
    &lt;p&gt;But whatever its detailed mechanisms, what should the AI constitution say? Different people and groups of people will definitely come to different conclusions about it. And presumably—just as there are different countries, etc. today with different systems of laws—there’ll be different groups that want to adopt different AI constitutions. (And, yes, the same issues about collective decision making apply again when those AI constitutions have to interact.)&lt;/p&gt;
    &lt;p&gt;But given an AI constitution, one has a base on which AIs can make decisions. And on top of this one imagines a huge network of computational contracts that are autonomously executed, essentially to “run the world”.&lt;/p&gt;
    &lt;p&gt;And this is perhaps one of those classic “what could possibly go wrong?” moments. An AI constitution has been agreed on, and now everything is being run efficiently and autonomously by AIs that are following it. Well, once again, computational irreducibility rears its head. Because however carefully the AI constitution is drafted, computational irreducibility implies that one won’t be able to foresee all its consequences: “unexpected” things will always happen—and some of them will undoubtedly be things “one doesn’t like”.&lt;/p&gt;
    &lt;p&gt;In human legal systems there’s always a mechanism for adding “patches”—filling in laws or precedents that cover new situations that have come up. But if everything is being autonomously run by AIs there’s no room for that. Yes, we as humans might characterize “bad things that happen” as “bugs” that could be fixed by adding a patch. But the AI is just supposed to be operating—essentially axiomatically—according to its constitution, so it has no way to “see that it’s a bug”.&lt;/p&gt;
    &lt;p&gt;Similar to what we discussed above, there’s an interesting analogy here with human law versus natural law. Human law is something we define and can modify. Natural law is something the universe just provides us (notwithstanding the issues about observers discussed above). And by “setting an AI constitution and letting it run” we’re basically forcing ourselves into a situation where the “civilization of the AIs” is some “independent stratum” in the world, that we essentially have to take as it is, and adapt to.&lt;/p&gt;
    &lt;p&gt;Of course, one might wonder if the AI constitution could “automatically evolve”, say based on what’s actually seen to happen in the world. But one quickly returns to the exact same issues of computational irreducibility, where one can’t predict whether the evolution will be “right”, etc.&lt;/p&gt;
    &lt;p&gt;So far, we’ve assumed that in some sense “humans are in charge”. But at some level that’s an issue for the AI constitution to define. It’ll have to define whether AIs have “independent rights”—just like humans (and, in many legal systems, some other entities too). Closely related to the question of independent rights for AIs is whether an AI can be considered autonomously “responsible for its actions”—or whether such responsibility must always ultimately rest with the (presumably human) creator or “programmer” of the AI.&lt;/p&gt;
    &lt;p&gt;Once again, computational irreducibility has something to say. Because it implies that the behavior of the AI can go “irreducibly beyond” what its programmer defined. And in the end (as we discussed above) this is the same basic mechanism that allows us humans to effectively have “free will” even when we’re ultimately operating according to deterministic underlying natural laws. So if we’re going to claim that we humans have free will, and can be “responsible for our actions” (as opposed to having our actions always “dictated by underlying laws”) then we’d better claim the same for AIs.&lt;/p&gt;
    &lt;p&gt;So just as a human builds up something irreducible and irreplaceable in the course of their life, so can an AI. As a practical matter, though, AIs can presumably be backed up, copied, etc.—which isn’t (yet) possible for humans. So somehow their individual instances don’t seem as valuable, even if the “last copy” might still be valuable. As humans, we might want to say “those AIs are something inferior; they shouldn’t have rights”. But things are going to get more entangled. Imagine a bot that no longer has an identifiable owner but that’s successfully befriending people (say on social media), and paying for its underlying operation from donations, ads, etc. Can we reasonably delete that bot? We might argue that “the bot can feel no pain”—but that’s not true of its human friends. But what if the bot starts doing “bad” things? Well, then we’ll need some form of “bot justice”—and pretty soon we’ll find ourselves building a whole human-like legal structure for the AIs.&lt;/p&gt;
    &lt;head rend="h2"&gt;So Will It End Badly?&lt;/head&gt;
    &lt;p&gt;OK, so AIs will learn what they can from us humans, then they’ll fundamentally just be running as autonomous computational systems—much like nature runs as an autonomous computational system—sometimes “interacting with us”. What will they “do to us”? Well, what does nature “do to us”? In a kind of animistic way, we might attribute intentions to nature, but ultimately it’s just “following its rules” and doing what it does. And so it will be with AIs. Yes, we might think we can set things up to determine what the AIs will do. But in the end—insofar as the AIs are really making use of what’s possible in the computational universe—there’ll inevitably be computational irreducibility, and we won’t be able to foresee what will happen, or what consequences it will have.&lt;/p&gt;
    &lt;p&gt;So will the dynamics of AIs in fact have “bad” effects—like, for example, wiping us out? Well, it’s perfectly possible nature could wipe us out too. But one has the feeling that—extraterrestrial “accidents” aside—the natural world around us is at some level enough in some kind of “equilibrium” that nothing too dramatic will happen. But AIs are something new. So maybe they’ll be different.&lt;/p&gt;
    &lt;p&gt;And one possibility might be that AIs could “improve themselves” to produce a single “apex intelligence” that would in a sense dominate everything else. But here we can see computational irreducibility as coming to the rescue. Because it implies that there can never be a “best at everything” computational system. It’s a core result of the emerging field of metabiology: that whatever “achievement” you specify, there’ll always be a computational system somewhere out there in the computational universe that will exceed it. (A simple example is that there’s always a Turing machine that can be found that will exceed any upper bound you specify on the time it takes to halt.)&lt;/p&gt;
    &lt;p&gt;So what this means is that there’ll inevitably be a whole “ecosystem” of AIs—with no single winner. Of course, while that might be an inevitable final outcome, it might not be what happens in the shorter term. And indeed the current tendency to centralize AI systems has a certain danger of AI behavior becoming “unstabilized” relative to what it would be with a whole ecosystem of “AIs in equilibrium”.&lt;/p&gt;
    &lt;p&gt;And in this situation there’s another potential concern as well. We humans are the product of a long struggle for life played out over the course of the history of biological evolution. And insofar as AIs inherit our attributes we might expect them to inherit a certain “drive to win”—perhaps also against us. And perhaps this is where the AI constitution becomes important: to define a “contract” that supersedes what AIs might “naturally” inherit from effectively observing our behavior. Eventually we can expect the AIs to “independently reach equilibrium”. But in the meantime, the AI constitution can help break their connection with our “competitive” history of biological evolution.&lt;/p&gt;
    &lt;head rend="h2"&gt;Preparing for an AI World&lt;/head&gt;
    &lt;p&gt;We’ve talked quite a bit about the ultimate future course of AIs, and their relation to us humans. But what about the short term? How today can we prepare for the growing capabilities and uses of AIs?&lt;/p&gt;
    &lt;p&gt;As has been true throughout history, people who use tools tend to do better than those who don’t. Yes, you can go on doing by direct human effort what has now been successfully automated, but except in rare cases you’ll increasingly be left behind. And what’s now emerging is an extremely powerful combination of tools: neural-net-style AI for “immediate human-like tasks”, along with computational language for deeper access to the computational universe and computational knowledge.&lt;/p&gt;
    &lt;p&gt;So what should people do with this? The highest leverage will come from figuring out new possibilities—things that weren’t possible before but have now “come into range” as a result of new capabilities. And as we discussed above, this is a place where we humans are inevitably central contributors—because we’re the ones who must define what we consider has value for us.&lt;/p&gt;
    &lt;p&gt;So what does this mean for education? What’s worth learning now that so much has been automated? I think the fundamental answer is how to think as broadly and deeply as possible—calling on as much knowledge and as many paradigms as possible, and particularly making use of the computational paradigm, and ways of thinking about things that directly connect with what computation can help with.&lt;/p&gt;
    &lt;p&gt;In the course of human history a lot of knowledge has been accumulated. But as ways of thinking have advanced, it’s become unnecessary to learn directly that knowledge in all its detail: instead one can learn things at a higher level, abstracting out many of the specific details. But in the past few decades something fundamentally new has come on the scene: computers and the things they enable.&lt;/p&gt;
    &lt;p&gt;For the first time in history, it’s become realistic to truly automate intellectual tasks. The leverage this provides is completely unprecedented. And we’re only just starting to come to terms with what it means for what and how we should learn. But with all this new power there’s a tendency to think something must be lost. Surely it must still be worth learning all those intricate details—that people in the past worked so hard to figure out—of how to do some mathematical calculation, even though Mathematica has been able to do it automatically for more than a third of a century?&lt;/p&gt;
    &lt;p&gt;And, yes, at the right time it can be interesting to learn those details. But in the effort to understand and best make use of the intellectual achievements of our civilization, it makes much more sense to leverage the automation we have, and treat those calculations just as “building blocks” that can be put together in “finished form” to do whatever it is we want to do.&lt;/p&gt;
    &lt;p&gt;One might think this kind of leveraging of automation would just be important for “practical purposes”, and for applying knowledge in the real world. But actually—as I have personally found repeatedly to great benefit over the decades—it’s also crucial at a conceptual level. Because it’s only through automation that one can get enough examples and experience that one’s able to develop the intuition needed to reach a higher level of understanding.&lt;/p&gt;
    &lt;p&gt;Confronted with the rapidly growing amount of knowledge in the world there’s been a tremendous tendency to assume that people must inevitably become more and more specialized. But with increasing success in the automation of intellectual tasks—and what we might broadly call AI—it becomes clear there’s an alternative: to make more and more use of this automation, so people can operate at a higher level, “integrating” rather than specializing.&lt;/p&gt;
    &lt;p&gt;And in a sense this is the way to make the best use of our human capabilities: to let us concentrate on setting the “strategy” of what we want to do—delegating the details of how to do it to automated systems that can do it better than us. But, by the way, the very fact that there’s an AI that knows how to do something will no doubt make it easier for humans to learn how to do it too. Because—although we don’t yet have the complete story—it seems inevitable that with modern techniques AIs will be able to successfully “learn how people learn”, and effectively present things an AI “knows” in just the right way for any given person to absorb.&lt;/p&gt;
    &lt;p&gt;So what should people actually learn? Learn how to use tools to do things. But also learn what things are out there to do—and learn facts to anchor how you think about those things. A lot of education today is about answering questions. But for the future—with AI in the picture—what’s likely to be more important is to learn how to ask questions, and how to figure out what questions are worth asking. Or, in effect, how to lay out an “intellectual strategy” for what to do.&lt;/p&gt;
    &lt;p&gt;And to be successful at this, what’s going to be important is breadth of knowledge—and clarity of thinking. And when it comes to clarity of thinking, there’s again something new in modern times: the concept of computational thinking. In the past we’ve had things like logic, and mathematics, as ways to structure thinking. But now we have something new: computation.&lt;/p&gt;
    &lt;p&gt;Does that mean everyone should “learn to program” in some traditional programming language? No. Traditional programming languages are about telling computers what to do in their terms. And, yes, lots of humans do this today. But it’s something that’s fundamentally ripe for direct automation (as examples with ChatGPT already show). And what’s important for the long term is something different. It’s to use the computational paradigm as a structured way to think not about the operation of computers, but about both things in the world and abstract things.&lt;/p&gt;
    &lt;p&gt;And crucial to this is having a computational language: a language for expressing things using the computational paradigm. It’s perfectly possible to express simple “everyday things” in plain, unstructured natural language. But to build any kind of serious “conceptual tower” one needs something more structured. And that’s what computational language is about.&lt;/p&gt;
    &lt;p&gt;One can see a rough historical analog in the development of mathematics and mathematical thinking. Up until about half a millennium ago, mathematics basically had to be expressed in natural language. But then came mathematical notation—and from it a more streamlined approach to mathematical thinking, that eventually made possible all the various mathematical sciences. And it’s now the same kind of thing with computational language and the computational paradigm. Except that it’s a much broader story, in which for basically every field or occupation “X” there’s a “computational X” that’s emerging.&lt;/p&gt;
    &lt;p&gt;In a sense the point of computational language (and all my efforts in the development of the Wolfram Language) is to be able to let people get “as automatically as possible” to computational X—and to let people express themselves using the full power of the computational paradigm.&lt;/p&gt;
    &lt;p&gt;Something like ChatGPT provides “human-like AI” in effect by piecing together existing human material (like billions of words of human-written text). But computational language lets one tap directly into computation—and gives the ability to do fundamentally new things, that immediately leverage our human capabilities for defining intellectual strategy.&lt;/p&gt;
    &lt;p&gt;And, yes, while traditional programming is likely to be largely obsoleted by AI, computational language is something that provides a permanent bridge between human thinking and the computational universe: a channel in which the automation is already done in the very design (and implementation) of the language—leaving in a sense an interface directly suitable for humans to learn, and to use as a basis to extend their thinking.&lt;/p&gt;
    &lt;p&gt;But, OK, what about the future of discovery? Will AIs take over from us humans in, for example, “doing science”? I, for one, have used computation (and many things one might think of as AI) as a tool for scientific discovery for nearly half a century. And, yes, many of my discoveries have in effect been “made by computer”. But science is ultimately about connecting things to human understanding. And so far it’s taken a human to knit what the computer finds into the whole web of human intellectual history.&lt;/p&gt;
    &lt;p&gt;One can certainly imagine, though, that an AI—even one rather like ChatGPT—could be quite successful in taking a “raw computational discovery” and “explaining” how it might relate to existing human knowledge. One could also imagine that the AI would be successful at identifying what aspects of some system in the world could be picked out to describe in some formal way. But—as is typical for the process of modeling in general—a key step is to decide “what one cares about”, and in effect in what direction to go in extending one’s science. And this—like so much else—is inevitably tied into the specifics of the goals we humans set ourselves.&lt;/p&gt;
    &lt;p&gt;In the emerging AI world there are plenty of specific skills that won’t make sense for (most) humans to learn—just as today the advance of automation has obsoleted many skills from the past. But—as we’ve discussed—we can expect there to “be a place” for humans. And what’s most important for us humans to learn is in effect how to pick “where next to go”—and where, out of all the infinite possibilities in the computational universe, we should take human civilization.&lt;/p&gt;
    &lt;head rend="h2"&gt;Afterword: Looking at Some Actual Data&lt;/head&gt;
    &lt;p&gt;OK, so we’ve talked quite a bit about what might happen in the future. But what about actual data from the past? For example, what’s been the actual history of the evolution of jobs? Conveniently, in the US, the Census Bureau has records of people’s occupations going back to 1850. Of course, many job titles have changed since then. Switchmen (on railroads), chainmen (in surveying) and sextons (in churches) aren’t really things anymore. And telemarketers, aircraft pilots and web developers weren’t things in 1850. But with a bit of effort, it’s possible to more or less match things up—at least if one aggregates into large enough categories.&lt;/p&gt;
    &lt;p&gt;So here are pie charts of different job categories at 50-year intervals:&lt;/p&gt;
    &lt;p&gt;And, yes, in 1850 the US was firmly an agricultural economy, with just over half of all jobs being in agriculture. But as agriculture got more efficient—with the introduction of machinery, irrigation, better seeds, fertilizers, etc.—the fraction dropped dramatically, to just a few percent today.&lt;/p&gt;
    &lt;p&gt;After agriculture, the next biggest category back in 1850 was construction (along with other real-estate-related jobs, mainly maintenance). And this is a category that for a century and a half hasn’t changed much in size (at least so far), presumably because, even though there’s been greater automation, this has just allowed buildings to be more complex.&lt;/p&gt;
    &lt;p&gt;Looking at the pie charts above, we can see a clear trend towards greater diversification in jobs (and indeed the same thing is seen in the development of other economies around the world). It’s an old theory in economics that increasing specialization is related to economic growth, but from our point of view here, we might say that the very possibility of a more complex economy, with more niches and jobs, is a reflection of the inevitable presence of computational irreducibility, and the complex web of pockets of computational reducibility that it implies.&lt;/p&gt;
    &lt;p&gt;Beyond the overall distribution of job categories, we can also look at trends in individual categories over time—with each one in a sense providing a certain window onto history:&lt;/p&gt;
    &lt;p&gt;One can definitely see cases where the number of jobs decreases as a result of automation. And this happens not only in areas like agriculture and mining, but also for example in finance (fewer clerks and bank tellers), as well as in sales and retail (online shopping). Sometimes—as in the case of manufacturing—there’s a decrease of jobs partly because of automation, and partly because the jobs move out of the US (mainly to countries with lower labor costs).&lt;/p&gt;
    &lt;p&gt;There are cases—like military jobs—where there are clear “exogenous” effects. And then there are cases like transportation+logistics where there’s a steady increase for more than half a century as technology spreads and infrastructure gets built up—but then things “saturate”, presumably at least partly as a result of increased automation. It’s a somewhat similar story with what I’ve called “technical operations”—with more “tending to technology” needed as technology becomes more widespread.&lt;/p&gt;
    &lt;p&gt;Another clear trend is an increase in job categories associated with the world becoming an “organizationally more complicated place”. Thus we see increases in management, as well as administration, government, finance and sales (which all have recent decreases as a result of computerization). And there’s also a (somewhat recent) increase in legal.&lt;/p&gt;
    &lt;p&gt;Other areas with increases include healthcare, engineering, science and education—where “more is known and there’s more to do” (as well as there being increased organizational complexity). And then there’s entertainment, and food+hospitality, with increases that one might attribute to people leading (and wanting) “more complex lives”. And, of course, there’s information technology which takes off from nothing in the mid-1950s (and which had to be rather awkwardly grafted into the data we’re using here).&lt;/p&gt;
    &lt;p&gt;So what can we conclude? The data seems quite well aligned with what we discussed in more general terms above. Well-developed areas get automated and need to employ fewer people. But technology also opens up new areas, which employ additional people. And—as we might expect from computational irreducibility—things generally get progressively more complicated, with additional knowledge and organizational structure opening up more “frontiers” where people are needed. But even though there are sometimes “sudden inventions”, it still always seems to take decades (or effectively a generation) for there to be any dramatic change in the number of jobs. (The few sharp changes visible in the plots seem mostly to be associated with specific economic events, and—often related—changes in government policies.)&lt;/p&gt;
    &lt;p&gt;But in addition to the different jobs that get done, there’s also the question of how individual people spend their time each day. And—while it certainly doesn’t live up to my own (rather extreme) level of personal analytics—there’s a certain amount of data on this that’s been collected over the years (by getting time diaries from randomly sampled people) in the American Heritage Time Use Study. So here, for example, are plots based on this survey for how the amount of time spent on different broad activities has varied over the decades (the main line shows the mean—in hours—for each activity; the shaded areas indicate successive deciles):&lt;/p&gt;
    &lt;p&gt;And, yes, people are spending more time on “media &amp;amp; computing”, some mixture of watching TV, playing videogames, etc. Housework, at least for women, takes less time, presumably mostly as a result of automation (appliances, etc.). (“Leisure” is basically “hanging out” as well as hobbies and social, cultural, sporting events, etc.; “Civic” includes volunteer, religious, etc. activities.)&lt;/p&gt;
    &lt;p&gt;If one looks specifically at people who are doing paid work&lt;/p&gt;
    &lt;p&gt;one notices several things. First, the average number of hours worked hasn’t changed much in half a century, though the distribution has broadened somewhat. For people doing paid work, media &amp;amp; computing hasn’t increased significantly, at least since the 1980s. One category in which there is systematic increase (though the total time still isn’t very large) is exercise.&lt;/p&gt;
    &lt;p&gt;What about people who—for one reason or another—aren’t doing paid work? Here are corresponding results in this case:&lt;/p&gt;
    &lt;p&gt;Not so much increase in exercise (though the total times are larger to begin with), but now a significant increase in media &amp;amp; computing, with the average recently reaching nearly 6 hours per day for men—perhaps as a reflection of “more of life going online”.&lt;/p&gt;
    &lt;p&gt;But looking at all these results on time use, I think the main conclusion that over the past half century, the ways people (at least in the US) spend their time have remained rather stable—even as we’ve gone from a world with almost no computers to a world in which there are more computers than people.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://writings.stephenwolfram.com/2023/03/will-ais-take-all-our-jobs-and-end-human-history-or-not-well-its-complicated/"/><published>2026-01-28T16:48:48+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=46797868</id><title>Spinning around: Please don't – Common problems with spin locks</title><updated>2026-01-28T21:19:28.275192+00:00</updated><content>&lt;doc fingerprint="3e1474539c305098"&gt;
  &lt;main&gt;
    &lt;head rend="h1"&gt;Intro&lt;/head&gt;
    &lt;p&gt;This is the 3rd project in less than a year where Iâve seen issues with spin-loops. Iâve been dealing with spinning threads for many years now, and I wonât lie: over the years Iâve been both on the offender and victim side.&lt;lb/&gt; Iâm getting tired of seeing the same issues again and again, which usually makes for a good reason to write a blog post so that, hopefully, people will read it and stop making the same mistakes others did.&lt;/p&gt;
    &lt;p&gt;Actually, many others have written about this, covering various issues related to spin locks 1 2 3 4 5 6. But I guess thereâs never enough material on those subjects. Some are about speed, others about fairness, a few about priority inversion, NUMA, and sometimes even about actually broken code.&lt;lb/&gt; If this list hasnât convinced you that things do spin out of control when using spin-locks, and that you should use OS primitives instead, keep reading. Iâll cover what you should not do when implementing your own spin-lock. Notice I said what you should NOT do, because, again, you should probably not use a spin-lock at all these days.&lt;lb/&gt; And if you doâ¦ make sure you really, REALLY, REALLY know what youâre doing (spoiler: it will always come back to bite you when you least expect it).&lt;/p&gt;
    &lt;p&gt;Note this is a story about spin loops in general, not about locking algorithms for which there are many 5.&lt;/p&gt;
    &lt;head rend="h1"&gt;The broken spin-lock&lt;/head&gt;
    &lt;p&gt;Letâs start with the basics, you want to implement your own spinlock.&lt;/p&gt;
    &lt;quote&gt;&lt;p&gt;ð¤ª âItâs easy! You simply have a boolean, a&lt;/p&gt;&lt;code&gt;lock&lt;/code&gt;and an&lt;code&gt;unlock&lt;/code&gt;function.â&lt;/quote&gt;
    &lt;p&gt;Rightâ¦&lt;/p&gt;
    &lt;p&gt;For demonstration purposes, we are using &lt;code&gt;int&lt;/code&gt; instead of &lt;code&gt;bool&lt;/code&gt; as you might have something more complicated to do with it, such as storing metadata (for example: the thread ID). There are also quite a few pieces of code around that do not implement a spin-lock per se, but mutate some other content such as pointers.&lt;/p&gt;
    &lt;code&gt;class BrokenSpinLock
{
    // Using int32_t instead of bool on purpose, don't mind it.
    int32_t isLocked = 0;
public:
    void lock()
    {
        while (isLocked != 0) // (1)
        {
            // Loop again until not locked anymore
        }
                            // (2)
        isLocked = 1;       // (3)
    }                       // (4)

    void unlock()
    {
        isLocked = 0;
    }
};&lt;/code&gt;
    &lt;p&gt;Those who have dealt with multi-threading before will immediately spot the issue. The code is not thread-safe as, if multiple threads attempt to use this lock, we could read invalid values of &lt;code&gt;isLocked&lt;/code&gt; (in theory, and on a CPU where tearing could happen on its word size).
Worse, even if this could not happen, a wild race-condition could appear.&lt;lb/&gt; Consider the following example where two threads would call &lt;code&gt;lock&lt;/code&gt; at the exact same time:&lt;/p&gt;
    &lt;code&gt;(1) ThreadA: Sees `isLocked == 0` | ThreadB: Sees `isLocked == 0` 
(2) ThreadA: Leaves the loop      | ThreadB: Leaves the loop       
(3) ThreadA: Writes 1 to isLocked | ThreadB: Writes 1 to isLocked &lt;/code&gt;
    &lt;p&gt;Now we have two threads who think they have successfully acquired the lock!&lt;/p&gt;
    &lt;p&gt;Some may also have heard about this shiny little thing called &lt;code&gt;atomic&lt;/code&gt; variables/operations.&lt;lb/&gt; To oversimplify: atomic operations guarantee that other threads cannot observe a partial/intermediate state of the operation and thus race-conditions can not occur (on those specific operations and memory).&lt;/p&gt;
    &lt;quote&gt;&lt;p&gt;ð¡ While named after the Greek&lt;/p&gt;&lt;code&gt;atomos&lt;/code&gt;that means âthat which cannot be dividedâ,&lt;code&gt;atomic&lt;/code&gt;operations might as well be as dangerous and difficult to use as nuclear energy.&lt;/quote&gt;
    &lt;p&gt;Letâs replace &lt;code&gt;isLocked&lt;/code&gt; by an atomic version: &lt;code&gt;std::atomic&amp;lt;int&amp;gt;&lt;/code&gt;. Though our code does not suffer from a race-condition on the data itself, we still do not know if the thread that sets &lt;code&gt;isLocked&lt;/code&gt; to &lt;code&gt;1&lt;/code&gt; is the one that now owns the lock. But we can now do an &lt;code&gt;exchange&lt;/code&gt; operation atomically, which solves our little problem!&lt;/p&gt;
    &lt;p&gt;Instead of first checking if the lock is locked, then writing, we actually write our value and get the previous value, in a single atomic operation! If the previous value was &lt;code&gt;0&lt;/code&gt;, then it means weâre the one who actually did the locking. Otherwise we will see a &lt;code&gt;1&lt;/code&gt;, meaning the lock was already held either before we tried, or because another threadâs exchange completed before ours.&lt;/p&gt;
    &lt;code&gt;void lock()
{
    while (isLocked.exchange(1) != 0) {}
}&lt;/code&gt;
    &lt;p&gt;Letâs replay the scenario. Even if both threads execute the exchange simultaneously, atomicity guarantees one will finish before the other, for example Thread Bâs:&lt;/p&gt;
    &lt;code&gt;ThreadA: `isLocked.exchange(1)` | ThreadB: `isLocked.exchange(1)` 
ThreadA: Writes 1, sees 1       | ThreadB: Writes 1, sees 0       
ThreadA: Writes 1, sees 1       | ThreadB: Now owns the lock!
ThreadA: ...                    | ThreadB: ... 
ThreadA: ...                    | ThreadB: `unlock()`, writes 0 
ThreadA: Writes 1, sees 0       | ThreadB: ... 
ThreadA: Now owns the lock!     | ThreadB: ... &lt;/code&gt;
    &lt;p&gt;Good, we now have a working spin-lock, but we still have a long way to go.&lt;/p&gt;
    &lt;quote&gt;
      &lt;p&gt;ð¡ In the CPU lingua, a memory read/write is called a memory load/store&lt;/p&gt;
    &lt;/quote&gt;
    &lt;head rend="h1"&gt;The spin-lock that burned CPUs&lt;/head&gt;
    &lt;p&gt;You may have realized that our spin-lock willâ¦ spin doing nothing, the loop is empty.&lt;/p&gt;
    &lt;quote&gt;
      &lt;p&gt;ð¤ª âGreat, itâll attempt to take ownership fasterâ&lt;/p&gt;
    &lt;/quote&gt;
    &lt;p&gt;Well, thatâs only true if you want to burn your CPU. Since the CPU has no way of knowing that you are waiting and not doing any meaningful work, it might stay at a high frequency. Modern CPUs can change the frequency of the cores to save energy, and effectively also lower the CPU core temperature. This is clearly not desirable behavior, especially on mobile/embedded devices.&lt;/p&gt;
    &lt;p&gt;Not convinced or do not care about the planet? (shame on you!) Then at least think about your usersâ power bill. Still not convinced? What if I told you this can actually be slower than doing something in the loop?&lt;lb/&gt; Imagine that a lot of threads are attempting to lock your spin-lock. Only one can win. But worse, due to its nature you always do memory writes, which need to be synchronized between the different cores of your CPU!&lt;/p&gt;
    &lt;p&gt;From Intelâs Optimization Reference Manual 3 11.4.2:&lt;/p&gt;
    &lt;quote&gt;
      &lt;p&gt;On a modern microprocessor with a superscalar speculative execution engine, a loop like this results in the issue of multiple simultaneous read requests from the spinning thread. These requests usually execute out-of-order with each read request being allocated a buffer resource. On detection of a write by a worker thread to a load that is in progress, the processor must guarantee no violations of memory order occur. The necessity of maintaining the order of outstanding memory operations inevitably costs the processor a severe penalty that impacts all threads.&lt;/p&gt;
    &lt;/quote&gt;
    &lt;p&gt;And the issue will keep getting bigger with recent CPUs that have many cores and sometimes NUMA memory.&lt;/p&gt;
    &lt;quote&gt;
      &lt;p&gt;This penalty occurs on the Intel Core Solo and Intel Core Duo processors. However, the penalty on these processors is small compared with penalties suffered on the Intel Xeon processors. There the performance penalty for exiting the loop is about 25 times more severe.&lt;/p&gt;
    &lt;/quote&gt;
    &lt;p&gt;If you still need some convincingâ¦ this is even worse if you enable SMT (hyperthreading):&lt;/p&gt;
    &lt;quote&gt;
      &lt;p&gt;On a processor supporting Intel HT Technology, spin-wait loops can consume a significant portion of the execution bandwidth of the processor. One logical processor executing a spin-wait loop can severely impact the performance of the other logical processor.&lt;/p&gt;
    &lt;/quote&gt;
    &lt;p&gt;Now that I hopefully have your attention, hereâs how to &lt;del&gt;solve&lt;/del&gt; mitigate the issue:&lt;lb/&gt; The best way to avoid âbotheringâ your neighbours is to &lt;del&gt;avoid spin loops&lt;/del&gt; tell the CPU you are waiting to be notified of a memory change/doing a spinloop! On x86 CPUs, this is done with the &lt;code&gt;PAUSE&lt;/code&gt; instruction. It was designed exactly for this use-case!&lt;/p&gt;
    &lt;quote&gt;&lt;p&gt;The penalty of exiting from a spin-wait loop can be avoided by inserting a&lt;/p&gt;&lt;code&gt;PAUSE&lt;/code&gt;instruction in the loop. In spite of the name, the&lt;code&gt;PAUSE&lt;/code&gt;instruction improves performance by introducing a slight delay in the loop and effectively causing the memory read requests to be issued at a rate that allows immediate detection of any store to the synchronization variable. This prevents the occurrence of a long delay due to memory order violation.&lt;/quote&gt;
    &lt;p&gt;You can modify the code to use this instruction with compiler intrinsics:&lt;/p&gt;
    &lt;code&gt;void cpu_pause()
{
#if defined(__i386__) || defined(__x86_64__) || defined(_M_IX86) || defined(_M_X64)
    _mm_pause();
#elif defined(__arm__) || defined(__aarch64__) || defined(_M_ARM) || defined(_M_ARM64) || defined(_M_ARM64EC)
    __yield();
#else
    #error "unknown instruction set"
#endif
}

void lock()
{
    while (isLocked.exchange(1) != 0)
    {
        cpu_pause();
    }
}&lt;/code&gt;
    &lt;head rend="h1"&gt;The spin-lock that didnât wait enough&lt;/head&gt;
    &lt;p&gt;As already mentioned, the penalty of synchronizing data between CPU cores is getting more expensive as new CPUs get more cores, get multiple core complexes or NUMA architectures. Resolving conflicts (multiple cores trying to do atomic stores) thus needs to be mitigated in some way. A traditional approach is to use a backoff strategy that increases the number of &lt;code&gt;PAUSE&lt;/code&gt; instructions for each attempt at locking.&lt;/p&gt;
    &lt;p&gt;The one you will find most (recommended by the Intel Optimization Manual, 2.7.4), is the exponential backoff:&lt;/p&gt;
    &lt;code&gt;void lock()
{
    const int maxPauses = 64; // MAX_BACKOFF
    int nbPauses = 1;
    while (isLocked.exchange(1) != 0)
    {
        for (int i = 0; i&amp;lt;nbPauses; i++)
            cpu_pause();
        // Multiply the number of pauses by 2 until we reach the max backoff count.
        nbPauses = nbPauses &amp;lt; maxPauses ? nbPauses * 2 : nbPauses;
    }
}&lt;/code&gt;
    &lt;p&gt;As mentioned by Intel:&lt;/p&gt;
    &lt;quote&gt;&lt;p&gt;The number of&lt;/p&gt;&lt;code&gt;PAUSE&lt;/code&gt;instructions are increased by a factor of 2 until some&lt;code&gt;MAX_BACKOFF&lt;/code&gt;is reached which is subject to tuning.&lt;/quote&gt;
    &lt;p&gt;We also mix it with a bit of randomness by using &lt;code&gt;rdtsc&lt;/code&gt;, and letâs refactor the yielding part into a structure that can be easily swapped:&lt;/p&gt;
    &lt;code&gt;struct Yielder
{
    static const int maxPauses = 64; // MAX_BACKOFF
    int nbPauses = 1;
    void do_yield()
    {
        // jitter is in the range of [0;nbPauses-1].
        // We can use bitwise AND since nbPauses is a power of 2.
        const int jitter = static_cast&amp;lt;int&amp;gt;(__rdtsc() &amp;amp; (nbPauses - 1));
        // So subtracting we get a value between [1;nbPauses]
        const int nbPausesThisLoop = nbPauses - jitter;
        for (int i = 0; i &amp;lt; nbPausesThisLoop; i++) 
            cpu_pause();
        // Multiply the number of pauses by 2 until we reach the max backoff count.
        nbPauses = nbPauses &amp;lt; maxPauses ? nbPauses * 2 : nbPauses;
    }
}

void lock()
{
    Yielder yielder;
    while (isLocked.exchange(1) != 0)
    {
        yielder.do_yield();
    }
}&lt;/code&gt;
    &lt;head rend="h1"&gt;The spin-lock that waited too long&lt;/head&gt;
    &lt;p&gt;Remember the comment above about &lt;code&gt;MAX_BACKOFF&lt;/code&gt; being subject to tuning?
Well youâd better make sure to tune it for the exact CPU youâll be working on.&lt;lb/&gt; Letâs have a look at the following table listing the measured7 duration of &lt;code&gt;PAUSE&lt;/code&gt; in cycles:&lt;/p&gt;
    &lt;table&gt;
      &lt;row span="18"&gt;
        &lt;cell role="head"&gt;Sandy Bridge&lt;/cell&gt;
        &lt;cell role="head"&gt;Ivy Bridge&lt;/cell&gt;
        &lt;cell role="head"&gt;Haswell&lt;/cell&gt;
        &lt;cell role="head"&gt;Broadwell&lt;/cell&gt;
        &lt;cell role="head"&gt;Skylake&lt;/cell&gt;
        &lt;cell role="head"&gt;Kaby Lake&lt;/cell&gt;
        &lt;cell role="head"&gt;Coffee Lake&lt;/cell&gt;
        &lt;cell role="head"&gt;Cannon Lake&lt;/cell&gt;
        &lt;cell role="head"&gt;Cascade Lake&lt;/cell&gt;
        &lt;cell role="head"&gt;Ice Lake&lt;/cell&gt;
        &lt;cell role="head"&gt;Rocket Lake&lt;/cell&gt;
        &lt;cell role="head"&gt;Alder Lake-P&lt;/cell&gt;
        &lt;cell role="head"&gt;Tremont&lt;/cell&gt;
        &lt;cell role="head"&gt;Alder Lake-E&lt;/cell&gt;
        &lt;cell role="head"&gt;AMD Zen+&lt;/cell&gt;
        &lt;cell role="head"&gt;AMD Zen2&lt;/cell&gt;
        &lt;cell role="head"&gt;AMD Zen3&lt;/cell&gt;
        &lt;cell role="head"&gt;AMD Zen4&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;cell&gt;11.00&lt;/cell&gt;
        &lt;cell&gt;10.00&lt;/cell&gt;
        &lt;cell&gt;9.00&lt;/cell&gt;
        &lt;cell&gt;9.00&lt;/cell&gt;
        &lt;cell&gt;140.00&lt;/cell&gt;
        &lt;cell&gt;140.00&lt;/cell&gt;
        &lt;cell&gt;152.50&lt;/cell&gt;
        &lt;cell&gt;157.00&lt;/cell&gt;
        &lt;cell&gt;40.00&lt;/cell&gt;
        &lt;cell&gt;138.20&lt;/cell&gt;
        &lt;cell&gt;138.20&lt;/cell&gt;
        &lt;cell&gt;160.17&lt;/cell&gt;
        &lt;cell&gt;176.00&lt;/cell&gt;
        &lt;cell&gt;61.80&lt;/cell&gt;
        &lt;cell&gt;3.00&lt;/cell&gt;
        &lt;cell&gt;65.00&lt;/cell&gt;
        &lt;cell&gt;65.00&lt;/cell&gt;
        &lt;cell&gt;65.00&lt;/cell&gt;
      &lt;/row&gt;
    &lt;/table&gt;
    &lt;p&gt;And thatâs where the issue lies. Depending on the architecture, you may get more than 10x changes in cycles per &lt;code&gt;PAUSE&lt;/code&gt;.&lt;lb/&gt; Old CPUs tended to have small &lt;code&gt;PAUSE&lt;/code&gt; duration of ~10 cycles on Intel, ~3 on AMD, where new architectures have a duration of 100-160 cycles on Intel, and ~60 cycles on AMD.
And this might get worse in the future!&lt;/p&gt;
    &lt;p&gt;This actually is also now part of the latest Intel Optimization Reference Manual 3 2.7.4:&lt;/p&gt;
    &lt;quote&gt;&lt;p&gt;The latency of the&lt;/p&gt;&lt;code&gt;PAUSE&lt;/code&gt;instruction in prior generation microarchitectures is about 10 cycles, whereas in Skylake Client microarchitecture it has been extended to as many as 140 cycles.&lt;/quote&gt;
    &lt;p&gt;How to fix this, you ask? Iâll defer to Intelâs advice again and limit the duration of the &lt;code&gt;PAUSE&lt;/code&gt; loop using CPU cycles instead of a counter:&lt;/p&gt;
    &lt;code&gt;static inline bool before(uint64_t a, uint64_t b)
{
    return ((int64_t)b - (int64_t)a) &amp;gt; 0;
}
void pollDelay(uint32_t clocks)
{
    uint64_t endTime = _rdtsc()+ clocks;
    for (; before(_rdtsc(), endTime); )
        cpu_pause();
}&lt;/code&gt;
    &lt;quote&gt;&lt;p&gt;As the&lt;/p&gt;&lt;code&gt;PAUSE&lt;/code&gt;latency has been increased significantly, workloads that are sensitive to&lt;code&gt;PAUSE&lt;/code&gt;latency will suffer some performance loss.&lt;lb/&gt;[â¦]&lt;lb/&gt;Notice that in the Skylake Client microarchitecture the&lt;code&gt;RDTSC&lt;/code&gt;instruction counts at the machineâs guaranteed P1 frequency independently of the current processor clock (see the INVARIANT TSC property), and therefore, when running in IntelÂ® Turbo-Boost-enabled mode, the delay will remain constant, but the number of instructions that could have been executed will change.&lt;/quote&gt;
    &lt;p&gt;Letâs implement this:&lt;/p&gt;
    &lt;code&gt;struct Yielder
{
    static const int maxPauses = 64; // MAX_BACKOFF
    int nbPauses = 1;
    
    const int maxCycles = /*Some value*/;
    
    void do_yield()
    {
        uint64_t beginTSC = __rdtsc();
        uint64_t endTSC = beginTSC + maxCycles; // Max duration of the yield
        // jitter is in the range of [0;nbPauses-1].
        // We can use bitwise AND since nbPauses is a power of 2.
        const int jitter = static_cast&amp;lt;int&amp;gt;(beginTSC &amp;amp; (nbPauses - 1));
        // So subtracting we get a value between [1;nbPauses]
        const int nbPausesThisLoop = nbPauses - jitter;
        for (int i = 0; i &amp;lt; nbPausesThisLoop &amp;amp;&amp;amp; before(__rdtsc(), endTSC); i++) 
            cpu_pause();
        // Multiply the number of pauses by 2 until we reach the max backoff count.
        nbPauses = nbPauses &amp;lt; maxPauses ? nbPauses * 2 : nbPauses;
    }
}

void lock()
{
    Yielder yield;
    while (isLocked.exchange(1) != 0)
    {
        yield.do_yield();
    }
}&lt;/code&gt;
    &lt;p&gt;This method has two main advantages:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;We define the max duration of a &lt;code&gt;PAUSE&lt;/code&gt;loop in terms of&lt;code&gt;TSC&lt;/code&gt;cycles, which is (on most modern CPUs) independent of the actual frequency of the core or duration of&lt;code&gt;PAUSE&lt;/code&gt;.&lt;/item&gt;
      &lt;item&gt;If the operating system happens to preempt our thread in the middle of the loop, it will stop yielding after being rescheduled if maximum duration has been exceeded. Otherwise we could call &lt;code&gt;PAUSE&lt;/code&gt;more than necessary on a thread wakeup.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Youâll notice that we kept the exponential backoff as a plain counter. This is to avoid having to compute the duration of a single &lt;code&gt;PAUSE&lt;/code&gt; (this would require getting rid of the jitter).
However, we still need to choose a value for &lt;code&gt;maxCycles&lt;/code&gt;. This again is purely empirical and needs tuning, but one may assume the duration of a context switch is about 3Âµs. Depending on the system and actual switch this can be more or be less. But it should be in the same order of magnitude.
We can then estimate the TSC cycles/Âµs conversion to be ~3200cycles/Âµs  for a 3.2Ghz clock. Another common frequency for the TSC is 2.5GHz.
While obviously incorrect, this is a good guesstimate for a default value on PC. At worst, youâll most likely get a 2x difference with the real value, which is way better than the x10 you could get with the varying &lt;code&gt;PAUSE&lt;/code&gt; durations!&lt;/p&gt;
    &lt;p&gt;I did however mention this is a default value, and the best thing to do is to retrieve the real value, either from the OS or by measuring it. Sadly TSC calibration is not officially exposed by Linux/Windows, so the best way is to measure the TSC against the system high resolution clock. Ideally this should be done asynchronously (donât do it on your application main thread at boot, please).&lt;/p&gt;
    &lt;code&gt;// Please, do this asynchronously and not during your main thread init
// Otherwise you will make your application boot longer for nothing!
// Note there are more accurate ways to do this, but we do not need a very high precision nor accuracy.
// You may also split this function in two and do some meaningful amount of work instead of sleeping.
uint64_t MeasureCyclesPerUs()
{
    const auto clockBefore = std::chrono::high_resolution_clock::now();
    const uint64_t cyclesBefore = __rdtsc();
    std::this_thread::sleep_for(std::chrono::microseconds{10});
    const auto clockAfter = std::chrono::high_resolution_clock::now();
    const uint64_t cyclesAfter = __rdtsc();
    const auto clockDelta = clockAfter - clockBefore;
    const uint64_t cyclesDelta = cyclesAfter - cyclesBefore;
    const uint64_t cyclesPerUs = (1000 * cyclesDelta) / std::chrono::nanoseconds(clockDelta).count();
    return cyclesPerUs;
}&lt;/code&gt;
    &lt;quote&gt;&lt;p&gt;ð¡ Windows actually âexposesâ this value as&lt;/p&gt;&lt;code&gt;CyclesPerYield&lt;/code&gt;in the kernel shared data at offset&lt;code&gt;0x2D6&lt;/code&gt;. This is used internally by synchronization primitives to determine how many&lt;code&gt;PAUSE&lt;/code&gt;instructions it should issue. However I wouldnât recommend using those internals unless your code sanitizes the value.&lt;/quote&gt;
    &lt;head rend="h1"&gt;The spin-lock that used too many barriers&lt;/head&gt;
    &lt;p&gt;We only briefly touched the topic of &lt;code&gt;atomics&lt;/code&gt;. All atomic operations actually take an optional parameter which is the memory order.
I donât want to spend too much time on this as entire talks are dedicated to it, and itâs not an easy topic.&lt;/p&gt;
    &lt;p&gt;However do know this: not providing the parameter is equivalent to using &lt;code&gt;std::memory_order_seq_cst&lt;/code&gt; (sequentially consistent) which enforces the most restrictions. On some platforms this may even flush your cache via memory barriers!
Our previous example can actually be re-written using acquire/release semantics:&lt;/p&gt;
    &lt;code&gt;void lock()
{
    Yielder yield;
    while (isLocked.exchange(1, std::memory_order_acquire) != 0)
    {
        yield.do_yield();
    }
}

void unlock()
{
    isLocked.store(0, std::memory_order_release);
}&lt;/code&gt;
    &lt;p&gt;On my x64 machine and exponential backoff:&lt;/p&gt;
    &lt;table&gt;
      &lt;row span="3"&gt;
        &lt;cell role="head"&gt;Lock Type&lt;/cell&gt;
        &lt;cell role="head"&gt;Uncontended (ops/s)&lt;/cell&gt;
        &lt;cell role="head"&gt;Contended (ops/s)&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;ExpBackoff+SeqCst&lt;/cell&gt;
        &lt;cell&gt;313M&lt;/cell&gt;
        &lt;cell&gt;55.3M&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;ExpBackoff+AcqRel&lt;/cell&gt;
        &lt;cell&gt;612M&lt;/cell&gt;
        &lt;cell&gt;58.7M&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;cell&gt;ExpBackoff+Acquire&lt;/cell&gt;
        &lt;cell&gt;652M&lt;/cell&gt;
        &lt;cell&gt;65.3M&lt;/cell&gt;
      &lt;/row&gt;
    &lt;/table&gt;
    &lt;p&gt;You may have a look at the various assemblies generated on this compiler explorer example https://godbolt.org/z/GjEEWPsj8.&lt;/p&gt;
    &lt;head rend="h1"&gt;The spin-lock that saturated the load ports&lt;/head&gt;
    &lt;p&gt;A spin-lock should be fast, otherwise you would just use your average system lock. While we mitigated the inter-core synchronization with the jitter and exponential backoff, there are ways to reduce the cache coherency 8 traffic under contention. This has been mentioned by many in the past 9 10 11 but it doesnât hurt to remind it again. Instead of looping over a Test-And-Set (aka Compare-And-Swap) operation, prefer using both Test and Test-And-Set operations! It also applies to our Load-And-Test (aka Exchange) operation.&lt;/p&gt;
    &lt;p&gt;So instead of:&lt;/p&gt;
    &lt;code&gt;void lock()
{
    Yielder yield;
    while (isLocked.exchange(1, std::memory_order_acquire) != 0)
    {
        yield.do_yield();
    }
}&lt;/code&gt;
    &lt;p&gt;Do:&lt;/p&gt;
    &lt;code&gt;void lock()
{
    Yielder yield;
    // Actually start by an exchange, we assume the lock is not already taken
    // This is because the main use case of a spinlock is when there's no contention!
    while (isLocked.exchange(1, std::memory_order_acquire) != 0)
    {
        // To avoid locking the cache line with a write access, always only read before attempting the writes
        do {
            yield.do_yield(); // Yield while we fail to obtain the lock.
        } while (isLocked.load(std::memory_order_relaxed) != 0);
    }
}&lt;/code&gt;
    &lt;head rend="h1"&gt;The spin-lock that didnât handle priority inversion&lt;/head&gt;
    &lt;p&gt;Priority inversion is one of the worst things that could (and will) happen with a spinlock. And it impacts most severely the platforms that need them the most! (Embedded, real-time OSes, â¦) Letâs have a look at the issue:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;A low-priority thread acquires your spinlock&lt;/item&gt;
      &lt;item&gt;A high-priority thread tries to acquire the lock and starts spinning&lt;/item&gt;
      &lt;item&gt;The OS scheduler preempts the low-priority thread to run another thread with medium/high priority (anything higher than âlowâ)&lt;/item&gt;
      &lt;item&gt;There are no cores left to run the low priority thread as they are all used by higher priority threads.&lt;/item&gt;
      &lt;item&gt;The high-priority thread burns CPU cycles spinning forever.&lt;/item&gt;
    &lt;/list&gt;
    &lt;quote&gt;&lt;p&gt;ð¤ª âLetâs use&lt;/p&gt;&lt;code&gt;std::this_thread::yield()&lt;/code&gt;?â&lt;/quote&gt;
    &lt;p&gt;Meh, did you test it on multiple systems? Iâll play along and give it a try.&lt;/p&gt;
    &lt;code&gt;struct Yielder
{
    void do_yield_expo_and_jitter()
    {
        // Same as before, exponential backoff and jitter
    }

    void do_yield()
    {
        do_yield_expo_and_jitter();
        if (nbPauses &amp;gt;= maxPauses)
        {
            std::this_thread::yield(); // Yield thread back to the OS
            nbPauses = 1;
        }
    }
}&lt;/code&gt;
    &lt;p&gt;Now when we reach the maximum number of iterations, we make the thread yield its quantum to the operating system (&lt;code&gt;SwitchToThread&lt;/code&gt; on Windows, &lt;code&gt;sched_yield&lt;/code&gt; on Linux) so that another thread may be scheduled.
While in practice this may, sometimes, solve the issue as the OS is now free to schedule other threads including the low priority one, this is not mandatory!
Some implementations may end up just rescheduling the thread that just yielded since itâs of higher priority.&lt;/p&gt;
    &lt;p&gt;You may have also seen implementations that use &lt;code&gt;Sleep(0)&lt;/code&gt; on Windows. This is better than &lt;code&gt;SwitchToThread&lt;/code&gt; (which can only yield to a thread ready to run on the current core, per the docs12. Same for normal Linux schedulers13). However this used to14 only yield to threads of same or higher priorities, and still does on the real-time version of the OS! For example on an embedded device, or a console.
The only way to schedule any thread on real-time kernels, be it Windows or Linux, is to sleep for a non-zero durationâ¦ which we obviously would like to avoid!&lt;/p&gt;
    &lt;p&gt;So the solution that the DotNet runtime team came up with is to start with &lt;code&gt;SwitchToThread&lt;/code&gt;, then &lt;code&gt;Sleep(0)&lt;/code&gt; then &lt;code&gt;Sleep(1)&lt;/code&gt;!&lt;/p&gt;
    &lt;code&gt;// We prefer to call Thread.Yield first, triggering a SwitchToThread. This
// unfortunately doesn't consider all runnable threads on all OS SKUs. In
// some cases, it may only consult the runnable threads whose ideal processor
// is the one currently executing code. Thus we occasionally issue a call to
// Sleep(0), which considers all runnable threads at equal priority. Even this
// is insufficient since we may be spin waiting for lower priority threads to
// execute; we therefore must call Sleep(1) once in a while too, which considers
// all runnable threads, regardless of ideal processor and priority, but may
// remove the thread from the scheduler's queue for 10+ms, if the system is
// configured to use the (default) coarse-grained system timer.&lt;/code&gt;
    &lt;head rend="h1"&gt;The spin-locks that woke something unrelated&lt;/head&gt;
    &lt;p&gt;So we dealt with the priority inversion at the cost of potential sleeps.&lt;/p&gt;
    &lt;quote&gt;
      &lt;p&gt;ð¤ª âShip it!â&lt;/p&gt;
    &lt;/quote&gt;
    &lt;p&gt;Please god noâ¦ Yes, you (most likely) avoid the worst case scenario (the livelock), but really, is it fine?&lt;/p&gt;
    &lt;p&gt;Letâs stop for a second here and assume we never did more than yield.&lt;/p&gt;
    &lt;p&gt;As you may have already guessed, a livelock is only half the story (this is starting to be a recurring pattern, isnât it?). The fact is, the issue could happen even if all your threads have the same priority! (Yes, I saw you coming asking for an easy fix by removing priorities.) Consider the following scenario:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;4 cores machine&lt;/item&gt;
      &lt;item&gt;4 high priority threads: A, B, C, D (your thread pool)&lt;/item&gt;
      &lt;item&gt;4 other high priority threads: X, Y, W, Z (controlled by a 3rd party, those suck. Please library writers, donât spawn threads on your own, thank you!).&lt;/item&gt;
      &lt;item&gt;Thread A acquires the lock&lt;/item&gt;
      &lt;item&gt;Threads B, C, D spin, trying to acquire it.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;At this point, we have the following:&lt;/p&gt;
    &lt;table&gt;
      &lt;row span="4"&gt;
        &lt;cell role="head"&gt;Core 0&lt;/cell&gt;
        &lt;cell role="head"&gt;Core 1&lt;/cell&gt;
        &lt;cell role="head"&gt;Core 2&lt;/cell&gt;
        &lt;cell role="head"&gt;Core 3&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;cell&gt;Thread A&lt;/cell&gt;
        &lt;cell&gt;Thread B&lt;/cell&gt;
        &lt;cell&gt;Thread C&lt;/cell&gt;
        &lt;cell&gt;Thread D&lt;/cell&gt;
      &lt;/row&gt;
    &lt;/table&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Thread X gets scheduled (A somehow released its quantum, still holds the lock)&lt;/item&gt;
    &lt;/list&gt;
    &lt;table&gt;
      &lt;row span="4"&gt;
        &lt;cell role="head"&gt;Core 0&lt;/cell&gt;
        &lt;cell role="head"&gt;Core 1&lt;/cell&gt;
        &lt;cell role="head"&gt;Core 2&lt;/cell&gt;
        &lt;cell role="head"&gt;Core 3&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;cell&gt;Thread X&lt;/cell&gt;
        &lt;cell&gt;Thread B&lt;/cell&gt;
        &lt;cell&gt;Thread C&lt;/cell&gt;
        &lt;cell&gt;Thread D&lt;/cell&gt;
      &lt;/row&gt;
    &lt;/table&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Thread B yields, Y is scheduled&lt;/item&gt;
    &lt;/list&gt;
    &lt;table&gt;
      &lt;row span="4"&gt;
        &lt;cell role="head"&gt;Core 0&lt;/cell&gt;
        &lt;cell role="head"&gt;Core 1&lt;/cell&gt;
        &lt;cell role="head"&gt;Core 2&lt;/cell&gt;
        &lt;cell role="head"&gt;Core 3&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;cell&gt;Thread X&lt;/cell&gt;
        &lt;cell&gt;Thread Y&lt;/cell&gt;
        &lt;cell&gt;Thread C&lt;/cell&gt;
        &lt;cell&gt;Thread D&lt;/cell&gt;
      &lt;/row&gt;
    &lt;/table&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Thread Y yields, B is scheduled again, C and D yield to W and Z&lt;/item&gt;
    &lt;/list&gt;
    &lt;table&gt;
      &lt;row span="4"&gt;
        &lt;cell role="head"&gt;Core 0&lt;/cell&gt;
        &lt;cell role="head"&gt;Core 1&lt;/cell&gt;
        &lt;cell role="head"&gt;Core 2&lt;/cell&gt;
        &lt;cell role="head"&gt;Core 3&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;cell&gt;Thread X&lt;/cell&gt;
        &lt;cell&gt;Thread B&lt;/cell&gt;
        &lt;cell&gt;Thread W&lt;/cell&gt;
        &lt;cell&gt;Thread Z&lt;/cell&gt;
      &lt;/row&gt;
    &lt;/table&gt;
    &lt;p&gt;I could continue this for a long time. Even though thread A might get scheduled again, it might not! This depends on your schedulerâs internals. Especially since yielding may yield only to the ready threads of the current core12 13. At the time of writing this article, this actually is a known issue with Address Sanitizer!&lt;/p&gt;
    &lt;p&gt;Oh, and even if it did get scheduled, you probably lost a lot of time switching from one thread to the other, this is your typical lock convoy15 and is what Linus Torvalds more or less hints here4 16 13:&lt;/p&gt;
    &lt;quote&gt;&lt;p&gt;And no, adding random â&lt;/p&gt;&lt;code&gt;sched_yield()&lt;/code&gt;â calls while youâre spinning on the spinlock will not really help. It will easily result in scheduling storms while people are yielding to all the wrong processes.&lt;/quote&gt;
    &lt;p&gt;So no, simply using the same priority for all threads or sleeping is not fine. Letâs see what we can do about it.&lt;/p&gt;
    &lt;head rend="h1"&gt;The spin-lock that spoke to the OS&lt;/head&gt;
    &lt;p&gt;The real problem, when you spin in a loop, is that you expect things to go fast so that your thread may continue.&lt;lb/&gt; But by yielding this way you defeat a lot of the kernel heuristics. It has no way to know what you actually meant, and may schedule anything (or nothing) but threads from your process. Worse, it may degrade your thread priority, move it to lower frequency cores, and you lose any kind of priority boost when waking up due to the lock being releasedâ¦&lt;lb/&gt; Thatâs clearly not what we want. If only there was a way to communicate our intent to the OSâ¦&lt;/p&gt;
    &lt;p&gt;Well thatâs exactly what Linux did when introducing the futex API! Since weâre waiting in a loop for a value to change, just notify the OS about it and let it handle things from there. Windows also implements this with the &lt;code&gt;WaitOnAddress&lt;/code&gt; API, which weâll be demonstrating here:&lt;/p&gt;
    &lt;code&gt;void do_yield(int32_t* address, int32_t comparisonValue, uint32_t timeoutMs)
{
    do_yield_expo_and_jitter();
    if (nbPauses &amp;gt;= maxPauses)
    {
        // The thread will stay asleep while the value at the given address doesn't change and `WakeByAddressSingle`/`WakeByAddressAll` isn't called.
        // We might have a spurious wakeup though, so the value needs to be checked afterward, which we already do since we spin.
        WaitOnAddress(address, &amp;amp;comparisonValue, sizeof(comparisonValue), timeoutMs);
        nbPauses = 1;
    }
}
void lock()
{
    Yielder yield;
    while (isLocked.exchange(1, std::memory_order_acquire) != 0)
    {
        do {
            yield.do_yield(&amp;amp;isLocked, 1 /*while locked*/ , 1 /*ms*/);
        } while (isLocked.load(std::memory_order_relaxed) != 0);
    }
}
void unlock()
{
    isLocked = 0;
    WakeByAddressSingle(&amp;amp;isLocked); // Notify a potential thread waiting, if any.
}&lt;/code&gt;
    &lt;p&gt;Windowsâ &lt;code&gt;WaitOnAddress&lt;/code&gt; internally does a single iteration before issuing the system call, but Linuxâs futex API is a direct syscall. Thatâs why we call &lt;code&gt;WaitOnAddress&lt;/code&gt; only after spinning a bit.&lt;lb/&gt; This lets us have a similar spinning strategy on all platforms, which ensures a more consistent behavior.&lt;/p&gt;
    &lt;quote&gt;&lt;p&gt;ð¡ You may notice that we always end up calling&lt;/p&gt;&lt;code&gt;WakeByAddressSingle&lt;/code&gt;even if thereâs no other thread waiting. While not that slow on Windows, this is slow on Linux since it will do a syscall. To avoid that one would usually store some state such as the number of waiting (parked) threads.&lt;/quote&gt;
    &lt;quote&gt;&lt;p&gt;ð¤ª âWait! Wasnât&lt;/p&gt;&lt;code&gt;std::atomic_wait&lt;/code&gt;added to the standard recently?â&lt;/quote&gt;
    &lt;p&gt;Yes! And this is what one should have used if implementers did the right thing from the get-go (and more importantly did the same thing for each implementation), but this was not the caseâ¦17&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;libc++&lt;/code&gt;(clang) used to do exponential backoff with thread yields before&lt;code&gt;futex&lt;/code&gt;. At least it got fixed in January 2025 but it still does exponential backoff.&lt;/item&gt;
      &lt;item&gt;MSVC STL does the right thingâ¢ imho and goes almost straight to the OS since the first implementation. Good job!&lt;/item&gt;
      &lt;item&gt;So does &lt;code&gt;libstdc++&lt;/code&gt;(GCC)!&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;So if you use it, you may get a built-in exponential backoff, or not. Both implementations actually make sense from an implementerâs point of view (Do you expect &lt;code&gt;std::atomic_wait&lt;/code&gt; users to use it with their own backoff strategies? Or directly as condition variables?), but this difference ends up being problematic since the code behaves differently between implementations.&lt;lb/&gt; In the end, as usual with the &lt;code&gt;std&lt;/code&gt; library, youâre better off using the OS primitives directly if you want portable behaviour that you control.&lt;/p&gt;
    &lt;quote&gt;&lt;p&gt;As mentioned, Windowsâ&lt;/p&gt;&lt;code&gt;WaitOnAddress&lt;/code&gt;will do a single spin before doing a syscall. The duration of&lt;code&gt;PAUSE&lt;/code&gt;is computed on process start by the loader in&lt;code&gt;LdrpInitializeProcess&lt;/code&gt;and stored in&lt;code&gt;ntdll.dll!RtlpWaitOnAddressSpinCycleCount&lt;/code&gt;.&lt;/quote&gt;
    &lt;head rend="h1"&gt;The spin-lock that was unfair&lt;/head&gt;
    &lt;p&gt;An issue with some lock algorithms is that they may be unfair: this is what happens when under contention a thread may never actually grab the ownership of the lock if other threads are faster.&lt;lb/&gt; This time Iâll simply give a warning and ask you to trust me as this article is starting to be lengthy. You may have encountered some âticketâ locks that attempt to enhance the fairness of the lock. While it may look good on paper, itâs actually not so good in practice.&lt;/p&gt;
    &lt;p&gt;Not only is it slower due to its complexity, but as mentioned before only the OS really knows whatâs good for scheduling. And if you want to use a &lt;code&gt;futex&lt;/code&gt;-like API you end up having to wake up all potential waiters instead of just the one you want. So please, rely on the OS primitives for fairness instead. (Even if we didnât have those primitives, a random+exponential backoff may perform better than a ticket lock anyway!)&lt;/p&gt;
    &lt;head rend="h1"&gt;The spin-locks that were falsely sharing&lt;/head&gt;
    &lt;p&gt;Here comes another tidbit of CPU architecture: even if you write to different variables, they may share the same cacheline! And this is really bad for performance when you do atomic operations on the same cacheline, even if the addresses are different. To fix this issue, you may enforce alignment of your variables or use padding in a &lt;code&gt;struct&lt;/code&gt;. False sharing is also known as destructive interference, which led to the standardâs &lt;code&gt;std::hardware_destructive_interference_size&lt;/code&gt; value!&lt;/p&gt;
    &lt;code&gt;alignas(std::hardware_destructive_interference_size) MyLock lock1;
alignas(std::hardware_destructive_interference_size) MyLock lock2;&lt;/code&gt;
    &lt;p&gt;This is however not a silver bullet!&lt;lb/&gt; While you will avoid false sharing, you may also fill your TLB and L1 cache faster which may lead to more cache thrashing.&lt;/p&gt;
    &lt;p&gt;You may even encounter cache bank conflicts. Cache bank conflicts only exist on some CPUs, but donât trust manufacturers to avoid them. From 3.6.1.3 of the Intel Optimization Reference Manual:&lt;/p&gt;
    &lt;quote&gt;
      &lt;item&gt;âIn the Sandy Bridge microarchitecture, the internal organization of the L1D cache may manifest [â¦]â&lt;/item&gt;
      &lt;item&gt;âThe L1D cache bank conflict issue does not apply to Haswell microarchitecture.â&lt;/item&gt;
      &lt;item&gt;âIn the Golden Cove microarchitecture, bank conflicts often happen when multiple loads access [â¦]â&lt;/item&gt;
      &lt;p&gt;ð¡ So this was once an issue, then fixed, then it came back in another form.&lt;/p&gt;
    &lt;/quote&gt;
    &lt;p&gt;These are thankfully mitigated thanks to the random+exponential backoff, but are getting worse (this pattern of âyes, butâ should really annoy you by now, thatâs the whole point of this article).&lt;/p&gt;
    &lt;quote&gt;
      &lt;p&gt;Whenever possible, avoid reading the same memory location within a tight loop or using multiple load operations.&lt;/p&gt;
    &lt;/quote&gt;
    &lt;p&gt;And the only way to really fix that is toâ¦ actually park the thread by calling an OS primitive such as a futex! You should also avoid doing multiple loads per loop, as recommended previously.&lt;/p&gt;
    &lt;head rend="h1"&gt;What about specialized instructions?&lt;/head&gt;
    &lt;quote&gt;&lt;p&gt;ð¤ª âIâve read about&lt;/p&gt;&lt;code&gt;MWAIT&lt;/code&gt;and&lt;code&gt;TPAUSE&lt;/code&gt;.â&lt;/quote&gt;
    &lt;p&gt;And you should probably have read further as those are privileged instructions! But yes they do have the same look as a futex wait/wake, which is very tempting. And, to be fair, AMD does offer a userland alternative which is &lt;code&gt;monitorx&lt;/code&gt; and &lt;code&gt;mwaitx&lt;/code&gt; that we can use!&lt;/p&gt;
    &lt;p&gt;One advantage of &lt;code&gt;mwaitx&lt;/code&gt; is that you can tell the CPU to wait for a given TSC count instead of having to loop! So it can be used to replace the &lt;code&gt;_mm_pause&lt;/code&gt; loop when supported, and thatâs actually what Windowsâ locking primitives such as &lt;code&gt;WaitOnAddress&lt;/code&gt; or &lt;code&gt;AcquireSRWLockExclusive&lt;/code&gt; do internally!
Not only is the âAPIâ easier (you provide a timestamp for the wakeup date) but it can save power! 18 19&lt;lb/&gt; Just do not use it for long periods since you are still delaying potential work from other threads by not explicitly yielding to the OS.&lt;/p&gt;
    &lt;quote&gt;&lt;p&gt;ð¡&lt;/p&gt;&lt;code&gt;mwaitx&lt;/code&gt;can spuriously wake up, but this is fine for our usage since weâll just spin and try again!&lt;/quote&gt;
    &lt;head rend="h1"&gt;Conclusion&lt;/head&gt;
    &lt;p&gt;Youâll notice I barely mentioned ARM, thatâs because I do not have enough experience with this architecture to give any advice other than you should use the proper memory ordering for decent performance.&lt;/p&gt;
    &lt;p&gt;If you read this far, Iâll say it again: in most (and pretty much all) cases you should not even need to worry about the performance of your locks. The best lock is the one you donât use.&lt;/p&gt;
    &lt;p&gt;Again, from Linus: 4&lt;/p&gt;
    &lt;quote&gt;
      &lt;p&gt;Because you should never ever think that youâre clever enough to write your own locking routines.. Because the likelihood is that you arenât (and by that âyouâ I very much include myself - weâve tweaked all the in-kernel locking over decades, and gone through the simple test-and-set to ticket locks to cacheline-efficient queuing locks, and even people who know what they are doing tend to get it wrong several times).&lt;/p&gt;
      &lt;p&gt;Thereâs a reason why you can find decades of academic papers on locking. Really. Itâs hard.&lt;/p&gt;
    &lt;/quote&gt;
    &lt;p&gt;But if you do, even after all those warnings, at least make sure you follow best practices and especially the pre-requisites for a spinlock to be efficient:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;There is low contention&lt;/item&gt;
      &lt;item&gt;The critical section (work done under the lock) is very small. (Consider that âsmallâ varies with the number of threads competing for the lockâ¦)&lt;/item&gt;
      &lt;item&gt;Notify your OS about what youâre doing (&lt;code&gt;futex&lt;/code&gt;,&lt;code&gt;WaitOnAddress&lt;/code&gt;, â¦)&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h1"&gt;Bonus!&lt;/head&gt;
    &lt;p&gt;List of projects/libraries that do (or did) it wrong and that I happened to stumble upon:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;RPMalloc: the one that led to this rant, we had a dependency using it on console, and it caused livelocks. It only loops with a single CPU yield. Bad for perf, impossible (read: will break) to use on embedded platforms with a realtime scheduler.&lt;/item&gt;
      &lt;item&gt;OpenBSDâs libc goes straight to an OS thread &lt;code&gt;yield&lt;/code&gt;&lt;/item&gt;
      &lt;item&gt;Glibc goes straight to &lt;code&gt;futex&lt;/code&gt;by default&lt;list rend="ul"&gt;&lt;item&gt;default mutex is the âsimpleâ one and only checks value once before going straight to the OS&lt;/item&gt;&lt;item&gt;&lt;code&gt;PTHREAD_MUTEX_ADAPTIVE_NP&lt;/code&gt;is mostly good! The number of spins is fixed by default but can be tweaked using the tunable&lt;code&gt;glibc.pthread.mutex_spin_count&lt;/code&gt;&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;Intel TBB: &lt;list rend="ul"&gt;&lt;item&gt;&lt;code&gt;tbb::spinlock&lt;/code&gt;: simple backoff with 16 yields&lt;/item&gt;&lt;item&gt;&lt;code&gt;tbb::mutex&lt;/code&gt;: Pure&lt;code&gt;_mm_pause&lt;/code&gt;backoff with fixed count, then thread yield backoff, then uses a futex wait on linux, or plain semaphore on other platforms&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;Webkit: &lt;list rend="ul"&gt;&lt;item&gt;OS Thread yield (&lt;code&gt;SwitchToThread&lt;/code&gt;/&lt;code&gt;sched_yield&lt;/code&gt;) on CAS failure&lt;/item&gt;&lt;item&gt;Hardcoded spincount&lt;/item&gt;&lt;item&gt;Duplicated here&lt;/item&gt;&lt;item&gt;Same thing here&lt;/item&gt;&lt;item&gt;Even though they have benchmarks (both for speed and fairness)!&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;OS Thread yield (&lt;/item&gt;
      &lt;item&gt;AddressSanitizer (ASAN) &lt;list rend="ul"&gt;&lt;item&gt;The Issue =&amp;gt; can livelock with a realtime scheduler&lt;/item&gt;&lt;item&gt;The Implementation&lt;/item&gt;&lt;item&gt;Yield is done by sched_yield on linux and &lt;code&gt;Sleep(0)&lt;/code&gt;on Windows&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;DotNet runtime still uses &lt;code&gt;Sleep&lt;/code&gt;instead of WaitOnAddress&lt;/item&gt;
      &lt;item&gt;And so many othersâ¦&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h2"&gt;Footnotes&lt;/head&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;
        &lt;p&gt;Measuring Mutexes, Spinlocks and how Bad the Linux Scheduler Really Is - Malte Skarupke â©&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Spinlocks Considered Harmful - matklad â©&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;IntelÂ® 64 and IA-32 Architectures Optimization Reference Manual â© â©2 â©3&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Linus Torvalds on spinlocks (1) - Real World Technologies Forum â© â©2 â©3&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;LockâUnlock: Is That All? A Pragmatic Analysis of Locking in Software Systems - Rachid Guerraoui, Hugo Guiroux, Renaud Lachaize, Vivien QuÃ©ma, Vasileios Trigonakis. ACM Transactions on Computer Systems, 2019, pp.1-149. â© â©2&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Spin Locks Considered Harmful, and How to Write Them When We Must - Intel (via The Wayback Machine) â©&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Cache coherency primer - Fabian Giesen â©&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;AMD Ryzen Processor Software Optimization (GDC 2024) - Ken Mitchell â©&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;AMD RYZENâ¢ Cpu Optimization (GDC 2018) - Ken Mitchell &amp;amp; Elliot Kim â©&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Correctly implementing a spinlock in C++ - Erik Rigtorp â©&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;SwitchToThread docs - Microsoft â© â©2&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Linus Torvalds on spinlocks (3) - Real World Technologies Forum â© â©2 â©3&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Sleeping vs. Yielding - Ken Henderson â©&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;A Complete Guide to Lock Convoys - Dave Kilian â©&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Linus Torvalds on spinlocks (2) - Real World Technologies Forum â©&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Implementing atomic wait and notify - Blat Blatnik â©&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;&lt;p&gt;SpecialKâs commit automating&lt;/p&gt;&lt;code&gt;mwaitx&lt;/code&gt;âs usage - Andon M. Coleman â©&lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;An Analysis of User-space Idle State Instructions on x86 Processors - Malte-Christian Kuns, Hannes TrÃ¶pgen, Robert SchÃ¶ne. ICPE â25: Proceedings of the 16th ACM/SPEC International Conference on Performance Engineering, 2025, pp.232-239. â©&lt;/p&gt;
      &lt;/item&gt;
    &lt;/list&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://www.siliceum.com/en/blog/post/spinning-around/"/><published>2026-01-28T16:48:59+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=46797913</id><title>Amazon One palm authentication discontinued</title><updated>2026-01-28T21:19:28.115972+00:00</updated><link href="https://amazonone.aws.com/help"/><published>2026-01-28T16:52:05+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=46798402</id><title>Mousefood – Build embedded terminal UIs for microcontrollers</title><updated>2026-01-28T21:19:27.931495+00:00</updated><content>&lt;doc fingerprint="8687611f4686e2e8"&gt;
  &lt;main&gt;
    &lt;p&gt;Mousefood - a no-std embedded-graphics backend for Ratatui!&lt;/p&gt;
    &lt;p&gt;Add mousefood as a dependency:&lt;/p&gt;
    &lt;code&gt;cargo add mousefood&lt;/code&gt;
    &lt;p&gt;Exemplary setup:&lt;/p&gt;
    &lt;code&gt;use mousefood::embedded_graphics::{mock_display::MockDisplay, pixelcolor::Rgb888};
use mousefood::prelude::*;
use ratatui::widgets::{Block, Paragraph};
use ratatui::{Frame, Terminal};

fn main() -&amp;gt; Result&amp;lt;(), Box&amp;lt;dyn std::error::Error&amp;gt;&amp;gt; {
    // replace this with your display driver
    // e.g. ILI9341, ST7735, SSD1306, etc.
    let mut display = MockDisplay::&amp;lt;Rgb888&amp;gt;::new();

    let backend = EmbeddedBackend::new(&amp;amp;mut display, EmbeddedBackendConfig::default());
    let mut terminal = Terminal::new(backend)?;

    terminal.draw(draw)?;
    Ok(())
}

fn draw(frame: &amp;amp;mut Frame) {
    let block = Block::bordered().title("Mousefood");
    let paragraph = Paragraph::new("Hello from Mousefood!").block(block);
    frame.render_widget(paragraph, frame.area());
}&lt;/code&gt;
    &lt;p&gt;Embedded-graphics includes bitmap fonts that have a very limited set of characters to save space (ASCII, ISO 8859 or JIS X0201). This makes it impossible to draw most of Ratatui's widgets, which heavily use box-drawing glyphs, Braille, and other special characters.&lt;/p&gt;
    &lt;p&gt;Mousefood by default uses &lt;code&gt;embedded-graphics-unicodefonts&lt;/code&gt;,
which provides embedded-graphics fonts with a much larger set of characters.&lt;/p&gt;
    &lt;p&gt;In order to save space and speed up rendering, the &lt;code&gt;fonts&lt;/code&gt; feature can be disabled by turning off the default crate features.
&lt;code&gt;ibm437&lt;/code&gt; is a good alternative that includes
some drawing characters, but is not as large as embedded-graphics-unicodefonts.&lt;/p&gt;
    &lt;p&gt;Bold and italic modifiers are supported, but this requires providing fonts through &lt;code&gt;EmbeddedBackendConfig&lt;/code&gt;.
If only regular font is provided, it serves as a fallback.
All fonts must be of the same size.&lt;/p&gt;
    &lt;code&gt;use mousefood::embedded_graphics::{mock_display::MockDisplay, pixelcolor::Rgb888};
use mousefood::{EmbeddedBackend, EmbeddedBackendConfig, fonts};
use ratatui::Terminal;

fn main() -&amp;gt; Result&amp;lt;(), Box&amp;lt;dyn std::error::Error&amp;gt;&amp;gt; {
    let mut display = MockDisplay::&amp;lt;Rgb888&amp;gt;::new();
    let config = EmbeddedBackendConfig {
        font_regular: fonts::MONO_6X13,
        font_bold: Some(fonts::MONO_6X13_BOLD),
        font_italic: Some(fonts::MONO_6X13_ITALIC),
        ..Default::default()
    };
    let backend = EmbeddedBackend::new(&amp;amp;mut display, config);
    let _terminal = Terminal::new(backend)?;
    Ok(())
}&lt;/code&gt;
    &lt;p&gt;Colors can be remapped using &lt;code&gt;color_theme&lt;/code&gt; on &lt;code&gt;EmbeddedBackendConfig&lt;/code&gt;.
By default the ANSI palette is used.&lt;/p&gt;
    &lt;code&gt;use mousefood::{ColorTheme, EmbeddedBackend, EmbeddedBackendConfig};
use mousefood::embedded_graphics::{mock_display::MockDisplay, pixelcolor::Rgb888};

fn main() -&amp;gt; Result&amp;lt;(), Box&amp;lt;dyn std::error::Error&amp;gt;&amp;gt; {
    let mut display = MockDisplay::&amp;lt;Rgb888&amp;gt;::new();
    let theme = ColorTheme {
        background: Rgb888::new(5, 5, 5),
        foreground: Rgb888::new(240, 240, 240),
        yellow: Rgb888::new(255, 200, 0),
        ..ColorTheme::ansi()
    };

    let config = EmbeddedBackendConfig {
        color_theme: theme,
        ..Default::default()
    };
    let backend = EmbeddedBackend::new(&amp;amp;mut display, config);
    Ok(())
}&lt;/code&gt;
    &lt;p&gt;Mousefood includes popular color themes that can be used directly:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;ColorTheme::ansi()&lt;/code&gt;- Standard ANSI colors (default)&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;ColorTheme::tokyo_night()&lt;/code&gt;- Tokyo Night dark theme with blue/purple tones&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Mousefood can be run in a simulator using embedded-graphics-simulator crate.&lt;/p&gt;
    &lt;p&gt;Run simulator example:&lt;/p&gt;
    &lt;code&gt;git clone https://github.com/ratatui/mousefood.git
cd mousefood/examples/simulator
cargo run&lt;/code&gt;
    &lt;p&gt;For more details, view the simulator example.&lt;/p&gt;
    &lt;p&gt;Support for EPD (e-ink displays) produced by WeAct Studio (&lt;code&gt;weact-studio-epd&lt;/code&gt; driver) can be enabled using &lt;code&gt;epd-weact&lt;/code&gt; feature.&lt;/p&gt;
    &lt;p&gt;This driver requires some additional configuration. Follow the &lt;code&gt;weact-studio-epd&lt;/code&gt;
crate docs and apply the same &lt;code&gt;flush_callback&lt;/code&gt; pattern used in the Waveshare example below.&lt;/p&gt;
    &lt;head&gt;Setup example&lt;/head&gt;
    &lt;code&gt;use mousefood::prelude::*;
use weact_studio_epd::graphics::Display290BlackWhite;
use weact_studio_epd::WeActStudio290BlackWhiteDriver;

fn main() -&amp;gt; Result&amp;lt;(), Box&amp;lt;dyn std::error::Error&amp;gt;&amp;gt; {
    // Configure SPI + GPIO + delay provider for your board.
    // let (spi_interface, busy, rst, delay) = ...;

    let mut driver = WeActStudio290BlackWhiteDriver::new(spi_interface, busy, rst, delay);
    let mut display = Display290BlackWhite::new();

    driver.init()?;

    let config = EmbeddedBackendConfig {
        flush_callback: Box::new(move |d| {
            driver.full_update(d).expect("epd update failed");
        }),
        ..Default::default()
    };

    let backend = EmbeddedBackend::new(&amp;amp;mut display, config);
    let _terminal = Terminal::new(backend)?;
    Ok(())
}&lt;/code&gt;
    &lt;p&gt;Support for EPD (e-ink displays) produced by Waveshare Electronics (&lt;code&gt;epd-waveshare&lt;/code&gt; driver) can be enabled using &lt;code&gt;epd-waveshare&lt;/code&gt; feature.&lt;/p&gt;
    &lt;head&gt;Setup example&lt;/head&gt;
    &lt;code&gt;use mousefood::prelude::*;
use epd_waveshare::{epd2in9_v2::*, prelude::*};

fn main() -&amp;gt; Result&amp;lt;(), Box&amp;lt;dyn std::error::Error&amp;gt;&amp;gt; {
    // Configure SPI + GPIO + delay provider for your board.
    // let (mut spi_device, busy, dc, rst, mut delay) = ...;

    let mut epd = Epd2in9::new(&amp;amp;mut spi_device, busy, dc, rst, &amp;amp;mut delay, None)?;
    let mut display = Display2in9::default();

    let config = EmbeddedBackendConfig {
        flush_callback: Box::new(move |d| {
            epd.update_and_display_frame(&amp;amp;mut spi_device, d.buffer(), &amp;amp;mut delay)
                .expect("epd update failed");
        }),
        ..Default::default()
    };

    let backend = EmbeddedBackend::new(&amp;amp;mut display, config);
    let _terminal = Terminal::new(backend)?;
    Ok(())
}&lt;/code&gt;
    &lt;p&gt;See the full embedded example at &lt;code&gt;examples/epd-waveshare-demo&lt;/code&gt;.&lt;/p&gt;
    &lt;p&gt;Flash memory on most embedded devices is very limited. Additionally, to achieve high frame rate when using the &lt;code&gt;fonts&lt;/code&gt; feature,
it is recommended to use &lt;code&gt;opt-level = 3&lt;/code&gt;,
which can make the resulting binary even larger.&lt;/p&gt;
    &lt;p&gt;Mousefood is hardware-agnostic. Successfully tested on:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;ESP32 (Xtensa)&lt;/item&gt;
      &lt;item&gt;ESP32-C6 (RISC-V)&lt;/item&gt;
      &lt;item&gt;STM32&lt;/item&gt;
      &lt;item&gt;RP2040&lt;/item&gt;
      &lt;item&gt;RP2350&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Full API docs are available on docs.rs.&lt;/p&gt;
    &lt;p&gt;All contributions are welcome!&lt;/p&gt;
    &lt;p&gt;Before opening a pull request, please read the contributing guidelines.&lt;/p&gt;
    &lt;p&gt;Here are some projects built using Mousefood:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Tuitar - A portable guitar training tool.&lt;/item&gt;
      &lt;item&gt;Mnyaoo32 - An eccentric way to consume IRC messages using ESP32.&lt;/item&gt;
      &lt;item&gt;Phone-OS - A modern phone OS for ESP32 CYD.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Send a pull request to add your project here!&lt;/p&gt;
    &lt;p&gt;Mousefood is dual-licensed under Apache 2.0 and MIT terms.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://github.com/ratatui/mousefood"/><published>2026-01-28T17:20:31+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=46798994</id><title>Computer History Museum Launches Digital Portal to Its Collection</title><updated>2026-01-28T21:19:27.825811+00:00</updated><content>&lt;doc fingerprint="bdf8b7dc9943ebbd"&gt;
  &lt;main&gt;
    &lt;p&gt;Gordon and Betty Moore Foundation Funded OpenCHM to Digitize One-of-a-Kind Archive&lt;/p&gt;
    &lt;p&gt;MOUNTAIN VIEW, Calif. – January 21, 2026 – The Computer History Museum (CHM), a leader in decoding technology—its computing past, digital present, and future impact on humanity—announced the launch of OpenCHM, a new digital portal providing global access to its unparalleled collection.&lt;/p&gt;
    &lt;p&gt;“OpenCHM is designed to inspire discovery, spark curiosity, and make the stories of the digital age more accessible to everyone, everywhere,” said CHM President and CEO Marc Etkind. “We’re unlocking the collection for new audiences to explore.”&lt;/p&gt;
    &lt;p&gt;OpenCHM is funded by the Gordon and Betty Moore Foundation and other generous donors, and this launch represents a major milestone in CHM's multi-year digitization initiative. Designed in collaboration with KeepThinking, the portal is powered by their innovative Qi collection management system.&lt;/p&gt;
    &lt;p&gt;“We were excited by the prospect of CHM opening up their unique collections to broader audiences, from scholars and teachers to students and the public. The balance of the engaging, curated narratives by CHM’s own historians and field experts along with the tools and capabilities to explore one’s own interests makes the platform truly compelling. The Moore Foundation also values the OpenCHM team's commitment to thoughtful design and documentation, which we hope will inspire and enable other organizations to share their collections more openly.”—Janet Coffey, Program Director, Science, Gordon and Betty Moore Foundation&lt;/p&gt;
    &lt;p&gt;The OpenCHM platform expands worldwide access to CHM’s vast collection through a digital portal, and ongoing digitization regularly adds more historical materials. Along with the collection, the portal introduces new digital storytelling and discovery tools designed to bring the history of the technology revolution to life for both experts and general audiences.&lt;/p&gt;
    &lt;p&gt;OpenCHM features include:&lt;/p&gt;
    &lt;p&gt;OpenCHM advances CHM’s mission to preserve and interpret the history of technology while making it broadly accessible as a public resource.&lt;/p&gt;
    &lt;p&gt;About CHM &lt;lb/&gt; The Computer History Museum (CHM) is the leading museum decoding computing’s ongoing impact on our world. We are uniquely positioned to cull the key lessons of the past and—through our research, exhibits, events, and incomparable collection of computing artifacts—create informed digital citizens empowered to make the choices that will shape a better future. &lt;/p&gt;
    &lt;p&gt;Press contact: Carina Sweet, [email protected], 650.810.1059&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://computerhistory.org/press-releases/computer-history-museum-launches-digital-portal-to-its-vast-collection/"/><published>2026-01-28T17:54:54+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=46799304</id><title>That's not how email works</title><updated>2026-01-28T21:19:27.232409+00:00</updated><content>&lt;doc fingerprint="e64f999b3b60becf"&gt;
  &lt;main&gt;
    &lt;p&gt;I have a credit card with HSBC1. It doesn’t see much use2, but I still get a monthly statement from them, and an email to say it’s available.&lt;/p&gt;
    &lt;p&gt;Not long ago I received a letter from them telling me that emails to me were being “returned undelivered” and they needed me to update the email address on my account.&lt;/p&gt;
    &lt;head rend="h2"&gt;“What’s happening?”&lt;/head&gt;
    &lt;p&gt;I logged into my account, per the instructions in the letter, and discovered my correct email address already right there, much to my… lack of surprise3.&lt;/p&gt;
    &lt;p&gt;So I kicked off a live chat via their app, with an agent called Ankitha. Over the course of a drawn-out hour-long conversation, they repeatedly told to tell me how to update my email address (which was never my question). Eventually, when they understood that my email address was already correct, then they concluded the call, saying (emphasis mine):&lt;/p&gt;
    &lt;quote&gt;
      &lt;p&gt;I can understand your frustration, but if the bank has sent the letter, you will have to update the e-mail address.&lt;/p&gt;
    &lt;/quote&gt;
    &lt;p&gt;This is the point at which a normal person would probably just change the email address in their online banking to a “spare” email address.&lt;/p&gt;
    &lt;p&gt;But aside from the fact that I’d rather not4, by this point I’d caught the scent of a deeper underlying issue. After all, didn’t I have a conversation a little like this one but with a different bank, about four years ago?&lt;/p&gt;
    &lt;p&gt;So I called Customer Services directly5, who told me that if my email address is already correct then I can ignore their letter.&lt;/p&gt;
    &lt;p&gt;I suggested that perhaps their letter template might need updating so it doesn’t say “action required” if action is not required. Or that perhaps what they mean to say is “action required: check your email address is correct”.&lt;/p&gt;
    &lt;p&gt;So anyway, apparently everything’s fine… although I reserved final judgement until I’d seen that they were still sending me emails!&lt;/p&gt;
    &lt;head rend="h2"&gt;“Action required”&lt;/head&gt;
    &lt;p&gt;I think I can place a solid guess about what went wrong here. But it makes me feel like we’re living in the Darkest Timeline.&lt;/p&gt;
    &lt;p&gt;I dissected HSBC’s latest email to me: it was of the “your latest statement is available” variety. Deep within the email, down at the bottom, is this code:&lt;/p&gt;
    &lt;p&gt;What you’re seeing are two tracking pixels: tiny 1×1 pixel images, usually transparent or white-on-white to make them even-more invisible, used to surreptitiously track when somebody reads an email. When you open an email from HSBC – potentially every time you open an email from them – your email client connects to those web addresses to get the necessary images. The code at the end of each identifies the email they were contained within, which in turn can be linked back to the recipient.&lt;/p&gt;
    &lt;p&gt;You know how invasive a read-receipt feels? Tracking pixels are like those… but turned up to eleven. While a read-receipt only says “the recipient read this email” (usually only after the recipient gives consent for it to do so), a tracking pixel can often track when and how often you refer to an email6.&lt;/p&gt;
    &lt;p&gt;If I re-read a year-old email from HSBC, they’re saying that they want to know about it.&lt;/p&gt;
    &lt;p&gt; But it gets worse. Because HSBC are using &lt;code&gt;http://&lt;/code&gt;, rather than &lt;code&gt;https://&lt;/code&gt; URLs for their tracking pixels, they’re also saying that every time you read an email
              from them, they’d like everybody on the same network as you to be able to know that you did so, too. If you’re at my house, on my WiFi, and you open an email from HSBC, not
              only might HSBC know about it, but I might know about it too.
            &lt;/p&gt;
    &lt;p&gt;An easily-avoidable security failure there, HSBC… which isn’t the kind of thing one hopes to hear about a bank!&lt;/p&gt;
    &lt;p&gt;But… tracking pixels don’t actually work. At least, they doesn’t work on me. Like many privacy-conscious individuals, my devices are configured to block tracking pixels (and a variety of other instruments of surveillance capitalism) right out of the gate.&lt;/p&gt;
    &lt;p&gt;This means that even though I do read most of the non-spam email that lands in my Inbox, the sender doesn’t get to know that I did so unless I choose to tell them. This is the way that email was designed to work, and is the only way that a sender can be confident that it will work.&lt;/p&gt;
    &lt;p&gt;But we’re in the Darkest Timeline. Tracking pixels have become so endemic that HSBC have clearly come to the opinion that if they can’t track when I open their emails, I must not be receiving their emails. So they wrote me a letter to tell me that my emails have been “returned undelivered” (which seems to be an outright lie).&lt;/p&gt;
    &lt;p&gt;Surveillance capitalism has become so ubiquitous that it’s become transparent. Transparent like the invisible spies at the bottom of your bank’s emails.&lt;/p&gt;
    &lt;p&gt;So in summary, with only a little speculation:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Surveillance capitalism became widespread enough that HSBC came to assume that tracking pixels have bulletproof reliability.&lt;/item&gt;
      &lt;item&gt; HSBC started using tracking pixels them to check whether emails are being received (even though that’s not what they do when they are reliable, which they’re not). &lt;list rend="ul"&gt;&lt;item&gt;(Oh, and their tracking pixels are badly-implemented, if they worked they’d “leak” data to other people on my network7.)&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;Eventually, HSBC assumed their tracking was bulletproof. Because HSBC couldn’t track how often, when, and where I was reading their emails… they posted me a letter to tell me I needed to change my email address.&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h2"&gt;What do I think HSBC should do?&lt;/head&gt;
    &lt;p&gt;Instead of sending me a misleading letter about undelivered emails, perhaps a better approach for HSBC could be:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;At an absolute minimum, stop using unencrypted connections for tracking pixels. I do not want to open a bank email on a cafe’s public WiFi and have everybody in the cafe potentially know who I bank with… and that I just opened an email from them! I certainly don’t want attackers injecting content into the bottom of legitimate emails.&lt;/item&gt;
      &lt;item&gt;Stop assuming that if somebody blocks your attempts to spy on them via your emails, it means they’re not getting your emails. It doesn’t mean that. It’s never meant that. There are all kinds of reasons that your tracking pixels might not work, and they’re not even all privacy-related reasons!&lt;/item&gt;
      &lt;item&gt;Or, better yet: just stop trying to surveil your customers’ email habits in the first place? You already sit on a wealth of personal and financial information which you can, and probably do, data-mine for your own benefit. Can you at least try to pay lip service to your own published principles on the ethical use of data and, if I may quote them, “use only that data which is appropriate for the purpose” and “embed privacy considerations into design and approval processes”.&lt;/item&gt;
      &lt;item&gt;If you need to check that an email address is valid, do that, not an unreliable proxy for it. Instead of this letter, you could have sent an email that said “We need to check that you’re receiving our emails. Please click this link to confirm that you are.” This not only achieves informed consent for your tracking, but it can be more-secure too because you can authenticate the user during the process.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Also, to quote your own principles once more: when you make a mistake like assuming your spying is a flawless way to detect the validity of email addresses, perhaps you should “be transparent with our customers and other stakeholders about how we use their data”.&lt;/p&gt;
    &lt;p&gt;Wouldn’t that be better than writing to a customer to say that their emails are being returned undelivered (when they’re not)… and then having your staff tell them that having received such an email they have no choice but to change the email address they use (which is then disputed by your other staff)?&lt;/p&gt;
    &lt;p&gt;
      &lt;code&gt;&amp;lt;/rant&amp;gt;&lt;/code&gt;
    &lt;/p&gt;
    &lt;head rend="h2"&gt;Footnotes&lt;/head&gt;
    &lt;p&gt;1 You know, the bank with virtue-signalling multiculturalism that we used to joke about.&lt;/p&gt;
    &lt;p&gt;2 Long, long ago I also had a current account with HSBC which I forgot to close when I switched banks… 20 years ago… and I possibly still owe them for the six pence the account was in debt at the time.&lt;/p&gt;
    &lt;p&gt;3 After all, I’d been reading their emails!&lt;/p&gt;
    &lt;p&gt;4 After all, as I’ll stress again: the email address HSBC have for me, and are using, is already correct.&lt;/p&gt;
    &lt;p&gt;5 In future, I’ll just do this in the first instance. The benefits of live chat being able to be done “in the background” while one gets on with some work are totally outweighed when the entire exchange takes an hour only to reach an unsatisfactory conclusion, whereas a telephone call got things sorted (well hopefully…) within 10 minutes.&lt;/p&gt;
    &lt;p&gt;6 A tracking pixel can also collect additional personal information about you, such as your IP address at the time that you opened the email, which might disclose your location.&lt;/p&gt;
    &lt;p&gt;7 It could be even worse still, actually! A sophisticated attacker could “inject” images into the bottom of a HSBC email; those images could, for example, be pictures of text saying things like “You need to urgently call HSBC on [attacker’s phone number].” This would allow a scammer to hijack a legitimate HSBC email by injecting their own content into the bottom of it. Seriously, HSBC, you ought to fix this.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://danq.me/2026/01/28/hsbc-dont-understand-email/"/><published>2026-01-28T18:12:02+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=46799402</id><title>Show HN: I'm building an AI-proof writing tool. How would you defeat it?</title><updated>2026-01-28T21:19:27.125444+00:00</updated><content>&lt;doc fingerprint="be4f40fe35b33ee5"&gt;
  &lt;main&gt;
    &lt;head rend="h1"&gt;Authentic Author&lt;/head&gt;
    &lt;p&gt;A writing tool designed to capture real, human thinking.&lt;/p&gt;
    &lt;p&gt;1&lt;/p&gt;
    &lt;p&gt;You'll be given a writing prompt. Write 1 to 2 paragraphs.&lt;/p&gt;
    &lt;p&gt;2&lt;/p&gt;
    &lt;p&gt;Write your response directly in the editor. No AI assistance allowed.&lt;/p&gt;
    &lt;p&gt;3&lt;/p&gt;
    &lt;p&gt;Pasting and DOM manipulation are disabled to ensure all writing is original.&lt;/p&gt;
    &lt;p&gt;4&lt;/p&gt;
    &lt;p&gt;We track telemetry such as typing speed, pauses, tab changes, and window focus events.&lt;/p&gt;
    &lt;p&gt;5&lt;/p&gt;
    &lt;p&gt;An Authenticity Score is calculated, which attempts to predict the likelihood that the writing is original.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://auth-auth.vercel.app/"/><published>2026-01-28T18:18:16+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=46799898</id><title>Show HN: A MitM proxy to see what your LLM tools are sending</title><updated>2026-01-28T21:19:26.929431+00:00</updated><content>&lt;doc fingerprint="3e57d65e9eab0bca"&gt;
  &lt;main&gt;
    &lt;p&gt;LLM API Traffic Inspector &amp;amp; Token Usage Dashboard&lt;/p&gt;
    &lt;p&gt;Installation • Quick Start • Features • Commands • Contributing&lt;/p&gt;
    &lt;p&gt;Sherlock is a transparent proxy that intercepts HTTPS traffic to LLM APIs and displays real-time token usage in a beautiful terminal dashboard. Track your AI costs, debug prompts, and monitor context window usage across your development session.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Track Token Usage: See exactly how many tokens each request consumes&lt;/item&gt;
      &lt;item&gt;Monitor Context Windows: Visual fuel gauge shows cumulative usage against your limit&lt;/item&gt;
      &lt;item&gt;Debug Prompts: Automatically saves every prompt as markdown and JSON for review&lt;/item&gt;
      &lt;item&gt;Zero Code Changes: Works with any tool that respects proxy environment variables&lt;/item&gt;
    &lt;/list&gt;
    &lt;code&gt;# Clone the repository
git clone https://github.com/yourusername/sherlock.git
cd sherlock

# Install in development mode
pip install -e .&lt;/code&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Python 3.10+&lt;/item&gt;
      &lt;item&gt;Node.js (for intercepting Node.js applications like Claude Code)&lt;/item&gt;
    &lt;/list&gt;
    &lt;code&gt;sherlock&lt;/code&gt;
    &lt;p&gt;On first run, Sherlock will:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Generate the mitmproxy CA certificate&lt;/item&gt;
      &lt;item&gt;Prompt you to install it in your system trust store&lt;/item&gt;
      &lt;item&gt;Ask where to save intercepted prompts&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;In a separate terminal, use Sherlock to proxy your commands:&lt;/p&gt;
    &lt;code&gt;# For Claude Code
sherlock claude

# For any command
sherlock run --node your-llm-tool&lt;/code&gt;
    &lt;p&gt;That's it! Watch the dashboard update in real-time as you interact with LLM APIs.&lt;/p&gt;
    &lt;code&gt;┌─────────────────────────────────────────────────────────────┐
│  🔍 SHERLOCK - LLM Traffic Inspector                        │
├─────────────────────────────────────────────────────────────┤
│  Context Usage  ████████████░░░░░░░░░░░░░░░░  42%           │
│                 (84,231 / 200,000 tokens)                   │
├─────────────────────────────────────────────────────────────┤
│  Time     Provider    Model                      Tokens     │
│  14:23:01 Anthropic   claude-sonnet-4-20250514   12,847     │
│  14:23:45 Anthropic   claude-sonnet-4-20250514   8,234      │
│  14:24:12 Anthropic   claude-sonnet-4-20250514   15,102     │
├─────────────────────────────────────────────────────────────┤
│  Last Prompt: "Can you help me refactor this function..."   │
└─────────────────────────────────────────────────────────────┘
&lt;/code&gt;
    &lt;p&gt;Every intercepted request is saved as:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Markdown - Human-readable format with metadata&lt;/item&gt;
      &lt;item&gt;JSON - Raw API request body for debugging&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Visual progress bar with color-coded warnings:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;🟢 Green: &amp;lt; 50% usage&lt;/item&gt;
      &lt;item&gt;🟡 Yellow: 50-80% usage&lt;/item&gt;
      &lt;item&gt;🔴 Red: &amp;gt; 80% usage&lt;/item&gt;
    &lt;/list&gt;
    &lt;table&gt;
      &lt;row span="2"&gt;
        &lt;cell role="head"&gt;Command&lt;/cell&gt;
        &lt;cell role="head"&gt;Description&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;
          &lt;code&gt;sherlock&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Start the proxy and dashboard&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;
          &lt;code&gt;sherlock start&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Same as above (explicit)&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;
          &lt;code&gt;sherlock claude&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Run Claude Code with proxy configured&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;
          &lt;code&gt;sherlock run &amp;lt;cmd&amp;gt;&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Run any command with proxy configured&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;
          &lt;code&gt;sherlock run --node &amp;lt;cmd&amp;gt;&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Run Node.js app with proxy configured&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;
          &lt;code&gt;sherlock check-certs&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Verify CA certificate installation&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;
          &lt;code&gt;sherlock install-certs&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Show certificate installation instructions&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;cell&gt;
          &lt;code&gt;sherlock env&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Print proxy environment variables&lt;/cell&gt;
      &lt;/row&gt;
    &lt;/table&gt;
    &lt;code&gt;sherlock start [OPTIONS]

Options:
  -p, --port NUM          Proxy port (default: 8080)
  -l, --limit NUM         Token limit for fuel gauge (default: 200000)
  --persist               Save token history across sessions
  --skip-cert-check       Skip certificate verification&lt;/code&gt;
    &lt;code&gt;┌──────────────────────────────────────────────────────────────────┐
│                      Your LLM Application                        │
│              (with proxy environment variables)                  │
└─────────────────────────────┬────────────────────────────────────┘
                              │ HTTPS
                              ▼
┌──────────────────────────────────────────────────────────────────┐
│                     mitmproxy (port 8080)                        │
│                   + Sherlock Interceptor                         │
└─────────────────────────────┬────────────────────────────────────┘
                              │ Parsed events
                              ▼
┌──────────────────────────────────────────────────────────────────┐
│                    Sherlock Dashboard                            │
│              Token tracking • Request log • Prompt preview       │
└──────────────────────────────────────────────────────────────────┘
                              │
                              ▼
                    ~/.sherlock/prompts/
                    ├── 2024-01-15_14-23-01_anthropic.md
                    └── 2024-01-15_14-23-01_anthropic.json
&lt;/code&gt;
    &lt;table&gt;
      &lt;row span="2"&gt;
        &lt;cell role="head"&gt;Provider&lt;/cell&gt;
        &lt;cell role="head"&gt;Status&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;Anthropic (Claude)&lt;/cell&gt;
        &lt;cell&gt;✅ Supported&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;OpenAI&lt;/cell&gt;
        &lt;cell&gt;🔜 Coming soon&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;cell&gt;Google Gemini&lt;/cell&gt;
        &lt;cell&gt;🔜 Coming soon&lt;/cell&gt;
      &lt;/row&gt;
    &lt;/table&gt;
    &lt;p&gt;Sherlock uses mitmproxy to intercept HTTPS traffic. On first run, it will guide you through installing the CA certificate.&lt;/p&gt;
    &lt;p&gt;macOS:&lt;/p&gt;
    &lt;code&gt;sudo security add-trusted-cert -d -r trustRoot \
  -k /Library/Keychains/System.keychain \
  ~/.mitmproxy/mitmproxy-ca-cert.pem&lt;/code&gt;
    &lt;p&gt;Ubuntu/Debian:&lt;/p&gt;
    &lt;code&gt;sudo cp ~/.mitmproxy/mitmproxy-ca-cert.pem \
  /usr/local/share/ca-certificates/mitmproxy-ca-cert.crt
sudo update-ca-certificates&lt;/code&gt;
    &lt;p&gt;For manual proxy configuration:&lt;/p&gt;
    &lt;code&gt;export HTTP_PROXY="http://127.0.0.1:8080"
export HTTPS_PROXY="http://127.0.0.1:8080"
export NODE_EXTRA_CA_CERTS="$HOME/.mitmproxy/mitmproxy-ca-cert.pem"&lt;/code&gt;
    &lt;p&gt;Or use the helper:&lt;/p&gt;
    &lt;code&gt;eval $(sherlock env)&lt;/code&gt;
    &lt;p&gt;Contributions are welcome! Here's how you can help:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Fork the repository&lt;/item&gt;
      &lt;item&gt;Create a feature branch (&lt;code&gt;git checkout -b feature/amazing-feature&lt;/code&gt;)&lt;/item&gt;
      &lt;item&gt;Commit your changes (&lt;code&gt;git commit -m 'Add amazing feature'&lt;/code&gt;)&lt;/item&gt;
      &lt;item&gt;Push to the branch (&lt;code&gt;git push origin feature/amazing-feature&lt;/code&gt;)&lt;/item&gt;
      &lt;item&gt;Open a Pull Request&lt;/item&gt;
    &lt;/list&gt;
    &lt;code&gt;git clone https://github.com/yourusername/sherlock.git
cd sherlock
python -m venv venv
source venv/bin/activate
pip install -e .&lt;/code&gt;
    &lt;p&gt;To add support for a new LLM provider:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Add the API host to &lt;code&gt;sherlock/config.py&lt;/code&gt;&lt;/item&gt;
      &lt;item&gt;Create a parser function in &lt;code&gt;sherlock/parser.py&lt;/code&gt;&lt;/item&gt;
      &lt;item&gt;Update the &lt;code&gt;parse_request()&lt;/code&gt;function to route to your parser&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;This project is licensed under the MIT License - see the LICENSE file for details.&lt;/p&gt;
    &lt;p&gt;See what's really being sent to the LLM. Learn. Optimize. Repeat.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://github.com/jmuncor/sherlock"/><published>2026-01-28T18:52:24+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=46800303</id><title>Trying to craft AI images that are worth displaying to end users</title><updated>2026-01-28T21:19:26.788767+00:00</updated><content>&lt;doc fingerprint="63c91d322d6d611a"&gt;
  &lt;main&gt;
    &lt;head rend="h1"&gt;How to turn 'sfo-jfk' into a beautiful photo&lt;/head&gt;
    &lt;p&gt;or, designing AI apps with a sense of taste&lt;/p&gt;
    &lt;p&gt;How do you turn a freeform query like ‘sfo-jfk’ into a beautiful image?&lt;/p&gt;
    &lt;p&gt;This was a real problem I to solve recently. Whenever our users create a trip, we find a beautiful photo of their destination and present it to them. To do this, we need a system that could understand anything, and respond with a hand-curated photo.&lt;/p&gt;
    &lt;p&gt;To solve this, I used LLMs for understanding, traditional software engineering in the middle, and human curation (by me) of photos by excellent (human) photographers. By walking through this, I hope to provide some inspiration for how to use LLMs in ways that feel crafted and not like slop!&lt;/p&gt;
    &lt;head rend="h2"&gt;The problem&lt;/head&gt;
    &lt;p&gt;I work on Stardrift, an AI travel planning app, and we let people type whatever they want into a chatbox. But then we need to turn that into a beautiful homepage of images for them:&lt;/p&gt;
    &lt;p&gt;Here are some silly ideas for how you could solve this. You could AI-generate an image for each conversation. But AI-generated images suck, and it’s expensive. You could Google search the destination – but that has copyright issues, and some risks:&lt;/p&gt;
    &lt;p&gt;Ultimately, what I wanted to do was hand-curate a beautiful mapping from ‘location’ to ‘destinations’. And I wanted to match a query that could be about literally anything to this.&lt;/p&gt;
    &lt;p&gt;If you break this problem down, there are effectively three problems here:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Take a freeform query (like ‘sfo-&amp;gt;jfk’) and turn it into a ‘place’&lt;/item&gt;
      &lt;item&gt;Build a database of ‘places’ -&amp;gt; pictures&lt;/item&gt;
      &lt;item&gt;Build a software system that can take a ‘place’, look it up in a database and spit out the right picture – even if that ‘place’ isn’t in the database&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;To explain how I built this, I’ll run through each step-by-step.&lt;/p&gt;
    &lt;head rend="h2"&gt;1. What is a place?&lt;/head&gt;
    &lt;p&gt;This was the simplest part of the project, from a technical perspective – and also the trickiest to design.&lt;/p&gt;
    &lt;p&gt;Nowadays, you can easily run a query like ‘SFO-JFK tomorrow’ through an LLM like Haiku and ask it to tell you where they’re going. Which is really cool – 5 years ago, this would have been impossible!&lt;/p&gt;
    &lt;p&gt;However, I had to be careful about what exactly I asked it for. If you think about it, a query like “SFO-JFK” should return “New York.” But “plan me a road-trip around the Isle of Skye” should return a picture of the “Isle of Skye”, not a generic picture of Scotland.&lt;/p&gt;
    &lt;p&gt;To add to the complication, very often our users mention multiple places in one chat — they might be going on a honeymoon trip through France, Germany and Belgium. We need to capture all of this.&lt;/p&gt;
    &lt;p&gt;After thinking a bit, I decided we’d build the system around this idea of a ‘place’. I decided that every query could give us a list of places, and every place would be a combination of a ‘name’ (e.g. New York), and a type of place (e.g. city/region/country).&lt;/p&gt;
    &lt;p&gt;So when the LLM is given “sfo-jfk,” it returns “the city, New York”&lt;code&gt;.&lt;/code&gt; “Plan me a 3-day road trip around the Isle of Skye” will return “Isle of Skye, the region”. And if you ask about multiple places, we return a list. This sounds a bit dry and technical — and it is — but it was important to make the rest work.&lt;/p&gt;
    &lt;p&gt;For the programmers, here’s the base datatype I ended up with:&lt;/p&gt;
    &lt;code&gt;class Place:
  type: Union["region" | "city" | "country"]
  name: str

def query_to_place(query: str) -&amp;gt; list[Place]:
  ...&lt;/code&gt;
    &lt;head rend="h2"&gt;2. Build a mapping of ‘places’ -&amp;gt; pictures&lt;/head&gt;
    &lt;p&gt;Now that I had a definition of a ‘place’ defined, I could start creating my database of pictures.&lt;/p&gt;
    &lt;p&gt;This part was the most fun. I ran this new function I’d written to map queries to places on a sample of real Stardrift queries, which gave me a list of places ranked by popularity.&lt;/p&gt;
    &lt;p&gt;Then I wrote a little game.&lt;/p&gt;
    &lt;p&gt;We source pictures from Unsplash, a fantastic photography bank. Unsplash has an API, so I wrote an internal tool that went through this ranked list of locations and pulled the top 5 images from Unsplash. This let me pick the best one, and it would be saved into a database:&lt;/p&gt;
    &lt;p&gt;Because of some API restrictions, I could only do about 20 places per hour. So while it only took me an afternoon to code the rest of the system, it took about 3 days to populate the database with the first 500 places, done mostly in 5-minute chunks every hour. But it was worth it – the game was very fun, and the mapping we produced is beautiful!&lt;/p&gt;
    &lt;head rend="h2"&gt;3. Putting it together&lt;/head&gt;
    &lt;p&gt;Now I could turn a conversation into a ‘place’, and had a database mapping ‘places’ to beautiful photos.&lt;/p&gt;
    &lt;p&gt;But our users could ask about anything, and our LLM would simply pass on whatever it said. To add insult to injury, our LLM wasn’t very precise — sometimes it would tell us the user was going to ‘NYC’, sometimes ‘New York’, sometime ‘New York City’. So how I meant to handle places that didn’t have an entry in the database?&lt;/p&gt;
    &lt;p&gt;Well, thanks to Google Maps, it’s very easy to turn any place name into latitude/longitude coordinates. So whenever we got weird input, we could turn it into a coordinate. And then we could ask: what’s the closest place that we do have in the database?&lt;/p&gt;
    &lt;p&gt;For instance, we might get a place like ‘Deadvlei.’ I have no idea where that is. But our geolocation API tells us it’s at (24.7° S, 15.2° E), so we can lookup to the closest coordinate that’s in the database, which is (24.8° S, 15.3° E). Then we can return the nearest one: in this case, Namibia:&lt;/p&gt;
    &lt;p&gt;This mostly works, but it does mean there are a few places that don’t properly show up! One of the last tools I built was a little map that showed us where we have photos, so I could see where we had gaps. It turned out we were missing a lot of Africa and South America — they are not common travel destinations. So I manually filled them in.&lt;/p&gt;
    &lt;p&gt;We have missed places since — recently someone tried to search ‘Mongolia,’ which we didn’t have. When this happens, it sets off an alert to us, and then I manually go in and backfill it. It works well enough.&lt;/p&gt;
    &lt;head rend="h2"&gt;Final thoughts&lt;/head&gt;
    &lt;p&gt;There are some flaws to this system: for instance, we have a lot of cities mapped but not a lot of regions, so you might search for ‘The Gold Coast’ and get a photo of Brisbane instead. And everything is subject to my taste—my team recently made fun of me for always picking golden hour photos. (Wait, maybe that’s a feature...)&lt;/p&gt;
    &lt;p&gt;But I like it as a small but tasteful AI project. The best AI products don’t use AI for everything; they use it for what it’s good at. And that’s exactly what we did here, mixing software engineering, AI engineering and a bit of good old human curation.&lt;/p&gt;
    &lt;p&gt;This is a cross-post from the Stardrift technical blog! Shoutout to Sarah Chieng and swyx for hosting the Write &amp;amp; Learn meetup where I wrote this.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://www.approachwithalacrity.com/how-to-turn-sfo-jfk-into-a-beautiful-photo/"/><published>2026-01-28T19:24:35+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=46800484</id><title>Show HN: Cursor for Userscripts</title><updated>2026-01-28T21:19:26.602540+00:00</updated><content>&lt;doc fingerprint="8c54d8f36db9feee"&gt;
  &lt;main&gt;
    &lt;p&gt;A coding agent for userscripts with its own loader.&lt;/p&gt;
    &lt;p&gt;Browser Code is a browser extension that gives Claude a virtual filesystem view of web pages. It generates, edits, and manages userscripts that persist to &lt;code&gt;chrome.userScripts&lt;/code&gt; (the same API that Tampermonkey uses) and auto-run on matching URLs.&lt;/p&gt;
    &lt;p&gt;Think Claude Code, but for the DOM.&lt;/p&gt;
    &lt;head class="px-3 py-2"&gt;demo.mp4&lt;/head&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Agent sees the page as a filesystem - The DOM becomes &lt;code&gt;page.html&lt;/code&gt;, console output is&lt;code&gt;console.log&lt;/code&gt;, and you can create scripts in&lt;code&gt;./scripts/&lt;/code&gt;and styles in&lt;code&gt;./styles/&lt;/code&gt;&lt;/item&gt;
      &lt;item&gt;Scripts persist via userScripts API - Saved scripts register with Chrome's &lt;code&gt;userScripts&lt;/code&gt;API (Chrome 120+) or Firefox's equivalent, bypassing CSP restrictions&lt;/item&gt;
      &lt;item&gt;Auto-runs on matching URLs - Scripts execute on page load for their saved URL patterns, including dynamic routes like &lt;code&gt;/products/[id]&lt;/code&gt;&lt;/item&gt;
    &lt;/list&gt;
    &lt;code&gt;┌─────────────────────────────────────────────────────────────────┐
│                     Browser Extension                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │              Background Service Worker                    │  │
│  │  • Claude API client (agentic loop)                       │  │
│  │  • userScripts registration &amp;amp; CSP bypass                  │  │
│  │  • Conversation history per tab                           │  │
│  │  • VFS storage coordination                               │  │
│  └──────────────────────────────────────────────────────────┘   │
│                              ↕                                  │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │                   Content Script                          │  │
│  │  • Virtual Filesystem (VFS) implementation                │  │
│  │  • DOM ↔ HTML serialization with version tracking         │  │
│  │  • Script execution in MAIN world                         │  │
│  │  • Console interception                                   │  │
│  └──────────────────────────────────────────────────────────┘   │
│                              ↕                                  │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │                   Sidebar Panel (React)                   │  │
│  │  • Chat UI with tool call visualization                   │  │
│  │  • Plan/Execute mode toggle                               │  │
│  │  • File browser &amp;amp; local sync                              │  │
│  └──────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
&lt;/code&gt;
    &lt;p&gt;Every website is presented as a virtual filesystem:&lt;/p&gt;
    &lt;code&gt;/{domain}/{url-path}/
├── page.html           # Live DOM (read/edit triggers mutations)
├── console.log         # Captured console output (read-only)
├── screenshot.png      # On-demand page capture
├── plan.md             # Agent's plan (plan mode)
├── scripts/
│   ├── my-script.js    # Your scripts (persisted, auto-run)
│   └── _auto_edits.js  # Generated from DOM edits
└── styles/
    └── custom.css      # Your styles (persisted, auto-injected)
&lt;/code&gt;
    &lt;p&gt;Files have version numbers for optimistic concurrency control. The agent must read a file before editing, and provide the version from the read. If the DOM changed (user scrolled, JS mutated it), the edit fails with a version mismatch - forcing a re-read.&lt;/p&gt;
    &lt;p&gt;This prevents the agent from making changes based on stale data when editing a live page.&lt;/p&gt;
    &lt;p&gt;Scripts saved to paths like &lt;code&gt;/products/[id]&lt;/code&gt; or &lt;code&gt;/docs/[...slug]&lt;/code&gt; match dynamically:&lt;/p&gt;
    &lt;table&gt;
      &lt;row span="3"&gt;
        &lt;cell role="head"&gt;Pattern&lt;/cell&gt;
        &lt;cell role="head"&gt;Matches&lt;/cell&gt;
        &lt;cell role="head"&gt;
          &lt;code&gt;window.__routeParams&lt;/code&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;
          &lt;code&gt;/products/[id]&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;
          &lt;code&gt;/products/123&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;
          &lt;code&gt;{ id: "123" }&lt;/code&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;
          &lt;code&gt;/users/[userId]/posts/[postId]&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;
          &lt;code&gt;/users/5/posts/42&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;
          &lt;code&gt;{ userId: "5", postId: "42" }&lt;/code&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;cell&gt;
          &lt;code&gt;/docs/[...path]&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;
          &lt;code&gt;/docs/api/auth/oauth&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;
          &lt;code&gt;{ path: ["api", "auth", "oauth"] }&lt;/code&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
    &lt;/table&gt;
    &lt;p&gt;Route params are injected into &lt;code&gt;window.__routeParams&lt;/code&gt; before your script runs.&lt;/p&gt;
    &lt;p&gt;Browser Code uses a two-phase workflow for safety:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Plan Mode (default) - Agent explores the page, reads files, proposes changes to &lt;code&gt;plan.md&lt;/code&gt;. Cannot mutate DOM or write scripts.&lt;/item&gt;
      &lt;item&gt;Execute Mode - After user approval, agent executes the plan. Can write files, edit DOM, run scripts.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;This prevents the agent from making unintended changes while exploring.&lt;/p&gt;
    &lt;p&gt;Sync your userscripts bidirectionally with your local filesystem:&lt;/p&gt;
    &lt;table&gt;
      &lt;row span="4"&gt;
        &lt;cell role="head"&gt;Browser&lt;/cell&gt;
        &lt;cell role="head"&gt;Read&lt;/cell&gt;
        &lt;cell role="head"&gt;Write&lt;/cell&gt;
        &lt;cell role="head"&gt;API Used&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;Chrome&lt;/cell&gt;
        &lt;cell&gt;✓&lt;/cell&gt;
        &lt;cell&gt;✓&lt;/cell&gt;
        &lt;cell&gt;File System Access API&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;cell&gt;Firefox&lt;/cell&gt;
        &lt;cell&gt;-&lt;/cell&gt;
        &lt;cell&gt;✓ (export)&lt;/cell&gt;
        &lt;cell&gt;Downloads API&lt;/cell&gt;
      &lt;/row&gt;
    &lt;/table&gt;
    &lt;p&gt;Chrome: Select a directory once, then edits sync both ways. Edit in VS Code, see changes in browser.&lt;/p&gt;
    &lt;p&gt;Firefox: Export-only via Downloads API. Scripts download to your configured directory.&lt;/p&gt;
    &lt;p&gt;Conflict resolution: newest wins, or choose per-conflict.&lt;/p&gt;
    &lt;p&gt;The agent has filesystem-like tools:&lt;/p&gt;
    &lt;table&gt;
      &lt;row span="2"&gt;
        &lt;cell role="head"&gt;Tool&lt;/cell&gt;
        &lt;cell role="head"&gt;Description&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;Read&lt;/cell&gt;
        &lt;cell&gt;Read file content. Returns content + version for conflict detection.&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;Edit&lt;/cell&gt;
        &lt;cell&gt;Find-and-replace in a file. Requires version from last Read.&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;Write&lt;/cell&gt;
        &lt;cell&gt;Write entire file. Use version 0 for new files.&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;Glob&lt;/cell&gt;
        &lt;cell&gt;Find files matching a pattern (&lt;code&gt;./scripts/*.js&lt;/code&gt;).&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;Grep&lt;/cell&gt;
        &lt;cell&gt;Search for regex in files. Returns matches with context.&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;Bash&lt;/cell&gt;
        &lt;cell&gt;Execute a script file (&lt;code&gt;./scripts/foo.js&lt;/code&gt;) or inline JS.&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;Ls&lt;/cell&gt;
        &lt;cell&gt;List directory contents.&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;Screenshot&lt;/cell&gt;
        &lt;cell&gt;Capture current viewport.&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;cell&gt;Todo&lt;/cell&gt;
        &lt;cell&gt;Manage task list for multi-step operations.&lt;/cell&gt;
      &lt;/row&gt;
    &lt;/table&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Build the extension (see below) or download a release&lt;/item&gt;
      &lt;item&gt;Go to &lt;code&gt;chrome://extensions&lt;/code&gt;&lt;/item&gt;
      &lt;item&gt;Enable Developer mode&lt;/item&gt;
      &lt;item&gt;Click Load unpacked → select &lt;code&gt;.output/chrome-mv3/&lt;/code&gt;&lt;/item&gt;
      &lt;item&gt;Click extension Details → enable User scripts permission (required for CSP bypass)&lt;/item&gt;
    &lt;/list&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Build the extension (see below)&lt;/item&gt;
      &lt;item&gt;Go to &lt;code&gt;about:debugging#/runtime/this-firefox&lt;/code&gt;&lt;/item&gt;
      &lt;item&gt;Click Load Temporary Add-on → select any file in &lt;code&gt;.output/firefox-mv2/&lt;/code&gt;&lt;/item&gt;
    &lt;/list&gt;
    &lt;code&gt;bun install

# Development
bun run dev           # Chrome
bun run dev:firefox   # Firefox

# Production
bun run build         # Both browsers
bun run zip           # Create distribution zips&lt;/code&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;CSP bypass requires permission: Sites like LinkedIn have strict CSP. Chrome's userScripts API bypasses this, but you must enable the "User scripts" permission in extension settings.&lt;/item&gt;
      &lt;item&gt;Trusted Types: Some sites sanitize innerHTML. Scripts may need to use DOM APIs (&lt;code&gt;createElement&lt;/code&gt;) instead.&lt;/item&gt;
      &lt;item&gt;Firefox sync is export-only: No File System Access API in Firefox, so sync is one-way via Downloads.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Storage: VFS data stored in &lt;code&gt;browser.storage.local&lt;/code&gt; keyed by &lt;code&gt;vfs:{domain}&lt;/code&gt;. Each domain has paths → scripts/styles.&lt;/p&gt;
    &lt;p&gt;Script Registration: On storage change, background script re-registers all scripts via &lt;code&gt;chrome.userScripts.register()&lt;/code&gt; with match patterns derived from VFS paths.&lt;/p&gt;
    &lt;p&gt;CSP Bypass: userScripts API configures a custom world with permissive CSP: &lt;code&gt;script-src 'self' 'unsafe-inline' 'unsafe-eval'&lt;/code&gt;.&lt;/p&gt;
    &lt;p&gt;DOM Serialization: &lt;code&gt;page.html&lt;/code&gt; reads serialize the full document. Writes diff against current DOM and apply minimal mutations.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://github.com/chebykinn/browser-code"/><published>2026-01-28T19:39:31+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=46800623</id><title>Who sets the Doomsday Clock?</title><updated>2026-01-28T21:19:26.346694+00:00</updated><content>&lt;doc fingerprint="77819165e9a446be"&gt;
  &lt;main&gt;
    &lt;quote&gt;Editor’s note: On January 27, 2026, the Bulletin of the Atomic Scientists announced that the clock is now set at 85 seconds to midnight, the closest it has ever been.&lt;/quote&gt;
    &lt;p&gt;On a warm day in mid-July, a roomful of Nobel laureates and nuclear security experts, some 80 pairs of eyes, gaze out of the expansive windows of a 10th floor University of Chicago conference room, imagining their deaths by nuclear explosion. A presenter directs the group’s attention past the trees and gothic buildings of campus, over the apartment buildings in Hyde Park, and out to the Chicago skyline, hazy with wildfire smoke from Canada. He points out which neighborhoods would vanish in blasts of varying size, estimating casualties, injuries, and radiation effects.&lt;/p&gt;
    &lt;p&gt;What I know, what everyone there knows, is that if a nuclear bomb were to explode right then, right over us, it would be better to be inside that room, in the zone of vaporization, than in an outer ring of slow, painful death.&lt;/p&gt;
    &lt;p&gt;It’s the opening session of the three-day 2025 Nobel Laureate Assembly for the Prevention of Nuclear War. The gathering is convened by scientists and nuclear security experts alarmed that a new arms race, eroding global cooperation, and the rise of artificial intelligence in warfare—among other factors—are pushing civilization closer to catastrophe. Timed to the 80th anniversary of the Trinity Test, the world’s first nuclear explosion, the assembly aims to produce a declaration urging world leaders to reduce the nuclear threat.&lt;/p&gt;
    &lt;p&gt;The same urgency drives the Bulletin of Atomic Scientists and its iconic Doomsday Clock, the stark graphic that represents how close we are to self-annihilation. The clock is set yearly by the Bulletin’s Science and Security Board chaired by Daniel Holz, PhD, a theoretical astrophysicist at the University of Chicago.&lt;/p&gt;
    &lt;p&gt;In January, six months before the Nobel Assembly, Holz stood at a lectern at the United States Institute of Peace in Washington, D.C., to announce the time. “It is now 89 seconds to midnight,” he said, as four solemn presenters swiveled a turntable to reveal a pared-down quarter clockface, a white wedge rimmed by black dots for numbers, the hands angled so sharply they overlapped. It was the closest to midnight since the clock’s inception in 1947.&lt;/p&gt;
    &lt;p&gt;Now Holz and several other clock setters are at the Nobel Assembly here in Chicago. The Bulletin is one of the sponsoring organizations, and Holz has spent the past year helping to plan the event, hoping that the voices of Nobel laureates and nuclear experts will move the world to act.&lt;/p&gt;
    &lt;p&gt;In December 1945, just months after the bombings of Hiroshima and Nagasaki, a group of Chicago-based Manhattan Project scientists published the first issue of a newsletter called the Bulletin of the Atomic Scientists. Fearing politicians and the public didn’t understand the gravity of the nuclear threat, the scientists used their publication to warn about the implications of the new weapons and to advocate for global policies governing nuclear energy. The Bulletin has since grown into a nonprofit organization with a digital platform covering nuclear weapons, climate change, and other man-made existential risks.&lt;/p&gt;
    &lt;p&gt;The Doomsday Clock is its most famous communication tool. Today, the time is set by the 17 scientists and policy experts who make up the organization’s Science and Security Board. They move the minute hand forward to indicate heightened existential threats, and back in response to efforts that can mitigate those threats. The farthest from midnight the clock has ever been was 17 minutes in 1991 at the end of the Cold War. Since 2010, it has only edged closer to midnight.&lt;/p&gt;
    &lt;p&gt;The clock is a compelling and polarizing image. Every year after the announcement, hundreds of international news outlets report the time with grim headlines that could be drawn from a thesaurus entry for doomsday: annihilation, apocalypse, Armageddon. The clock has been celebrated as a powerful and enduring example of information design and criticized as a fear-mongering media stunt. In the nearly 80 years of its history, it has inspired music by Iron Maiden, Linkin Park, and Hozier, among others, and has appeared in TV shows from Dr. Who to The Late Show with Stephen Colbert, and even in a satirical adaptation of the children’s book Goodnight Moon called Goodnight Trump: “Goodnight global climate shock. Goodnight ticking Doomsday Clock.”&lt;/p&gt;
    &lt;p&gt;Eighty-two years ago, my grandfather George Strasser began his career as a nuclear weapons scientist enriching uranium for the first atomic bomb. He died before I was born, and my family didn’t talk much about his work. It wasn’t until I was about to graduate from college that I began to be haunted by a memory from my childhood: a photograph of my grandfather posing in front of a nuclear test blast. The ensuing effort to reckon with what it meant sent me into a decade researching and writing about the far-reaching consequences of his work.&lt;/p&gt;
    &lt;p&gt;While I began by confronting the past violence of the bomb, I ended profoundly shaken by the precarity of life on a planet armed with thousands of nuclear weapons far more powerful than those that devastated Hiroshima and Nagasaki. In the Doomsday Clock, I found a shorthand to communicate the imminent and increasing existential threat of nuclear weapons. I often invoked the clock’s authority without thinking much about who sets it and how.&lt;/p&gt;
    &lt;p&gt;That changed in November 2024, when I was invited to speak at the Bulletin’s annual fundraising dinner to accept an award for a piece I’d written for the publication. What I hadn’t realized, until I was sipping wine at the reception, was that the clock setters were there, halfway through their two-day deliberations to set the time for 2025.&lt;/p&gt;
    &lt;p&gt;I chatted with Manpreet Sethi, a nuclear security expert from India, who was new to the board. For years, she had followed the clock and tried to reconstruct the process, guessing at the considerations that had led to a certain time. She’d always wanted to be “a fly on that wall,” she said, and later told me she was so invigorated by the discussion that she could hardly sleep that night.&lt;/p&gt;
    &lt;p&gt;Over the following months, I became consumed by the question of what it is to be a person in that room, tasked with coolly analyzing how our world could end. Maybe it was a way of channeling my own apocalyptic dread, a more organized doomscrolling. What does it feel like to hold such intimate knowledge of a possible apocalypse? How do the clock setters distill horror and uncertainty into a time on a metaphorical clock? And how should the rest of us understand what it all means?&lt;/p&gt;
    &lt;p&gt;Daniel Holz is perhaps the most visible of the clock setters, the person most deeply immersed in its mechanics. At 55, he has a graying mop of wavy hair, a bouncing stride, and a kind of boyish earnestness when he’s not serving as a stone-faced doomsayer.&lt;/p&gt;
    &lt;p&gt;With a background that has more to do with the mysteries of the distant universe than with how we might extinguish life on this planet, his path to the Doomsday Clock was unconventional. A childhood in the Philippines, where his parents worked, gave him an international perspective at a young age. He was inspired by a passionate math teacher at the International School Manila, and eventually a Princeton University mentor set him on a path to a career in physics. After a PhD at the University of Chicago and a few postdocs, Holz spent seven years in New Mexico at the Los Alamos National Laboratory studying cosmology and astrophysics. The experience gave him a taste of the intersection of science with questions of global and national security.&lt;/p&gt;
    &lt;p&gt;In 2011, Holz returned to academia as an assistant professor at the University of Chicago. From his new office, he could see the bronze Henry Moore sculpture marking the site where, on a bitterly cold December day in 1942, Enrico Fermi and his team had initiated the first self-sustaining nuclear chain reaction, ushering the atomic bomb from theory to technical possibility. The sculpture’s bulbous abstract form, part skull and part mushroom cloud, would become a daily reminder of that history.&lt;/p&gt;
    &lt;p&gt;Holz’s office was in the building where Fermi had conducted pioneering research in particle physics after the war. That physical proximity to Fermi’s complex legacy was a manifestation of a tension Holz continues to wrestle with: the responsibility of the scientist in relation to the promises and perils of scientific advancement. “What am I being associated with?” he wondered. “I still struggle with that stuff.”&lt;/p&gt;
    &lt;p&gt;Only after Holz received tenure in 2015 did he have time to engage in much beyond astrophysics. “It’s a privilege to spend your day thinking about black holes,” he says. “But the rest of the world matters too.” He started to attend Bulletin events. Ever the eager student, he sought out experts and asked lots of questions. He joined the board in 2017 and became a chair in 2021.&lt;/p&gt;
    &lt;p&gt;The more he learned, the more he felt an urgency to bring in others. In 2022, Holz founded the Existential Risk Laboratory, or XLab. He wanted to give students concerned about that ticking clock a way to channel fear into something productive. He also co-teaches a course called “Are We Doomed?” where students consider existential risk through the lenses of science, policy, and culture. The 2024 syllabus included guest speakers such as Geoffrey Hinton, the “godfather of AI,” and David Wallace-Wells, author of The Uninhabitable Earth; films such as Contagion, Dr. Strangelove, and Wall-E; and books such as Plato’s Republic, Octavia Butler’s Parable of the Sower, and Margaret Atwood’s The Handmaid’s Tale.&lt;/p&gt;
    &lt;p&gt;When I talk to Holz six months after the 2025 clock announcement, he and his XLab team are in the final throes of planning the Nobel Assembly. He’s frustrated and amused by the tedious event logistics when the world is at stake. “You go from ‘how do we think about what’s happening in Iran’ and ‘will this lead to the destruction of civilization’ to ‘what color should the napkins be?’”&lt;/p&gt;
    &lt;p&gt;After a year of preparation, the event consists of just three days to wrangle some 80 international participants representing diverse disciplines and politics to agree on a set of recommendations for world leaders. The conversations span security, geopolitics, ethics, science, law, and psychology, tackling terrifying subjects such as the risks of AI to nuclear security, the weaponization of space, and nuclear close calls. Holz is less participant than timekeeper, often standing in the corner of the room waving both arms to wrap up a session that’s going on too long. At night, he stays up late with the rest of the organizing committee to draft the statement. The morning after the assembly, he agonizes over a short follow-up email to participants, sending and unsending it three times.&lt;/p&gt;
    &lt;p&gt;He’d been petrified that no one would sign the declaration. “I would end up with five people signing it and 75 people really pissed off.” (In the end, most signed.)&lt;/p&gt;
    &lt;p&gt;The humming anxiety under everything is—will any of it work?&lt;/p&gt;
    &lt;p&gt;Humans have been telling stories about the apocalypse for thousands of years, at least—often involving divine punishment by natural disaster. But the nuclear age marked a new reality that our end could be self-inflicted. The Doomsday Clock is an early symbol of that awareness—and it began as an artist’s vision. In 1947, painter Martyl Langsdorf, wife of Manhattan Project physicist Alexander Langsdorf Jr., was asked to design a cover for the Bulletin’s first magazine-length issue. She sketched her idea on the back of a copy of Beethoven’s Piano Sonatas, choosing a minimalist clock to convey the “panicky time” and setting the hands seven minutes to midnight because it “suited [her] eye.” There was never a plan to move the hands. But in October 1949, in response to the Soviets’ first nuclear bomb test, the inception of the arms race the scientists had been warning about, editor Eugene Rabinowitch changed the time on the cover to three minutes to midnight. He continued to shift the clock forward and back as threats fluctuated; one minute ahead in 1953 for the hydrogen bomb; three minutes back in 1969 for the Nuclear Non-Proliferation Treaty.&lt;/p&gt;
    &lt;p&gt;Today the clock-setting is more complicated than when nuclear weapons were the only way we knew we could extinct ourselves. The single time represents the board’s analysis of the dangers posed by a set of distinct, complex, and intersecting threats in four focus areas: nuclear weapons, climate change, disruptive technologies, and biological threats.&lt;/p&gt;
    &lt;p&gt;Throughout the year, the clock setters meet over Zoom to discuss current and emerging threats, consult other experts, and prepare reports for the rest of the board. The whole group gathers in Chicago in June and November. They set the time at the end of the November meeting and announce it in January.&lt;/p&gt;
    &lt;p&gt;The in-person gatherings, occurring over two or three days, are held in a conference room in an upper floor of an office building in downtown Chicago, with a sweeping view of the city and the river, Lake Michigan a darker blue smudge on the horizon.&lt;/p&gt;
    &lt;p&gt;To allow for candid conversation, journalists are not allowed to witness the deliberations. The board members I spoke to told me what they could, pausing occasionally to consider how much to reveal. There are presentations on various threats followed by discussion. The topics are grim, but the clock setters approach them with a professional distance born of careers spent in the trenches.&lt;/p&gt;
    &lt;p&gt;“I’ve been working on this since I was 14 years old,” says Jon Wolfsthal. “I tend not to get choked up about my work.” Wolfsthal, head of Global Risk at the Federation of American Scientists and former staffer to President Obama and Vice President Biden, got his start as a teenage activist in the nuclear freeze movement of the 1980s. He seems like the kind of person who plays devil’s advocate to provoke debate but doesn’t mind being wrong. “I’m the dumbest person in the room when I go to those meetings,” he tells me. “It’s great.”&lt;/p&gt;
    &lt;p&gt;“You have to have a certain kind of personality,” says board member Asha George, executive director of the Bipartisan Commission on Biodefense, former paratrooper, military intelligence officer, and congressional staffer. “If you are freaking out all the time, [it] affects your ability to be rational.”&lt;/p&gt;
    &lt;p&gt;Clock setter Alexandra Bell was 8 years old when she wrote a letter to President George H.W. Bush expressing outrage about the Exxon Valdez oil spill and accusing him of spending too much time on nuclear weapons. A form response thanked her for writing and urged her to keep reading books. “I was like, this is garbage,” she says. “I was just radicalized.” Her righteous, youthful anger led her to a career in nuclear policy and diplomacy in both government and nonprofit roles, and in February 2025, she joined the Bulletin as its new president.&lt;/p&gt;
    &lt;p&gt;The clock setters don’t always agree—on the magnitude of a certain threat, for instance, or on what should be done about it. Board members have worked on nuclear modernization, negotiated arms-control treaties, or supported nuclear abolition—positions often at odds in the nuclear security space. The ideological diversity is “not accidental” says Holz, and it makes for lively conversation. But everyone I spoke to described an atmosphere of mutual respect and open-minded discussion. They seem to like each other, even to enjoy these hours rigorously considering the worst-case scenarios. And if you spend your days thinking about end times, it’s important to have people to talk to. I ask Holz if they have a Doomsday Clock group chat, and he laughs. “We have various ways to get in touch with each other.”&lt;/p&gt;
    &lt;p&gt;There are moments when alarming new information moves from head to heart, bursting like bubbles on the surface of the water. “I thought I was past the ability to be scared about new things,” says Bell. As the new president, she attended her first clock meeting this past June. “I walked out of that room more concerned than I was walking in.”&lt;/p&gt;
    &lt;p&gt;Mirror life was what scared her.&lt;/p&gt;
    &lt;p&gt;Last December, researchers issued a warning about the dangers of synthesizing molecules that reverse the natural structures of those that form the building blocks of all known life. While such developments could have beneficial medical applications, they might also lead to the production of mirror-image organisms that could spread unchecked through humans, plants, and animals, evading natural immune defenses, predators, and breakdown processes. A lab leak or bioweapon could devastate life on Earth, the scientists warned as they called for a pause on research to assess the risks.&lt;/p&gt;
    &lt;p&gt;Two other board members mention mirror life when I ask about their “oh shit” moments. It might not be on the public radar yet, “but if something goes wrong,” says Holz, “it’ll be the one thing everyone in the world knows about before we all turn to goop.”&lt;/p&gt;
    &lt;p&gt;Wolfsthal can’t even tell me the most recent revelation that shook him. A perk of being on the board is that you get to learn about new hazards before there’s public awareness.&lt;/p&gt;
    &lt;p&gt;It’s usually after the meeting has ended for the day, when the intellectual adrenaline has faded, that “your human-being part kicks in,” says Holz. They ride the elevator to the lobby and exit the building into a sunny, bustling downtown Chicago. “You’ve just spent two or three days…thinking about all the things that can go wrong.” But people are shopping, going to the movies, out to dinner. “We’re all kind of in shock. And around us, there’s all the normal day-to-day life.”&lt;/p&gt;
    &lt;p&gt;During these months researching the clock, I begin to experience something similar. I find myself asking—what if it happened now? The lab leak, the fatal first launch. I think this while reading on a screened-in porch surrounded by trees and the drone of crickets. While stargazing, I imagine the light of an intercontinental ballistic missile bursting through the night sky. What if it’s already happening somewhere? Where would it end?&lt;/p&gt;
    &lt;p&gt;After a day or two of presentations and deliberations, the time must be set. Is the world safer or in more danger than last year? And how does this year compare to the nearly 80 years of the clock’s history?&lt;/p&gt;
    &lt;p&gt;The board homes in on a time through rounds of voting and discussion. Sometimes agreement is immediate. Other times, they need follow-up discussions. In the months between decision and announcement, John Mecklin, editor of the Bulletin, drafts the statement that lays out the board’s analysis of the threats and suggested actions. The text is circulated and revised until everyone stands behind it. By the January announcement, the message is united.&lt;/p&gt;
    &lt;p&gt;That unity, however, doesn’t erase the ambiguities at the heart of the clock. What does a second or minute mean? Until 2017, the clock had only ever shifted by minutes. But closer to midnight, every second counts for more. In 2017, the clock was moved 30 seconds, and the changes have continued to get smaller. The one-second shift in 2025 was the smallest yet.&lt;/p&gt;
    &lt;p&gt;It’s this imprecision that most critics take issue with. Midnight itself is difficult to define. In 1947, the threat of nuclear annihilation represented a clear and catastrophic end. But the expansion of threats with the addition of climate change in 2007 complicated matters. Is midnight societal collapse, millions of deaths, human extinction?&lt;/p&gt;
    &lt;p&gt;Rachel Bronson, who finished her 10-year term as president of the Bulletin in January 2025, tells me that midnight is “the end of life on Earth as we know it” or “civilization changing events.” George goes further: “To me, it’s extinction.”&lt;/p&gt;
    &lt;p&gt;Holz also uses the phrase “as we know it.” If midnight is the end “as we know it,” then it’s fair to ask, who are “we”? The Bulletin’s founders and early writers were nuclear insiders who knew the horror of the weapons because they had done the calculations and the tests. They knew that the weapons would become more powerful; some were still working to make them so.&lt;/p&gt;
    &lt;p&gt;Today, the Science and Security Board is more diverse in terms of race, gender, and expertise. Bell points out that she is the third consecutive woman to head the Bulletin. Still, there is a long way to go. As reflective of STEM and national security fields at large, the board members are mostly white and mostly men. And they are largely insiders drawn from academia, government, and defense, some from within the nuclear weapons industry itself. Most notably perhaps, many have worked in or consulted for the U.S. government (though they cannot be currently employed by any government).&lt;/p&gt;
    &lt;p&gt;Sethi, the Indian nuclear security expert and one of two board members based outside the U.S., thinks that lack of international perspectives can lead to blind spots. Wolfsthal agrees. “We can’t save everybody if we only represent parts of the population,” he says.&lt;/p&gt;
    &lt;p&gt;Certainly, preventing nuclear war and pandemics, mitigating climate change, and regulating dangerous emerging technologies are incontrovertibly in the interest of all humanity. The Bulletin strives to be a nonpartisan space of informed debate and analysis, publishing a variety of divergent perspectives. “We have one prejudice,” their website reads. “We are opposed to extinction.”&lt;/p&gt;
    &lt;p&gt;But at 89 seconds to midnight, we might say that the efforts of insiders have not worked. The questions are complicated, but what voices and frameworks, what bold and creative solutions, do we miss when conversations are dominated by those who have always been in the room?&lt;/p&gt;
    &lt;p&gt;And existential threat depends on where you’re sitting. “My kids would say school shootings are existential,” Bronson says. “For them, it’s an existential threat, going to school and having kids mowed down.” Those events are deadly, dangerous, she agrees, but they are not “civilization ending as we know it.”&lt;/p&gt;
    &lt;p&gt;Even as I push for a definition of midnight, I find the attempt chilling. Inez Fung, climate scientist and professor emerita at UC Berkeley, now in her second year on the board, worries about increasing agricultural failure, water insecurity, floods, deadly heat waves, sea level rise, disasters already underway across the world. She tosses the question back to me—how many people would have to die before we’d call it a catastrophe?&lt;/p&gt;
    &lt;p&gt;The board frequently discusses the nuance of midnight but, for now, have agreed not to be definitive. “Here’s a very quantitative group of people choosing not to use very quantitative methods,” reflects Princeton professor emeritus Robert Socolow, a physicist and climate scientist serving a second term on the board. “We’re just allowing the ambiguities to be absorbed within the decision.”&lt;/p&gt;
    &lt;p&gt;Holz urges a broad view of the clock’s trajectory. “There’s a consensus that things are getting worse,” he says. “In that sense, the message we’re trying to send is pretty clear.”&lt;/p&gt;
    &lt;p&gt;The event horizon of a black hole is the boundary beyond which nothing, not even light, can escape. The point of no return. Once you’ve taken on doomsday professionally, where do you stop?&lt;/p&gt;
    &lt;p&gt;The day after the Nobel Assembly, there’s a stack of doomy books on Holz’s desk. Among them are Annie Jacobsen’s Nuclear War: A Scenario, a terrifying minute-by-minute account of how a global nuclear conflict could unfold; Two Minutes to Midnight, a popular history of 1953 by Roger Hermiston that Holz found by chance in a used bookstore; and Jonathan Lear’s Imagining the End, a philosophical exploration of mourning and meaning-making in the face of planetary precarity.&lt;/p&gt;
    &lt;p&gt;“You could just spend all your time reading about doom if you wanted,” Holz acknowledges. But he tries to alternate between dark and light books. Right now, light is 1984. I laugh. “It’s readable!” he insists.&lt;/p&gt;
    &lt;p&gt;When it’s too much, he turns to the universe. “The black holes, the physics—it’s my refuge. I can solve stuff here. I get results. I write papers.”&lt;/p&gt;
    &lt;p&gt;On the blackboard, there are a few quickly sketched graphs—an undulating line in a funnel, a bell curve. Holz studies gravitational waves with the Laser Interferometer Gravitational-Wave Observatory team that first detected them in 2015—ripples in spacetime caused by the collision of two black holes more than one billion years ago.&lt;/p&gt;
    &lt;p&gt;I ask him what it’s like to toggle between one billion years and 89 seconds. Homo sapiens evolved hundreds of thousands of years ago. We are the tiniest sliver of a fraction of a percent of Earth’s 4.5 billion years and the universe’s 13.8 billion. Nuclear weapons kept on “hair-trigger alert” can be launched by a presidential order within minutes. Global escalation could lead to millions of deaths within hours and trigger a nuclear winter, killing billions by starvation within two years.&lt;/p&gt;
    &lt;p&gt;“We’re surrounding a pretty boring star in a pretty boring galaxy,” Holz says. Probably, he thinks, there’s other life out there, and he finds it comforting to think our destruction wouldn’t be the end of the universe. “If we blow ourselves up, no one’s going to notice or care.” But that notion motivates Holz. “It really emphasizes that it’s on us. It’s our responsibility to take care of ourselves.”&lt;/p&gt;
    &lt;p&gt;Despite his commitment to the metaphorical clock, Holz craves quantifiability and enjoys a hard math problem. So he’s trying to build an equation to more precisely map how existential threats intersect with each other.&lt;/p&gt;
    &lt;p&gt;The idea is similar in ethos to the famous Drake equation for estimating how many technologically advanced civilizations might be spinning out in the cosmos, ready to make contact. The Drake equation multiplies the conditions necessary for life—variables such as the rate of star formation, fraction of stars with planets, planets per star capable of supporting life—by estimates of the likelihood that life will develop the means to communicate with us. Then there’s that ominous final variable: How long do intelligent civilizations last?&lt;/p&gt;
    &lt;p&gt;Which is, perhaps, where Holz’s equation comes in. Is self-destruction the inevitable end of the technologically advanced? Or can we choose otherwise?&lt;/p&gt;
    &lt;p&gt;This calculation is more complicated. Each variable in the Drake equation is independent—a different estimate of the proportion of intelligent life that will develop the technology to communicate doesn’t change the rate of star formation. But the threats that might end us can’t be considered in isolation. Climate change increases global instability, heightening the risk of conflicts that could escalate to nuclear war. The use of AI in military operations, underway in many countries, raises the danger that a machine error or increased time pressure could lead to nuclear launch. And in a conflict-ridden world, nonnuclear countries might use AI to develop bioweapons to counter nuclear threats. Overlaying everything, the spread of disinformation undermines our ability to address any of these threats.&lt;/p&gt;
    &lt;p&gt;There’s tons of uncertainty, says Holz, but it’s useful to think through the variables that might matter and filter out the ones that don’t. You start with the parts of this precarious mess you can count: global nuclear weapons arsenals, the number kept on high alert, CO2 in the atmosphere, degrees of warming. And then there are climate models linking temperature rise and extreme weather and estimates on the number of climate refugees under certain conditions.&lt;/p&gt;
    &lt;p&gt;Questions spiral out with increasing complexity and ambiguity—can you quantify disinformation? Measure the effect of AI or autocracy? How do these factors impact the likelihood of conflicts?&lt;/p&gt;
    &lt;p&gt;Maybe the biggest unknown is human behavior. “The question of whether human beings will address climate change and stop burning fossil fuels is not a technical question. It’s a question about society,” says Holz. “Will a single person end civilization by launching nuclear weapons and starting World War III? It’s hard to capture that in an equation. But you can say, what factors make that more or less likely?” Some fixes are simple: A rule requiring at least two humans to initiate a nuclear launch could prevent a mistake or rash first strike. Calculating estimates for the impact of these changes might help convince decision-makers to adopt them.&lt;/p&gt;
    &lt;p&gt;He’s still in the conceptual phases—work that takes place on his blackboard, or with pen and paper. Eventually he hopes to build a dynamic model that could help identify the most effective levers for reducing threats.&lt;/p&gt;
    &lt;p&gt;Holz swings between optimism and pessimism. Many solutions are known: treaties, regulation, sustainable energy. “It’s not even that difficult,” he says, but “maybe I don’t know enough about politics because I’m a physicist.”&lt;/p&gt;
    &lt;p&gt;The June 2025 clock meeting landed midway through a dizzying year. Even before Holz took the podium to announce the 2025 time in late January, headlines about a still- smoldering Los Angeles had been drowned out by coverage of Trump’s first week, a barrage of actions paving the way for rapid defunding of scientific research, backtracking on climate action, dismantling public health protections, and destabilizing international relations. All dropped into a world of escalating global conflicts and humanitarian crises. The meeting was “not boring,” Holz acknowledges.&lt;/p&gt;
    &lt;p&gt;If the experts felt anxious before about their ability to break through, growing mistrust of science and the proliferation of alternate facts is making them desperate. “We’re driving at the edge of a cliff with dim headlights,” Socolow told me in July. “[These] last six months have been different for me than any other time thinking about existential risk.” Three months later, Trump casually suggested the U.S. would resume nuclear testing, a move that would break a decades-long moratorium and inflame nuclear tensions with Russia and China.&lt;/p&gt;
    &lt;p&gt;Herb Lin studies the intersection of emerging technologies and national security at Stanford and wrapped up a nine-year term on the board in 2025. He believes that the erosion of shared reality is a greater danger than putting AI in control of nuclear weapons. He doesn’t consider himself an optimist, “but I’ll be damned if I’m going to do nothing,” he says. “There’s a story about a guy who’s walking along the beach, and he sees millions and millions of starfish swept up,” he begins, then sees my nod.&lt;/p&gt;
    &lt;p&gt;My mom used to tell me the story when I was overwhelmed by my smallness in the face of suffering in the world. The beach walker sees a lone figure on the shore, throwing starfish back into the water one by one. Lin finishes the story: “You can’t make any difference. There’s millions of them,” the beach walker says. “It makes a difference to that one,” the thrower insists, tossing another into the sea.&lt;/p&gt;
    &lt;p&gt;“And,” Lin adds, “there’s always ice cream.”&lt;/p&gt;
    &lt;p&gt;I’m confused.&lt;/p&gt;
    &lt;p&gt;“The fact that there’s ice cream in the world matters, right?” he says. “And I have a daughter who loves me. That matters too.”&lt;/p&gt;
    &lt;p&gt;This work can be Sisyphean, Bell acknowledges, and we’re backsliding. But, she says, “I don’t need to know the end to know that I have to keep pushing the rock up the hill. If we don’t, it’s going to roll right over us.”&lt;/p&gt;
    &lt;p&gt;There are no prophets or saviors here, just people who know a lot about the dangers we face and spend a lot of time thinking about how to avoid annihilation. I still have plenty of questions, but to me, understanding more about the human process of the clock-setting, the tension between expertise and fallibility, quantifiability and uncertainty, is what saves the clock from being an exercise in total hubris or fear-mongering. The clock is meant to be a warning and a call to action, not a prediction.&lt;/p&gt;
    &lt;p&gt;Wrestling with a symbol I find simultaneously compelling and unsettling, useful and provocative, has helped me think more precisely about how I choose to engage with the things that scare me.&lt;/p&gt;
    &lt;p&gt;The new time will be announced on January 27, 2026. It will represent a distillation of counted and analyzed threats. Between us and midnight are the unpredictable dynamics of individual and collective human behavior. Perhaps the bigger question than where the clock hands lie is, what will we do in the space of what is still possible?&lt;/p&gt;
    &lt;p&gt;Emily Strasser’s work has appeared in Ploughshares, Guernica, Colorado Review, The Bitter Southerner, and Bulletin of the Atomic Scientists, among others. Her deeply researched memoir, Half-Life of a Secret, traces her journey to reckon with the toxic legacies of her grandfather’s work building nuclear weapons. She is based in Boston.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://www.popularmechanics.com/science/a70162364/setting-the-doomsday-clock/"/><published>2026-01-28T19:48:59+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=46800645</id><title>Native Instruments enters into insolvency proceedings</title><updated>2026-01-28T21:19:25.508148+00:00</updated><content>&lt;doc fingerprint="d504409dd0bab9d5"&gt;
  &lt;main&gt;
    &lt;head rend="h1"&gt;Native Instruments enters into insolvency proceedings, leaving its future uncertain&lt;/head&gt;
    &lt;head rend="h2"&gt;An administrator has been appointed to restructure the company and potentially sell off assets.&lt;/head&gt;
    &lt;p&gt;Music hardware and software manufacturer Native Instruments has entered into preliminary insolvency proceedings, according to a report by Create Digital Music. This is the company behind iconic software like Massive, Traktor and Kontakt and hardware like Maschine+. Native Instruments also owns the brands iZotope, Brainworx and Plugin Alliance.&lt;/p&gt;
    &lt;p&gt;We don't have many specifics as to what this entails and what the future of the company will look like. We do know that an administrator has been appointed to handle restructuring and, potentially, to sell off existing assets. Native Instruments employs hundreds of people and their fates also remain uncertain.&lt;/p&gt;
    &lt;p&gt;A private equity firm called Francisco Partners owns a majority stake in the company. It also owns majority stakes in entities like GoodRX and Verifone, among others. This isn't the first time Native Instruments has been forced into major restructuring. The company experienced plenty of layoffs and uncertainty between 2019 and 2020 before being purchased by private equity.&lt;/p&gt;
    &lt;p&gt;Again, we have no idea how this will shake out. It's possible that new investors will jump on board and it goes back to business as usual. It's also possible everything will be scrapped for parts and sold to the highest bidder.&lt;/p&gt;
    &lt;p&gt;We do know that subsidiary Plugin Alliance seems to be unaffected. It issued a statement on Facebook saying that it isn't involved with the proceedings and that operations will continue as normal. This means new plugins will be released, along with updates for current software.&lt;/p&gt;
    &lt;p&gt;Everything else is still up in the air. This is troubling for those who have heavily invested in the company's ecosystem of products. I'm one of them. Any hope I had for a hardware refresh of the Maschine+ just went out the window.&lt;/p&gt;
    &lt;p&gt;If the company's robust line of software goes up for sale, Akai is likely the best bet. It has already begun incorporating Native Instruments software into MPC machines.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://www.engadget.com/audio/native-instruments-enters-into-insolvency-proceedings-leaving-its-future-uncertain-183206826.html"/><published>2026-01-28T19:51:05+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=46800737</id><title>Native Linux VST plugin directory</title><updated>2026-01-28T21:19:24.368630+00:00</updated><content>&lt;doc fingerprint="ca2eb295dcc9645c"&gt;
  &lt;main&gt;
    &lt;p&gt;Search&lt;/p&gt;
    &lt;p&gt;Categories&lt;/p&gt;
    &lt;p&gt;Category id: --------- All --- Effects ------ Distortion --------- Bitcrusher --------- Saturation ------ Dynamics --------- Compressor --------- De-esser --------- Gate --------- Limiters --------- Transient Designer ------ EQ ------ Emulations --------- Amp simulation --------- Cabinet simulation --------- Console Buss Emulation ------ Filter ------ Meter/Analyser ------ Modulation --------- Chorus --------- Flanger --------- Phaser --------- Pitch/Frequency shifter --------- Tremolo ------ Multieffect ------ Time/Space --------- Delay --------- Reverb --------- Stereo widening ------ Tool --------- Dither --------- Tone/Noise Generator/FX --- Instrument ------ Drums ------ Sampler/Trigger ------ Synth ------ Vocoder --- Midi --- Other ------ Bundle ------ Software --------- DAW --------- Utils&lt;/p&gt;
    &lt;p&gt;Format: VST2 VST3 LV2 CLAP DAW DSSI JACK LADSPA standalone&lt;/p&gt;
    &lt;p&gt;Free: Unknown Yes No&lt;/p&gt;
    &lt;p&gt;Tabular view:&lt;/p&gt;
    &lt;p&gt;Order by: Updated Neweset Name&lt;/p&gt;
    &lt;p&gt;Show untested:&lt;/p&gt;
    &lt;p&gt;Filter&lt;/p&gt;
    &lt;p&gt;True iron&lt;/p&gt;
    &lt;p&gt;Saturation by Kazrog&lt;/p&gt;
    &lt;p&gt;True dynamics&lt;/p&gt;
    &lt;p&gt;Compressor by Kazrog&lt;/p&gt;
    &lt;p&gt;True 252&lt;/p&gt;
    &lt;p&gt;EQ by Kazrog&lt;/p&gt;
    &lt;p&gt;Synth Warmer&lt;/p&gt;
    &lt;p&gt;Distortion by Kazrog&lt;/p&gt;
    &lt;p&gt;Retro Sta-Level&lt;/p&gt;
    &lt;p&gt;MHB Green&lt;/p&gt;
    &lt;p&gt;KClip Zero&lt;/p&gt;
    &lt;p&gt;Limiters by Kazrog&lt;/p&gt;
    &lt;p&gt;KClip 3&lt;/p&gt;
    &lt;p&gt;Avalon VT-747SP&lt;/p&gt;
    &lt;p&gt;Console Buss Emulation by Kazrog&lt;/p&gt;
    &lt;p&gt;Airline V15&lt;/p&gt;
    &lt;p&gt;Amp simulation by Kazrog&lt;/p&gt;
    &lt;p&gt;AmpCraft - 1992&lt;/p&gt;
    &lt;p&gt;Avalon EQ Bundle&lt;/p&gt;
    &lt;p&gt;Trailbender&lt;/p&gt;
    &lt;p&gt;Delay by Signal Perspective&lt;/p&gt;
    &lt;p&gt;Pyrite&lt;/p&gt;
    &lt;p&gt;Distortion by Signal Perspective&lt;/p&gt;
    &lt;p&gt;Grindbox Mk2&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://linuxmusic.rocks"/><published>2026-01-28T19:59:04+00:00</published></entry><entry><id>https://news.ycombinator.com/item?id=46801225</id><title>What does Werner Herzog's nihilist penguin teach us about life?</title><updated>2026-01-28T21:19:24.137832+00:00</updated><content>&lt;doc fingerprint="511b119a8de7059f"&gt;
  &lt;main&gt;
    &lt;p&gt;The film is an investigation of a beautiful and brutal landscape, a natural world of extreme weather and unimaginable violence. But first and foremost it’s about people and how they interact with and interpret the harsh environment. Herzog, a chronic wanderer himself, meets a stream of fascinating, often eccentric characters gathered to form a working community in and around McMurdo Station, an American research centre located on the southern tip of Antarctica’s Ross Island. He speaks, for example, to a glaciologist, a survival school instructor, a team of volcanologists, a utility mechanic and a multiple world record holder. They all have their own intriguing stories to tell.&lt;/p&gt;
    &lt;p&gt;Interviewed in a greenhouse, “amongst unripe tomatoes”, an unsurprisingly articulate linguist explains that those who are not tied down tend to fall to the bottom of the planet. “We’re all at loose ends,” he says, “and here we are together.” It’s a nice metaphor.&lt;/p&gt;
    &lt;head rend="h3"&gt;Get more Little White Lies&lt;/head&gt;
    &lt;p&gt;It’s a decade since the film officially premiered at the 2007 Toronto Film Festival, and it remains one of Herzog’s finest achievements. The film is crammed with complex and challenging material that calls into question everything we think we know about the term “documentary”. While the images of a totally alien, underwater world – filmed by collaborator Henry Kaiser – inspire awe, and the discussion with the aforementioned utility mechanic makes for a profoundly moving exchange, there is one scene in particular that warrants close attention: that concerning penguins prone to existential crises.&lt;/p&gt;
    &lt;p&gt;Early on in the film, Herzog assures us that he is not interested in making a film about penguins and, as he introduces the colony at Cape Royds, he explains: “Everyone spoke about penguins, however, the questions I had were not so easily answered.” As such, we should expect something out of the ordinary. The man tasked with fielding the examination is marine ecologist Dr David Ainley, who is described as “a taciturn man who in his solitude was not much into conversation with humans anymore”. This must, of course, be taken with a pinch of salt.&lt;/p&gt;
    &lt;p&gt;Ainley begins with a brief history of the spot and a summation of how the colony is faring, explaining that the penguins have had a good winter, they have claimed their territories and the females have left the males to tend the eggs. There’s a brief pause, perhaps a hint of awkwardness, and Herzog works to keep the conversation going. First, he asks about the penguins’ sexual behaviour, hearing about triangular relationships and “prostitution” in response, before moving on to the crux of his inquiry: “Dr Ainley, is there such thing as insanity among penguins? I try to avoid a definition of insanity or derangement… but could they just go crazy because they have had enough of their colony?”&lt;/p&gt;
    &lt;p&gt;The expert reflects on never having seen a penguin “bashing its head against a rock”, but he goes on to describe how they do get disoriented and “end up in places they shouldn’t be, a long way from the ocean.” Cue a moment of vintage Herzog. The soft, angelic tones of Alexander Sedov’s rendition of ‘Retche Gospod Gospodevi Moyemu’ slowly rise and the camera pans above a group of penguins shuffling over a large sheet of ice, with a range of colossal peaks looming behind. The director narrates in his customary tongue-in-cheek poetic style (it’s as if he can’t resist mocking his own philosophical inclinations): “One of them caught our eye – the one in the centre.”&lt;/p&gt;
    &lt;p&gt;Herzog proceeds to explain that the penguin will not go to the feeding grounds at the edge of the ice, nor will he return to the colony; instead he heads straight for the mountains, “some 70 kilometres away”. Catching him and bringing him back will make no difference – he’ll simply turn around and head again for the interior. “But why?” Herzog asks. We then see footage of another of these “deranged” penguins, 80 kilometres off course, sliding on its belly towards certain death. These shots of the solitary birds marching to their demise, mere black dots against the white expanse, are perfect in their portrayal of loneliness and desolation.&lt;/p&gt;
    &lt;p&gt;The scene, then, is a splendid tragicomedy, serving as a sour antidote to the fluffy charm of films like the The March of the Penguins, which arrived two years earlier. It’s a play within a play; masterfully constructed, it delivers a hefty emotional blow. It’s in this construction, and self-reflexive style, that truth and revelation can be found – Herzog’s ecstatic truth, that is. The natural world, as we learnt from the horrors of Grizzly Man, is not easily compared with ours. The structures we adopt for our stories – be they tragic, romantic or comedic – do not fit nature quite so tightly, and Herzog knows this. Any facts about the penguins’ motivations and thought processes remain unobtainable. We view the narrative as the filmmaker builds it: through an exclusively human lens.&lt;/p&gt;
    &lt;p&gt;In his 1999 Minnesota Declaration, Herzog queried the validity of the “documentary” label. He drew distinctions between the superficial “truth of accountants” and the “deeper strata of truth in cinema”, which is “mysterious and elusive, and can be reached only through fabrication and imagination and stylisation”. Let’s not forget that he once called Fitzcarraldo his greatest documentary. Essentially, Encounters at the End of the World is a film about us, not penguins. The truth is in our response to the subject matter – what it tells us about ourselves and about cinema. It’s certainly a sequence worth pondering.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</content><link href="https://lwlies.com/article/werner-herzog-penguin-encounters-at-the-end-of-the-world"/><published>2026-01-28T20:43:10+00:00</published></entry></feed>