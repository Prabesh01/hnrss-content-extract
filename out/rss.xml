<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>Hacker News: Front Page</title><link>https://raw.githubusercontent.com/Prabesh01/hnrss-content-extract/refs/heads/main/out/rss.xml</link><description>Hacker News RSS</description><atom:link href="https://raw.githubusercontent.com/Prabesh01/hnrss-content-extract/refs/heads/main/out/rss.xml" rel="self"/><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><language>en</language><lastBuildDate>Tue, 07 Oct 2025 09:37:48 +0000</lastBuildDate><item><title>Microformats – building blocks for data-rich web pages</title><link>https://microformats.org</link><description>&lt;doc fingerprint="36c91293e6b5fe11"&gt;
  &lt;main&gt;
    &lt;p&gt;A (very) belated follow up to Getting Started with Microformats 2, covering the basics of consuming and using microformats 2 data. Originally posted on waterpigs.co.uk.&lt;/p&gt;
    &lt;p&gt;More and more people are using microformats 2 to mark up profiles, posts, events and other data on their personal sites, enabling developers to build applications which use this data in useful and interesting ways. Whether you want to add basic support for webmention comments to your personal site, or have ambitious plans for a structured-data-aware-social-graph-search-engine-super-feed-reader, you’re going to need a solid grasp of how to parse and handle microformats 2 data.&lt;/p&gt;
    &lt;head rend="h2"&gt;Choose a Parser&lt;/head&gt;
    &lt;p&gt;To turn a web page containing data marked up with microformats 2 (or classic microformats, if supported) into a canonical MF2 JSON data structure, you’ll need a parser.&lt;/p&gt;
    &lt;p&gt;At the time of writing, there are actively supported microformats 2 parsers available for the following programming languages:&lt;/p&gt;
    &lt;p&gt;Parsers for various other languages exist, but might not be actively supported or support recent changes to the parsing specification.&lt;/p&gt;
    &lt;p&gt;There are also various websites which you can use to experiment with microformats markup without having to download a library and write any code:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;My own live-updating php-mf2 sandbox&lt;/item&gt;
      &lt;item&gt;The various parser comparison tools hosted on microformats.io&lt;/item&gt;
      &lt;item&gt;Aaron Parecki’s pin13.net microformats parser for parsing either URLs or HTML fragments&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;If there’s not currently a parser available for your language of choice, you have a few options:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Call the command-line tools provided by one of the existing libraries from your code, and consume the JSON they provide&lt;/item&gt;
      &lt;item&gt;Make use of one of the online mf2 parsers capable of parsing sites, and consume the JSON it returns (only recommended for very low volume usage!)&lt;/item&gt;
      &lt;item&gt;Write your own microformats 2 parser! There are plenty of people happy to help, and a language-agnostic test suite you can plug your implementation into for testing.&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h2"&gt;Considerations During Fetching and Parsing&lt;/head&gt;
    &lt;p&gt;Most real-world microformats data is fetched from a URL, which could potentially redirect to a different URL one or more times. The final URL in the redirect chain is called the “effective URL”. HTML often contains relative URLs, which need to be resolved against a base URL in order to be useful out of context.&lt;/p&gt;
    &lt;p&gt;If your parser has a function for “parsing microformats from a URL”, it should deal with all of this for you. If you’re making the request yourself (e.g. to use custom caching or network settings) and then passing the response HTML and base URL to the parser, make sure to use the effective URL, not the starting URL! The parser will handle relative URL resolution, but it needs to know the correct base URL.&lt;/p&gt;
    &lt;p&gt;When parsing microformats, an HTTP request which returns a non-200 value doesn’t necessarily mean that there’s nothing to parse! For example, a &lt;code&gt;410 Gone&lt;/code&gt; response might contain a h-entry with a message explaining the deletion of whatever was there before.

&lt;/p&gt;
    &lt;head rend="h2"&gt;Storing Raw HTML vs Parsed Canonical JSON vs Derived Data&lt;/head&gt;
    &lt;p&gt;When consuming microformats 2 data, you’ll most often be fetching raw HTML from a URL, parsing it to canonical JSON, then finally processing it into a simpler, cleaned and sanitised format ready for use in your website or application. That’s three different representations of the same data — you’ll most likely end up storing the derived data somewhere for quick access, but what about the other two?&lt;/p&gt;
    &lt;p&gt;Experience shows that, over time:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;the way a particular application cleans up mf2 data will be tweaked and improved as you add new features and handle unexpected edge-cases&lt;/item&gt;
      &lt;item&gt;mf2 parsers gradually get improved, fixing bugs and occasionally adding entirely new features.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Therefore, if it makes sense for your use case, I recommend archiving a copy of the original HTML as well as your derived data, leaving out the intermediate canonical JSON. That way, you can easily create scripts or background jobs to update all the derived data based on the original HTML, taking advantage of both parser improvements and improvements to your own code at the same time, without having to re-fetch potentially hundreds of potentially broken links.&lt;/p&gt;
    &lt;p&gt;As mentioned in the previous section, if you archive original HTML for re-parsing, you’ll need to additionally store the effective URL for correct relative URL resolution.&lt;/p&gt;
    &lt;p&gt;For some languages, there are already libraries (such as XRay for PHP) which will perform common cleaning and sanitisation for you. If the assumptions with which these libraries are built suit your applications, you may be able to avoid a lot of the hard work of handling raw microformats 2 data structures!&lt;/p&gt;
    &lt;p&gt;If not, read on…&lt;/p&gt;
    &lt;head rend="h2"&gt;Navigating Microformat Structures&lt;/head&gt;
    &lt;p&gt;A parsed page may contain a number of microformat data structures (mf structs), in various different places.&lt;/p&gt;
    &lt;p&gt;Take a look at the parsed canonical microformats JSON for the article you’re reading right now, for example.&lt;/p&gt;
    &lt;p&gt;&lt;code&gt;items&lt;/code&gt; is a list of top-level mf structs, each of which may contain nested mf structs either under their &lt;code&gt;properties&lt;/code&gt; or &lt;code&gt;children&lt;/code&gt; keys.&lt;/p&gt;
    &lt;p&gt;Each individual mf struct is guaranteed to have at least two keys, &lt;code&gt;type&lt;/code&gt; and &lt;code&gt;properties&lt;/code&gt;. &lt;code&gt;type&lt;/code&gt; is the primary way of identifying what sort of thing that struct represents (e.g. a person, a post, an event). Structs can have more than one type if they represent multiple things at once without wanting to nest them — for example, a post detailing an event might be both a h-entry and a h-event at the same time. Structs can also have additional top-level keys such as &lt;code&gt;id&lt;/code&gt; and &lt;code&gt;lang&lt;/code&gt;.&lt;/p&gt;
    &lt;p&gt;Generally speaking, &lt;code&gt;type&lt;/code&gt; information is most useful when dealing with top-level mf structs, and mf structs nested under a &lt;code&gt;children&lt;/code&gt; key. Nested mf structs found in &lt;code&gt;properties&lt;/code&gt; will also have &lt;code&gt;type&lt;/code&gt; information, but their usage is usually implied by the property name they’re found under.&lt;/p&gt;
    &lt;p&gt;For many common use cases (e.g. a homepage feed and profile) there are several different ways people might nest mf structs to achieve the same goals, so it’s important that your code is capable of searching the entire tree, rather than just looking at the top-level mf structs. Never assume that the microformat struct you’re looking for will be in the top-level of the &lt;code&gt;items&lt;/code&gt; list! You need to search the whole tree.&lt;/p&gt;
    &lt;p&gt;I recommend writing some functions which can traverse a mf tree and return all structs which match a filtering callback. This can then be used as a basis for writing more specific convenience functions for common tasks such as finding all microformats on a page of a particular type, or where a certain property matches a certain value.&lt;/p&gt;
    &lt;p&gt;See my microformats2 PHP functions for some working examples.&lt;/p&gt;
    &lt;head rend="h2"&gt;Possible Property Values&lt;/head&gt;
    &lt;p&gt;Each key in a mf struct’s &lt;code&gt;properties&lt;/code&gt; dict maps to a list of values for that property. Every property may map to multiple values, and those values may be a mixture of any of the following:&lt;/p&gt;
    &lt;p&gt;A plain string value, containing no HTML, and leaving HTML entities unescaped (e.g. &lt;code&gt;&amp;lt;&lt;/code&gt;)&lt;/p&gt;
    &lt;code&gt;{
  "items": [{
    "type": ["h-card"],
    "properties": {
      "name": ["Barnaby Walters"]
    }
  }]
}
&lt;/code&gt;
    &lt;p&gt;(In future examples I will leave out the encapsulating &lt;code&gt;{"items": [{"type": [•••], •••}]}&lt;/code&gt; for brevity, focusing on the &lt;code&gt;properties&lt;/code&gt; key of a single mf struct.)&lt;/p&gt;
    &lt;p&gt;An embedded HTML struct, containing two keys: &lt;code&gt;html&lt;/code&gt;, which maps to an HTML representation of the property, and &lt;code&gt;value&lt;/code&gt;, mapping to a plain text version.&lt;/p&gt;
    &lt;code&gt;"properties": {
  "content": [{
    "html": "&amp;lt;p&amp;gt;The content of a post, as &amp;lt;strong&amp;gt;raw HTML&amp;lt;/strong&amp;gt; (or not).&amp;lt;/p&amp;gt;",
    "value": "The content of a post, as raw HTML (or not)."
  }]
}
&lt;/code&gt;
    &lt;p&gt;An img/alt struct, containing the URL of a parsed image under &lt;code&gt;value&lt;/code&gt;, and its alt text under &lt;code&gt;alt&lt;/code&gt;.&lt;/p&gt;
    &lt;code&gt;"properties": {
  "photo": [{
    "value": "https://example.com/profile-photo.jpg",
    "alt": "Example Person"
  }]
}
&lt;/code&gt;
    &lt;p&gt;A nested microformat data structure, with an additional &lt;code&gt;value&lt;/code&gt; key containing a plaintext representation of the data contained within.&lt;/p&gt;
    &lt;code&gt;"properties": {
  "author": [{
    "type": ["h-card"],
    "properties": {
      "name": ["Barnaby Walters"]
    },
    "value": "Barnaby Walters
  }]
}
&lt;/code&gt;
    &lt;p&gt;All properties may have more than one value. In cases where you expect a single property value (e.g. &lt;code&gt;name&lt;/code&gt;), simply take the first one you find, and in cases where you expect multiple values, use all values you consider valid. There are also some cases where it may make sense to use multiple values, but to prioritise one based on some heuristic — for example, an h-card may have multiple &lt;code&gt;url&lt;/code&gt; values, in which case the first one is usually the “canonical” URL, and further URLs refer to external profiles.&lt;/p&gt;
    &lt;p&gt;Let’s look at the implications of each of the potential property value structures in turn.&lt;/p&gt;
    &lt;p&gt;Firstly, Never assume that a property value will be a plaintext string. Microformats publishers can nest microformats, embedded content and img/alt structures in a variety of different ways, and your consuming code should be as flexible as possible.&lt;/p&gt;
    &lt;p&gt;To partially make up for this complexity, you can always rely on the &lt;code&gt;value&lt;/code&gt; key of nested structs to provide you with an equivalent plaintext value, regardless of what type of struct you’ve found.&lt;/p&gt;
    &lt;p&gt;When you start consuming microformats 2, write a function like this, and get into the habit of using it every time you want a single, plaintext value from a property:&lt;/p&gt;
    &lt;code&gt;def get_first_plaintext(mf_struct, property_name):
  try:
    first_val = mf_struct['properties'][property_name][0]
    if isinstance(first_val, str):
      return first_val
    else:
      return first_val['value']
  except (IndexError, KeyError):
    return None
&lt;/code&gt;
    &lt;p&gt;Secondly, Never assume that a particular property will contain an embedded HTML struct — this usually applies to &lt;code&gt;content&lt;/code&gt;, but is relevant anywhere your application expects embedded HTML. If you want to reliably get a value encoded as raw HTML, then you need to:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Check whether the first property value is an embedded HTML struct (i.e. has an &lt;code&gt;html&lt;/code&gt;key). If so, take the value of the&lt;code&gt;html&lt;/code&gt;key&lt;/item&gt;
      &lt;item&gt;Otherwise, get the first plaintext property value using the approach above, and HTML-escape it&lt;/item&gt;
      &lt;item&gt;If neither is found, the property has no value.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;In Python 3.5+, that could look something like this:&lt;/p&gt;
    &lt;code&gt;from html import escape

def get_first_html(mf_struct, property_name):
  try:
    first_val = mf_struct['properties'][property_name][0]
    if isinstance(first_val, dict) and 'html' in first_val:
      return first_val['html']
    else:
      plaintext_val = get_first_plaintext(mf_struct, property_name)

      if plaintext_val is not None:
        plaintext_val = escape(plaintext_val)

      return plaintext_val
  except (IndexError, KeyError):
    return None
&lt;/code&gt;
    &lt;p&gt;In some cases, it may make sense for your application to be aware of whether a value was parsed as embedded HTML or a plain text string, and to store/treat them differently. In all other cases, always use a function like this when you’re expecting embedded HTML data.&lt;/p&gt;
    &lt;p&gt;Thirdly, when expecting an image URL, check for an img/alt structure, falling back to the plain text value (and either assuming an empty alt text or inferring an appropriate one, depending on your specific use case). Something like this could be a good starting point:&lt;/p&gt;
    &lt;code&gt;def get_img_alt(mf_struct, property_name):
  try:
    first_val = mf_struct['properties'][property_name][0]
    if isinstance(first_val, dict) and 'alt' in first_val:
      return first_val
    else:
      plaintext_val = get_first_plaintext(mf_struct, property_name)

      if plaintext_val is not None:
        return {'value': plaintext_val, 'alt': ''}

      return None
  except (IndexError, KeyError):
    return None
&lt;/code&gt;
    &lt;p&gt;Finally, in cases where you expect a nested microformat, you might end up getting something else. This is the hardest case to deal with, and the one which depends the most on the specific data and use-case you’re dealing with. For example, if you’re expecting a nested h-card under an &lt;code&gt;author&lt;/code&gt; property, but get something else, you could use any of the following approaches:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;If you got a plain string which doesn’t look like a URL, treat it as the &lt;code&gt;name&lt;/code&gt;property of an implied h-card structure with no other properties (and if you need a URL, you could potentially take the hostname of the effective URL, if it works in context as a useful fallback value)&lt;/item&gt;
      &lt;item&gt;If you got an img alt struct, you could treat the &lt;code&gt;value&lt;/code&gt;as the&lt;code&gt;photo&lt;/code&gt;property, the&lt;code&gt;alt&lt;/code&gt;as the&lt;code&gt;name&lt;/code&gt;property, and potentially even take the hostname of the&lt;code&gt;photo&lt;/code&gt;URL to be the implied fallback&lt;code&gt;url&lt;/code&gt;property (although that’s pushing it a bit, and in most cases it’s probably better to just leave out the&lt;code&gt;url&lt;/code&gt;)&lt;/item&gt;
      &lt;item&gt;If you got an embedded HTML struct, take its plaintext &lt;code&gt;value&lt;/code&gt;and use one of the first two approaches&lt;/item&gt;
      &lt;item&gt;If you got a plain string, check to see if it looks like a URL. If so, fetch that URL and look for a representative h-card to use as the author value&lt;/item&gt;
      &lt;item&gt;If you get an embedded mf struct with a &lt;code&gt;url&lt;/code&gt;property but no&lt;code&gt;photo&lt;/code&gt;, you could fetch the&lt;code&gt;url&lt;/code&gt;, look for a representative h-card (more on that in the next section) and see if it has a&lt;code&gt;photo&lt;/code&gt;property&lt;/item&gt;
      &lt;item&gt;Treat the &lt;code&gt;author&lt;/code&gt;property as invalid and run the h-entry (or entire page if relevant) through the authorship algorithm&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The first three are general principles which can be applied to many scenarios where you expect an embedded mf struct but find something else. The last three, however, are examples of a common trend in consuming microformats 2 data: for many common use-cases, there are well-thought-through algorithms you can use to interpret data in a standardised way.&lt;/p&gt;
    &lt;head rend="h2"&gt;Know Your Algorithms and Vocabularies&lt;/head&gt;
    &lt;p&gt;The authorship algorithm mentioned above is one of several more-or-less formally established algorithms used to solve common problems in indieweb usages of microformats 2. Some others which are worth knowing about include:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;“Who wrote this post?”: authorship algorithm&lt;/item&gt;
      &lt;item&gt;“There’s more than one h-card on this page, which one should I use?”: representative h-card&lt;/item&gt;
      &lt;item&gt;“I want to get a paginated feed of posts from this page”: How to consume h-feed&lt;/item&gt;
      &lt;item&gt;“How do I find and display the main post on this page?”: How to consume h-entry&lt;/item&gt;
      &lt;item&gt;“I received a response to one of my posts via webmention, how do I display it?”: How to display comments&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Library implementations of these algorithms exist for some languages, although they often deviate slightly from the exact text. See if you can find one which meets your needs, and if not, write your own and share it with the community!&lt;/p&gt;
    &lt;p&gt;In addition to the formal consumption algorithms, it’s worth looking through the definitions of the microformats vocabularies you’re using (as well as testing with real-world data) and adding support for properties or publishing techniques you might not have thought of the first time around. Some examples to get you started:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;If an h-card has no valid &lt;code&gt;photo&lt;/code&gt;, see if there’s a valid&lt;code&gt;logo&lt;/code&gt;you can use instead&lt;/item&gt;
      &lt;item&gt;When presenting a h-entry with a featured photo, check both the &lt;code&gt;photo&lt;/code&gt;property and the&lt;code&gt;featured&lt;/code&gt;property, as one or the other might be used in different scenarios&lt;/item&gt;
      &lt;item&gt;When dealing with address or location data (e.g. on an h-card, h-entry or h-event), be aware that either might be present in various different forms. Co-ordinates might be separate &lt;code&gt;latitude&lt;/code&gt;and&lt;code&gt;longitude&lt;/code&gt;properties, a combined plaintext&lt;code&gt;geo&lt;/code&gt;property, or an embedded&lt;code&gt;h-geo&lt;/code&gt;. Addresses might be separate top-level properties or an embedded h-adr. There are many variations which are totally valid to publish, and your consuming code should be as liberal as possible in what it accepts.&lt;/item&gt;
      &lt;item&gt;If a h-entry contains images which are marked up with &lt;code&gt;u-photo&lt;/code&gt;within the&lt;code&gt;e-content&lt;/code&gt;, they’ll be present both in the&lt;code&gt;content&lt;/code&gt;&lt;code&gt;html&lt;/code&gt;key and also under the&lt;code&gt;photo&lt;/code&gt;property. If your app shows the embedded&lt;code&gt;content&lt;/code&gt;HTML rather than using the plaintext version, and also supports&lt;code&gt;photo&lt;/code&gt;properties (which may also be present outside the&lt;code&gt;content&lt;/code&gt;), you may have to sniff the presence of photos within the&lt;code&gt;content&lt;/code&gt;, and either remove them from it or ignore the corresponding&lt;code&gt;photo&lt;/code&gt;properties to avoid showing photos twice.&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h2"&gt;Sanitise, Validate, and Truncate&lt;/head&gt;
    &lt;p&gt;In the vast majority of cases, consuming microformats 2 data involves handling, storing and potentially re-publishing untrusted and potentially dangerous input data. Preventing XSS and other attacks is out of the scope of the microformats parsing algorithm, so the data your parser gives you is just as dangerous as the original source. You need to take your own measures for sanitising and truncating it so you can store and display it safely.&lt;/p&gt;
    &lt;p&gt;Covering every possible injection and XSS attack is out of the scope of this article, so I highly recommend referring to the OWASP resources on XSS Prevention, Unicode Attacks and Injection Attacks for more information.&lt;/p&gt;
    &lt;p&gt;Other than that, the following ideas are a good start:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Use plaintext values where possible, only using embedded HTML when absolutely necessary&lt;/item&gt;
      &lt;item&gt;Pass everything (HTML or not) through a well-respected HTML sanitizer such as PHP’s HTML Purifier. Configure it to make sure that embedded HTML can’t interfere with your own markup or CSS. It probably shouldn’t contain any javascript ever, either.&lt;/item&gt;
      &lt;item&gt;In any case where you’re expecting a value with a specific format, validate it as appropriate.&lt;/item&gt;
      &lt;item&gt;More specifically, everywhere that you expect a URL, check that what you got was actually a URL. If you’re using the URL as an image, consider fetching it an checking its content type&lt;/item&gt;
      &lt;item&gt;Consider either proxying resource such as images, or storing local copies of them (reducing size and resolution as necessary), to avoid mixed content issues, potential attacks, and missing images if the links break in the future.&lt;/item&gt;
      &lt;item&gt;Decide on relevant maximum length values for each separate piece of external content, and truncate them as necessary. Ideally, use a language-aware truncation algorithm to avoid breaking words apart. When the content of a post is truncated, consider adding a “Read More” link for convenience.&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h2"&gt;Test with Real-World Data&lt;/head&gt;
    &lt;p&gt;The web is a diverse place, and microformats are a flexible, permissive method of marking up structured data. There are often several different yet perfectly valid ways to achieve the same goal, and as a good consumer of mf2 data, your application should strive to accept as many of them as possible!&lt;/p&gt;
    &lt;p&gt;The best way to test this is with real world data. If your application is built with a particular source of data in mind, then start off with testing it against that. If you want to be able to handle a wider variety of sources, the best way is to determine what vocabularies and publishing use-cases your application consumes, and look at the Examples sections of the relevant indieweb.org wiki pages for real-world sites to test your code against.&lt;/p&gt;
    &lt;p&gt;Don’t forget to test your code against examples you’ve published on your own personal site!&lt;/p&gt;
    &lt;head rend="h2"&gt;Next Steps&lt;/head&gt;
    &lt;p&gt;Hopefully this article helped you avoid a lot of common gotchas, and gave you a good head-start towards successfully consuming real-world microformats 2 data.&lt;/p&gt;
    &lt;p&gt;If you have questions or issues, or want to share something cool you’ve built, come and join us in the indieweb chat room.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=45473357</guid><pubDate>Sat, 04 Oct 2025 13:58:00 +0000</pubDate></item><item><title>It's just a virus, the E.R. told him – days later, he was dead</title><link>https://www.nytimes.com/2025/10/05/well/sam-terblanche-virus-death-columbia.html</link><description></description><guid isPermaLink="false">https://news.ycombinator.com/item?id=45487519</guid><pubDate>Mon, 06 Oct 2025 03:57:26 +0000</pubDate></item><item><title>Compiling a Forth</title><link>https://healeycodes.com/compiling-a-forth</link><description>&lt;doc fingerprint="22047e11e047ab00"&gt;
  &lt;main&gt;
    &lt;p&gt;I was curious how Forth worked so I built a bytecode compiler and a VM for a Forth-like language, as well as some visualizations to show how it all works.&lt;/p&gt;
    &lt;p&gt;You don't need to know anything about Forth to follow along, aside from the fact it's a stack-oriented language.&lt;/p&gt;
    &lt;p&gt;Here's a small program that prints the number three.&lt;/p&gt;
    &lt;quote&gt;3 .&lt;/quote&gt;
    &lt;p&gt;The number (&lt;code&gt;3&lt;/code&gt;) is pushed to the data stack, and then the dot (&lt;code&gt;.&lt;/code&gt;) pops it from the data stack and prints it.&lt;/p&gt;
    &lt;p&gt;We'll need more Forth features than this to build interesting programs.&lt;/p&gt;
    &lt;p&gt;Forth has two built-in stacks. The data stack (sometimes just called "the stack") and the return stack. When a word is called in Forth (words are like functions) the address of the next instruction is pushed to the return stack. When the word finishes executing, the return stack is popped into the instruction pointer.&lt;/p&gt;
    &lt;quote&gt;\ (1) word declaration: PRINT10\ (3) the word body is executed10 .\ (4) ";" compiles an exit – at runtime it pops the return stack\ into the instruction pointer.;\ (2) instruction pointer lands on a word,\ the next address is pushed to the return stack,\ and the instruction pointer is set to the word addressPRINT10\ (5) next address is executed&lt;/quote&gt;
    &lt;p&gt;As well as words, my compiler also supports &lt;code&gt;DO&lt;/code&gt;/&lt;code&gt;LOOP&lt;/code&gt;s. These use the return stack too. When &lt;code&gt;DO&lt;/code&gt; executes, it pops the limit and the iterator from the data stack and stores them in the return stack. This allows the inner loop to freely operate on the data stack. When &lt;code&gt;LOOP&lt;/code&gt; executes, it pops the limit and iterator from the return stack, adds one to the iterator and compares it to the limit (and exits or loops again).&lt;/p&gt;
    &lt;p&gt;There are also variables, which can be declared with &lt;code&gt;VARIABLE X&lt;/code&gt;, loaded with &lt;code&gt;X @&lt;/code&gt;, and stored with &lt;code&gt;1 X !&lt;/code&gt;.&lt;/p&gt;
    &lt;p&gt;Putting these features together, here's how you can build &lt;code&gt;10&lt;/code&gt; by adding &lt;code&gt;1&lt;/code&gt; repeatedly.&lt;/p&gt;
    &lt;quote&gt;VARIABLE A: RUN0 A ! \ initialize A10 0 DO \ push limit and iterator for DO\ DO places these on the return stackA @ 1 + A ! \ A = A + 1LOOP \ increment i and exits when i == limitA @ . \ prints 10;RUN&lt;/quote&gt;
    &lt;p&gt;This set of features is enough for us to calculate numbers from the Fibonacci series, which is the example program I'll be using throughout the rest of this post.&lt;/p&gt;
    &lt;head rend="h2"&gt;Tokenizing&lt;/head&gt;
    &lt;p&gt;Tokenization translates raw text into meaningful symbols.&lt;/p&gt;
    &lt;p&gt;To turn source code into tokens, we scan through the code, skipping over whitespace and appending tokens to a list. Syntax that's a single character is turned straight into a token but multi-character syntax needs to be grouped together. For example, entire comments are discarded, and while they are being discarded, we need to track that we're "within" a comment.&lt;/p&gt;
    &lt;p&gt;Identifiers, like keywords like &lt;code&gt;DO&lt;/code&gt; or &lt;code&gt;LOOP&lt;/code&gt;, or custom variables like &lt;code&gt;MYLONGVAR&lt;/code&gt;, become single tokens.&lt;/p&gt;
    &lt;p&gt;First, a visualization of what's happening:&lt;/p&gt;
    &lt;p&gt;And here's a trimmed version of my tokenizer:&lt;/p&gt;
    &lt;quote&gt;function tokenize(source: string): Token[] {const tokens: Token[] = [];let index = 0;while (index &amp;lt; source.length) {// Consume and discard everything on a line after '\'if (source[index] === "\\") {const commentStart = index;while (index &amp;lt; source.length &amp;amp;&amp;amp; source[index] !== "\n") {index++;}index++;continue;}// Skip over whitespaceif (isWhitespace(source[index])) {index++;continue;}if (source[index] === "@") {tokens.push({ type: "load" });index++;continue;}// Handle identifiersif (isLetter(source[index])) {const start = index;let value = "";while (isLetter(source[index])) {value += source[index];index++;}// Special-case the keywordsif (value === "DO") {tokens.push({ type: "do" });continue;}if (value === "LOOP") {tokens.push({ type: "loop" });continue;}tokens.push({ type: "identifier", value });continue;}// .. trimmed other tokens, see source}return tokens;}&lt;/quote&gt;
    &lt;p&gt;With our list of tokens, we're ready to start generating bytecode for the VM.&lt;/p&gt;
    &lt;head rend="h2"&gt;Generating Bytecode&lt;/head&gt;
    &lt;p&gt;Usually, in a compiler, the step after tokenization is called parsing where an abstract syntax tree is built. However, the feature set of my Forth is so small, that I decided to generate bytecode directly from the list of tokens.&lt;/p&gt;
    &lt;p&gt;After bytecode generation, my VM needs two things:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;A list of operations for the VM's instruction pointer to navigate&lt;/item&gt;
      &lt;item&gt;The number of variables that the program refers to&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The latter tells the VM how many variables to allocate (a zero-initialized array). Variables in source (e.g., &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;) become integer indices into this array.&lt;/p&gt;
    &lt;p&gt;This means that my bytecode generation step needs to keep track of variables that have been seen before so that I can output the correct memory address (i.e. an index into the variable table).&lt;/p&gt;
    &lt;p&gt;I'll show the full list of bytecode operations and then a few of the steps for handling specific tokens.&lt;/p&gt;
    &lt;quote&gt;type Op = {op: "lit", // Push value or address to DSvalue: number;} | {op: "load", // Pop address from DS, push value at address} | {op: "store", // Pop address from DS, pop value from DS, store value at address} | {op: "dup2", // Duplicate top two values on DS [a, b] -&amp;gt; [a, b, a, b]} | {op: "add", // Pop top two values from DS, push sum to DS} | {op: "eq", // Pop top two values from DS, push 1 if equal, 0 if not} | {op: "jz", // Pop value from DS, if zero, jump to addressaddress: number;} | {op: "jmp", // Jump to addressaddress: number;} | {op: "call", // Push IP to RS, jump to addressaddress: number;} | {op: "ret", // Pop IP from RS, jump to IP} | {op: "rs_push", // Pop from DS, push to RS} | {op: "rs_pop", // Pop from RS, push to DS} | {op: "drop", // Discard top value from DS} | {op: "print", // Pop value from DS, print it}&lt;/quote&gt;
    &lt;p&gt;The bytecode generation step scans through the list of tokens and, as it processes them, it appends to a list of bytecode and increments the variable count to set up the correct references.&lt;/p&gt;
    &lt;p&gt;Identifier tokens are either variable references, or words (function calls).&lt;/p&gt;
    &lt;quote&gt;function compile(tokens: Token[]) {// Bytecode that runs in the VMconst bytecode: Bytecode[] = [];// Word -&amp;gt; bytecode offsets (for calls)const wordTable: { [key: string]: number } = {};// Variable -&amp;gt; memory addressconst variableTable: { [key: string]: number } = {};// ..let index = 0;while (index &amp;lt; tokens.length) {const token = tokens[index];if (token.type === "identifier") {if (token.value === "VARIABLE") {const nextToken = tokens[index + 1];// Store a binding of variable name to memory addressvariableTable[nextToken.value] = Object.keys(variableTable).length;index += 2;continue;}// If the variable has been declared as a word like `: FIB10`// then we have previously stored the bytecode offset which we// will set the instruction pointer to at runtimeif (wordTable[token.value] !== undefined) {bytecode.push({ op: "call", address: wordTable[token.value] });index++;continue;}// If it's not a variable declaration, or a word, then we// look up the memory addressbytecode.push({ op: "lit", value: variableTable[token.value] });index++;continue;}// ..&lt;/quote&gt;
    &lt;p&gt;Setting up the &lt;code&gt;DO&lt;/code&gt;/&lt;code&gt;LOOP&lt;/code&gt; bytecode generation was the trickiest part of this project. It's a minefield of possible off-by-one errors. It's also not easy to read and understand but I've chosen to put it here anyway because even just glancing over it should help you understand how the loop variables (limit, iterator) and instruction pointer jumps are combined to execute loops in Forth.&lt;/p&gt;
    &lt;quote&gt;// .. still inside compile()if (token.type === "do") {index++;// Expect: DS has [limit, start] (start is top)// Move both to RS: start then limit (RS top becomes limit)bytecode.push({ op: "rs_push" }) // start -&amp;gt; RSbytecode.push({ op: "rs_push" }) // limit -&amp;gt; RS// Mark first instruction of loop bodyloopStart.push(bytecode.length);continue;}if (token.type === "loop") {// Pop limit and i from RS (RS top is limit)bytecode.push({ op: "rs_pop" }) // limit -&amp;gt; DSbytecode.push({ op: "rs_pop" }) // i -&amp;gt; DS// Increment ibytecode.push({ op: "lit", value: 1 })bytecode.push({ op: "add" }) // i on DS// Duplicate i and limit for compare and possible restorebytecode.push({ op: "dup2" })bytecode.push({ op: "eq" }) // eq flag on DSconst loopStartAddress = loopStart.pop(); // first instr of loop body// Branch: continue when not equal (eq==0), exit when equalconst continueAddress = bytecode.length + 4; // skip equal-path (2 drops + jmp)bytecode.push({ op: "jz", address: continueAddress })// Equal path (fallthrough): cleanup and exitbytecode.push({ op: "drop" }) // drop ibytecode.push({ op: "drop" }) // drop limitconst afterBlockAddress = bytecode.length + 1 /* jmp */ + 3 /* continue block */;bytecode.push({ op: "jmp", address: afterBlockAddress })// Continue path:// address == continueAddressbytecode.push({ op: "rs_push" }) // i -&amp;gt; RS (top)bytecode.push({ op: "rs_push" }) // limit -&amp;gt; RSbytecode.push({ op: "jmp", address: loopStartAddress })index++;continue;}// .. trimmed other tokens, see source&lt;/quote&gt;
    &lt;p&gt;The rest of the token branches are more straightforward. Tokens like dot, store, load, and print all map directly to bytecode operations.&lt;/p&gt;
    &lt;p&gt;The colon token branch sets the bytecode offset for the word name which allows identifiers to become word calls as we saw above.&lt;/p&gt;
    &lt;p&gt;Now we've earned a visualization break.&lt;/p&gt;
    &lt;head rend="h2"&gt;VM&lt;/head&gt;
    &lt;p&gt;Writing the VM felt a little bit like dessert. Manually stepping through the bytecode as I worked on the generation logic gave me fairly good confidence that I was heading in the right direction, I only came across one or two off-by-one bugs when putting the VM together. Essentially, I had designed it ahead-of-time.&lt;/p&gt;
    &lt;p&gt;The VM scans through the bytecode operations using the instruction pointer (which starts at &lt;code&gt;0&lt;/code&gt;). The instruction pointer can jump around as it encounters &lt;code&gt;jmp&lt;/code&gt; (jump to offset) or &lt;code&gt;jz&lt;/code&gt; (conditional jump).&lt;/p&gt;
    &lt;p&gt;It manages the data stack, return stack, and the variable table (i.e. memory addresses).&lt;/p&gt;
    &lt;p&gt;Here's a trimmed version of the VM:&lt;/p&gt;
    &lt;quote&gt;function vm(program: Program) =&amp;gt; {const dataStack: number[] = [];const returnStack: number[] = [];const variableTable: number[] = new Array(program.variableCount).fill(0);let ip = 0;while (ip &amp;lt; program.bytecode.length) {const cur = program.bytecode[ip];if (cur.op === "lit") {dataStack.push(cur.value); // Literal or memory addressip++;continue;} else if (cur.op === "store") {const address = dsPop();const value = dsPop();variableTable[address] = value;ip++;continue;} else if (cur.op === "jmp") {ip = cur.address;continue;} else if (cur.op === "jz") {if (dsPop() === 0) {ip = cur.address;continue;}ip++;continue;} else if (cur.op === "call") {ip++returnStack.push(ip);ip = cur.address;continue;} else if (cur.op === "ret") {ip = rsPop();continue;}// .. trimmed other ops, see source}}&lt;/quote&gt;
    &lt;p&gt;The code for my compiler and VM are embedded in this website. I've been iterating on it by just running the TypeScript file:&lt;/p&gt;
    &lt;quote&gt;bun ./components/visuals/forth/components.tsx55 # 10th Fibonacci number&lt;/quote&gt;
    &lt;p&gt;The visuals are React components with sleeps. In order to display the progress of the different steps (tokenizing, bytecode generation, VM), I first got each working and then added a callback which takes the current data and then sleeps.&lt;/p&gt;
    &lt;p&gt;So the VM function is actually async and accepts this callback:&lt;/p&gt;
    &lt;quote&gt;// VMasync function vm(program: Program, callback:(highlight: { ip: number },dataStack: number[],returnStack: number[],variableTable: number[]) =&amp;gt; Promise&amp;lt;void&amp;gt;) {// .. inside VM loopawait callback({ ip }, dataStack, returnStack, variableTable);// ..}&lt;/quote&gt;
    &lt;p&gt;And the component calls it and passes &lt;code&gt;setState&lt;/code&gt; functions:&lt;/p&gt;
    &lt;quote&gt;// Componentexport function VM() {// .. inside useEffectawait vm(program, async (highlight, newDataStack, newReturnStack, newVariableTable) =&amp;gt; {setHighlightIP(highlight.ip);setDataStack([...newDataStack]);setReturnStack([...newReturnStack]);setVariableTable([...newVariableTable]);await new Promise(resolve =&amp;gt; setTimeout(resolve, 500));});// ..}&lt;/quote&gt;
    &lt;p&gt;For the Forth code snippets in this post, I had to write a Prism plugin to get syntax highlighting working. Now that I've learned how to do this, I'll be using this method for syntax highlighting for the more esoteric (or, original) programming languages I write about!&lt;/p&gt;
    &lt;head rend="h2"&gt;Discrepancies&lt;/head&gt;
    &lt;p&gt;I described my compiler/VM as Forth-like because it's a little bit different from how Forth works.&lt;/p&gt;
    &lt;p&gt;My implementation compiles to bytecode ahead-of-time. Forth is traditionally interactive. Words are interpreted and executed as they are entered, and only colon definitions are compiled. Forth uses threaded code where words contain lists of addresses pointing to other words instead of a different bytecode offset.&lt;/p&gt;
    &lt;p&gt;Real Forth uses a dynamic dictionary that can be altered at runtime with new variables or word definitions. As I mentioned earlier, my word bodies are compiled with jump-over logic in the main execution stream. Also, my variables compile to &lt;code&gt;lit address&lt;/code&gt; operations but real Forth variables return their address when executed directly.&lt;/p&gt;
    &lt;p&gt;These are just a few of the differences but I feel like my Forth-like compiler and VM capture enough of the spirit of Forth!&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=45491470</guid><pubDate>Mon, 06 Oct 2025 13:52:50 +0000</pubDate></item><item><title>Show HN: Kent Dybvig's Scheme Machine in 400 Lines of C (Heap-Memory Model)</title><link>https://gist.github.com/swatson555/8cc36d8d022d7e5cc44a5edb2c4f7d0b</link><description>&lt;doc fingerprint="c5d093b93a485002"&gt;
  &lt;main&gt;
    &lt;p&gt; Created &lt;relative-time&gt;February 17, 2023 12:42&lt;/relative-time&gt;&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;
        &lt;tool-tip&gt;Save swatson555/8cc36d8d022d7e5cc44a5edb2c4f7d0b to your computer and use it in GitHub Desktop.&lt;/tool-tip&gt;
      &lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt; Heap based scheme machine. &lt;/p&gt;
    &lt;p&gt; This file contains hidden or bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters &lt;/p&gt;
    &lt;table&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;/* Heap based virtual machine described in section 3.4 of Three Implementation Models for Scheme, Dybvig&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;*/&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;#include &amp;lt;string.h&amp;gt;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;#include &amp;lt;ctype.h&amp;gt;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;#include &amp;lt;assert.h&amp;gt;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;char token[128][32];&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;int lexer(char* input) {&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;int ii = 0; // input index&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;int ti = 0; // token index&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;while(input[ii] != '\0')&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;switch(input[ii]) {&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;// Ignore whitespace and newlines&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;case ' ':&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;case '\n':&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;++ii;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;break;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;// Turn a left parenthesis into a token.&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;case '(':&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;token[ti][0] = '(';&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;token[ti][1] = '\0';&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;++ii;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;++ti;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;break;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;// Turn a right parenthesis into a token.&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;case ')':&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;token[ti][0] = ')';&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;token[ti][1] = '\0';&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;++ii;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;++ti;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;break;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;// Turn an apostrophe into a token.&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;case '\'':&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;token[ti][0] = '\'';&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;token[ti][1] = '\0';&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;++ii;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;++ti;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;break;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;// Anything else is a symbol&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;default:&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;for(int i = 0;; ++i) {&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;if(input[ii] != ' ' &amp;amp;&amp;amp;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;input[ii] != ')' &amp;amp;&amp;amp;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;input[ii] != '(' &amp;amp;&amp;amp;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;input[ii] != '\n' &amp;amp;&amp;amp;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;input[ii] != '\0') {&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;token[ti][i] = input[ii++];&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;}&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;else {&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;token[ti][i] = '\0';&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;break;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;}&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;}&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;++ti;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;break;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;}&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;return ti;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;}&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;int curtok;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;char* nexttok() {&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;return token[curtok++];&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;}&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;char* peektok() {&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;return token[curtok];&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;}&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;typedef struct Pair {&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;void* car;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;void* cdr;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;} Pair;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;typedef struct Text {&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;char* car;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;struct Text* cdr;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;} Text;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;Pair text[1280];&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;Pair* textptr;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;int istext(void* x) {&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;return x &amp;gt;= (void*)&amp;amp;text &amp;amp;&amp;amp;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;x &amp;lt; (void*)&amp;amp;text[1280];&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;}&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;Pair* cons(void* x, void* y) {&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;assert(istext(textptr));&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;textptr-&amp;gt;car = x;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;textptr-&amp;gt;cdr = y;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;return textptr++;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;}&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;void* read(char* ln);&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;void* read_exp();&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;void* read_list();&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;void* read(char* ln) {&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;// Initialize the lexer and list memory.&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;curtok = 0;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;textptr = text;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;lexer(ln);&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;return read_exp();&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;}&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;void* read_exp() {&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;char* tok = nexttok();&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;if (tok[0] == '(' &amp;amp;&amp;amp; peektok()[0] == ')') {&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;nexttok();&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;return NULL;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;}&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;else if (tok[0] == '\'')&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;return cons("quote", cons(read_exp(), NULL));&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;else if (tok[0] == '(')&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;return read_list();&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;else&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;return tok;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;}&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;void* read_list() {&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;char* tok = peektok();&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;if(tok[0] == ')') {&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;nexttok();&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;return NULL;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;}&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;else if(tok[0] == '.') {&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;nexttok();&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;tok = read_exp();&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;nexttok();&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;return tok;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;}&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;else {&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;void* fst = read_exp();&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;void* snd = read_list();&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;return cons(fst, snd);&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;}&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;}&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;void print(void* exp);&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;void print_exp(void* exp);&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;void print_list(Pair* list);&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;void print_cons(Pair* pair);&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;void print(void* exp) {&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;print_exp(exp);&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;printf("\n");&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;}&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;void print_exp(void* exp) {&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;if (istext(exp)) {&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;Pair* pair = exp;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;if(!istext(pair-&amp;gt;cdr) &amp;amp;&amp;amp; pair-&amp;gt;cdr != NULL) {&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;printf("(");&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;print_cons(exp);&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;printf(")");&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;}&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;else {&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;printf("(");&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;print_list(exp);&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;}&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;}&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;else&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;printf("%s", exp ? (char*)exp : "()");&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;}&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;void print_list(Pair* list) {&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;if (list-&amp;gt;cdr == NULL) {&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;print_exp(list-&amp;gt;car);&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;printf(")");&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;}&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;else {&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;if(!istext(list-&amp;gt;cdr) &amp;amp;&amp;amp; list-&amp;gt;cdr != NULL) {&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;print_cons(list);&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;printf(")");&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;}&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;else {&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;print_exp(list-&amp;gt;car);&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;printf(" ");&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;print_list(list-&amp;gt;cdr);&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;}&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;}&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;}&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;void print_cons(Pair* pair) {&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;print_exp(pair-&amp;gt;car);&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;printf(" . ");&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;print_exp(pair-&amp;gt;cdr);&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;}&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;Pair* compile(void* exp, void* next) {&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;if (istext(exp)) {&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;Text* p = exp;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;if (strcmp(p-&amp;gt;car, "quote") == 0) {&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;return cons("constant", cons(p-&amp;gt;cdr-&amp;gt;car, cons(next, NULL)));&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;}&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;else if (strcmp(p-&amp;gt;car, "lambda") == 0) {&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;return cons("close", cons(p-&amp;gt;cdr-&amp;gt;car, cons(compile(p-&amp;gt;cdr-&amp;gt;cdr-&amp;gt;car, cons("return", NULL)), cons(next, NULL))));&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;}&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;else if (strcmp(p-&amp;gt;car, "if") == 0) {&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;return compile(p-&amp;gt;cdr-&amp;gt;car, cons("test", cons(compile(p-&amp;gt;cdr-&amp;gt;cdr-&amp;gt;car, next),&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;cons(compile(p-&amp;gt;cdr-&amp;gt;cdr-&amp;gt;cdr-&amp;gt;car, next),&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;NULL))));&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;}&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;else if (strcmp(p-&amp;gt;car, "set!") == 0) {&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;return compile(p-&amp;gt;cdr-&amp;gt;cdr-&amp;gt;car, cons("assign", cons(p-&amp;gt;cdr-&amp;gt;car, cons(next, NULL))));&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;}&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;else if (strcmp(p-&amp;gt;car, "call/cc") == 0) {&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;void* c = cons("conti", cons(cons("argument", cons(compile(p-&amp;gt;cdr-&amp;gt;car, cons("apply", NULL)), NULL)), NULL));&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;Text* n = next;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;if (strcmp(n-&amp;gt;car, "return") == 0)&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;return c;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;else&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;return cons("frame", cons(next, cons(c, NULL)));&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;}&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;else {&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;Pair* args = (Pair*)p-&amp;gt;cdr;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;void* c = compile(p-&amp;gt;car, cons("apply", NULL));&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;while (args) {&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;c = compile(args-&amp;gt;car, cons("argument", cons(c, NULL)));&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;args = args-&amp;gt;cdr;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;}&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;Text* n = next;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;if (strcmp(n-&amp;gt;car, "return") == 0)&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;return c;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;else&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;return cons("frame", cons(next, cons(c, NULL)));&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;}&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;}&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;else if(isdigit(*((char*)exp))) { // a number&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;return cons("constant", cons(exp, cons(next, NULL)));&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;}&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;else if(strcmp(exp, "#t") == 0) { // a boolean&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;return cons("constant", cons(exp, cons(next, NULL)));&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;}&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;else if(strcmp(exp, "#f") == 0) { // a boolean&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;return cons("constant", cons(exp, cons(next, NULL)));&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;}&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;else { // a symbol&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;return cons("refer", cons(exp, cons(next, NULL)));&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;}&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;}&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;void* get(void* env, char* var) {&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;Pair* e = env;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;while(env) {&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;Pair* cur = e-&amp;gt;car;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;Pair* vars = cur-&amp;gt;car;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;Pair* vals = cur-&amp;gt;cdr;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;while (vars &amp;amp;&amp;amp; vals) {&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;if (strcmp(vars-&amp;gt;car, var) == 0)&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;return vals-&amp;gt;car;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;vars = vars-&amp;gt;cdr;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;vals = vals-&amp;gt;cdr;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;}&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;e = e-&amp;gt;cdr;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;}&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;fprintf(stderr, "No definition in environment for %s.\n", var);&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;assert(0);&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;}&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;void set(void* env, char* var, char* val) {&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;void* ref = get(env, var);&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;ref = val;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;}&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;void* extend(void* env, void* vars, void* vals) {&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;return cons(cons(vars, vals), env);&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;}&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;void* callframe(void* next, void* env, void* rib, void* stack) {&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;return cons(next, cons(env, cons(rib, cons(stack, NULL))));&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;}&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;void* closure(void* body, void* env, void* vars) {&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;return cons(body, cons(env, cons(vars, NULL)));&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;}&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;void* continuation(void* stack) {&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;return closure(cons("nuate", cons(stack, cons("v", NULL))), NULL, cons("v", NULL));&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;}&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;void* accum;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;void* next;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;void* env;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;void* rib;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;void* stack;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;void virtmach() {&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;Text* n = next;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;if (strcmp(n-&amp;gt;car, "halt") == 0) {&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;}&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;else if (strcmp(n-&amp;gt;car, "refer") == 0) {&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;accum = get(env, n-&amp;gt;cdr-&amp;gt;car);&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;next = n-&amp;gt;cdr-&amp;gt;cdr-&amp;gt;car;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;return virtmach();&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;}&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;else if (strcmp(n-&amp;gt;car, "constant") == 0) {&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;accum = n-&amp;gt;cdr-&amp;gt;car;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;next = n-&amp;gt;cdr-&amp;gt;cdr-&amp;gt;car;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;return virtmach();&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;}&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;else if (strcmp(n-&amp;gt;car, "close") == 0) {&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;void* vars = n-&amp;gt;cdr-&amp;gt;car;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;void* body = n-&amp;gt;cdr-&amp;gt;cdr-&amp;gt;car;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;void* x = n-&amp;gt;cdr-&amp;gt;cdr-&amp;gt;cdr-&amp;gt;car;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;accum = closure(body, env, vars);&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;next = x;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;return virtmach();&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;}&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;else if (strcmp(n-&amp;gt;car, "test") == 0) {&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;void* consequent = n-&amp;gt;cdr-&amp;gt;car;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;void* alternate = n-&amp;gt;cdr-&amp;gt;cdr-&amp;gt;car;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;next = strcmp(accum, "#f") == 0 ? alternate : consequent;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;return virtmach();&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;}&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;else if (strcmp(n-&amp;gt;car, "assign") == 0) {&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;set(env, n-&amp;gt;cdr-&amp;gt;car, accum);&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;next = n-&amp;gt;cdr-&amp;gt;cdr-&amp;gt;car;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;return virtmach();&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;}&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;else if (strcmp(n-&amp;gt;car, "conti") == 0) {&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;accum = continuation(stack);&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;next = n-&amp;gt;cdr-&amp;gt;car;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;return virtmach();&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;}&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;else if (strcmp(n-&amp;gt;car, "nuate") == 0) {&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;stack = n-&amp;gt;cdr-&amp;gt;car;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;accum = get(env, n-&amp;gt;cdr-&amp;gt;cdr-&amp;gt;car);&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;next = cons("return", NULL);&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;return virtmach();&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;}&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;else if (strcmp(n-&amp;gt;car, "frame") == 0) {&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;stack = callframe(n-&amp;gt;cdr-&amp;gt;car, env, rib, stack);&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;rib = NULL;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;next = n-&amp;gt;cdr-&amp;gt;cdr-&amp;gt;car;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;return virtmach();&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;}&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;else if (strcmp(n-&amp;gt;car, "argument") == 0) {&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;rib = cons(accum, rib);&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;next = n-&amp;gt;cdr-&amp;gt;car;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;return virtmach();&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;}&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;else if (strcmp(n-&amp;gt;car, "apply") == 0) {&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;Text* a = accum;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;void* body = a-&amp;gt;car;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;void* clos = a-&amp;gt;cdr-&amp;gt;car;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;void* vars = a-&amp;gt;cdr-&amp;gt;cdr-&amp;gt;car;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;env = extend(env, vars, rib);&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;rib = NULL;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;next = body;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;return virtmach();&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;}&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;else if (strcmp(n-&amp;gt;car, "return") == 0) {&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;Text* s = stack;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;next = s-&amp;gt;car;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;env = s-&amp;gt;cdr-&amp;gt;car;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;rib = s-&amp;gt;cdr-&amp;gt;cdr-&amp;gt;car;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;stack = s-&amp;gt;cdr-&amp;gt;cdr-&amp;gt;cdr-&amp;gt;car;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;return virtmach();&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;}&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;else {&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;fprintf(stderr, "Unhandled operation.\n");&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;assert(0);&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;}&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;}&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;int main(int argc, char** argv) {&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;// note! repl implies there's a top-level but there isn't...&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;printf("Lisp REPL\n\n");&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;printf("&amp;gt;&amp;gt; ");&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;char buffer[256];&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;while (fgets(buffer, 256, stdin)) {&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;next = compile(read(buffer), cons("halt", NULL));&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;virtmach();&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;print(accum);&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;printf("&amp;gt;&amp;gt; ");&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;}&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;return 0;&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;cell&gt;}&lt;/cell&gt;
      &lt;/row&gt;
    &lt;/table&gt;
    &lt;p&gt; Sign up for free to join this conversation on GitHub. Already have an account? Sign in to comment &lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=45491609</guid><pubDate>Mon, 06 Oct 2025 14:06:29 +0000</pubDate></item><item><title>Mise: Monorepo Tasks</title><link>https://github.com/jdx/mise/discussions/6564</link><description>&lt;doc fingerprint="6c502c738fd7a4ba"&gt;
  &lt;main&gt;
    &lt;head rend="h1"&gt;Introducing Monorepo Tasks #6564&lt;/head&gt;
    &lt;p&gt;-&lt;/p&gt;
    &lt;table&gt;
      &lt;row&gt;
        &lt;cell&gt;
          &lt;p&gt;We're excited to announce Monorepo Tasks, a powerful new feature that brings first-class monorepo support to mise tasks! 🚀&lt;/p&gt;
          &lt;head&gt;What is it?&lt;/head&gt;
          &lt;p&gt;Monorepo Tasks allows you to manage tasks across multiple projects in a single repository, with each project maintaining its own tools, environment variables, and tasks. Think of it as bringing the power of tools like Bazel or Turborepo to mise's task system, but with mise's signature simplicity.&lt;/p&gt;
          &lt;head&gt;Key Features&lt;/head&gt;
          &lt;head&gt;🎯 Unified Task Namespace&lt;/head&gt;
          &lt;p&gt;All tasks across your monorepo are automatically discovered and prefixed with their location:&lt;/p&gt;
          &lt;code&gt;mise //projects/frontend:build
mise //projects/backend:test
mise //services/api:deploy&lt;/code&gt;
          &lt;head&gt;🌳 Smart Tool &amp;amp; Environment Inheritance&lt;/head&gt;
          &lt;p&gt;Define common tools at the root, override them where needed:&lt;/p&gt;
          &lt;code&gt;# Root mise.toml
[tools]
node = "20"      # Inherited everywhere
python = "3.12"

# projects/legacy-app/mise.toml
[tools]
node = "14"      # Override just for this project
# python still inherited!&lt;/code&gt;
          &lt;head&gt;🎭 Powerful Wildcard Patterns&lt;/head&gt;
          &lt;p&gt;Run tasks across multiple projects with ease:&lt;/p&gt;
          &lt;code&gt;# Run tests in ALL projects
mise //...:test

# Run all build tasks under services/
mise //services/...:build

# Run ALL tasks in frontend (wildcards need quotes)
mise '//projects/frontend:*'

# Run all test:* tasks everywhere
mise '//...:test:*'&lt;/code&gt;
          &lt;head&gt;✨ Consistent Execution Anywhere&lt;/head&gt;
          &lt;p&gt;Run tasks from anywhere in the monorepo - they always execute with the correct context, tools, and environment from their config_root.&lt;/p&gt;
          &lt;head&gt;🔒 Automatic Trust Propagation&lt;/head&gt;
          &lt;p&gt;Trust your monorepo root once, and all descendant configs are automatically trusted.&lt;/p&gt;
          &lt;head&gt;Quick Start&lt;/head&gt;
          &lt;p&gt;1. Enable the feature in your root &lt;/p&gt;
          &lt;code&gt;experimental_monorepo_root = true

[tools]
node = "20"
python = "3.12"&lt;/code&gt;
          &lt;p&gt;2. Set the experimental flag:&lt;/p&gt;
          &lt;code&gt;export MISE_EXPERIMENTAL=1&lt;/code&gt;
          &lt;p&gt;3. Add tasks to your projects:&lt;/p&gt;
          &lt;code&gt;# projects/frontend/mise.toml
[tasks.build]
run = "npm run build"

[tasks.test]
run = "npm test"&lt;/code&gt;
          &lt;p&gt;4. Run tasks from anywhere:&lt;/p&gt;
          &lt;code&gt;mise //projects/frontend:build
mise //...:test  # Run tests in all projects!&lt;/code&gt;
          &lt;head&gt;Example Monorepo Structure&lt;/head&gt;
          &lt;p&gt;Run all service builds: &lt;/p&gt;
          &lt;head&gt;Why This Matters&lt;/head&gt;
          &lt;p&gt;Managing monorepos is hard. Coordinating tools, tasks, and environments across dozens of projects is even harder. With Monorepo Tasks, you get:&lt;/p&gt;
          &lt;head&gt;How Does This Compare to Other Tools?&lt;/head&gt;
          &lt;p&gt;The monorepo ecosystem is rich with excellent tools, each with different strengths. Here's how mise's Monorepo Tasks compares:&lt;/p&gt;
          &lt;head&gt;Simple Task Runners&lt;/head&gt;
          &lt;p&gt;Taskfile and Just are fantastic for single-project task automation. They're lightweight and easy to set up, but they weren't designed with monorepos in mind. While you can have multiple Taskfiles/Justfiles in a repo, they don't provide unified task discovery, cross-project wildcards, or automatic tool/environment inheritance across projects.&lt;/p&gt;
          &lt;p&gt;mise's advantage: Automatic task discovery across the entire monorepo with a unified namespace and powerful wildcard patterns.&lt;/p&gt;
          &lt;head&gt;JavaScript-Focused Tools&lt;/head&gt;
          &lt;p&gt;Nx, Turborepo, and Lerna are powerful tools specifically designed for JavaScript/TypeScript monorepos.&lt;/p&gt;
          &lt;p&gt;mise's advantage: Language-agnostic support. While these tools excel in JS/TS ecosystems, mise works equally well with Rust, Go, Python, Ruby, or any mix of languages. You also get unified tool version management (not just tasks) and environment variables across your entire stack.&lt;/p&gt;
          &lt;head&gt;Large-Scale Build Systems&lt;/head&gt;
          &lt;p&gt;Bazel (Google) and Buck2 (Meta) are industrial-strength build systems designed for massive, multi-language monorepos at companies with thousands of engineers.&lt;/p&gt;
          &lt;p&gt;Both are extremely powerful but come with significant complexity:&lt;/p&gt;
          &lt;p&gt;mise's advantage: Simplicity through non-hermetic builds. mise doesn't try to control your entire build environment in isolation - instead, it manages tools and tasks in a flexible, practical way. This "non-hermetic" approach means you can use mise without restructuring your entire codebase or learning a new language. You get powerful monorepo task management with simple TOML configuration - enough power for most teams without the enterprise-level complexity that hermetic builds require.&lt;/p&gt;
          &lt;head&gt;Other Notable Tools&lt;/head&gt;
          &lt;p&gt;Rush (Microsoft) offers strict dependency management and build orchestration for JavaScript monorepos, with a focus on safety and convention adherence.&lt;/p&gt;
          &lt;p&gt;Moon is a newer Rust-based build system that aims to be developer-friendly while supporting multiple languages.&lt;/p&gt;
          &lt;head&gt;The mise Sweet Spot&lt;/head&gt;
          &lt;p&gt;mise's Monorepo Tasks aims to hit the sweet spot between simplicity and power:&lt;/p&gt;
          &lt;p&gt;When to choose mise:&lt;/p&gt;
          &lt;p&gt;When to consider alternatives:&lt;/p&gt;
          &lt;p&gt;The best tool is the one that fits your team's needs. mise's Monorepo Tasks is designed for teams who want powerful monorepo management without the complexity overhead, especially when working across multiple languages.&lt;/p&gt;
          &lt;head&gt;Try It Out!&lt;/head&gt;
          &lt;p&gt;This feature is experimental, which means:&lt;/p&gt;
          &lt;p&gt;Read the full documentation: Monorepo Tasks Guide&lt;/p&gt;
          &lt;head&gt;We Want Your Feedback!&lt;/head&gt;
          &lt;p&gt;Please try it out and let us know:&lt;/p&gt;
          &lt;p&gt;Share your experience in the comments below! 👇&lt;/p&gt;
          &lt;p&gt;Special shoutout to the mise community for the feedback and ideas that led to this feature. Happy building! 🛠️&lt;/p&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
    &lt;/table&gt;
    &lt;p&gt;Beta Was this translation helpful? Give feedback.&lt;/p&gt;
    &lt;head rend="h2"&gt;Replies: 3 comments 8 replies&lt;/head&gt;
    &lt;p&gt;-&lt;/p&gt;
    &lt;table&gt;
      &lt;row&gt;
        &lt;cell&gt;
          &lt;p&gt;Does this support &lt;/p&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
    &lt;/table&gt;
    &lt;p&gt;Beta Was this translation helpful? Give feedback.&lt;/p&gt;
    &lt;p&gt;-&lt;/p&gt;
    &lt;table&gt;
      &lt;row&gt;
        &lt;cell&gt;
          &lt;p&gt;Excited to see this! We're currently using turbo in a mixed Rust/wasm/TS/Python/Go repo, and it's been a bit of a mixed bag (admittedly, I don't know how much of that is because we're unwilling to invest effort into modelling task inputs/outputs correctly in turbo).&lt;/p&gt;
          &lt;p&gt;Compounding the issue is that what we really want a whole bunch of things out of it:&lt;/p&gt;
          &lt;p&gt;Absent these, I don't really see us adopting this anytime soon unfortunately.&lt;/p&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
    &lt;/table&gt;
    &lt;p&gt;Beta Was this translation helpful? Give feedback.&lt;/p&gt;
    &lt;p&gt;-&lt;/p&gt;
    &lt;table&gt;
      &lt;row&gt;
        &lt;cell&gt;
          &lt;p&gt;The &lt;/p&gt;
        &lt;/cell&gt;
      &lt;/row&gt;
    &lt;/table&gt;
    &lt;p&gt;Beta Was this translation helpful? Give feedback.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=45491621</guid><pubDate>Mon, 06 Oct 2025 14:07:46 +0000</pubDate></item><item><title>OpenZL: An open source format-aware compression framework</title><link>https://engineering.fb.com/2025/10/06/developer-tools/openzl-open-source-format-aware-compression-framework/</link><description>&lt;doc fingerprint="b69d42b82801cb99"&gt;
  &lt;main&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;OpenZL is a new open source data compression framework that offers lossless compression for structured data.&lt;/item&gt;
      &lt;item&gt;OpenZL is designed to offer the performance of a format-specific compressor with the easy maintenance of a single executable binary.&lt;/item&gt;
      &lt;item&gt;You can get started with OpenZL today by visiting our Quick Start guide and the OpenZL GitHub repository.&lt;/item&gt;
      &lt;item&gt;Learn more about the theory behind OpenZL in this whitepaper.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Today, we are excited to announce the public release of OpenZL, a new data compression framework. OpenZL offers lossless compression for structured data, with performance comparable to specialized compressors. It accomplishes this by applying a configurable sequence of transforms to the input, revealing hidden order in the data, which can then be more easily compressed. Despite applying distinct transformation permutations for every file type, all OpenZL files can be decompressed using the same universal OpenZL decompressor.&lt;/p&gt;
    &lt;head rend="h2"&gt;A Decade of Lessons&lt;/head&gt;
    &lt;p&gt;When Zstandard was announced, it came with a simple pitch: It promised the same or better compression ratio of prior default but at the much increased speed required by datacenter workloads. By pairing strong entropy coding with a design that fully utilized modern CPU capabilities, Zstandard offered a substantial improvement that justified its presence in datacenters.&lt;/p&gt;
    &lt;p&gt;However, while it was improved over time, remaining within the Zstandard framework offers diminishing returns. So we started looking for the next great leap in data compression.&lt;/p&gt;
    &lt;p&gt;In this quest, one pattern kept repeating: Using generic methods on structured data leaves compression gains on the table. Data isn’t just byte soup. It can be columnar, encode enums, be restricted to specific ranges, or carry highly repetitive fields. More importantly, it has predictable shapes. A bespoke compressor that leans into that structure can beat general-purpose tools on both ratio and speed. But there’s a catch — every bespoke scheme means another compressor and decompressor to create, ship, audit, patch, and trust.&lt;/p&gt;
    &lt;p&gt;OpenZL is our answer to the tension between the performance of format-specific compressors and the maintenance simplicity of a single executable binary.&lt;/p&gt;
    &lt;head rend="h2"&gt;Make the Structure Explicit&lt;/head&gt;
    &lt;p&gt;General compressors rely on a one-size fits all processing strategy, or alternatively spend a lot of their cycles guessing which techniques to use. OpenZL saves those cycles by making the structure an explicit input parameter. Compression can then focus on a sequence of reversible steps that surface patterns before coding.&lt;/p&gt;
    &lt;p&gt;As a user, you provide OpenZL with the data shape (via a preset or a thin format description). Then the trainer, an offline optimization component, builds an effective compression config that can be re-employed for similar data. During encoding that config resolves into a concrete decode recipe that’s embedded into the frame. The universal decoder will directly execute that recipe, without any out-of-band information.&lt;/p&gt;
    &lt;head rend="h2"&gt;An Example Compression Using OpenZL&lt;/head&gt;
    &lt;p&gt;As an example, let’s compress sao, which is part of the Silesia Compression Corpus. This file follows a well-defined format featuring an array of records, each one describing a star. Providing this information to OpenZL is enough to give it an edge over generic lossless compressors, which only see bytes.&lt;/p&gt;
    &lt;p&gt;Comparison on a M1 cpu, using clang-17&lt;/p&gt;
    &lt;table&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;Compressor&lt;/cell&gt;
        &lt;cell&gt;zstd -3&lt;/cell&gt;
        &lt;cell&gt;xz -9&lt;/cell&gt;
        &lt;cell&gt;OpenZL&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;Compressed Size&lt;/cell&gt;
        &lt;cell&gt;5,531,935 B&lt;/cell&gt;
        &lt;cell&gt;4,414,351 B&lt;/cell&gt;
        &lt;cell&gt;3,516,649 B&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;Compression Ratio&lt;/cell&gt;
        &lt;cell&gt;x1.31&lt;/cell&gt;
        &lt;cell&gt;x1.64&lt;/cell&gt;
        &lt;cell&gt;x2.06&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="4"&gt;
        &lt;cell&gt;Compression Speed&lt;/cell&gt;
        &lt;cell&gt;220 MB/s&lt;/cell&gt;
        &lt;cell&gt;3.5 MB/s&lt;/cell&gt;
        &lt;cell&gt;340 MB/s&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;cell&gt;Decompression Speed&lt;/cell&gt;
        &lt;cell&gt;850 MB/s&lt;/cell&gt;
        &lt;cell&gt;45 MB/s&lt;/cell&gt;
        &lt;cell&gt;1200 MB/s&lt;/cell&gt;
      &lt;/row&gt;
    &lt;/table&gt;
    &lt;p&gt;Crucially, OpenZL produces a higher compression ratio while preserving or even improving speed, which is critical for data center processing pipelines.&lt;/p&gt;
    &lt;p&gt;For illustration, this result is achieved using the following simple graph:&lt;/p&gt;
    &lt;head rend="h3"&gt;A Brief Explanation&lt;/head&gt;
    &lt;p&gt;So what is happening in this example?&lt;/p&gt;
    &lt;p&gt;We start by separating the header from the rest, a large table of structures. Then each field gets extracted into its own stream: the array of structures becomes a structure of arrays. After that point, we expect that each stream contains homogeneous data of the same type and semantic meaning. We can now focus on finding an optimal compression strategy for each one.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;SRA0 is a position on the X axis. Due to the way the table is generated, the index is mostly sorted, inviting the use of delta to reduce the range of values represented. This mechanically makes the resulting stream easier to compress.&lt;/item&gt;
      &lt;item&gt;SDEC0 is a position on the Y axis. It’s not as well sorted as the X axis, but we can at least exploit the fact that it’s bounded between a minimum and a maximum. This makes the higher bytes more predictable, which can be exploited for better compression with the transpose operation.&lt;/item&gt;
      &lt;item&gt;The other fields (IS, MAG, XRPM, XDPM) share a common property: their cardinality is much lower than their quantities, and there is no relation between 2 consecutive values. This makes them a good target for tokenize, which will convert the stream into a dictionary and an index list.&lt;/item&gt;
      &lt;item&gt;The resulting dictionaries and index lists are very different. They benefit from completely different compression strategies. So they are sent to dedicated processing graphs.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The graph continues beyond these steps. But at some point, we can also stop making decisions. The main work is to group data into homogeneous streams. After that, one can count on openzl to take care of the rest.&lt;/p&gt;
    &lt;p&gt;To go even further, we would like to generate compression strategies that are specifically fine-tuned for each stream. This is where the offline trainer stage comes into play.&lt;/p&gt;
    &lt;head rend="h2"&gt;Generate a Compressor Automatically&lt;/head&gt;
    &lt;p&gt;It’s possible to take full control of the compression process, but it’s also not required. A faster strategy is to just describe your data and let the system learn a compression config.&lt;/p&gt;
    &lt;p&gt;Describe the input: With the Simple Data Description Language (SDDL), you sketch how the bytes map to fields — rows, columns, enums, nested records. SDDL is for parsing only; it just tells OpenZL the shape of your data. Alternatively, you can write your own parser function directly using one of the supported languages, and register it with OpenZL to delegate the logic.&lt;/p&gt;
    &lt;p&gt;Learn the config: Starting from a preset, a parser function or an SDDL description, the trainer runs a budgeted search over transform choices and parameters to produce a Plan. It can provide a full set of speed/ratio tradeoffs, or directly target the best configuration respecting some speed constraints. Internally it uses a cluster finder (to group fields that behave alike) and a graph explorer (to try candidate subgraphs and keep score).&lt;/p&gt;
    &lt;p&gt;Resolve at encode-time: While compressing, the encoder turns the Plan into a concrete recipe — the Resolved Graph. If the Plan has control points, it picks the branch that fits the data and records that choice into the frame.&lt;/p&gt;
    &lt;p&gt;Decode without coordination: Each frame chunk carries its own resolved graph. The single decoder checks it, enforces limits, and runs the steps in order. When a plan improves, you just roll out the new plan, no new decompressor needed. Old data keeps decoding; new data get improved gains.&lt;/p&gt;
    &lt;p&gt;In practice the loop is straightforward: describe (SDDL) → train (produce a plan) → compress (emit frames with resolved graphs) → decode anywhere with the same binary.&lt;/p&gt;
    &lt;head rend="h2"&gt;Embracing Changes: Re-Training and In-Flight Control&lt;/head&gt;
    &lt;p&gt;In the real world, data evolves constantly, in both structure and content. A compressor built for one version of a schema would have a short lifetime.&lt;/p&gt;
    &lt;p&gt;Thankfully, with the flexibility offered by compression plans, we can react swiftly to data changes. At Meta, this is the core mission of Managed Compression, originally created to automate dictionary compression with Zstandard, and presented in an earlier blog on how we improved compression at with Zstandard.&lt;/p&gt;
    &lt;p&gt;OpenZL offers a training process that updates compression plans to maintain or improve compression performance, based on provided data samples. Now the synergy with Managed Compression is apparent: Each registered use case is monitored, sampled, periodically re-trained, and receives new configs when they prove beneficial. The decompression side continues to decode both old and new data without any change.&lt;/p&gt;
    &lt;p&gt;Runtime Adaptation: A compression config can include control points that read lightweight statistics at compression time (e.g., string repetition stats, run-length, histogram skew, delta variance) and choose the best branch of the Plan to go to next. Many technologies can be used, and textbook classifiers qualify. Control points handle bursts, outliers, and seasonal shifts without brute-force exploration: exploration is bounded, in order to maintain speed expectations. Taken branches are then recorded into the frame, and the decoder just executes the recorded path.&lt;/p&gt;
    &lt;p&gt;This gives the best of both worlds: dynamic behavior at compression time to handle variations and exceptions — without turning compression into an unbounded search problem — and with zero complexity added to the decoder.&lt;/p&gt;
    &lt;head rend="h2"&gt;The Advantages of the Universal Decoder&lt;/head&gt;
    &lt;p&gt;OpenZL is capable of compressing a vast array of data formats, and they can all be decompressed with a single decompressor binary. Even when the compression configuration changes, the decoder does not. This may sound like operational minutiae, but it’s critical to OpenZL’s deployment success.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;One audited surface: Security and correctness reviews focus on a single binary with consistent invariants, fuzzing, and hardening; there’s no myriad of per-format tools that can drift apart.&lt;/item&gt;
      &lt;item&gt;Fleet-wide improvements: A decoder update (security or performance — SIMD kernels, memory bounds, scheduling) benefits every compressed file, even those that predate the change.&lt;/item&gt;
      &lt;item&gt;Operational clarity: Same binary, same CLI, same metrics and dashboards across datasets; patching and rollout are uneventful by design.&lt;/item&gt;
      &lt;item&gt;Continuous training: With one decoder and many compression plans, we can keep improving while the system is live. Train a plan offline, try it on a small slice, then roll it out like any other config change. Backward compatibility is built-in — old frames still decode while new frames get better.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;In other words, it’s possible to afford domain-specific compression without fragmenting the ecosystem.&lt;/p&gt;
    &lt;head rend="h2"&gt;Results With OpenZL&lt;/head&gt;
    &lt;p&gt;When OpenZL is able to understand and parse the file format, it is able to offer large improvements in compression ratio, while still providing fast compression and decompression speed. However, this is no magic bullet. When OpenZL doesn’t understand the input file format, it simply falls back to zstd.&lt;/p&gt;
    &lt;p&gt;OpenZL, through its offline training capabilities, is also able to offer a wide range of configurations in the tradeoff space of compression ratio, compression speed, and decompression speed. Unlike traditional compressors, which offer configuration by setting a compression level, OpenZL offers configuration by serializing the compressor graph. This allows an immense amount of flexibility to select diverse tradeoffs.&lt;/p&gt;
    &lt;p&gt;These results are based on datasets we’ve developed for our whitepaper. The datasets were chosen because they are highly structured and in a format that OpenZL supports. Every figure below is produced with scripts in the OpenZL repository so they can be reproduced, and the input data and logs from our runs have been uploaded to GitHub.&lt;/p&gt;
    &lt;p&gt;Note that data points connected by a line are pareto-optimal. All such points have the property that there is no point in the same dataset which beats them in both metrics.&lt;/p&gt;
    &lt;head rend="h3"&gt;When It’s Not Useful&lt;/head&gt;
    &lt;p&gt;OpenZL relies on a description of some structure to leverage its set of transforms. When there is no structure, there is no advantage. This is typically the case in pure text documents, such as enwik or dickens. In these cases, OpenZL falls back to zstd, offering essentially the same level of performance.&lt;/p&gt;
    &lt;head rend="h2"&gt;Getting Started With OpenZL&lt;/head&gt;
    &lt;p&gt;OpenZL’s selection of codecs is well-suited to compressing vector, tabular, or tree-structured data, and can be expected to perform well with numeric, string, or binary data. Common examples include timeseries datasets, ML tensors, and database tables. Keep in mind that we are bound by the limits of information theory, so the input needs to have some order that can be uncovered. As time goes on, we plan to incorporate additional codecs, as described in the next section.&lt;/p&gt;
    &lt;p&gt;If your data fits one of the above categories, then give it a try! Visit the OpenZL site and our Quick Start guide to get started.&lt;/p&gt;
    &lt;p&gt;If you want to dive into the code, check out the GitHub repository for source, documentation, and examples. We welcome contributions and feedback from the community!&lt;/p&gt;
    &lt;head rend="h2"&gt;Where We’re Going&lt;/head&gt;
    &lt;p&gt;OpenZL’s general direction is set: make it easier to expose structures, and exploit it with automated compression plans for evolving data.&lt;/p&gt;
    &lt;p&gt;Next up: We’re extending the transform library for time-series and grid-shaped data, improving performance of codecs, and enabling the trainer to find better compression plans faster. We also are actively working to extend SDDL to describe nested data formats more flexibly. Finally, the automated compressor explorer is getting better at proposing safe, testable changes to a compression plan within a specified budget.&lt;/p&gt;
    &lt;p&gt;Where the community can help: If you have a format or a dataset with obvious structure, try compressing it with an OpenZL prebuilt Plan. If it’s promising, try generating a new plan with the trainer or customizing it with our documentation to improve it. If it’s a format that the public might want, send it to us in a PR.&lt;/p&gt;
    &lt;p&gt;You can also contribute to the OpenZL core. If you have a knack for optimizing C/C++, help us speed up the engine or add transforms to cover new data formats. If your super power is reliability, the project would surely benefit from more validation rules and resource caps. And if you care about benchmarks, add your dataset to the harness so others can reproduce your results.&lt;/p&gt;
    &lt;p&gt;How to engage: Open an issue on the GitHub issue board. If you have a use-case for which you would expect OpenZL to do better, provide a few small samples, so that we can analyze them together. You may also contribute to codec optimizations, and propose new graphs, parsers or control points. All these topics do not impact the universality of the decoder.&lt;/p&gt;
    &lt;p&gt;We believe OpenZL opens up a new universe of possibilities to the data compression field, and we’re excited to see what the open source community will do with it!&lt;/p&gt;
    &lt;p&gt;To learn more about Meta Open Source, visit our website, subscribe to our YouTube channel, or follow us on Facebook, Threads, X, Bluesky and LinkedIn.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=45492803</guid><pubDate>Mon, 06 Oct 2025 16:01:58 +0000</pubDate></item><item><title>Ladybird passes the Apple 90% threshold on web-platform-tests</title><link>https://twitter.com/awesomekling/status/1974781722953953601</link><description>&lt;doc fingerprint="d635f48b34542867"&gt;
  &lt;main&gt;
    &lt;p&gt;We’ve detected that JavaScript is disabled in this browser. Please enable JavaScript or switch to a supported browser to continue using x.com. You can see a list of supported browsers in our Help Center.&lt;/p&gt;
    &lt;p&gt;Help Center&lt;/p&gt;
    &lt;p&gt;Terms of Service Privacy Policy Cookie Policy Imprint Ads info © 2025 X Corp.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=45493358</guid><pubDate>Mon, 06 Oct 2025 16:52:58 +0000</pubDate></item><item><title>OpenAI ChatKit</title><link>https://github.com/openai/chatkit-js</link><description>&lt;doc fingerprint="22998170f99ebfba"&gt;
  &lt;main&gt;
    &lt;p&gt;ChatKit is a batteries-included framework for building high-quality, AI-powered chat experiences. It’s designed for developers who want to add advanced conversational intelligence to their apps fast—with minimal setup and no reinventing the wheel. ChatKit delivers a complete, production-ready chat interface out of the box.&lt;/p&gt;
    &lt;p&gt;Key features include:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Deep UI customization so that ChatKit feels like a first-class part of your app&lt;/item&gt;
      &lt;item&gt;Built-in response streaming for interactive, natural conversations&lt;/item&gt;
      &lt;item&gt;Tool and workflow integration for visualizing agentic actions and chain-of-thought reasoning&lt;/item&gt;
      &lt;item&gt;Rich interactive widgets rendered directly inside the chat&lt;/item&gt;
      &lt;item&gt;Attachment handling with support for file and image uploads&lt;/item&gt;
      &lt;item&gt;Thread and message management for organizing complex conversations&lt;/item&gt;
      &lt;item&gt;Source annotations and entity tagging for transparency and references&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Simply drop the ChatKit component into your app, configure a few options, and you're good to go.&lt;/p&gt;
    &lt;p&gt;ChatKit is a framework-agnostic, drop-in chat solution. You don’t need to build custom UIs, manage low-level chat state, or patch together various features yourself. Just add the ChatKit component, give it a client token, and customize the chat experience as needed, no extra work needed.&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;
        &lt;p&gt;Generate a client token on your server.&lt;/p&gt;
        &lt;quote&gt;from fastapi import FastAPI from pydantic import BaseModel from openai import OpenAI import os app = FastAPI() openai = OpenAI(api_key=os.environ["OPENAI_API_KEY"]) @app.post("/api/chatkit/session") def create_chatkit_session(): session = openai.chatkit.sessions.create({ # ... }) return { client_secret: session.client_secret }&lt;/quote&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Install the React bindings&lt;/p&gt;
        &lt;quote&gt;npm install @openai/chatkit-react&lt;/quote&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Add the ChatKit JS script to your page&lt;/p&gt;
        &lt;quote&gt;&amp;lt;script src="https://cdn.platform.openai.com/deployments/chatkit/chatkit.js" async &amp;gt;&amp;lt;/script&amp;gt;&lt;/quote&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Render ChatKit&lt;/p&gt;
        &lt;quote&gt;import { ChatKit, useChatKit } from '@openai/chatkit-react'; export function MyChat() { const { control } = useChatKit({ api: { async getClientSecret(existing) { if (existing) { // implement session refresh } const res = await fetch('/api/chatkit/session', { method: 'POST', headers: { 'Content-Type': 'application/json', }, }); const { client_secret } = await res.json(); return client_secret; }, }, }); return &amp;lt;ChatKit control={control} className="h-[600px] w-[320px]" /&amp;gt;; }&lt;/quote&gt;
      &lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;This project is licensed under the Apache License 2.0.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=45493718</guid><pubDate>Mon, 06 Oct 2025 17:23:20 +0000</pubDate></item><item><title>Apps SDK</title><link>https://developers.openai.com/apps-sdk/</link><description>&lt;doc fingerprint="9dca97fe33d1af9f"&gt;
  &lt;main&gt;
    &lt;p&gt;Our framework to build apps for ChatGPT.&lt;/p&gt;
    &lt;p&gt;Design components and conversational flows that feel native to ChatGPT.&lt;/p&gt;
    &lt;p&gt;Build apps that meet our quality, safety, and policy standards.&lt;/p&gt;
    &lt;p&gt;Identify and prioritize Apps SDK use cases.&lt;/p&gt;
    &lt;p&gt;Create and configure an MCP server.&lt;/p&gt;
    &lt;p&gt;Learn how to deploy your MCP server&lt;/p&gt;
    &lt;p&gt;Improve discovery and behavior with rich metadata.&lt;/p&gt;
    &lt;p&gt;Security and privacy considerations for Apps SDK.&lt;/p&gt;
    &lt;p&gt;Troubleshoot issues in Apps SDK apps.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=45494558</guid><pubDate>Mon, 06 Oct 2025 18:27:33 +0000</pubDate></item><item><title>Translating Cython to Mojo, a first attempt</title><link>https://fnands.com/blog/2025/sklearn-mojo-dbscan-inner/</link><description>&lt;doc fingerprint="56b814f1ca2612d1"&gt;
  &lt;main&gt;
    &lt;p&gt;Ever since I heard about Mojo I (and presumably most other people) thought it would be a good language to speed up functions to be called from Python. Everyone knows that vanilla Python can be slow, but one of the reasons that Python programs can be reasonably fast in practice is because Python often leans on libraries written in more performant languages, predominantly C/C++, but increasingly also Rust.&lt;/p&gt;
    &lt;p&gt;Until recently, there has been no real way to call Mojo code from Python, but about a month ago (in Max release 25.4) the ability to call Mojo from Python was added as a beta feature. It’s not fully cooked yet, and it will likely still change a lot, but I wanted to give it a look just to get an idea of where things are heading.&lt;/p&gt;
    &lt;p&gt;One specific idea that I had when I heard about Mojo was that Mojo might be a good replacement for Cython and apparently I was not the only one to have had this thought:&lt;/p&gt;
    &lt;p&gt;The comments are from the HackerNews discussion on Vincent Warmerdam’s blog post titled “Python can run Mojo now” which made it to the front page of HN a while ago.&lt;/p&gt;
    &lt;p&gt;So where can I find a lot of Cython code?&lt;/p&gt;
    &lt;head rend="h2"&gt;Scikit-learn&lt;/head&gt;
    &lt;p&gt;Scikit-learn implements a bunch of machine learning algorithms and related utilities, and makes heavy use of Cython. How hard would it be to translate some of the Cython code in scikit-learn to Mojo?&lt;/p&gt;
    &lt;p&gt;I wanted a piece of code that was relatively simple, both just as I didn’t want to jump into the deep end, but also because there are some restrictions on Mojo functions being called from Python, namely (from the known limitations section of the Mojo/Python interop):&lt;/p&gt;
    &lt;quote&gt;&lt;p&gt;Functions taking more than 3 arguments. Currently&lt;/p&gt;&lt;code&gt;PyTypeBuilder.add_function()&lt;/code&gt;and related function bindings only support Mojo functions that take up to 3&lt;code&gt;PythonObject&lt;/code&gt;arguments:&lt;code&gt;fn(PythonObject, PythonObject, PythonObject)&lt;/code&gt;.&lt;/quote&gt;
    &lt;head rend="h3"&gt;A simple case: dbscan_inner&lt;/head&gt;
    &lt;p&gt;An example I found that satisfies this criteria is the inner loop of DBSCAN that assigns points to clusters. It’s relatively short and takes exactly three arguments.&lt;/p&gt;
    &lt;p&gt;This is a classic case of a place where you would usually want to call speed up a tight inner loop in Python, in this case written in Cython:&lt;/p&gt;
    &lt;code&gt;# Fast inner loop for DBSCAN.

# Authors: The scikit-learn developers
# SPDX-License-Identifier: BSD-3-Clause

from libcpp.vector cimport vector

from ..utils._typedefs cimport uint8_t, intp_t


def dbscan_inner(const uint8_t[::1] is_core,
object[:] neighborhoods,
                  1] labels):
                  intp_t[::= 0, v
     cdef intp_t i, label_num 
     cdef intp_t[:] neighb
     cdef vector[intp_t] stack
for i in range(labels.shape[0]):
     if labels[i] != -1 or not is_core[i]:
         continue
             
# Depth-first search starting from i, ending at the non-core points.
         # This is very similar to the classic algorithm for computing connected
         # components, the difference being that we label non-core points as
         # part of a cluster (component), but don't expand their neighborhoods.
         while True:
         if labels[i] == -1:
             = label_num
                 labels[i] if is_core[i]:
                 = neighborhoods[i]
                     neighb for i in range(neighb.shape[0]):
                     = neighb[i]
                         v if labels[v] == -1:
                         
                             stack.push_back(v)
if stack.size() == 0:
             break
                 = stack.back()
             i 
             stack.pop_back()
+= 1         label_num &lt;/code&gt;
    &lt;p&gt;It’s not a complicated algorithm, and it labels core points and propagates that label to the neighbors of the core points.&lt;/p&gt;
    &lt;head rend="h3"&gt;Translating to Mojo&lt;/head&gt;
    &lt;p&gt;For the most part I just copied over the Cython code verbatim. There is a bit of boilerplate we need to add to the &lt;code&gt;.mojo&lt;/code&gt; file to make the function callable:&lt;/p&gt;
    &lt;code&gt;from python import PythonObject
from python.bindings import PythonModuleBuilder

from os import abort

@export
fn PyInit__dbscan_inner_mojo() -&amp;gt; PythonObject:
try:
     var m = PythonModuleBuilder("dbscan_inner_mojo")
         "dbscan_inner", docstring="Fast inner loop for DBSCAN.")
         m.def_function[dbscan_inner](return m.finalize()
         except e:
     return abort[PythonObject](String("error creating Python Mojo module:", e))         &lt;/code&gt;
    &lt;p&gt;but other than that, the translation was actually surprisingly straightforward, see if you can spot the differences in the Mojo and Cython versions:&lt;/p&gt;
    &lt;code&gt;fn dbscan_inner(is_core: PythonObject,

                  neighborhoods: PythonObject,raises:
                  labels: PythonObject) var i: Int = 0
     var label_num: Int= 0
     var v: Int = 0
     
var stack: List[Int] = []
     
for i in range(labels.shape[0]):
     if labels[i] != -1 or not is_core[i]:
         continue
             
# Depth-first search starting from i, ending at the non-core points.
         # This is very similar to the classic algorithm for computing connected
         # components, the difference being that we label non-core points as
         # part of a cluster (component), but don't expand their neighborhoods.
         while True:
         if labels[i] == -1:
             = label_num
                 labels[i] if is_core[i]:
                 = neighborhoods[i]
                     neighb for i in range(neighb.shape[0]):
                     = Int(neighb[i])
                         v if labels[v] == -1:
                         
                             stack.append(v)
if len(stack) == 0:
             break
                 = stack.pop()
             i 
+= 1         label_num &lt;/code&gt;
    &lt;p&gt;I defined &lt;code&gt;stack&lt;/code&gt; as a Mojo &lt;code&gt;List[Int]&lt;/code&gt; to replace the C++ &lt;code&gt;vector[intp_t]&lt;/code&gt; implementation in Cython. Other than the changes related to &lt;code&gt;stack&lt;/code&gt;, the only other changes were the initializations of the variables, and casting the entries in neighbors to integers.&lt;/p&gt;
    &lt;p&gt;It was honestly quite a bit simpler than I thought it would be, and the fact that both Cython and Mojo’s syntax is based on Python means a lot of the code “just works”.&lt;/p&gt;
    &lt;p&gt;As part of this experiment, my goal was to change the Python code as little as possible, and all I needed to do in &lt;code&gt;_dbscan.py&lt;/code&gt; was add:&lt;/p&gt;
    &lt;code&gt;import max.mojo.importer
import sys
0, "")
 sys.path.insert(
from _dbscan_inner_mojo import dbscan_inner&lt;/code&gt;
    &lt;p&gt;The &lt;code&gt;sys.path.insert(0, "")&lt;/code&gt; is a bit clunky, but the Mojo devs have said this is a temporary workaround.&lt;/p&gt;
    &lt;p&gt;I then ran pytest and all all the dbscan tests passed:&lt;/p&gt;
    &lt;code&gt;============================================================== test session starts ==============================================================
platform linux -- Python 3.12.9, pytest-8.4.1, pluggy-1.6.0
rootdir: /fast/Workspace/scikit-learn
configfile: pyproject.toml
plugins: anyio-4.9.0
collected 30 items                                                                                                                              

tests/test_dbscan.py ..............................                                                                                       [100%]

======================================================== 30 passed, 10 warnings in 0.54s ========================================================&lt;/code&gt;
    &lt;p&gt;The performance however is a bit lacking, presumably because Mojo is iterating over &lt;code&gt;PythonObjects&lt;/code&gt; for which it can’t properly optimize:&lt;/p&gt;
    &lt;quote&gt;&lt;p&gt;Cython average time: 2.78e-05 seconds&lt;/p&gt;&lt;lb/&gt;Mojo average time: 0.0227 seconds&lt;/quote&gt;
    &lt;p&gt;That’s around 800 times slower than Cython. We can however, make some minor tweaks to improve this.&lt;/p&gt;
    &lt;head rend="h3"&gt;Improving performance&lt;/head&gt;
    &lt;p&gt;Let’s look at what is being passed to &lt;code&gt;dbscan_inner&lt;/code&gt;:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;core_samples&lt;/code&gt;is a numpy array of bytes (&lt;code&gt;np.uint8&lt;/code&gt;) signifying whether on not a sample is considered a core sample.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;neighborhoods&lt;/code&gt;is a list of numpy arrays of integers that specify which points neighbor each point. Effectively the edges of a graph.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;labels&lt;/code&gt;is a numpy array of integers, initialized to&lt;code&gt;-1&lt;/code&gt;, signifying that the points are currently unlabeled.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;We can transform &lt;code&gt;labels&lt;/code&gt; and &lt;code&gt;is_core&lt;/code&gt; into Mojo Spans (thanks to Owen Hilyard on the Modular Discord for the hints):&lt;/p&gt;
    &lt;code&gt;= labels_py.ctypes.data.unsafe_get_as_pointer[DType.index]()
 var labels_ptr = Span(labels_ptr, Int(labels_py.shape[0]))
 var labels 
= is_core_py.ctypes.data.unsafe_get_as_pointer[DType.bool]()
 var is_core_ptr = Span(is_core_ptr, Int(is_core_py.shape[0])) var is_core &lt;/code&gt;
    &lt;p&gt;Not the prettiest, but this creates the &lt;code&gt;Span&lt;/code&gt;s without copying over the data.&lt;/p&gt;
    &lt;p&gt;The final code looks like:&lt;/p&gt;
    &lt;code&gt;fn dbscan_inner(is_core_py: PythonObject,

                  neighborhoods_py: PythonObject,raises:
                  labels_py: PythonObject) var label_num: Int= 0
     var v: Int = 0
     
var labels_ptr = labels_py.ctypes.data.unsafe_get_as_pointer[DType.index]()
     var labels = Span(labels_ptr, Int(labels_py.shape[0]))
     
var is_core_ptr = is_core_py.ctypes.data.unsafe_get_as_pointer[DType.bool]()
     var is_core = Span[mut=False](is_core_ptr, Int(is_core_py.shape[0]))
     

var stack: List[Int] = []
     
for i in range(len(labels)):
     if labels[i] != -1 or not is_core[i]:
         continue
             
# Depth-first search starting from i, ending at the non-core points.
         # This is very similar to the classic algorithm for computing connected
         # components, the difference being that we label non-core points as
         # part of a cluster (component), but don't expand their neighborhoods.
         while True:
         if labels[i] == -1:
             = label_num
                 labels[i] if is_core[i]:
                 var neighb = neighborhoods_py[i]
                     
for j in range(len(neighb)):
                     = Int(neighb[j])
                         v if labels[v] == -1:
                         
                             stack.append(v)
if len(stack) == 0:
             break
                 = stack.pop()
             i 
+= 1         label_num &lt;/code&gt;
    &lt;p&gt;Testing the performance now, we get:&lt;/p&gt;
    &lt;quote&gt;&lt;p&gt;Cython average time: 2.9e-05 seconds&lt;/p&gt;&lt;lb/&gt;Mojo average time: 8.59e-05 seconds&lt;/quote&gt;
    &lt;p&gt;So around 3x slower than Cython, but a lot faster than before.&lt;/p&gt;
    &lt;p&gt;Ideally we would also translate &lt;code&gt;neighborhoods&lt;/code&gt; into a Mojo type, but it gets a bit tricky here as &lt;code&gt;neighborhoods&lt;/code&gt; is a list of numpy arrays, which can all have different sizes, so simply assigning them to a type is a bit hard. There might be some solution out there, although likely changing the input to &lt;code&gt;dbscan_inner&lt;/code&gt; to something that can more easily be mapped to Mojo is likely the most sensible answer, but that’s beyond the scope of this little test.&lt;/p&gt;
    &lt;p&gt;Even so, the overall performance of DBSCAN as a whole is unchanged, as this inner function isn’t really the slow part of the algorithm (benchmarking code adapted from HDBSCAN):&lt;/p&gt;
    &lt;p&gt;The performance is identical (lines overlap almost exactly), and it’s the other parts of DBSCAN, like the neighborhood calculation, that take up the majority of the time:&lt;/p&gt;
    &lt;code&gt;=== Component Breakdown ===
Data validation: 0.0003s (0.0%)
NearestNeighbors fit: 0.0304s (2.1%)
Radius neighbors computation: 1.3573s (95.1%)
Core sample identification: 0.0019s (0.1%)
Cluster assignment: 0.0002s (0.0%)
Total: 1.4278s&lt;/code&gt;
    &lt;p&gt;In the future, I’d like to look into translating the slower parts of DBSCAN into Mojo, as the neighborhood radius calculation that takes up the most time can probably be parallelized, maybe even on the GPU.&lt;/p&gt;
    &lt;head rend="h2"&gt;Conclusions&lt;/head&gt;
    &lt;p&gt;I chose this example not because it makes a lot of sense to translate it to Mojo, but just because it was easy to do so in a short amount of time. Right now, the Python interop is still a little too bleeding edge to do anything serious with, but at the pace that the language is evolving I doubt that this will be true for long.&lt;/p&gt;
    &lt;p&gt;It was however promising just how simple it was in this case, and most of the effort was in translating the PythonObjects into appropriate Mojo types to allow the compiler to reason about them. If I could request something from the Modular team it would be a “cheat-sheet” for best practices for translating common Python/numpy types into Mojo.&lt;/p&gt;
    &lt;p&gt;A more wholistic approach would be to also reconsider what is being passed to Mojo to make your life a bit easier when it comes to doing these translations.&lt;/p&gt;
    &lt;head rend="h2"&gt;Future plans&lt;/head&gt;
    &lt;p&gt;Once the Python interop stabilizes a little I want to see if I can rewrite some more substantial part of scikit-learn in Mojo, and preferably some algorithm that’s amenable to vectorization, possibly even on the GPU, so that I can really play into the strengths of Mojo. If you have any suggestions for an algorithm that is in need of some speeding up, let me know.&lt;/p&gt;
    &lt;p&gt;I think moving a lot of scikit-learn’s more computationally intensive code to Mojo could be an interesting project. There is a project called Mojmelo which is effectively the Mojo ecosystem’s answer to scikit-learn, however, almost no-one uses Mojo just yet.&lt;/p&gt;
    &lt;p&gt;On the other hand, scikit-learn was downloaded 100 Million times last month, so if you can speed up some of scikit-learn’s algorithms you can have a positive impact for a lot of users.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=45495738</guid><pubDate>Mon, 06 Oct 2025 20:09:44 +0000</pubDate></item><item><title>CodeMender: an AI agent for code security</title><link>https://deepmind.google/discover/blog/introducing-codemender-an-ai-agent-for-code-security/</link><description>&lt;doc fingerprint="b750e3f46eb396bc"&gt;
  &lt;main&gt;
    &lt;p&gt;Responsibility &amp;amp; Safety&lt;/p&gt;
    &lt;head rend="h1"&gt;Introducing CodeMender: an AI agent for code security&lt;/head&gt;
    &lt;p&gt;Using advanced AI to fix critical software vulnerabilities&lt;/p&gt;
    &lt;p&gt;Today, we’re sharing early results from our research on CodeMender, a new AI-powered agent that improves code security automatically.&lt;/p&gt;
    &lt;p&gt;Software vulnerabilities are notoriously difficult and time-consuming for developers to find and fix, even with traditional, automated methods like fuzzing. Our AI-based efforts like Big Sleep and OSS-Fuzz have demonstrated AI’s ability to find new zero-day vulnerabilities in well-tested software. As we achieve more breakthroughs in AI-powered vulnerability discovery, it will become increasingly difficult for humans alone to keep up.&lt;/p&gt;
    &lt;p&gt;CodeMender helps solve this problem by taking a comprehensive approach to code security that’s both reactive, instantly patching new vulnerabilities, and proactive, rewriting and securing existing code and eliminating entire classes of vulnerabilities in the process. Over the past six months that we’ve been building CodeMender, we have already upstreamed 72 security fixes to open source projects, including some as large as 4.5 million lines of code.&lt;/p&gt;
    &lt;p&gt;By automatically creating and applying high-quality security patches, CodeMender’s AI-powered agent helps developers and maintainers focus on what they do best — building good software.&lt;/p&gt;
    &lt;head rend="h2"&gt;CodeMender in action&lt;/head&gt;
    &lt;p&gt;CodeMender operates by leveraging the thinking capabilities of recent Gemini Deep Think models to produce an autonomous agent capable of debugging and fixing complex vulnerabilities.&lt;/p&gt;
    &lt;p&gt;To do this, the CodeMender agent is equipped with robust tools that let it reason about code before making changes, and automatically validate those changes to make sure they’re correct and don’t cause regressions.&lt;/p&gt;
    &lt;p&gt;While large language models are rapidly improving, mistakes in code security could be costly. CodeMender’s automatic validation process ensures that code changes are correct across many dimensions by only surfacing for human review high-quality patches that, for example, fix the root cause of the issue, are functionally correct, cause no regressions and follow style guidelines.&lt;/p&gt;
    &lt;p&gt;As part of our research, we also developed new techniques and tools that let CodeMender reason about code and validate changes more effectively. This includes:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Advanced program analysis: We developed tools based on advanced program analysis that include static analysis, dynamic analysis, differential testing, fuzzing and SMT solvers. Using these tools to systematically scrutinize code patterns, control flow and data flow, CodeMender can better identify the root causes of security flaws and architectural weaknesses.&lt;/item&gt;
      &lt;item&gt;Multi-agent systems: We developed special-purpose agents that enable CodeMender to tackle specific aspects of an underlying problem. For example, CodeMender uses a large language model-based critique tool that highlights the differences between the original and modified code in order to verify that the proposed changes do not introduce regressions, and self-correct as needed.&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h2"&gt;Fixing vulnerabilities&lt;/head&gt;
    &lt;p&gt;To effectively patch a vulnerability, and prevent it from re-emerging, Code Mender uses a debugger, source code browser, and other tools to pinpoint root causes and devise patches. We have added two examples of CodeMender patching vulnerabilities in the video carousel below.&lt;/p&gt;
    &lt;p&gt;Example #1: Identifying the root cause of a vulnerability&lt;/p&gt;
    &lt;p&gt;Here’s a snippet of the agent's reasoning about the root cause for a CodeMender-generated patch, after analyzing the results of debugger output and a code search tool.&lt;/p&gt;
    &lt;p&gt;Although the final patch in this example only changed a few lines of code, the root cause of the vulnerability was not immediately clear. In this case, the crash report showed a heap buffer overflow, but the actual problem was elsewhere — an incorrect stack management of Extensible Markup Language (XML) elements during parsing.&lt;/p&gt;
    &lt;p&gt;Example #2: Agent is able to create non-trivial patches&lt;/p&gt;
    &lt;p&gt;In this example, the CodeMender agent was able to come up with a non-trivial patch that deals with a complex object lifetime issue.&lt;/p&gt;
    &lt;p&gt;The agent was not only able to figure out the root cause of the vulnerability, but was also able to modify a completely custom system for generating C code within the project.&lt;/p&gt;
    &lt;head rend="h2"&gt;Proactively rewriting existing code for better security&lt;/head&gt;
    &lt;p&gt;We also designed CodeMender to proactively rewrite existing code to use more secure data structures and APIs.&lt;/p&gt;
    &lt;p&gt;For example, we deployed CodeMender to apply -fbounds-safety annotations to parts of a widely used image compression library called libwebp. When -fbounds-safety annotations are applied, the compiler adds bounds checks to the code to prevent an attacker from exploiting a buffer overflow or underflow to execute arbitrary code.&lt;/p&gt;
    &lt;p&gt;A few years ago, a heap buffer overflow vulnerability in libwebp (CVE-2023-4863) was used by a threat actor as part of a zero-click iOS exploit. With -fbounds-safety annotations, this vulnerability, along with most other buffer overflows in the project where we've applied annotations, would’ve been rendered unexploitable forever.&lt;/p&gt;
    &lt;p&gt;In the video carousel below we show examples of the agent’s decision-making process, including the validation steps.&lt;/p&gt;
    &lt;p&gt;Example #1: Agent’s reasoning steps&lt;/p&gt;
    &lt;p&gt;In this example, the CodeMender agent is asked to address the following -fbounds-safety error on bit_depths pointer:&lt;/p&gt;
    &lt;p&gt;Example #2: Agent automatically corrects errors and test failures&lt;/p&gt;
    &lt;p&gt;Another of CodeMender’s key features is its ability to automatically correct new errors and any test failures that arise from its own annotations. Here is an example of the agent recovering from a compilation error.&lt;/p&gt;
    &lt;p&gt;Example #3: Agent validates the changes&lt;/p&gt;
    &lt;p&gt;In this example, the CodeMender agent modifies a function and then uses the LLM judge tool configured for functional equivalence to verify that the functionality remains intact. When the tool detects a failure, the agent self-corrects based on the LLM judge's feedback.&lt;/p&gt;
    &lt;head rend="h2"&gt;Making software secure for everyone&lt;/head&gt;
    &lt;p&gt;While our early results with CodeMender are promising, we’re taking a cautious approach, focusing on reliability. Currently, all patches generated by CodeMender are reviewed by human researchers before they’re submitted upstream.&lt;/p&gt;
    &lt;p&gt;Using CodeMender, we've already begun submitting patches to various critical open-source libraries, many of which have already been accepted and upstreamed. We’re gradually ramping up this process to ensure quality and systematically address feedback from the open-source community.&lt;/p&gt;
    &lt;p&gt;We’ll also be gradually reaching out to interested maintainers of critical open source projects with CodeMender-generated patches. By iterating on feedback from this process, we hope to release CodeMender as a tool that can be used by all software developers to keep their codebases secure.&lt;/p&gt;
    &lt;p&gt;We will have a number of techniques and results to share, which we intend to publish as technical papers and reports in the coming months. With CodeMender, we've only just begun to explore AI’s incredible potential to enhance software security for everyone.&lt;/p&gt;
    &lt;p&gt;Acknowledgements&lt;/p&gt;
    &lt;p&gt;Credits (listed in alphabetical order):&lt;/p&gt;
    &lt;p&gt;Alex Rebert, Arman Hasanzadeh, Carlo Lemos, Charles Sutton, Dongge Liu, Gogul Balakrishnan, Hiep Chu, James Zern, Koushik Sen, Lihao Liang, Max Shavrick, Oliver Chang and Petros Maniatis.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=45496533</guid><pubDate>Mon, 06 Oct 2025 21:28:56 +0000</pubDate></item><item><title>RediShell: Critical remote code execution vulnerability in Redis</title><link>https://www.wiz.io/blog/wiz-research-redis-rce-cve-2025-49844</link><description>&lt;doc fingerprint="3f7819f38f20f501"&gt;
  &lt;main&gt;
    &lt;p&gt;Wiz Research has uncovered a critical Remote Code Execution (RCE) vulnerability, CVE-2025-49844 which we've dubbed #RediShell, in the widely used Redis in-memory data structure store. The vulnerability has been assigned a CVSS score of 10.0 - the highest possible severity.&lt;/p&gt;
    &lt;p&gt;The vulnerability exploits a Use-After-Free (UAF) memory corruption bug that has existed for approximately 13 years in the Redis source code. This flaw allows a post auth attacker to send a specially crafted malicious Lua script (a feature supported by default in Redis) to escape from the Lua sandbox and achieve arbitrary native code execution on the Redis host. This grants an attacker full access to the host system, enabling them to exfiltrate, wipe, or encrypt sensitive data, hijack resources, and facilitate lateral movement within cloud environments.&lt;/p&gt;
    &lt;p&gt;Given that Redis is used in an estimated 75% of cloud environments, the potential impact is extensive. Organizations are strongly urged to patch instances immediately by prioritizing those that are exposed to the internet.&lt;/p&gt;
    &lt;p&gt;On October 3, Redis released a security advisory along with a patched version of Redis. We extend our gratitude to the entire Redis team for their collaboration throughout the disclosure process. We greatly appreciate their transparency, responsiveness, and partnership during this engagement.&lt;/p&gt;
    &lt;p&gt;In this post, we will provide a high-level overview of our discovery and its implications. Given the prevalence and sensitivity of this vulnerability, we will defer some of the technical details to a future installment, omitting exploit information for now to allow impacted organizations sufficient time to address the vulnerability.&lt;/p&gt;
    &lt;p&gt;Organizations utilizing Redis are strongly encouraged to update their Redis instances to the latest version immediately.&lt;/p&gt;
    &lt;p&gt;Vulnerability Meets Ubiquity: The Redis Risk Multiplier&lt;/p&gt;
    &lt;p&gt;The newly disclosed RediShell (CVE-2025-49844) vulnerability in Redis has been assigned a CVSS score of 10.0 - a rating rarely seen, with only around 300 vulnerabilities receiving it in the past year. It’s also the first Redis vulnerability to be rated as critical. The score reflects not just the technical severity of remote code execution, but also how Redis is commonly used and deployed. Redis is widely used in cloud environments for caching, session management, and pub/sub messaging. While Redis has had a strong security history, the combination of this flaw and common deployment practices significantly increases its potential impact.&lt;/p&gt;
    &lt;p&gt;Scope&lt;/p&gt;
    &lt;p&gt;Wiz Research discovered a Remote Code Execution vulnerability CVE-2025-49844 affecting the widely used Redis database. The vulnerability is a Use-After-Free (UAF) memory corruption that allows an attacker to send a malicious Lua script that leads to arbitrary code execution outside Redis’s Lua interpreter sandbox, gaining access to the host.&lt;/p&gt;
    &lt;p&gt;The urgency with which you should address this vulnerability depends on how Redis was installed and its exposure level.&lt;/p&gt;
    &lt;p&gt;Exposure Analysis&lt;/p&gt;
    &lt;p&gt;Our analysis across cloud environments revealed the extensive scope of this vulnerability:&lt;/p&gt;
    &lt;p&gt;Approximately 330,000 Redis instances are exposed to the internet at the time of this blog post&lt;/p&gt;
    &lt;p&gt;About 60,000 instances have no authentication configured&lt;/p&gt;
    &lt;p&gt;57% of cloud environments install Redis as container images, many without proper security hardening&lt;/p&gt;
    &lt;p&gt;The official Redis container, by default, does not require authentication. Our analysis shows that 57% of cloud environments install Redis as an image. If not installed carefully, these instances may lack authentication entirely. The combination of no authentication and exposure to the internet is highly dangerous, allowing anyone to query the Redis instance and, specifically, send Lua scripts (which are enabled by default). This enables attackers to exploit the vulnerability and achieve RCE within the environment.&lt;/p&gt;
    &lt;p&gt;High Risk - Internal Network Exposure:&lt;/p&gt;
    &lt;p&gt;More Redis instances are exposed to internal networks where authentication may not be prioritized, allowing any host in the local network to connect to the database server. An attacker with a foothold in the cloud environment could gain access to sensitive data and exploit the vulnerability to run arbitrary code for lateral movement into sensitive networks.&lt;/p&gt;
    &lt;p&gt;Attack Flow and Impact&lt;/p&gt;
    &lt;p&gt;The attack sequence demonstrates how an attacker can exploit RediShell (CVE-2025-49844) to achieve comprehensive system compromise:&lt;/p&gt;
    &lt;p&gt;Initial Exploitation&lt;/p&gt;
    &lt;p&gt;Attacker sends a malicious Lua script to exploit the use-after-free vulnerability&lt;/p&gt;
    &lt;p&gt;Sandbox Escape&lt;/p&gt;
    &lt;p&gt;Script escapes the Lua sandbox and achieves arbitrary code execution&lt;/p&gt;
    &lt;p&gt;Establishes reverse shell for persistent access&lt;/p&gt;
    &lt;p&gt;System Compromise&lt;/p&gt;
    &lt;p&gt;Steals credentials (.ssh keys, IAM tokens, certificates)&lt;/p&gt;
    &lt;p&gt;Installs malware or crypto miners&lt;/p&gt;
    &lt;p&gt;Exfiltrates sensitive data from Redis and host&lt;/p&gt;
    &lt;p&gt;Lateral Movement&lt;/p&gt;
    &lt;p&gt;Uses stolen IAM tokens to access other cloud services&lt;/p&gt;
    &lt;p&gt;Escalates privileges and moves to additional systems&lt;/p&gt;
    &lt;p&gt;The Result: Host Remote Code Execution&lt;/p&gt;
    &lt;p&gt;**We recommend that all Redis users upgrade their instances immediately, as this vulnerability poses a significant risk.**&lt;/p&gt;
    &lt;p&gt;Disclosure Timeline&lt;/p&gt;
    &lt;p&gt;May 16, 2025: Initial vulnerability report sent to Redis in Pwn2Own Berlin.&lt;/p&gt;
    &lt;p&gt;Oct 3, 2025: Redis publishes the security bulletin and assigned CVE-2025-49844.&lt;/p&gt;
    &lt;p&gt;Oct 6, 2025: Wiz Research publishes this blog post.&lt;/p&gt;
    &lt;p&gt;Recommended Actions&lt;/p&gt;
    &lt;p&gt;Update Redis Immediately: Upgrade to the latest patched version. Prioritize any internet-exposed or unauthenticated instances.&lt;/p&gt;
    &lt;p&gt;Security Hardening:&lt;/p&gt;
    &lt;p&gt;Enable Redis Authentication: Use the requirepass directive.&lt;/p&gt;
    &lt;p&gt;Disable Unnecessary Commands: This includes Lua scripting if it's not being used. You can achieve this by revoking user scripting permissions via Redis ACLs or by disabling scripting commands.&lt;/p&gt;
    &lt;p&gt;Run with Minimal Privileges: Operate Redis using a non-root user account.&lt;/p&gt;
    &lt;p&gt;Enable Logging and Monitoring: Activate Redis logging and monitoring to track activity and identify potential issues.&lt;/p&gt;
    &lt;p&gt;Restrict Redis Access: Limit access to authorized networks only.&lt;/p&gt;
    &lt;p&gt;How Wiz can help&lt;/p&gt;
    &lt;p&gt;Wiz customers can use the pre-built query and advisory in the Wiz Threat Center to assess the risk in their environment.&lt;/p&gt;
    &lt;p&gt;Wiz identifies both internal and publicly exposed Redis instances in your environment affected by CVE-2025-49844, and alerts you to instances that have been misconfigured to allow unauthenticated access or use weak or default passwords.&lt;/p&gt;
    &lt;p&gt;Conclusion: treat with urgency&lt;/p&gt;
    &lt;p&gt;RediShell (CVE-2025-49844) represents a critical security vulnerability that affects all Redis versions due to its root cause in the underlying Lua interpreter. With hundreds of thousands of exposed instances worldwide, this vulnerability poses a significant threat to organizations across all industries.&lt;/p&gt;
    &lt;p&gt;The combination of widespread deployment, default insecure configurations, and the severity of the vulnerability creates an urgent need for immediate remediation. Organizations must prioritize updating their Redis instances and implementing proper security controls to protect against exploitation.&lt;/p&gt;
    &lt;p&gt;This vulnerability also highlights how deeply today’s cloud environments depend on open-source technologies like Redis. That shared reliance is what motivated us, alongside other cloud providers, to launchZeroDay.Cloud, a community-driven effort to identify and responsibly disclose critical zero-day vulnerabilities in the open-source software powering the cloud. Redis, along with other core open-source technologies, is part of that effort.&lt;/p&gt;
    &lt;p&gt;Wiz Research will continue to monitor the threat landscape and provide additional technical details in future publications so that organizations have time to implement necessary security measures.&lt;/p&gt;
    &lt;p&gt;For technical questions about this research, please contact: research@wiz.io&lt;/p&gt;
    &lt;p&gt;---&lt;/p&gt;
    &lt;p&gt;This research was conducted by the Wiz Research team. We thank the Redis security team for their professional handling of this disclosure and their commitment to user security.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=45497027</guid><pubDate>Mon, 06 Oct 2025 22:30:12 +0000</pubDate></item><item><title>Microsoft is plugging more holes that let you use Windows 11 without MS account</title><link>https://www.theverge.com/news/793579/microsoft-windows-11-local-account-bypass-workaround-changes</link><description>&lt;doc fingerprint="2798ea1532e6f0d7"&gt;
  &lt;main&gt;
    &lt;p&gt;Microsoft is cracking down on bypass methods that let Windows 11 installs use a local account, and avoid an internet requirement during the setup process. In a new Windows 11 test build released today, Microsoft says it’s removing known workarounds for creating local accounts as they can apparently cause issues during the setup process.&lt;/p&gt;
    &lt;head rend="h1"&gt;Microsoft is plugging more holes that let you use Windows 11 without an online account&lt;/head&gt;
    &lt;p&gt;Microsoft really doesn’t want you creating a local account on Windows 11.&lt;/p&gt;
    &lt;p&gt;Microsoft really doesn’t want you creating a local account on Windows 11.&lt;/p&gt;
    &lt;p&gt;“We are removing known mechanisms for creating a local account in the Windows Setup experience (OOBE),” says Amanda Langowski, the lead for the Windows Insider Program. “While these mechanisms were often used to bypass Microsoft account setup, they also inadvertently skip critical setup screens, potentially causing users to exit OOBE with a device that is not fully configured for use.”&lt;/p&gt;
    &lt;p&gt;The changes mean Windows 11 users will need to complete the OOBE screens with an internet connection and Microsoft account in future versions of the OS.&lt;/p&gt;
    &lt;p&gt;Microsoft already removed the “bypassnro” workaround earlier this year, and today’s changes also disable the “start ms-cxh:localonly” command that Windows 11 users discovered after Microsoft’s previous changes. Using this command now resets the OOBE process and it fails to bypass the Microsoft account requirement.&lt;/p&gt;
    &lt;p&gt;These workarounds have been widely used to avoid a Microsoft account or internet access on Windows 11 Pro and Home installs in recent years. They’re easy to use, so you don’t have to create a custom unattended answer file to force Windows 11 to create a local account.&lt;/p&gt;
    &lt;p&gt;A lot of Windows users simply want to avoid using a Microsoft account or just want to customize the user folder name that Windows 11 creates from the email address of a Microsoft account. Thankfully, Microsoft is now adding a way to name your default user folder during the setup process, although you’ll need to use a command to get a custom folder name. Hopefully this will eventually become a simple option during the setup process.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=45497384</guid><pubDate>Mon, 06 Oct 2025 23:15:26 +0000</pubDate></item><item><title>The least amount of CSS for a decent looking site (2023)</title><link>https://thecascade.dev/article/least-amount-of-css/</link><description>&lt;doc fingerprint="8c8abb396bb90f9d"&gt;
  &lt;main&gt;
    &lt;head rend="h1"&gt;The least amount of CSS for a decent looking site&lt;/head&gt;
    &lt;p&gt;Summary: People often over-engineer solutions, and it leads to them running into problems with their CSS. In this article, we'll take a look at the least amount of CSS that you need to make a decent looking page.&lt;/p&gt;
    &lt;p&gt;The fun part of making a website is that if you write your HTML and nothing else, you have a responsive website.&lt;/p&gt;
    &lt;p&gt;Granted, if you have images they can cause some overflow issues.&lt;/p&gt;
    &lt;p&gt;So we can start things off by fixing that:&lt;/p&gt;
    &lt;code&gt;img {
  max-width: 100%;
  display: block;
}&lt;/code&gt;
    &lt;p&gt;It’s possible you have videos or SVGs that are also causing problems (less likely with SVGs though), so if you need, you can expand upon this a little bit.&lt;/p&gt;
    &lt;code&gt;img,
svg,
video {
  max-width: 100%;
  display: block;
}&lt;/code&gt;
    &lt;head rend="h2"&gt;Improving the typography&lt;/head&gt;
    &lt;p&gt;The first thing we can do is change the font family since the default is never very exciting.&lt;/p&gt;
    &lt;p&gt;We’ll just use a basic &lt;code&gt;system-ui&lt;/code&gt; for this example. It has pretty good support these days, and looks good on every system without having to worry about loading in any extra fonts.&lt;/p&gt;
    &lt;p&gt;In general, the font-size is a little small as well, so we can bump it up, and the default line-height is always a bit tight, so anything within the 1.5 to 1.7 range should do:&lt;/p&gt;
    &lt;code&gt;body {
  font-family: System UI;
  font-size: 1.25rem;
  line-height: 1.5;
}&lt;/code&gt;
    &lt;p&gt;Though not perfect, this is already a huge improvement over the regular defaults.&lt;/p&gt;
    &lt;head rend="h2"&gt;Adding Dark Mode Support&lt;/head&gt;
    &lt;p&gt;Many people love dark mode, so let’s enable it based on a user’s system preferences.&lt;/p&gt;
    &lt;p&gt;We can do this by using the &lt;code&gt;color-scheme&lt;/code&gt; property:&lt;/p&gt;
    &lt;code&gt;html {
  color-scheme: light dark;
}&lt;/code&gt;
    &lt;p&gt;This will set the user-agent-styles to either a light or dark theme, based on the users system preferences.&lt;/p&gt;
    &lt;p&gt;If you’d prefer, we can do this without CSS as well!&lt;/p&gt;
    &lt;code&gt;&amp;lt;html lang="en" color-scheme="light dark"&amp;gt;&amp;lt;/html&amp;gt;&lt;/code&gt;
    &lt;head rend="h3"&gt;A small note on following the system preferences&lt;/head&gt;
    &lt;p&gt;While this is really handy, it is a best practice to allow users to manually toggle the color-scheme as well.&lt;/p&gt;
    &lt;p&gt;Some people prefer a dark system theme, but light website themes, and vice-versa.&lt;/p&gt;
    &lt;head rend="h2"&gt;Restraining Content Width&lt;/head&gt;
    &lt;p&gt;Line-length is one of the most important things when it comes to the readability of text.&lt;/p&gt;
    &lt;p&gt;We generally want to try and fall somewhere in the 45-90 characters per line range (for body text, not headlines).&lt;/p&gt;
    &lt;p&gt;To make the website more readable, we’ll limit the content width using a &lt;code&gt;main&lt;/code&gt; element and some CSS magic:&lt;/p&gt;
    &lt;code&gt;main {
  max-width: min(70ch, 100% - 4rem);
  margin-inline: auto;
}&lt;/code&gt;
    &lt;p&gt;The &lt;code&gt;min()&lt;/code&gt; function here will pick whatever is smallest, either &lt;code&gt;70ch&lt;/code&gt; or &lt;code&gt;100% - 4rem&lt;/code&gt;. Because we are inside a &lt;code&gt;min()&lt;/code&gt; function, we don’t need to use a &lt;code&gt;calc()&lt;/code&gt;.&lt;/p&gt;
    &lt;p&gt;Whatever the output from that min() function, the width is less than 100%, so the page will be stuck to the left side of the viewport.&lt;/p&gt;
    &lt;p&gt;We can then use margin-inline: auto to center it, as this acts on the margins on the inline axis, so in any horizontal writing modes, that means both the margin-left and margin-right are auto.&lt;/p&gt;
    &lt;p&gt;You might want to switch out the main selector for a .container or .wrapper so you can have more control over where you use it.&lt;/p&gt;
    &lt;p&gt;And with that, our final CSS file looks like this:&lt;/p&gt;
    &lt;code&gt;html {
  color-scheme: light dark;
}

body {
  font-family: system-ui;
  font-size: 1.25rem;
  line-height: 1.5;
}

img,
svg,
video {
  max-width: 100%;
  display: block;
}

main {
  max-width: min(70ch, 100% - 4rem);
  margin-inline: auto;
}&lt;/code&gt;
    &lt;head rend="h2"&gt;Build on top of this&lt;/head&gt;
    &lt;p&gt;This is just a quick start to get things off the ground, though it could be used for a very simple page as well.&lt;/p&gt;
    &lt;p&gt;For the most part, though, you’ll probably want to build on top of this, but it should be able to act as a nice jumping off point!&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=45497624</guid><pubDate>Mon, 06 Oct 2025 23:47:24 +0000</pubDate></item><item><title>Origami Patterns Solve a Major Physics Riddle</title><link>https://www.quantamagazine.org/origami-patterns-solve-a-major-physics-riddle-20251006/</link><description>&lt;doc fingerprint="350a413e116f0c2f"&gt;
  &lt;main&gt;
    &lt;head rend="h1"&gt;Origami Patterns Solve a Major Physics Riddle&lt;/head&gt;
    &lt;head rend="h2"&gt;Introduction&lt;/head&gt;
    &lt;p&gt;The amplituhedron is a geometric shape with an almost mystical quality: Compute its volume, and you get the answer to a central calculation in physics about how particles interact.&lt;/p&gt;
    &lt;p&gt;Now, a young mathematician at Cornell University named Pavel (Pasha) Galashin has found that the amplituhedron is also mysteriously connected to another completely unrelated subject: origami, the art of paper folding. In a proof posted in October 2024, he showed that patterns that arise in origami can be translated into a set of points that together form the amplituhedron. Somehow, the way paper folds and the way particles collide produce the same geometric shape.&lt;/p&gt;
    &lt;p&gt;“Pasha has done some brilliant work related to the amplituhedron before,” said Nima Arkani-Hamed, a physicist at the Institute for Advanced Study who introduced the amplituhedron in 2013 with his graduate student at the time, Jaroslav Trnka. “But this is next-level stuff for me.”&lt;/p&gt;
    &lt;p&gt;By drawing on this new link to origami, Galashin was also able to resolve an open conjecture about the amplituhedron, one that physicists had long assumed to be true but hadn’t been able to rigorously prove: that the shape really can be cut up into simpler building blocks that correspond to the calculations physicists want to make. In other words, the pieces of the amplituhedron really do fit together the way they’re supposed to.&lt;/p&gt;
    &lt;p&gt;The result doesn’t just build a bridge between two seemingly disparate areas of study. Galashin and other mathematicians are already exploring what else that bridge can tell them. They’re using it to better understand the amplituhedron — and to answer other questions in a far broader range of settings.&lt;/p&gt;
    &lt;head rend="h2"&gt;Explosive Computations&lt;/head&gt;
    &lt;p&gt;Physicists want to predict what will happen when fundamental particles interact. Say two subatomic particles called gluons collide. They might bounce off each other unchanged, or transform into a set of four gluons, or do something else entirely. Each outcome occurs with a certain probability, which is represented by a mathematical expression called a scattering amplitude.&lt;/p&gt;
    &lt;p&gt;For decades, physicists calculated scattering amplitudes in one of two ways. The first used Feynman diagrams, squiggly-line drawings that describe how particles move and interact. Each diagram represents a mathematical computation; by adding together the computations corresponding to different Feynman diagrams, you can calculate a given scattering amplitude. But as the number of particles in a collision increases, the number of Feynman diagrams you need grows explosively. Things quickly get out of hand: Computing the scattering amplitudes of relatively simple events can require adding thousands or even millions of terms.&lt;/p&gt;
    &lt;p&gt;The second method, introduced in the early 2000s, is called Britto-Cachazo-Feng-Witten (BCFW) recursion. It breaks up complex particle interactions into smaller, simpler interactions that are easier to study. You can calculate amplitudes for these simpler interactions and keep track of them using collections of vertices and edges called graphs. These graphs tell you how to stitch the simpler interactions back together in order to compute the scattering amplitude of the original collision.&lt;/p&gt;
    &lt;p&gt;BCFW recursion requires less work than Feynman diagrams. Instead of adding up millions of terms, you might only need to add up hundreds. But both methods have the same problem: The final answer is often much simpler than the extensive computations it takes to get there, with many terms canceling out in the end.&lt;/p&gt;
    &lt;p&gt;Then, in 2013, Arkani-Hamed and Trnka made a surprising discovery: that the complicated math of particle collisions is actually geometry in disguise.&lt;/p&gt;
    &lt;head rend="h2"&gt;Saved by Geometry&lt;/head&gt;
    &lt;p&gt;In the early 2000s, Alexander Postnikov, a mathematician at the Massachusetts Institute of Technology, was studying a geometric object known as the positive Grassmannian.&lt;/p&gt;
    &lt;p&gt;The positive Grassmannian, which has been a subject of mathematical interest since the 1930s, is built in a highly abstract way. First, take an n-dimensional space and consider all the planes of some given, smaller dimension that live inside it. For example, inside the three-dimensional space we inhabit, you can find infinitely many flat two-dimensional planes that spread out in every direction.&lt;/p&gt;
    &lt;p&gt;Each plane — essentially a slice of the larger n-dimensional space — can be defined by an array of numbers called a matrix. You can compute certain values from this matrix, called minors, that tell you about properties of the plane.&lt;/p&gt;
    &lt;p&gt;Now consider only those planes in your space whose minors are all positive. The collection of all such special “positive” planes gives you a complicated geometric space — the positive Grassmannian.&lt;/p&gt;
    &lt;p&gt;To understand the positive Grassmannian’s rich internal structure, mathematicians divvy it up into different regions, so that each region consists of an assortment of planes that share certain patterns. Postnikov, hoping to make this task easier, came up with a way to keep track of the different regions and how they fit together. He invented what he called plabic (short for “planar bicolored”) graphs — networks of black and white vertices connected by edges, drawn so that no edges cross. Each plabic graph captured one region of the positive Grassmannian, giving mathematicians a visual language for what would otherwise be defined by dense algebraic formulas.&lt;/p&gt;
    &lt;p&gt;Nearly a decade after Postnikov introduced his plabic graphs, Arkani-Hamed and Trnka were trying to calculate the scattering amplitudes of various particle collisions. As they grappled with their BCFW recursion formulas, they noticed something uncanny. The graphs they were using to keep track of their calculations looked just like Postnikov’s plabic graphs. Curious, they drove up to MIT to meet him.&lt;/p&gt;
    &lt;p&gt;“At lunch we said, ‘It’s weird, we’re seeing exactly the same thing,’” Arkani-Hamed recalled.&lt;/p&gt;
    &lt;p&gt;They were right. To calculate the scattering amplitude for a collision of n particles, physicists would have to add up many BCFW terms — and each of those terms corresponded to a region of the positive Grassmannian in n dimensions.&lt;/p&gt;
    &lt;p&gt;Arkani-Hamed and Trnka realized that this geometric connection might make it easier to compute scattering amplitudes. Using data about their particle collision — the momenta of the particles, for instance — they defined a lower-dimensional shadow of the positive Grassmannian. The total volume of this shadow was equal to the scattering amplitude.&lt;/p&gt;
    &lt;p&gt;And so the amplituhedron was born.&lt;/p&gt;
    &lt;p&gt;That was only the beginning of the story. Physicists and mathematicians wanted to confirm, for instance, that the same plabic graphs that defined regions of the positive Grassmannian could also define pieces of the amplituhedron — and that those pieces would have no gaps or overlaps, perfectly fitting together to encompass the shape’s exact volume. This hope came to be known as the triangulation conjecture: Could the amplituhedron be cleanly triangulated, or subdivided, into simpler building blocks?&lt;/p&gt;
    &lt;p&gt;Proving this would cement Arkani-Hamed and Trnka’s vision: that the complicated BCFW formulas that produced a particle collision’s scattering amplitude (albeit inefficiently) could be understood as the sum of the volumes of the amplituhedron’s building blocks.&lt;/p&gt;
    &lt;p&gt;This was no easy task. For one thing, from the get-go it was clear there were really two amplituhedra. The first was defined in momentum-twistor coordinates — a clever mathematical relabeling that made the shape easier to work with because it related naturally to the positive Grassmannian and Postnikov’s plabic graphs. Mathematicians were able to prove the triangulation conjecture for this version of the amplituhedron in 2021.&lt;/p&gt;
    &lt;p&gt;The other version, known as the momentum amplituhedron, was instead defined directly in terms of the momenta of colliding particles. Physicists cared more about this second version, because it spoke the same language as real particle collisions and scattering experiments. But it was also harder to describe mathematically. As a result, the triangulation conjecture remained wide open.&lt;/p&gt;
    &lt;p&gt;If triangulation were to fail for the momentum amplituhedron, then it would mean that the amplituhedron was not the right way to make sense of BCFW formulas for computing scattering amplitudes.&lt;/p&gt;
    &lt;p&gt;For more than a decade, the uncertainty lingered — until the study of paper folds began to suggest a way forward.&lt;/p&gt;
    &lt;head rend="h2"&gt;Finding Bigfoot&lt;/head&gt;
    &lt;p&gt;Pavel Galashin didn’t set out to study either origami or the amplituhedron. In 2018, as one of Postnikov’s graduate students, he and a colleague had just proved an intriguing link between the positive Grassmannian and the Ising model, which is used to study the behavior of systems like ferromagnets. Galashin was now trying to understand a celebrated proof about the Ising model — in particular, about special symmetries it exhibited — in terms of the positive Grassmannian.&lt;/p&gt;
    &lt;p&gt;While working through the proof — a project he intermittently returned to over the next few years — Galashin encountered a couple of intriguing papers where researchers used other kinds of diagrams to make the geometry more tractable: origami crease patterns. These are diagrams of lines that tell you where to fold paper to make, say, a crane or frog.&lt;/p&gt;
    &lt;p&gt;It might seem strange for origami to crop up here. But over the years, the mathematics of origami has turned out to be surprisingly deep. Problems about origami — such as whether a given crease pattern will produce a shape that you can flatten without tearing — are computationally hard to solve. And it’s now known that origami can be used to perform all sorts of computations.&lt;/p&gt;
    &lt;p&gt;In 2023, while probing what origami was doing in papers about the Ising model, Galashin came across a question that caught his attention. Say you only have information about a crease pattern’s outer boundary — the border of the paper, which the creases divide into various line segments. In particular, say you only have information about how those line segments are situated in space before and after folding. Can you always find a complete crease pattern that both satisfies those constraints and produces an origami shape that can flatten properly? Mathematicians had conjectured that the answer was yes, but no one could prove it.&lt;/p&gt;
    &lt;p&gt;Galashin found the conjecture striking, because in his usual area of research, which deals with the positive Grassmannian, examining the boundary of an object is a common way to gain information about it.&lt;/p&gt;
    &lt;p&gt;But for months, he made no progress on it. Then he came to a sudden realization: The problem didn’t just have the same flavor as his own line of work. It could be rewritten in the language of the amplituhedron. The momentum amplituhedron, at that.&lt;/p&gt;
    &lt;p&gt;“It took much longer than I care to admit,” he said. “You don’t expect the connection, so you never realize it. You’re not supposed to see Bigfoot in Manhattan.”&lt;/p&gt;
    &lt;p&gt;But could he prove it?&lt;/p&gt;
    &lt;head rend="h2"&gt;Forget Flat&lt;/head&gt;
    &lt;p&gt;Galashin considered a collision involving some number of particles, and started with a crease pattern boundary that was divided into that number of line segments.&lt;/p&gt;
    &lt;p&gt;He described each line segment with a vector that consisted of two numbers. Next, he wrote down vectors that described what the same segments’ new positions should be after folding. These were determined based on information about the momenta of the particles in his collision of interest.&lt;/p&gt;
    &lt;p&gt;For each segment, he then combined the “before” and “after” vectors into a single four-dimensional vector. By listing the numbers in all these vectors as one set of coordinates, Galashin was able to define a point in a high-dimensional space. And this point didn’t live just anywhere in high-dimensional space — it lived in the momentum amplituhedron.&lt;/p&gt;
    &lt;p&gt;Galashin showed that the answer to the origami question about flat-folding crease patterns was indeed yes — and that whenever such a crease pattern could be found for a given boundary, the point encoded by that boundary had to reside in the amplituhedron.&lt;/p&gt;
    &lt;p&gt;It was an entirely new way to think about the shape. “That’s the most amazing thing to me about Pasha’s work, that this connection to origami just gives you this incredibly beautiful one-line definition of the momentum amplituhedron,” Arkani-Hamed said.&lt;/p&gt;
    &lt;p&gt;Galashin’s new origami-based interpretation gave him an idea for how to finally solve the momentum amplituhedron’s central riddle. He could resolve the triangulation conjecture if he could show that each origami-derived point was situated not just inside the amplituhedron, but inside a very particular region — in just such a way that the regions would lock together without gaps or overlaps.&lt;/p&gt;
    &lt;p&gt;To do that, he devised an algorithm that took a boundary pattern as its input and assigned a unique crease pattern to it. The crease pattern would always obey the rules that linked it to the geometry of the amplituhedron: Namely, when folded, the paper would still be able to flatten.&lt;/p&gt;
    &lt;p&gt;Galashin then represented the crease pattern as a plabic graph: First, he drew a point in the middle of each region of the crease pattern, coloring it white if that region would face up once the paper was folded, and black if the region would face down. He then drew an edge between vertices in regions that shared a crease.&lt;/p&gt;
    &lt;p&gt;Finally, he showed that this graph carved out a region of the amplituhedron. The point encoded by that crease pattern’s boundary sat inside the region.&lt;/p&gt;
    &lt;p&gt;This was enough to resolve the triangulation question. If two regions in the amplituhedron overlapped — that is, if one point in the amplituhedron lived in two different regions — that would be equivalent to being able to match a boundary pattern to two different crease patterns. But Galashin had designed his algorithm to produce a unique match, so that was impossible. Similarly, the algorithm also implied that there could be no gaps: Every point in the amplituhedron could be rewritten as a boundary, and every boundary, when given as an input to the algorithm, landed neatly inside a region.&lt;/p&gt;
    &lt;p&gt;The amplituhedron fit together perfectly.&lt;/p&gt;
    &lt;head rend="h2"&gt;New Dreams&lt;/head&gt;
    &lt;p&gt;For mathematicians, the elegance of the argument was striking.&lt;/p&gt;
    &lt;p&gt;“To relate two seemingly unconnected ideas is always quite beautiful,” said Lauren Williams, a mathematician at Harvard University. “I hadn’t thought about origami crease patterns before, so it was a surprise to see them connected to the amplituhedron.”&lt;/p&gt;
    &lt;p&gt;Galashin shared her surprise. “I don’t have a good explanation for why boundaries of origami are points in the amplituhedron,” he said. “A priori there is no reason why one has to do with the other.” But he hopes that future investigations will uncover a deeper reason for the connection.&lt;/p&gt;
    &lt;p&gt;He is also hopeful that his result can help him with his original goal: to understand models of ferromagnetism and related systems through the lens of the positive Grassmannian. Perhaps using origami could help.&lt;/p&gt;
    &lt;p&gt;More broadly, physicists and mathematicians want to see if they can learn more about the amplituhedron — and wield it in a wider variety of theoretical calculations about particle collisions — by thinking about it in terms of origami. For instance, one goal is to be able to compute the scattering amplitude of a particle collision from the volume of the amplituhedron directly, without breaking it into pieces. Perhaps continuing to explore the link between crease patterns and particle collisions will help achieve this dream.&lt;/p&gt;
    &lt;p&gt;“As a physicist, I would not have come up with this in a million years,” Arkani-Hamed said. “But I find it a spectacular result, and I want to understand it more and see what it might tell us.”&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=45498469</guid><pubDate>Tue, 07 Oct 2025 01:34:32 +0000</pubDate></item><item><title>Pdoc – Generate API documentation for Python projects</title><link>https://pdoc.dev/</link><description>&lt;doc fingerprint="16c91461fc9ed2c5"&gt;
  &lt;main&gt;&lt;p&gt;&lt;code&gt;pdoc&lt;/code&gt; auto-generates API documentation that follows your project's Python module hierarchy.
                It requires no configuration, has first-class support for type annotations,
                cross-links between identifiers, comes with an integrated live-reloading web server,
                and understands numpydoc or Google-style docstrings.
            &lt;/p&gt;&lt;head rend="h2"&gt;Installation&lt;/head&gt;&lt;p&gt;Latest Release: 15.0.4&lt;/p&gt; Documentation Changelog PyPI GitHub &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=45499170</guid><pubDate>Tue, 07 Oct 2025 03:40:41 +0000</pubDate></item><item><title>California law forces Netflix, Hulu to turn down ad volumes</title><link>https://www.politico.com/news/2025/10/06/dial-it-down-california-forces-netflix-hulu-to-lower-ad-volume-00595663</link><description></description><guid isPermaLink="false">https://news.ycombinator.com/item?id=45499281</guid><pubDate>Tue, 07 Oct 2025 04:03:49 +0000</pubDate></item><item><title>Learning a foreign language–before you're born</title><link>https://nouvelles.umontreal.ca/en/article/2025/10/03/learning-a-foreign-language-before-you-re-born</link><description>&lt;doc fingerprint="d3707dadc9ef5906"&gt;
  &lt;main&gt;
    &lt;p&gt;Can your brain attune itself to a foreign language before you’re born? A UdeM-led team of neuropsychology researchers has found that it can. A few weeks of prenatal exposure to a new language is enough to rewire the language networks in a newborn’s brain. From the very first hours of life, the foreign language heard in the womb is processed along the same neural pathways as the mother tongue, while a completely new foreign language is processed differently.&lt;/p&gt;
    &lt;p&gt;The findings are reported in an article published in Communications Biology. Lead authors Andréanne René and Laura Caron-Desrochers are doctoral students in Université de Montréal’s Department of Psychology, supervised by Professor Anne Gallagher. The study was funded by the Natural Sciences and Engineering Research Council of Canada.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=45499730</guid><pubDate>Tue, 07 Oct 2025 05:43:56 +0000</pubDate></item><item><title>Deloitte to refund the Australian government after using AI in $440k report</title><link>https://www.theguardian.com/australia-news/2025/oct/06/deloitte-to-pay-money-back-to-albanese-government-after-using-ai-in-440000-report</link><description>&lt;doc fingerprint="b60d88152e1fdfd2"&gt;
  &lt;main&gt;
    &lt;p&gt;Deloitte will provide a partial refund to the federal government over a $440,000 report that contained several errors, after admitting it used generative artificial intelligence to help produce it.&lt;/p&gt;
    &lt;p&gt;The Department of Employment and Workplace Relations (DEWR) confirmed Deloitte would repay the final instalment under its contract, which will be made public after the transaction is finalised. It comes as one Labor senator accused the consultancy firm of having a “human intelligence problem”.&lt;/p&gt;
    &lt;p&gt;Deloitte was commissioned by the department to review the targeted compliance framework and its IT system, used to automate penalties in the welfare system if mutual obligations weren’t met by jobseekers, in December 2024.&lt;/p&gt;
    &lt;p&gt;Sign up: AU Breaking News email&lt;/p&gt;
    &lt;p&gt;The subsequent report found widespread issues, including a lack of “traceability” between the rules of the framework and the legislation behind it, as well as “system defects”. It said an IT system was “driven by punitive assumptions of participant non-compliance”.&lt;/p&gt;
    &lt;p&gt;It was first published on 4 July. It was re-uploaded to the DEWR website on Friday, after the Australian Financial Review in August reported that multiple errors had been found, including nonexistent references and citations.&lt;/p&gt;
    &lt;p&gt;University of Sydney academic, Dr Christopher Rudge, who first highlighted the errors, said the report contained “hallucinations” where AI models may fill in gaps, misinterpret data, or try to guess answers.&lt;/p&gt;
    &lt;p&gt;“Instead of just substituting one hallucinated fake reference for a new ‘real’ reference, they’ve substituted the fake hallucinated references and in the new version, there’s like five, six or seven or eight in their place,” he said.&lt;/p&gt;
    &lt;p&gt;“So what that suggests is that the original claim made in the body of the report wasn’t based on any one particular evidentiary source.”&lt;/p&gt;
    &lt;p&gt;The updated review noted a “small number of corrections to references and footnotes”, but the department has said there have been no changes to the review’s recommendations.&lt;/p&gt;
    &lt;p&gt;“Deloitte conducted the independent assurance review and has confirmed some footnotes and references were incorrect,” a spokesperson for the department said.&lt;/p&gt;
    &lt;p&gt;“The substance of the independent review is retained, and there are no changes to the recommendations.”&lt;/p&gt;
    &lt;p&gt;In the updated version of the report, Deloitte added reference to the use of generative AI in its appendix. It states that a part of the report “included the use of a generative artificial intelligence (AI) large language model (Azure OpenAI GPT – 4o) based tool chain licensed by DEWR and hosted on DEWR’s Azure tenancy.”&lt;/p&gt;
    &lt;p&gt;Deloitte did not state that artificial intelligence was the reason behind the errors in its original report. It also stood by the original findings of the review.&lt;/p&gt;
    &lt;p&gt;“The updates made in no way impact or affect the substantive content, findings and recommendations in the report,” it stated in the amended version.&lt;/p&gt;
    &lt;p&gt;A spokesperson for Deloitte said “the matter has been resolved directly with the client”.&lt;/p&gt;
    &lt;p&gt;Rudge said that, despite his criticism, he hesitates to say the whole report should be “regarded as illegitimate”, because the conclusions concur with other widespread evidence.&lt;/p&gt;
    &lt;p&gt;Labor senator Deborah O’Neill, who was on a senate inquiry into the integrity of consulting firms, said it looked like “AI is being left to do the heavy lifting”.&lt;/p&gt;
    &lt;p&gt;“Deloitte has a human intelligence problem. This would be laughable if it wasn’t so lamentable. A partial refund looks like a partial apology for substandard work,” she said.&lt;/p&gt;
    &lt;p&gt;“Anyone looking to contract these firms should be asking exactly who is doing the work they are paying for, and having that expertise and no AI use verified.&lt;/p&gt;
    &lt;p&gt;“Perhaps instead of a big consulting firm, procurers would be better off signing up for a ChatGPT subscription.”&lt;/p&gt;
    &lt;p&gt;The AFR found several incorrect references in the original report, including nonexistent reports by professors at the University of Sydney and the Lund University in Sweden.&lt;/p&gt;
    &lt;p&gt;The paper also reported a made-up reference to a court decision in a robodebt case, Deanna Amato v Commonwealth. Deloitte wrote in its final report that the update “amend[ed] the summary of the Amato proceeding which contained errors”.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=45500485</guid><pubDate>Tue, 07 Oct 2025 07:51:57 +0000</pubDate></item><item><title>Ford CEO Says There Aren't Enough Mechanics. Then a Mechanic Responds</title><link>https://www.motor1.com/news/774805/ford-ceo-complains-shortage-mechanics/</link><description>&lt;doc fingerprint="2e58f1f73be0cce7"&gt;
  &lt;main&gt;
    &lt;head rend="h1"&gt;'It Pays Like .6:' Ford CEO Says There Aren't Enough Mechanics. Then a Mechanic Responds&lt;/head&gt;
    &lt;head rend="h2"&gt;After Ford's CEO talked about a mechanic shortage, a mechanic offered a reason why no one wants to work in the industry.&lt;/head&gt;
    &lt;p&gt;Ford’s CEO recently said that there is a shortage of mechanics in the US. A mechanic says he knows exactly why it’s hard to find good help these days—and that car companies themselves may be to blame.&lt;/p&gt;
    &lt;p&gt;Wiktor Ivanovko posted a video to his Facebook page. It starts with a clip of comments made by Ford CEO Jim Farley to Yahoo Finance about how a lack of skilled mechanics is impacting the auto industry.&lt;/p&gt;
    &lt;p&gt;"This morning when I woke up, there were 6,000 bays in our dealerships," Farley says in the clip.&lt;/p&gt;
    &lt;p&gt;Yahoo Finance editor Brian Sozzi asks, "Why is there a shortage of these workers?"&lt;/p&gt;
    &lt;p&gt;"Well, it’s a complicated problem, but—" Farley says as the video cuts out.&lt;/p&gt;
    &lt;head rend="h2"&gt;Response to Ford CEO's Skilled Workers Comments&lt;/head&gt;
    &lt;p&gt;Clearly, Ivanovko thinks he’s got an idea why Ford is struggling to hire skilled mechanics. And it doesn’t have to do with lack of trained workers. It’s all about engineering and flat-rate pay for repairs under warranty.&lt;/p&gt;
    &lt;p&gt;“You’ll have to do this oil pan gasket on this F-250,” Ivanovko says, mimicking a Ford dealership manager. “You’ll have to pull the cab off of the frame to do it. And it’s under warranty, so it pays like .6 [hours]. Why don’t you want to work for me?”&lt;/p&gt;
    &lt;head rend="h3"&gt;FROM THE TRENDING NEWS DESK&lt;/head&gt;
    &lt;p&gt;Viral bits from across the social media landscape&lt;/p&gt;
    &lt;p&gt;Our team of experts tracks what's trending so you don't have to—from viral videos to online debates that have everyone talking.&lt;/p&gt;
    &lt;p&gt;Estimates vary, but online consensus is that it will take at least a few hours to remove the cab of a truck, and upwards of an entire day. But if the warranty pays a flat rate of just 40 minutes for a repair that requires removing the cab first, the mechanic is essentially losing time and money.&lt;/p&gt;
    &lt;p&gt;Many self-identified mechanics who commented on Ivanovko’s post blamed the engineers who design vehicles for making them difficult to work on.&lt;/p&gt;
    &lt;p&gt;“Engineers should design them to be worked on. Not to speed up the assembly process,” wrote one.&lt;/p&gt;
    &lt;head rend="h2"&gt;Why Is Ford Struggling to Hire Skilled Mechanics?&lt;/head&gt;
    &lt;p&gt;While Ford has 6,000 open positions, Farley estimated that the overall economy needs another 400,000 mechanic technicians. He blamed the gap on decreased productivity over the past 20 years, the lack of glamour associated with the position, and excessive regulation.&lt;/p&gt;
    &lt;p&gt;According to MarketWatch, the automotive industry is indeed short nearly half a million mechanics. While Farley focused on public perception of working people as a primary driver of this shortage, analysts attributed it to a lack of mechanics graduating from school, a wave of retirements by older generations of mechanics, and the fact that new vehicles generally last longer than older ones.&lt;/p&gt;
    &lt;p&gt;Mechanics on a Reddit thread posted to r/AutoMechanics earlier this year note the study and dedication needed to learn the trade, the long hours, and the physical aspect of the job. Add to that the fact that it’s more expensive than ever to run an auto body shop, and you’ve got a recipe for a shortage.&lt;/p&gt;
    &lt;p&gt;However, there are signs this trend might be reversing, including an increased number of mechanic graduates entering the job market.&lt;/p&gt;
    &lt;head rend="h2"&gt;Viewers React to Ivanovko’s Ford Response&lt;/head&gt;
    &lt;p&gt;In the comments, viewers reacted to Ivanovko’s retort to the Ford CEO. Many said his criticism is justified.&lt;/p&gt;
    &lt;p&gt;“Always been a strong believer that if you want to be an engineer, you should have to work in the trade for no less than two years,” wrote one viewer. “So they understand what it takes.”&lt;/p&gt;
    &lt;p&gt;“And you have to buy all of your own tools to do it,” agreed a second viewer.&lt;/p&gt;
    &lt;p&gt;A third viewer added, “I’m not a mechanic, but maybe make vehicles that are less of a hassle to work on and this goes for all vehicle manufacturers.”&lt;/p&gt;
    &lt;p&gt;Motor1 contacted Ivanovko via Instagram direct message for comment. We’ll update this if he responds.&lt;/p&gt;
    &lt;p&gt;RECOMMENDED FOR YOU&lt;/p&gt;
    &lt;p&gt;Every Manual Car You Can Still Buy in 2025&lt;/p&gt;
    &lt;p&gt;The New Honda Prelude Is a Smash Hit, Especially Among Older Folks&lt;/p&gt;
    &lt;p&gt;Performance Car Sales Are Depressingly Low&lt;/p&gt;
    &lt;p&gt;Toyota Says What Everyone Thinks: Mild-Hybrids Aren't Really Hybrids&lt;/p&gt;
    &lt;p&gt;The Best Cheap Sports Cars You Can Buy in 2026&lt;/p&gt;
    &lt;p&gt;Car Salesman Says This Make and Model Is 'So Ugly' That Even ‘Desperate’ People With Bad Credit Don’t Want It&lt;/p&gt;
    &lt;p&gt;‘I Don’t Blame Your Neighbors!:’ Ford Driver Has A Loud, Custom Mustang. Then The Police Get Called To Check If It’s Too Loud&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=45500699</guid><pubDate>Tue, 07 Oct 2025 08:27:41 +0000</pubDate></item></channel></rss>