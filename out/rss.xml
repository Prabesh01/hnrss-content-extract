<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>Hacker News: Front Page</title><link>https://raw.githubusercontent.com/Prabesh01/hnrss-content-extract/refs/heads/main/out/rss.xml</link><description>Hacker News RSS</description><atom:link href="https://raw.githubusercontent.com/Prabesh01/hnrss-content-extract/refs/heads/main/out/rss.xml" rel="self"/><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><language>en</language><lastBuildDate>Fri, 03 Oct 2025 20:10:46 +0000</lastBuildDate><item><title>In Praise of RSS and Controlled Feeds of Information</title><link>https://blog.burkert.me/posts/in_praise_of_syndication/</link><description>&lt;doc fingerprint="e6f45a221ea4acb5"&gt;
  &lt;main&gt;
    &lt;p&gt;The way we consume content on the internet is increasingly driven by walled-garden platforms and black-box feed algorithms. This shift is making our media diets miserable. Ironically, a solution to the problem predates algorithmic feeds, social media and other forms of informational junk food. It is called RSS (Really Simple Syndication) and it is beautiful.&lt;/p&gt;
    &lt;head rend="h2"&gt;What the hell is RSS?&lt;/head&gt;
    &lt;p&gt;RSS is just a format that defines how websites can publish updates (articles, posts, episodes, and so on) in a standard feed that you can subscribe to using an RSS reader (or aggregator). Don’t worry if this sounds extremely uninteresting to you; there aren’t many people that get excited about format specifications; the beauty of RSS is in its simplicity. Any content management system or blog platform supports RSS out of the box, and often enables it by default. As a result, a large portion of the content on the internet is available to you in feeds that you can tap into. But this time, you’re in full control of what you’re receiving, and the feeds are purely reverse chronological bliss. Coincidentally, you might already be using RSS without even knowing, because the whole podcasting world runs on RSS.&lt;/p&gt;
    &lt;p&gt;There are many amazing articles about the utility and elegance of RSS, and I do not think the world needs another, so I will spare you and instead focus on my personal experience and tips. If you are interested in a deeper dive, I highly recommend Molly White’s article Curate your own newspaper with RSS. It is a convincing, well-written article that you can also listen to in Molly’s own voice if you wish to.&lt;/p&gt;
    &lt;head rend="h2"&gt;Broken distribution models&lt;/head&gt;
    &lt;p&gt;Here’s a little story about the promise of social media. In 2011, my band was getting a little more serious and preparing to record our first album. Facebook was rapidly growing all over the world, so I created an account - mostly to manage my band’s Facebook page. Back then, social media (and Facebook in particular) felt very different: vibrant and full of promise for the brave new future of web 2.0. I looked up all my favorite bands so that every time they put out an album or tour near me, I wouldn’t miss it. Many bands either lacked proper websites or rarely updated them in a useful way, so this felt like the perfect use case for Facebook.&lt;/p&gt;
    &lt;p&gt;It didn’t take long for me to start seeing the cracks. As Facebook would push for more engagement, some bands would flood their pages with multiple posts per day, especially if they were touring or had a new release coming up. Others would be more restrained, but then their posts would often be lost in the feed. There was no way to opt in only for a certain type of updates from my followed pages, and the increasingly algorithmic feed would simply prioritize posts by engagement. I realized that I wouldn’t be able to get just the important updates; instead, I’d get a wild mish-mash of engagement-bait that I wasn’t willing to work my way through. And don’t get me started about how over time, page owners had to pay to promote their posts to get any reach on the platform - that is simply extortion.&lt;/p&gt;
    &lt;p&gt;I no longer use Facebook (or any similar social media for that matter) for many reasons, though algorithmic feeds are at the top of the list. Algorithms on social media are very unlikely to be written with your best interest in mind: The goal of social media is to keep you glued to the feed for as long as possible. It optimizes for the most time spent, for engagement, for serving the most ads. It will not necessarily optimize for keeping you well informed, showing you balanced opinions, giving you control or even showing you all the information you’d like. The misalignment of incentives has become very apparent in the last few years, but the problem goes deeper. Any type of curation (because algorithmic feeds are simply curation machines) will never be flexible enough to account for every person’s needs. The story we are sold with algorithmic curation is that it adapts to everyone’s taste and interests, but that’s only true until the interests of the advertisers enter the picture.&lt;/p&gt;
    &lt;head rend="h2"&gt;How I use RSS&lt;/head&gt;
    &lt;p&gt;My RSS journey starting many moons ago with Opera and Thunderbird, continued with Google Reader (RIP) and The Old Reader, and finally led me to running my own instance of FreshRSS. However, in the last year, I have read most of the content from my RSS feeds on my phone via the FeedMe app. I find that it scratches the itch of unlocking your phone and wanting to see something novel (probably gravitating towards social media). On the upside, it feeds me only articles and media that a) I have picked upfront and nothing more, b) is typically longer-form and more thoughtful than your typical social media posts.&lt;/p&gt;
    &lt;p&gt;Also, unlike algorithmic feeds, it allows me to pick what category of my interests I am in the mood for. If I’m in the mood for something lighter, I can just look into my “Fun” folder to check out new stuff from The Oatmeal or xkcd. If I feel like reading something more thoughtful, I’d dive into my “Reads” folder for The Marginalian or Sentiers. Feeling like catching up on the newest AI research? I can browse the latest research papers from arXiv that have specific keywords in the abstracts (such as prompt injection). Or I could just browse everything at once to see what piques my interest. I am the master of what information I consume, how and in what order, and no one can take that away from me by rearranging my feed or tweaking the algorithm.&lt;/p&gt;
    &lt;p&gt;One of the many small advantages is the consistency of the interface and the lack of distractions when reading. Modern browsers support reader modes, but you need to enter the mode manually and some pages might not be displayed correctly. I don’t have any attention problems (that I know of), but reading articles on certain newspaper sites feels like a cruel joke: the text of the article is often drowned by ads, suggested articles, polls, and other visual smog. Not a pleasant reading experience. Your RSS reader always uses the same font, font size, screen real estate and never shows anything but the article itself.&lt;/p&gt;
    &lt;p&gt;The focused, reductive nature of RSS readers means you don’t get the full website experience, but that is arguably for the better in a lot of cases. We already mentioned the lack of suggested articles with engagement bait that could easily draw you in, but another notable omission is the comments section. It is very easy to slip into the comments section at the bottom of an article and spend far too much time reading those. You can still do that in an RSS reader by opening the article in your browser, scrolling down to the comments and diving in. At least in my case, that is a safe amount of friction to prevent me from doing it most of the time. Less is more!&lt;/p&gt;
    &lt;head rend="h2"&gt;Tips to get you going&lt;/head&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Many of the websites you open regularly, follow on social media or get a newsletter from, likely have an RSS feed. Look out for the RSS icon or the words RSS or feed. There are also tools like Lighthouse that can sniff out the feed for you. That said, my experience is that simply adding the homepage URL of the website into an aggregator usually works.&lt;/item&gt;
      &lt;item&gt;Remember my frustration with Facebook as a source of news for new music releases? Turns out there is a much better free solution called Muspy, where you enter all your favorite artists and it will notify you of their new releases. And guess what? You either get notified via email, or you use your personal RSS feed. Highly recommended!&lt;/item&gt;
      &lt;item&gt;Start easy with something like The Old Reader or Feedly - both offer relatively generous free tiers. And if you outgrow them or want to try something else, you simply export an OPML file with all your feeds and import them into your new RSS solution. This is the upside of open standards: freedom, ownership, and portability.&lt;/item&gt;
      &lt;item&gt;Once you have more than 5-10 feeds, start putting them into folders/categories. No need to overthink it, but doing this will help you be more selective about the content you read if you’re in a specific mood.&lt;/item&gt;
      &lt;item&gt;RSS readers can be great when traveling or whenever your internet connection might be down or spotty. You can set up your RSS client in a way that automatically fetches new content, so when you board the plane and go dark, you can still read through the already downloaded articles. (Beware, though: not all RSS feeds include full content - sometimes they’re more like teasers.)&lt;/item&gt;
      &lt;item&gt;Some websites that limit how many articles you can browse for free are actually less strict about content accessed through RSS feeds. There are obvious ethical concerns with abusing this, but it is still an upside, and you are only consuming what they provide.&lt;/item&gt;
      &lt;item&gt;If you want to tinker, you can set up an RSS aggregator like FreshRSS, tiny tiny RSS or selfoss on a shared web hosting service. If you want to go full self-hosted, there are many more options available.&lt;/item&gt;
      &lt;item&gt;Get a good mobile app. Try a few before you settle! This is a highly personal choice because even small UI quirks and differences may bother you. If you’re anything like me, you’ll do most of the reading on your phone, so make sure it feels good.&lt;/item&gt;
      &lt;item&gt;RSS readers/clients often have bookmarking/starring system which works much like dedicated bookmarking apps.&lt;/item&gt;
      &lt;item&gt;Bigger publications often have separate feeds for individual categories or tags - check those to avoid getting your main feed flooded.&lt;/item&gt;
      &lt;item&gt;Some websites have very elaborate RSS APIs which allow you to query for specific types of content. For example, arXiv has a really elaborate one, allowing you to only follow specific topics. The documentation is quite complex, so here is a quick example to kick start you:&lt;list rend="ul"&gt;&lt;item&gt;&lt;code&gt;https://export.arxiv.org/api/query?search_query=abs:LLM+AND+multilingual&amp;amp;sortBy=submittedDate&amp;amp;sortOrder=descending&lt;/code&gt;&lt;/item&gt;&lt;item&gt;The query searches through the most recently submitted papers with the words LLM and multilingual in the abstract.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;Do a little cleanup from time to time: unsubscribe from feeds that no longer seem to interest you. It’s fine, no one will take offense, and your attention is too precious to be wasted on stuff that is not for you.&lt;/item&gt;
      &lt;item&gt;Don’t know where to start? Check out this list of 100 most popular RSS feeds, Feedspot’s 70 most popular feeds or Hostinger’s list of 55 popular blogs. Apart from that, Google is your friend (especially if you start searching for specific topics or niches), and good blogs often link to other blogs - all you need to do is to follow the breadcrumbs.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Happy RSS-ing!&lt;/p&gt;
    &lt;p&gt;EDIT: Hello, Hacker News! Thrilled to be on the front page.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=45459233</guid><pubDate>Fri, 03 Oct 2025 05:13:47 +0000</pubDate></item><item><title>Niri – A scrollable-tiling Wayland compositor</title><link>https://github.com/YaLTeR/niri</link><description>&lt;doc fingerprint="f76fe4761cb74b90"&gt;
  &lt;main&gt;
    &lt;p&gt;A scrollable-tiling Wayland compositor.&lt;/p&gt;
    &lt;p&gt;Getting Started | Configuration | Setup Showcase&lt;/p&gt;
    &lt;p&gt;Windows are arranged in columns on an infinite strip going to the right. Opening a new window never causes existing windows to resize.&lt;/p&gt;
    &lt;p&gt;Every monitor has its own separate window strip. Windows can never "overflow" onto an adjacent monitor.&lt;/p&gt;
    &lt;p&gt;Workspaces are dynamic and arranged vertically. Every monitor has an independent set of workspaces, and there's always one empty workspace present all the way down.&lt;/p&gt;
    &lt;p&gt;The workspace arrangement is preserved across disconnecting and connecting monitors where it makes sense. When a monitor disconnects, its workspaces will move to another monitor, but upon reconnection they will move back to the original monitor.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Built from the ground up for scrollable tiling&lt;/item&gt;
      &lt;item&gt;Dynamic workspaces like in GNOME&lt;/item&gt;
      &lt;item&gt;An Overview that zooms out workspaces and windows&lt;/item&gt;
      &lt;item&gt;Built-in screenshot UI&lt;/item&gt;
      &lt;item&gt;Monitor and window screencasting through xdg-desktop-portal-gnome &lt;list rend="ul"&gt;&lt;item&gt;You can block out sensitive windows from screencasts&lt;/item&gt;&lt;item&gt;Dynamic cast target that can change what it shows on the go&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;Touchpad and mouse gestures&lt;/item&gt;
      &lt;item&gt;Group windows into tabs&lt;/item&gt;
      &lt;item&gt;Configurable layout: gaps, borders, struts, window sizes&lt;/item&gt;
      &lt;item&gt;Gradient borders with Oklab and Oklch support&lt;/item&gt;
      &lt;item&gt;Animations with support for custom shaders&lt;/item&gt;
      &lt;item&gt;Live-reloading config&lt;/item&gt;
      &lt;item&gt;Works with screen readers&lt;/item&gt;
    &lt;/list&gt;
    &lt;head class="px-3 py-2"&gt;demo.mp4&lt;/head&gt;
    &lt;p&gt;Also check out this video from Brodie Robertson that showcases a lot of the niri functionality: Niri Is My New Favorite Wayland Compositor&lt;/p&gt;
    &lt;p&gt;Niri is stable for day-to-day use and does most things expected of a Wayland compositor. Many people are daily-driving niri, and are happy to help in our Matrix channel.&lt;/p&gt;
    &lt;p&gt;Give it a try! Follow the instructions on the Getting Started page. Have your waybars and fuzzels ready: niri is not a complete desktop environment. Also check out awesome-niri, a list of niri-related links and projects.&lt;/p&gt;
    &lt;p&gt;Here are some points you may have questions about:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Multi-monitor: yes, a core part of the design from the very start. Mixed DPI works.&lt;/item&gt;
      &lt;item&gt;Fractional scaling: yes, plus all niri UI stays pixel-perfect.&lt;/item&gt;
      &lt;item&gt;NVIDIA: seems to work fine.&lt;/item&gt;
      &lt;item&gt;Floating windows: yes, starting from niri 25.01.&lt;/item&gt;
      &lt;item&gt;Input devices: niri supports tablets, touchpads, and touchscreens. You can map the tablet to a specific monitor, or use OpenTabletDriver. We have touchpad gestures, but no touchscreen gestures yet.&lt;/item&gt;
      &lt;item&gt;Wlr protocols: yes, we have most of the important ones like layer-shell, gamma-control, screencopy. You can check on wayland.app at the bottom of each protocol's page.&lt;/item&gt;
      &lt;item&gt;Performance: while I run niri on beefy machines, I try to stay conscious of performance. I've seen someone use it fine on an Eee PC 900 from 2008, of all things.&lt;/item&gt;
      &lt;item&gt;Xwayland: integrated via xwayland-satellite starting from niri 25.08.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;niri: Making a Wayland compositor in Rust · December 2024&lt;/p&gt;
    &lt;p&gt;My talk from the 2024 Moscow RustCon about niri, and how I do randomized property testing and profiling, and measure input latency. The talk is in Russian, but I prepared full English subtitles that you can find in YouTube's subtitle language selector.&lt;/p&gt;
    &lt;p&gt;An interview with Ivan, the developer behind Niri · June 2025&lt;/p&gt;
    &lt;p&gt;An interview by a German tech podcast Das Triumvirat (in English). We talk about niri development and history, and my experience building and maintaining niri.&lt;/p&gt;
    &lt;p&gt;A tour of the niri scrolling-tiling Wayland compositor · July 2025&lt;/p&gt;
    &lt;p&gt;An LWN article with a nice overview and introduction to niri.&lt;/p&gt;
    &lt;p&gt;If you'd like to help with niri, there are plenty of both coding- and non-coding-related ways to do so. See CONTRIBUTING.md for an overview.&lt;/p&gt;
    &lt;p&gt;Niri is heavily inspired by PaperWM which implements scrollable tiling on top of GNOME Shell.&lt;/p&gt;
    &lt;p&gt;One of the reasons that prompted me to try writing my own compositor is being able to properly separate the monitors. Being a GNOME Shell extension, PaperWM has to work against Shell's global window coordinate space to prevent windows from overflowing.&lt;/p&gt;
    &lt;p&gt;Here are some other projects which implement a similar workflow:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;PaperWM: scrollable tiling on top of GNOME Shell.&lt;/item&gt;
      &lt;item&gt;karousel: scrollable tiling on top of KDE.&lt;/item&gt;
      &lt;item&gt;scroll and papersway: scrollable tiling on top of sway/i3.&lt;/item&gt;
      &lt;item&gt;hyprscrolling and hyprslidr: scrollable tiling on top of Hyprland.&lt;/item&gt;
      &lt;item&gt;PaperWM.spoon: scrollable tiling on top of macOS.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Our main communication channel is a Matrix chat, feel free to join and ask a question: https://matrix.to/#/#niri:matrix.org&lt;/p&gt;
    &lt;p&gt;We also have a community Discord server: https://discord.gg/vT8Sfjy7sx&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=45461500</guid><pubDate>Fri, 03 Oct 2025 11:08:42 +0000</pubDate></item><item><title>A Thermometer for Measuring Quantumness</title><link>https://www.quantamagazine.org/a-thermometer-for-measuring-quantumness-20251001/</link><description>&lt;doc fingerprint="f5dbf1ebe585c5e8"&gt;
  &lt;main&gt;
    &lt;head rend="h1"&gt;A Thermometer for Measuring Quantumness&lt;/head&gt;
    &lt;head rend="h2"&gt;Introduction&lt;/head&gt;
    &lt;p&gt;If there’s one law of physics that seems easy to grasp, it’s the second law of thermodynamics: Heat flows spontaneously from hotter bodies to colder ones. But now, gently and almost casually, Alexssandre de Oliveira Jr. has just shown me I didn’t truly understand it at all.&lt;/p&gt;
    &lt;p&gt;Take this hot cup of coffee and this cold jug of milk, the Brazilian physicist said as we sat in a café in Copenhagen. Bring them into contact and, sure enough, heat will flow from the hot object to the cold one, just as the German scientist Rudolf Clausius first stated formally in 1850. However, in some cases, de Oliveira explained, physicists have learned that the laws of quantum mechanics can drive heat flow the opposite way: from cold to hot.&lt;/p&gt;
    &lt;p&gt;This doesn’t really mean that the second law fails, he added as his coffee reassuringly cooled. It’s just that Clausius’ expression is the “classical limit” of a more complete formulation demanded by quantum physics.&lt;/p&gt;
    &lt;p&gt;Physicists began to appreciate the subtlety of this situation more than two decades ago and have been exploring the quantum mechanical version of the second law ever since. Now, de Oliveira, a postdoctoral researcher at the Technical University of Denmark, and colleagues have shown that the kind of “anomalous heat flow” that’s enabled at the quantum scale could have a convenient and ingenious use.&lt;/p&gt;
    &lt;p&gt;It can serve, they say, as an easy method for detecting “quantumness” — sensing, for instance, that an object is in a quantum “superposition” of multiple possible observable states, or that two such objects are entangled, with states that are interdependent — without destroying those delicate quantum phenomena. Such a diagnostic tool could be used to ensure that a quantum computer is truly using quantum resources to perform calculations. It might even help to sense quantum aspects of the force of gravity, one of the stretch goals of modern physics. All that’s needed, the researchers say, is to connect a quantum system to a second system that can store information about it, and to a heat sink: a body that’s able to absorb a lot of energy. With this setup, you can boost the transfer of heat to the heat sink, exceeding what would be permitted classically. Simply by measuring how hot the sink is, you could then detect the presence of superposition or entanglement in the quantum system.&lt;/p&gt;
    &lt;p&gt;Practical benefits aside, the research demonstrates a new aspect of a deep truth about thermodynamics: How heat and energy can be transformed and moved in physical systems is intimately bound up with information — what is or can be known about those systems. In this case, we “pay for” the anomalous heat flow by sacrificing stored information about the quantum system.&lt;/p&gt;
    &lt;p&gt;“I love the idea that thermodynamic quantities can signal quantum phenomena,” said the physicist Nicole Yunger Halpern of the University of Maryland. “The topic is fundamental and deep.”&lt;/p&gt;
    &lt;head rend="h2"&gt;Knowledge Is Power&lt;/head&gt;
    &lt;p&gt;The connection between the second law of thermodynamics and information was first explored in the 19th century by the Scottish physicist James Clerk Maxwell. To Maxwell’s distress, Clausius’ second law seemed to imply that pockets of heat will dissipate throughout the universe until all temperature differences disappear. In the process, the total entropy of the universe — crudely, a measure of how disordered and featureless it is — will inexorably increase. Maxwell realized that this trend would eventually remove all possibility of harnessing heat flows to do useful work, and the universe would settle into a sterile equilibrium pervaded by a uniform buzz of thermal motion: a “heat death.” That forecast would be troubling enough to anyone. It was anathema to the devoutly Christian Maxwell. But in a letter to his friend Peter Guthrie Tait in 1867, Maxwell claimed to have found a way to “pick a hole” in the second law.&lt;/p&gt;
    &lt;p&gt;He imagined a tiny being (later dubbed a demon) who could see the motions of individual molecules in a gas. The gas would fill a box that was divided in two by a wall with a trapdoor. By opening and closing the trapdoor selectively, the demon could sequester the faster-moving molecules in one compartment and the slower-moving ones in the other, making a hot gas and a cold one, respectively. By acting on the information it gathered about molecules’ motions, the demon thus reduced the entropy of the gas, creating a temperature gradient that could be used to do mechanical work, such as pushing a piston.&lt;/p&gt;
    &lt;p&gt;Scientists felt sure that Maxwell’s demon couldn’t really violate the second law, but it took nearly 100 years to figure out why not. The answer is that the information the demon collects and stores about the molecular motions will eventually fill up its finite memory. Its memory must then be erased and reset for it to keep working. The physicist Rolf Landauer showed in 1961 that this erasure burns energy and produces entropy — more entropy than is reduced by the demon’s sorting actions. Landauer’s analysis established an equivalence between information and entropy, implying that information itself can act as a thermodynamic resource: It can be transformed into work. Physicists experimentally demonstrated this information-to-energy conversion in 2010.&lt;/p&gt;
    &lt;p&gt;But quantum phenomena allow information to be processed in ways that classical physics does not permit — that’s the entire basis of technologies such as quantum computing and quantum cryptography. And that’s why quantum theory messes with the conventional second law.&lt;/p&gt;
    &lt;head rend="h2"&gt;Exploiting Correlations&lt;/head&gt;
    &lt;p&gt;Entangled quantum objects have mutual information: They are correlated, so we can discover properties of one by looking at the other. That in itself is not so strange; if you look at one of a pair of gloves and find it’s left-handed, you know the other is right-handed. But a pair of entangled quantum particles differs from gloves in a particular way: Whereas the handedness of gloves is already fixed before you look, this isn’t the case for the particles, according to quantum mechanics. Before we measure them, it’s undecided which value of the observable property each particle in the entangled pair has. At that stage the only things we can know are the probabilities of the possible combinations of values, such as 50% left-right and 50% right-left. Only when we measure the state of one of the particles do these possibilities resolve themselves into a definite outcome. In that measurement process, the entanglement is destroyed.&lt;/p&gt;
    &lt;p&gt;If gas molecules are entangled in this way, then a Maxwell’s demon can manipulate them more efficiently than if all the molecules are moving independently. If, say, the demon knows that any fast-moving molecule it sees coming is correlated in such a way that it will be trailed by another fast one just a moment later, the demon doesn’t have to bother observing the second particle before opening the trapdoor to admit it. The thermodynamic cost of (temporarily) foiling the second law is lowered.&lt;/p&gt;
    &lt;p&gt;In 2004, the quantum theorists Časlav Brukner of the University of Vienna and Vlatko Vedral, then at Imperial College London, pointed out that this means macroscopic thermodynamic measurements can be used as a “witness” to reveal the presence of quantum entanglement between particles. Under certain conditions, they showed, a system’s heat capacity or its response to an applied magnetic field should carry an imprint of entanglement, if it is present.&lt;/p&gt;
    &lt;p&gt;In a similar vein, other physicists calculated that you can extract more work from a warm body when there is quantum entanglement in the system than when it is purely classical.&lt;/p&gt;
    &lt;p&gt;And in 2008, the physicist Hossein Partovi of California State University identified a particularly dramatic implication of the way quantum entanglement can undermine preconceptions derived from classical thermodynamics. He realized that the presence of entanglement can actually reverse the spontaneous flow of heat from a hot object to a cold one, seemingly upending the second law itself.&lt;/p&gt;
    &lt;p&gt;That reversal is a special kind of refrigeration, Yunger Halpern said. And as usual with refrigeration, it doesn’t come for free (and so doesn’t truly subvert the second law). Classically, refrigerating an object takes work: We have to pump the heat the “wrong” way by consuming fuel, thereby repaying the entropy that’s lost by making the cold object colder and the hot object hotter. But in the quantum case, Yunger Halpern said, instead of burning fuel to achieve refrigeration, “you burn the correlations.” In other words, as the anomalous heat flow proceeds, the entanglement gets destroyed: Particles that initially had correlated properties become independent. “We can use the correlations as a resource to push heat in the opposite direction,” Yunger Halpern said.&lt;/p&gt;
    &lt;p&gt;In effect, the fuel here is information itself: specifically the mutual information of the entangled hot and cold bodies.&lt;/p&gt;
    &lt;p&gt;Two years later, David Jennings and Terry Rudolph of Imperial College London clarified what’s going on. They showed how the second law of thermodynamics can be reformulated to include the case where mutual information is present, and they calculated the limits on how much the classical heat flow can be altered and even reversed by the consumption of quantum correlations.&lt;/p&gt;
    &lt;head rend="h2"&gt;The Demon Knows&lt;/head&gt;
    &lt;p&gt;When quantum effects are in play, then, the second law isn’t so simple. But can we do anything useful with the way quantum physics loosens the bounds of thermodynamic laws? That’s one of the goals of the discipline called quantum thermodynamics, in which some researchers seek to make quantum engines that run more efficiently than classical ones, or quantum batteries that charge more quickly.&lt;/p&gt;
    &lt;p&gt;Patryk Lipka-Bartosik of the Center for Theoretical Physics at the Polish Academy of Sciences has sought practical applications in the other direction: using thermodynamics as a tool for probing quantum physics. Last year, he and his co-workers saw how to realize Brukner and Vedral’s 2004 idea to use thermodynamic properties as a witness of quantum entanglement. Their scheme involves hot and cold quantum systems that are correlated with each other, and a third system to mediate the heat flow between the two. We can think of this third system as a Maxwell’s demon, except now it has a “quantum memory” that can itself be entangled with the systems it is manipulating. Being entangled with the demon’s memory effectively links the hot and cold systems so that the demon can infer something about one from the properties of the other.&lt;/p&gt;
    &lt;p&gt;Such a quantum demon can act as a kind of catalyst, helping heat transfer happen by accessing correlations that are inaccessible otherwise. That is, because it is entangled with the hot and cold objects, the demon can divine and exploit all their correlations systematically. And, again like a catalyst, this third system returns to its original state once the heat exchange between the objects is completed. In this way, the process can boost the anomalous heat flow beyond what can be achieved without such a catalyst.&lt;/p&gt;
    &lt;p&gt;The paper this year by de Oliveira, co-authored by Lipka-Bartosik and Jonatan Bohr Brask of the Technical University of Denmark, uses some of these same ideas but with a crucial difference that turns the setup into a kind of thermometer for measuring quantumness. In the earlier work, the demonlike quantum memory interacted with a correlated pair of quantum systems, one hot and one cold. But in the latest work, it sits between a quantum system (say, an array of entangled quantum bits, or qubits, in a quantum computer) and a simple heat sink with which the quantum system is not directly entangled.&lt;/p&gt;
    &lt;p&gt;Because the memory is entangled with both the quantum system and the sink, it can again catalyze heat flow between them beyond what is possible classically. In that process, entanglement within the quantum system converts into extra heat that enters the sink. So measuring the energy stored in the heat sink (akin to reading its “temperature”) reveals the presence of entanglement in the quantum system. But since the system and sink aren’t themselves entangled, the measurement doesn’t affect the state of the quantum system. This gambit circumvents the notorious way that measurements destroy quantumness. “If you simply tried to make a measurement on the [quantum] system directly, you’d destroy its entanglement before the process could even unfold,” de Oliveira said.&lt;/p&gt;
    &lt;p&gt;The new scheme has the advantage of being simple and general, said Vedral, who is now at the University of Oxford. “These verification protocols are very important,” he said: Whenever some quantum computer company makes a new announcement about the performance of its latest device, he said the question always arises of how (or if) they really know that entanglement among the qubits is helping with the computation. A heat sink could serve as a detector of such quantum phenomena purely via its energy change. To implement the idea, you might designate one quantum bit as the memory whose state reveals that of other qubits, and then couple this memory qubit to a set of particles that will serve as the sink, whose energy you can measure. (One proviso, Vedral added, is that you need to have very good control over your system to be sure there aren’t other sources of heat flow contaminating the measurements. Another is that the method will not detect all entangled states.)&lt;/p&gt;
    &lt;p&gt;De Oliveira thinks that a system already exists for testing their idea experimentally. He and his colleagues are discussing that goal with Roberto Serra’s research group at the Federal University of ABC in São Paulo, Brazil. In 2016, Serra and colleagues used the magnetic orientations, or spins, of carbon and hydrogen atoms in molecules of chloroform as quantum bits between which they could transfer heat.&lt;/p&gt;
    &lt;p&gt;Using this setup, de Oliveira says it should be possible to exploit a quantum behavior — in this case coherence, meaning that the properties of two or more spins are evolving in phase with one another — to change the heat flow between the atoms. Coherence of qubits is essential for quantum computing, so being able to verify it by detecting anomalous heat exchange could be helpful.&lt;/p&gt;
    &lt;p&gt;The stakes could be even higher. Several research groups are trying to design experiments to determine whether gravity is a quantum force like the other three fundamental forces. Some of these efforts involve looking for quantum entanglement between two objects generated purely by their mutual gravitational attraction. Perhaps researchers could probe such gravity-induced entanglement by making simple thermodynamic measurements on them — thereby verifying (or not) that gravity really is quantized.&lt;/p&gt;
    &lt;p&gt;To study one of the deepest questions in physics, Vedral said, “wouldn’t it be lovely if you could do something as easy and macroscopic as this?”&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=45462143</guid><pubDate>Fri, 03 Oct 2025 12:24:02 +0000</pubDate></item><item><title>The Faroes</title><link>https://photoblog.nk412.com/Faroe2025/Faroes/n-cPCNFr</link><description>&lt;doc fingerprint="b6601c6e8caa7e9e"&gt;
  &lt;main&gt;
    &lt;head rend="h1"&gt;The Faroes (2025)&lt;/head&gt;
    &lt;p&gt;The Faroe Islands are like the child that Denmark and Iceland had, but forgot to tell the world about. This group of eighteen small islands receives the least amount of sunshine in the world per year. Constant rain and heavy winds have always battered these lands.&lt;lb/&gt;Politically part of Denmark (for now) but fiercely independent in spirit, the Faroes exist in their own bubble of Nordic culture. Here, sheep outnumber humans two to one, villages of colorful houses cling to clifftops like they're holding on for dear life, and the weather can shift from apocalyptic storms to sunny calm in the space of an hour.&lt;/p&gt;
    &lt;p&gt;Situated between Iceland, Norway and Scotland, the Faroes face the brunt of the North Atlantic weather system. Constant storms and crashing waves have sculpted the volcanic rock over millions of years into some of the most jaw-dropping (and vertigo-inducing) coastlines on Earth. These towering basalt cliffs can reach heights of over 400 meters, dropping straight into churning seas below.&lt;lb/&gt;What's most striking is how abruptly the land stops. There are no sandy beaches or gentle slopes here—the islands simply plunge headfirst into the Atlantic. One step you're on grass-covered clifftops, the next you're staring down hundreds of meters of sheer volcanic rock to where waves explode against the base far below.&lt;/p&gt;
    &lt;p&gt;The weather here is unpredictable, and changes faster than you can put your raincoat on—one minute you're in thick fog, the next you're hit with winds and piercing rain that'll knock you sideways, then suddenly the clouds part to reveal views that'll make your camera work overtime.&lt;/p&gt;
    &lt;p&gt;Meet the true locals of the Faroes. These wooly sheep have been roaming the islands for over a thousand years, and they outnumber people on the islands. They couldn't care less about your hiking plans and will casually block paths or graze on the edge of 200-meter cliffs like it's the most natural thing in the world.&lt;lb/&gt;Faroe's name comes from a combination of fær (sheep) and eyjar (islands). &lt;/p&gt;
    &lt;p&gt;Unlike their farm-bound cousins elsewhere, Faroese sheep roam completely free across the islands, somehow always managing to find the most photogenic spots for an impromptu rest. This fellow right here is the only one that gave me any sort of attention. Otherwise, they are all busy grazing on all the grass they could ever ask for.&lt;/p&gt;
    &lt;p&gt;Why fight the landscape? For over a millennium, islanders have been topping their huts with birch bark and soil and let the grass grow wild. They act as insulation, and the thick roots are an excellent waterproof seal against the weather.&lt;lb/&gt;The grass grows quickly and does need tending every once in a while. In typical Faroese fashion, the solution is simple: put a sheep on top for an afternoon.&lt;/p&gt;
    &lt;p&gt;On the northern tip of Kalsoy lies the Kallur lighthouse. Like most regions on the islands, the land is privately owned. Hiking usually incurs a modest fee paid at the trailhead to the land owners, and the rest is up to you. Trails are just sheep paths, worn smooth by countless hooves over years rather than any official trail maintenance.&lt;/p&gt;
    &lt;p&gt;There are no guardrails, no warning signs, and definitely no liability waivers - just you, the weather, and whatever route the sheep decided made sense. The approach to Kallur is particularly gnarly, following a knife-edge ridge with steep drops on both sides before reaching the lighthouse perched dramatically on sea cliffs.&lt;/p&gt;
    &lt;p&gt;In No Time To Die (2021), Daniel Craig's James Bond meets his end at the villain's lair, which happened to be here on Kalsoy. The Faroese then followed through with the obvious next step.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=45462297</guid><pubDate>Fri, 03 Oct 2025 12:41:03 +0000</pubDate></item><item><title>Arbitrary code execution in Unity Runtime</title><link>https://flatt.tech/research/posts/arbitrary-code-execution-in-unity-runtime/</link><description>&lt;doc fingerprint="b56811138876f9e9"&gt;
  &lt;main&gt;
    &lt;head rend="h1"&gt;CVE-2025-59489: Arbitrary Code Execution in Unity Runtime&lt;/head&gt;
    &lt;head rend="h5"&gt;Posted on October 3, 2025 • 6 minutes • 1067 words&lt;/head&gt;
    &lt;head class="flex items-center font-bold py-2 px-4 cursor-pointer justify-between select-none text-black dark:text-white"&gt;Table of contents&lt;/head&gt;
    &lt;head rend="h2"&gt;Introduction&lt;/head&gt;
    &lt;p&gt;Hello, I’m RyotaK (@ryotkak ), a security engineer at GMO Flatt Security Inc.&lt;/p&gt;
    &lt;p&gt;In May 2025, I participated in the Meta Bug Bounty Researcher Conference 2025. During this event, I discovered a vulnerability (CVE-2025-59489) in the Unity Runtime that affects games and applications built on Unity 2017.1 and later.&lt;/p&gt;
    &lt;p&gt;In this article, I will explain the technical aspects of this vulnerability and its impact.&lt;/p&gt;
    &lt;p&gt;This vulnerability was disclosed to Unity following responsible disclosure practices.&lt;lb/&gt; Unity has since released patches for Unity 2019.1 and later, as well as a Unity Binary Patch tool to address the issue, and I strongly encourage developers to download the updated versions of Unity, recompile affected games or applications, and republish as soon as possible.&lt;/p&gt;
    &lt;p&gt;For the official security advisory, please refer to Unity’s advisory here: https://unity.com/security/sept-2025-01&lt;/p&gt;
    &lt;p&gt;We appreciate Unity’s commitment to addressing this issue promptly and their ongoing efforts to enhance the security of their platform.&lt;lb/&gt; Security vulnerabilities are an inherent challenge in software development, and by working together as a community, we can continue to make software systems safer for everyone.&lt;/p&gt;
    &lt;head rend="h2"&gt;TL;DR&lt;/head&gt;
    &lt;p&gt;A vulnerability was identified in the Unity Runtime’s intent handling process for Unity games and applications.&lt;lb/&gt; This vulnerability allows malicious intents to control command line arguments passed to Unity applications, enabling attackers to load arbitrary shared libraries (&lt;code&gt;.so&lt;/code&gt; files) and execute malicious code, depending on the platform.&lt;/p&gt;
    &lt;p&gt;In its default configuration, this vulnerability allowed malicious applications installed on the same device to hijack permissions granted to Unity applications.&lt;lb/&gt; In specific cases, the vulnerability could be exploited remotely to execute arbitrary code, although I didn’t investigate third-party Unity applications to find an app with the functionality required to enable this exploit.&lt;/p&gt;
    &lt;p&gt;Unity has addressed this issue and has updated all affected Unity versions starting with 2019.1. Developers are strongly encouraged to download them, recompile their games and applications, and republish to ensure their projects remain secure.&lt;/p&gt;
    &lt;head rend="h2"&gt;About Unity&lt;/head&gt;
    &lt;p&gt;Unity is a popular game engine used to develop games and applications for various platforms, including Android.&lt;/p&gt;
    &lt;p&gt;According to Unity’s website, 70% of top mobile games are built with Unity. This includes popular games like Among Us and Pokémon GO, along with many other applications that use Unity for development.&lt;/p&gt;
    &lt;head rend="h2"&gt;Technical Details&lt;/head&gt;
    &lt;p&gt;Note: During the analysis, I used Android 16.0 on the Android Emulator of Android Studio. The behavior and impact of this vulnerability may differ on older Android versions.&lt;/p&gt;
    &lt;head rend="h3"&gt;Unity’s Intent Handler&lt;/head&gt;
    &lt;p&gt;To support debugging Unity applications on Android devices, Unity automatically adds a handler for the intent containing the &lt;code&gt;unity&lt;/code&gt; extra to the UnityPlayerActivity. This activity serves as the default entry point for applications and is exported to other applications.&lt;/p&gt;
    &lt;p&gt;https://docs.unity3d.com/6000.0/Documentation/Manual/android-custom-activity-command-line.html&lt;/p&gt;
    &lt;code&gt;adb shell am start -n "com.Company.MyGame/com.unity3d.player.UnityPlayerActivity" -e unity "-systemallocator"
&lt;/code&gt;
    &lt;p&gt;As documented above, the &lt;code&gt;unity&lt;/code&gt; extra is parsed as command line arguments for Unity.&lt;/p&gt;
    &lt;p&gt;While Android’s permission model manages feature access by granting permissions to applications, it does not restrict which intents can be sent to an application.&lt;lb/&gt; This means any application can send the &lt;code&gt;unity&lt;/code&gt; extra to a Unity application, allowing attackers to control the command line arguments passed to that application.&lt;/p&gt;
    &lt;head rend="h3"&gt;xrsdk-pre-init-library Command Line Argument&lt;/head&gt;
    &lt;p&gt;After loading the Unity Runtime binary into Ghidra, I discovered the following command line argument:&lt;/p&gt;
    &lt;code&gt;initLibPath = FUN_00272540(uVar5, "xrsdk-pre-init-library");
&lt;/code&gt;
    &lt;p&gt;The value of this command line argument is later passed to &lt;code&gt;dlopen&lt;/code&gt;, causing the path specified in &lt;code&gt;xrsdk-pre-init-library&lt;/code&gt; to be loaded as a native library.&lt;/p&gt;
    &lt;code&gt;lVar2 = dlopen(initLibPath, 2);  
&lt;/code&gt;
    &lt;p&gt;This behavior allows attackers to execute arbitrary code within the context of the Unity application, leveraging its permissions by launching them with the -xrsdk-pre-init-library argument.&lt;/p&gt;
    &lt;head rend="h2"&gt;Attack Scenarios&lt;/head&gt;
    &lt;head rend="h3"&gt;Local Attack&lt;/head&gt;
    &lt;p&gt;Any malicious application installed on the same device can exploit this vulnerability by:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Extracting the native library with the &lt;code&gt;android:extractNativeLibs&lt;/code&gt;attribute set to&lt;code&gt;true&lt;/code&gt;in the AndroidManifest.xml&lt;/item&gt;
      &lt;item&gt;Launching the Unity application with the &lt;code&gt;-xrsdk-pre-init-library&lt;/code&gt;argument pointing to the malicious library&lt;/item&gt;
      &lt;item&gt;The Unity application would then load and execute the malicious code with its own permissions&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h3"&gt;Remote Exploitation via Browser&lt;/head&gt;
    &lt;p&gt;In specific cases, this vulnerability could potentially be exploited remotely although the condition .&lt;lb/&gt; For example, if an application exports &lt;code&gt;UnityPlayerActivity&lt;/code&gt; or &lt;code&gt;UnityPlayerGameActivity&lt;/code&gt; with the &lt;code&gt;android.intent.category.BROWSABLE&lt;/code&gt; category (allowing browser launches), websites can specify extras passed to the activity using intent URLs:&lt;/p&gt;
    &lt;code&gt;intent:#Intent;package=com.example.unitygame;scheme=custom-scheme;S.unity=-xrsdk-pre-init-library%20/data/local/tmp/malicious.so;end;
&lt;/code&gt;
    &lt;p&gt;At first glance, it might appear that malicious websites could exploit this vulnerability by forcing browsers to download &lt;code&gt;.so&lt;/code&gt; files and load them via the &lt;code&gt;xrsdk-pre-init-library&lt;/code&gt; argument.&lt;/p&gt;
    &lt;head rend="h3"&gt;SELinux Restrictions&lt;/head&gt;
    &lt;p&gt;However, Android’s strict SELinux policy prevents &lt;code&gt;dlopen&lt;/code&gt; from opening files in the downloads directory, which mitigates almost all remote exploitation scenarios.&lt;/p&gt;
    &lt;code&gt;library "/sdcard/Download/libtest.so" ("/storage/emulated/0/Download/libtest.so") needed 
or dlopened by "/data/app/~~24UwD8jnw7asNjRwx1MOBg==/com.DefaultCompany.com.unity.template. 
mobile2D-E043IptGJDwcTqq56BocIA==/lib/arm64/libunity.so" is not accessible for the 
namespace: [name="clns-9", ld_library_paths="",default_library_paths="/data/app/~~24UwD8jnw7asNjRwx1MOBg==/com.DefaultCompany.com.unity.template. 
mobile2D-E043IptGJDwcTqq56BocIA==/lib/arm64:/data/app/~~24UwD8jnw7asNjRwx1MOBg==/com.DefaultCompany.com.unity.template.mobile2D-E043IptGJDwcTqq56BocIA==/base.apk!/lib/arm64-v8a", permitted_paths="/data:/mnt/expand:/data/data/com.DefaultCompany.com.unity.template.mobile2D"]
&lt;/code&gt;
    &lt;p&gt;That being said, since the &lt;code&gt;/data/&lt;/code&gt; directory is included in &lt;code&gt;permitted_paths&lt;/code&gt;, if the target application writes files to its private storage, it can be used to bypass this restriction.&lt;/p&gt;
    &lt;p&gt;Furthermore, &lt;code&gt;dlopen&lt;/code&gt; doesn’t require the &lt;code&gt;.so&lt;/code&gt; file extension. If attackers can control the content of a file in an application’s private storage, they can exploit this vulnerability by creating a file containing malicious native library binary. This is actually a common pattern when applications cache data.&lt;/p&gt;
    &lt;p&gt;For example, another vulnerability in Messenger was exploited using the application’s cache: https://www.hexacon.fr/slides/Calvanno-Defense_through_Offense_Building_a_1-click_Exploit_Targeting_Messenger_for_Android.pdf&lt;/p&gt;
    &lt;head rend="h3"&gt;Requirements for Remote Exploitation&lt;/head&gt;
    &lt;p&gt;To exploit this vulnerability remotely, the following conditions must be met:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;The application exports &lt;code&gt;UnityPlayerActivity&lt;/code&gt;or&lt;code&gt;UnityPlayerGameActivity&lt;/code&gt;with the&lt;code&gt;android.intent.category.BROWSABLE&lt;/code&gt;category&lt;/item&gt;
      &lt;item&gt;The application writes files with attacker-controlled content to its private storage (e.g., through caching)&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Even without these conditions, local exploitation remains possible for any Unity application.&lt;/p&gt;
    &lt;head rend="h2"&gt;Demonstration&lt;/head&gt;
    &lt;head rend="h2"&gt;Conclusion&lt;/head&gt;
    &lt;p&gt;In this article, I explained a vulnerability in Unity Runtime that allows arbitrary code execution in almost all Unity applications on Android.&lt;/p&gt;
    &lt;p&gt;I hope this article helps you understand that vulnerabilities can exist in the frameworks and libraries you depend on, and you should always be mindful of the security implications of the features you use.&lt;/p&gt;
    &lt;head rend="h2"&gt;Shameless plug&lt;/head&gt;
    &lt;p&gt;At GMO Flatt Security, we provide top-notch penetration testing for a wide range of targets, from Web apps to IoT devices.&lt;/p&gt;
    &lt;p&gt;https://flatt.tech/en/professional/penetration_test&lt;/p&gt;
    &lt;p&gt;We also developed Takumi, our AI security engineer. It’s an autonomous agent that finds vulnerabilities in source code and has already discovered CVEs in major libraries like Vim and Next.js. https://flatt.tech/en/takumi&lt;/p&gt;
    &lt;p&gt;Recently, we’ve expanded Takumi’s capabilities. It’s no longer just a SAST (white-box testing) tool; we’ve added DAST (black-box testing) to enable high-fidelity gray-box scanning for more accurate results.&lt;/p&gt;
    &lt;p&gt;Based in Japan, we work with clients globally, including industry leaders like Canonical Ltd.&lt;/p&gt;
    &lt;p&gt;If you’d like to learn more, please contact us at https://flatt.tech/en&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=45462713</guid><pubDate>Fri, 03 Oct 2025 13:21:44 +0000</pubDate></item><item><title>Webbol: A minimal static web server written in COBOL</title><link>https://github.com/jmsdnns/webbol</link><description>&lt;doc fingerprint="11bcbc59fd061f87"&gt;
  &lt;main&gt;
    &lt;p&gt;A minimal static web server written in COBOL using GnuCOBOL.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Serves static files from the current directory&lt;/item&gt;
      &lt;item&gt;Automatic MIME type detection for common file types&lt;/item&gt;
      &lt;item&gt;HTTP status codes: 200 (OK), 403 (Forbidden), 404 (Not Found), 413 (Payload Too Large)&lt;/item&gt;
      &lt;item&gt;Path traversal attack prevention&lt;/item&gt;
      &lt;item&gt;Clean request logging with full HTTP headers&lt;/item&gt;
      &lt;item&gt;Defaults to &lt;code&gt;index.html&lt;/code&gt;for root path requests&lt;/item&gt;
    &lt;/list&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;GnuCOBOL (cobc) compiler&lt;/item&gt;
      &lt;item&gt;POSIX-compatible operating system (Linux, macOS, BSD)&lt;/item&gt;
      &lt;item&gt;make&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;macOS:&lt;/p&gt;
    &lt;code&gt;brew install gnucobol&lt;/code&gt;
    &lt;p&gt;Ubuntu/Debian:&lt;/p&gt;
    &lt;code&gt;sudo apt-get install gnucobol&lt;/code&gt;
    &lt;p&gt;Fedora/RHEL:&lt;/p&gt;
    &lt;code&gt;sudo dnf install gnucobol&lt;/code&gt;
    &lt;p&gt;Clone or download the repository, then compile:&lt;/p&gt;
    &lt;code&gt;make&lt;/code&gt;
    &lt;p&gt;This will compile all modules and create the &lt;code&gt;webserver&lt;/code&gt; executable.&lt;/p&gt;
    &lt;p&gt;To clean build artifacts:&lt;/p&gt;
    &lt;code&gt;make clean&lt;/code&gt;
    &lt;p&gt;Start the server from the directory you want to serve:&lt;/p&gt;
    &lt;code&gt;./webserver&lt;/code&gt;
    &lt;p&gt;The server will start on port 8080 and serve files from the current directory.&lt;/p&gt;
    &lt;code&gt;# Create a test HTML file
echo "&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;&amp;lt;h1&amp;gt;Hello from COBOL!&amp;lt;/h1&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;" &amp;gt; index.html

# Start the server
./webserver

# In another terminal, test it
curl http://localhost:8080/&lt;/code&gt;
    &lt;p&gt;Once running, you can access files via:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;http://localhost:8080/&lt;/code&gt;- serves&lt;code&gt;index.html&lt;/code&gt;from the current directory&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;http://localhost:8080/filename.html&lt;/code&gt;- serves the specified file&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;http://localhost:8080/path/to/file.txt&lt;/code&gt;- serves files from subdirectories&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Press &lt;code&gt;Ctrl+C&lt;/code&gt; to stop the server.&lt;/p&gt;
    &lt;p&gt;To change the server port, edit &lt;code&gt;config.cpy&lt;/code&gt; and modify the &lt;code&gt;SERVER-PORT&lt;/code&gt; value:&lt;/p&gt;
    &lt;code&gt;01 SERVER-PORT          PIC 9(5) VALUE 8080.&lt;/code&gt;
    &lt;p&gt;Then recompile with &lt;code&gt;make&lt;/code&gt;.&lt;/p&gt;
    &lt;code&gt;webbol/
├── Makefile              # Build configuration
├── README.md            # This file
├── config.cpy           # Server configuration
├── socket-defs.cpy      # Socket structure definitions
├── http-structs.cpy     # HTTP data structures
├── file-structs.cpy     # File handling structures
├── path-utils.cbl       # Path validation and sanitization
├── mime-types.cbl       # MIME type detection
├── file-ops.cbl         # File reading operations
├── http-handler.cbl     # HTTP request/response handling
└── webserver.cbl        # Main server program
&lt;/code&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;HTML: &lt;code&gt;text/html&lt;/code&gt;&lt;/item&gt;
      &lt;item&gt;CSS: &lt;code&gt;text/css&lt;/code&gt;&lt;/item&gt;
      &lt;item&gt;JavaScript: &lt;code&gt;application/javascript&lt;/code&gt;&lt;/item&gt;
      &lt;item&gt;JSON: &lt;code&gt;application/json&lt;/code&gt;&lt;/item&gt;
      &lt;item&gt;XML: &lt;code&gt;application/xml&lt;/code&gt;&lt;/item&gt;
      &lt;item&gt;Plain text: &lt;code&gt;text/plain&lt;/code&gt;&lt;/item&gt;
      &lt;item&gt;PNG: &lt;code&gt;image/png&lt;/code&gt;&lt;/item&gt;
      &lt;item&gt;JPEG: &lt;code&gt;image/jpeg&lt;/code&gt;&lt;/item&gt;
      &lt;item&gt;GIF: &lt;code&gt;image/gif&lt;/code&gt;&lt;/item&gt;
      &lt;item&gt;SVG: &lt;code&gt;image/svg+xml&lt;/code&gt;&lt;/item&gt;
      &lt;item&gt;ICO: &lt;code&gt;image/x-icon&lt;/code&gt;&lt;/item&gt;
      &lt;item&gt;PDF: &lt;code&gt;application/pdf&lt;/code&gt;&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Additional MIME types can be added by editing &lt;code&gt;mime-types.cbl&lt;/code&gt;.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Path traversal prevention: Blocks requests containing &lt;code&gt;..&lt;/code&gt;sequences&lt;/item&gt;
      &lt;item&gt;Directory access restriction: Only serves files from the current directory and subdirectories&lt;/item&gt;
      &lt;item&gt;Safe file handling: Validates all paths before file system access&lt;/item&gt;
    &lt;/list&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Single-threaded: Handles one request at a time&lt;/item&gt;
      &lt;item&gt;No SSL/TLS support&lt;/item&gt;
      &lt;item&gt;Maximum file size: 64KB&lt;/item&gt;
      &lt;item&gt;Line sequential file organization only (text files)&lt;/item&gt;
      &lt;item&gt;No caching or compression&lt;/item&gt;
      &lt;item&gt;No range requests or partial content support&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Port already in use:&lt;/p&gt;
    &lt;code&gt;Bind failed - check if port is in use
&lt;/code&gt;
    &lt;p&gt;Another process is using port 8080. Either stop that process or change the port in &lt;code&gt;config.cpy&lt;/code&gt;.&lt;/p&gt;
    &lt;p&gt;Permission denied: Ensure the files you're trying to serve have read permissions and the current user can access them.&lt;/p&gt;
    &lt;p&gt;File not found (404): Verify the file exists in the current directory where the server is running. File paths are case-sensitive.&lt;/p&gt;
    &lt;p&gt;This project is released into the public domain. Use it however you'd like.&lt;/p&gt;
    &lt;p&gt;Built with GnuCOBOL, demonstrating that COBOL can still be used for modern systems programming tasks.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=45463251</guid><pubDate>Fri, 03 Oct 2025 14:13:03 +0000</pubDate></item><item><title>I turned the Lego Game Boy into a working Game Boy</title><link>https://blog.nataliethenerd.com/i-turned-the-lego-game-boy-into-a-working-game-boy-part-1/</link><description>&lt;doc fingerprint="15cf6c54ebc4b5f9"&gt;
  &lt;main&gt;
    &lt;head rend="h1"&gt;I turned the Lego Game Boy into a working Game Boy part. 1&lt;/head&gt;
    &lt;p&gt;Through my documentation of Game Boy boards, I have drawn up schematics of each device. I know them pretty well. Check out my board scan wiki https://wiki.nataliethenerd.com/&lt;/p&gt;
    &lt;p&gt;I jokingly made this tweet when the kit was announced, but decided to actually do it.&lt;/p&gt;
    &lt;p&gt;I know from experience of routing Game Boy CPU PCBs that there isn't much to it. There's the RAM, CPU, some decoupling capacitors and power regulation. &lt;lb/&gt;Note: I went with the MGB (Pocket) CPU rather than DMG for a couple of reasons.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;They are pretty much the same&lt;/item&gt;
      &lt;item&gt;I have more of them&lt;/item&gt;
      &lt;item&gt;They are cheaper and easier to get. This opens up the project to more people&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The DMG CPU has external VRAM, the MGB CPU has internal VRAM and in a very space conscious build that was the biggest factor.&lt;/p&gt;
    &lt;head rend="h2"&gt;Pre Planning&lt;/head&gt;
    &lt;p&gt;I only had the press pictures to work off. I used the dimensions to scale the image on my PC and from that I got measurements for the screen inserts; since that's where I plan to put the Game Boy.&lt;/p&gt;
    &lt;p&gt;I incorporated the power circuit I use for my Safer Charger boards, changed the power switch to a soft latching power button, added pin outs for the button matrix and audio.&lt;/p&gt;
    &lt;p&gt;I didn't really know what the buttons on the Lego would be like, but the fact that they could be pressed was enough for me to know I could implement them. At the moment I have them wired up to custom 3D printed *toy brick* parts. Same with the USB C&lt;/p&gt;
    &lt;p&gt;I am currently working on refining the board now I have the Lego build in my hands. This project will be released in full once I am finished with it - so stay tuned!&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=45463319</guid><pubDate>Fri, 03 Oct 2025 14:18:56 +0000</pubDate></item><item><title>Microsoft CTO says he wants to swap most AMD and Nvidia GPUs for homemade chips</title><link>https://www.cnbc.com/2025/10/01/microsoft-wants-to-mainly-use-its-own-ai-chips-in-the-future.html</link><description>&lt;doc fingerprint="4730961c4eaec8b5"&gt;
  &lt;main&gt;
    &lt;p&gt;Microsoft would like to mainly use its own chips in its data centers in the future, the tech giant's chief technology officer said on Wednesday, in a move which could reduce its reliance on major players like Nvidia and AMD.&lt;/p&gt;
    &lt;p&gt;Semiconductors and the servers that sit inside data centers have underpinned the development of artificial intelligence models and applications.&lt;/p&gt;
    &lt;p&gt;Tech giant Nvidia has dominated the space so far with its graphics processing unit (GPUs), while rival AMD has a smaller slice of the pie.&lt;/p&gt;
    &lt;p&gt;But major cloud computing players, including Microsoft, have also designed their own custom chips for specifically for data centers.&lt;/p&gt;
    &lt;p&gt;Kevin Scott, chief technology officer at Microsoft, laid out the company's strategy around chips for AI during a fireside chat at Italian Tech Week that was moderated by CNBC.&lt;/p&gt;
    &lt;p&gt;Microsoft primarily uses chips from Nvidia and AMD in its own data centers. The focus has been on picking the right silicon — another shorthand term for semiconductor — that offers "the best price performance" per chip.&lt;/p&gt;
    &lt;p&gt;"We're not religious about what the chips are. And ... that has meant the best price performance solution has been Nvidia for years and years now," Scott said. "We will literally entertain anything in order to ensure that we've got enough capacity to meet this demand."&lt;/p&gt;
    &lt;p&gt;At the same time, Microsoft has been using some of its own chips.&lt;/p&gt;
    &lt;p&gt;In 2023, Microsoft launched the Azure Maia AI Accelerator which is designed for AI workloads, as well as the Cobalt CPU. In addition, the firm is reportedly working on its next-generation of semiconductor products. Last week, the U.S. technology giant unveiled new cooling technology using "microfluids" to solve the issue of overheating chips.&lt;/p&gt;
    &lt;p&gt;When asked if the longer term plan is to have mainly Microsoft chips in the firm's own data centers, Scott said: "Absolutely," adding that the company is using "lots of Microsoft" silicon right now.&lt;/p&gt;
    &lt;p&gt;The focus on chips is part of a strategy to eventually design an entire system that goes into the data center, Scott said.&lt;/p&gt;
    &lt;p&gt;"It's about the entire system design. It's the networks and the cooling and you want to be able to have the freedom to make the decisions that you need to make in order to really optimize your compute to the workload," Scott said.&lt;/p&gt;
    &lt;p&gt;Microsoft and its rivals Google and Amazon are designing their own chips to not only reduce reliance on Nvidia and AMD, but also to make their products more efficient for their specific requirements.&lt;/p&gt;
    &lt;head rend="h2"&gt;Compute capacity shortage&lt;/head&gt;
    &lt;p&gt;Tech giants including Meta, Amazon, and Alphabet and Microsoft have committed to more than $300 billion of capital expenditures this year, with much of that focused on AI investments as they look to satisfy booming demand for AI.&lt;/p&gt;
    &lt;p&gt;Scott flagged that there is still a shortage of computing capacity.&lt;/p&gt;
    &lt;p&gt;"[A] massive crunch [in compute] is probably an understatement," Scott said. "I think we have been in a mode where it's been almost impossible to build capacity fast enough since ChatGPT ... launched."&lt;/p&gt;
    &lt;p&gt;Microsoft has been building capacity through data centers but it's still not enough to meet demand, the CTO warned.&lt;/p&gt;
    &lt;p&gt;"Even our most ambitious forecasts are just turning out to be insufficient on a regular basis. And so ... we deployed an incredible amount of capacity over the past year and it will be even more over the coming handful of years," Scott said.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=45463642</guid><pubDate>Fri, 03 Oct 2025 14:48:36 +0000</pubDate></item><item><title>Social anxiety isn't about being liked</title><link>https://chrislakin.blog/p/social-anxiety</link><description>&lt;doc fingerprint="3b56d8150053c6b5"&gt;
  &lt;main&gt;
    &lt;p&gt;There's this popular idea that socially anxious folks are just dying to be liked. It seems logical, right? Why else would someone be so anxious about how others see them?&lt;/p&gt;
    &lt;p&gt;And yet, being socially anxious tends to make you less likeable…they must be optimizing poorly, behaving irrationally, right?&lt;/p&gt;
    &lt;p&gt;Maybe not. What if social anxiety isn’t about getting people to like you? What if it's about stopping them from disliking you?&lt;/p&gt;
    &lt;p&gt;Consider what can happen when someone has social anxiety (or self-loathing, self-doubt, insecurity, lack of confidence, etc.):&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;
        &lt;p&gt;They stoop or take up less space&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;They become less agentic&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;They make fewer requests of others&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;They maintain fewer relationships, go out less, take fewer risks…&lt;/p&gt;
      &lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;If they were trying to get people to like them, becoming socially anxious would be an incredibly bad strategy.&lt;/p&gt;
    &lt;p&gt;So what if they’re not concerned with being likeable?&lt;/p&gt;
    &lt;head rend="h2"&gt;What if what they actually want is to avoid being disliked?&lt;/head&gt;
    &lt;quote&gt;
      &lt;p&gt;To understand the object of an obscure plot, observe its consequences and ask who might have intended them… —Harry Potter and the Methods of Rationality&lt;/p&gt;
    &lt;/quote&gt;
    &lt;p&gt;What if the socially anxious were calibrating to avoid being DISliked?&lt;/p&gt;
    &lt;p&gt;Consider: if you shrink and never make any attention-getting moves, you are less likely to dangerously disappoint others, get into risky conflicts or be seen as a failure, embarrassment, or threat.&lt;/p&gt;
    &lt;p&gt;Like, yeah, it’s wonderful to do awesome things and have people love you. But you know what’s better than being loved? People not hating you.&lt;/p&gt;
    &lt;head rend="h2"&gt;Social anxiety is a symptom of risk aversion&lt;/head&gt;
    &lt;p&gt;It’s not a pursuit of potential upside, but an attempt to avoid downsides.&lt;/p&gt;
    &lt;p&gt;Once you see this pattern, you see it everywhere.&lt;/p&gt;
    &lt;p&gt;Two examples:&lt;/p&gt;
    &lt;p&gt;1) When you feel financially insecure, you’re not optimizing for windfall as much as you’re optimizing for not going bankrupt. You avoid risky bets with higher EV in favor of safer, more predictable options, even if they offer smaller returns. The goal is to keep you fed, not to make you rich.&lt;/p&gt;
    &lt;p&gt;2) Reversely, countersignalling is a demonstration of safety in close relationships. In Scott Alexander’s Friendship is Countersignalling, he describes an interaction he has with a friend:&lt;/p&gt;
    &lt;quote&gt;
      &lt;p&gt;Becca: What are you doing here? I figured they’d have locked you away in the psych ward for good by now.&lt;/p&gt;
      &lt;p&gt;Scott: Nope. And what are you doing here? You haven’t killed off all your patients yet?&lt;/p&gt;
      &lt;p&gt;Becca: Only person in this hospital I might kill is standing right in front of me.&lt;/p&gt;
      &lt;p&gt;Scott: Be careful, I’m armed and dangerous *picks up a central line placement practice set menacingly*&lt;/p&gt;
    &lt;/quote&gt;
    &lt;p&gt;The security of good friendship diffuses your anxiety about making a social faux pas and enables you to take more risks.&lt;/p&gt;
    &lt;head rend="h2"&gt;What does this mean for your growth?&lt;/head&gt;
    &lt;p&gt;If you believe your primary goal is to “be liked” and you keep finding yourself hiding in the shadows, you’ll feel like a total failure. This hurts!&lt;/p&gt;
    &lt;p&gt;But all our feelings have their own kind of logic. Even when we do things that seem self-sabotaging, there’s usually an incentive that makes sense in that specific context – even if it maybe not the best strategy overall. Locally optimal!&lt;/p&gt;
    &lt;p&gt;Consider: what if all these symptoms of social anxiety aren’t failures of a system trying to be liked, but successes of a system trying to avoid being disliked?&lt;/p&gt;
    &lt;p&gt;What if you’ve been operating pretty rationally this whole time, but not for the outcome you thought you were optimizing for?&lt;/p&gt;
    &lt;p&gt;What if you’re not failing at being liked - you’re succeeding at avoiding being disliked?&lt;/p&gt;
    &lt;p&gt;Recognize this, and you’ll be able to shift your focus to the real work: becoming comfortable with the worst-case scenarios your anxiety is protecting you from.&lt;/p&gt;
    &lt;p&gt;The solution isn’t trying harder to be liked. It’s unlearning your discomfort with being disliked.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=45463656</guid><pubDate>Fri, 03 Oct 2025 14:51:02 +0000</pubDate></item><item><title>LinkedIn sues software company allegedly scraping data from profiles</title><link>https://therecord.media/linkedin-sues-data-scraping-company</link><description>&lt;doc fingerprint="a8a449dc503497ed"&gt;
  &lt;main&gt;
    &lt;head rend="h1"&gt;LinkedIn sues software company allegedly scraping data from millions of profiles&lt;/head&gt;
    &lt;p&gt;Social media giant LinkedIn on Thursday filed a lawsuit against a company which it says operates a network of millions of fake accounts used to scrape data from LinkedIn members before selling the information to third parties without permission.&lt;/p&gt;
    &lt;p&gt;ProAPIs, a software company, and its CEO Rahmat Alam allegedly run an operation which LinkedIn says charges customers up to $15,000 per month for scraped user data taken from the social media platform.&lt;/p&gt;
    &lt;p&gt;With the rise of artificial intelligence, companies which scrape user data at scale are proliferating and are increasingly undermining consumer privacy.&lt;/p&gt;
    &lt;p&gt;Data scraped by ProAPIs allegedly includes LinkedIn member information as well as their posts, reactions and comments, according to the lawsuit, which was filed in a Northern California federal court.&lt;/p&gt;
    &lt;p&gt;“Defendants’ industrial-scale fake account mill scrapes member information that real people have posted on LinkedIn, including data that is only available behind LinkedIn’s password wall and that Defendants’ customers may not otherwise be allowed to access, and certainly are not allowed to copy and keep in perpetuity,” the lawsuit says.&lt;/p&gt;
    &lt;p&gt;ProAPIs did not respond to a request for comment. Creating fake accounts is against LinkedIn’s terms of service.&lt;/p&gt;
    &lt;p&gt;The lawsuit says that Microsoft-owned LinkedIn routinely detects ProAPIs’ scraping within hours of it beginning, but because the software firm creates “hundreds if not thousands” of fake accounts daily it is impossible to stop all of the activity.&lt;/p&gt;
    &lt;p&gt;ProAPIs uses LinkedIn’s trademark to promote its product, according to the lawsuit, which says the copyright abuse falsely suggests that the company is endorsed by the social network.&lt;/p&gt;
    &lt;p&gt;Suzanne Smalley&lt;/p&gt;
    &lt;p&gt;is a reporter covering privacy, disinformation and cybersecurity policy for The Record. She was previously a cybersecurity reporter at CyberScoop and Reuters. Earlier in her career Suzanne covered the Boston Police Department for the Boston Globe and two presidential campaign cycles for Newsweek. She lives in Washington with her husband and three children.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=45464111</guid><pubDate>Fri, 03 Oct 2025 15:30:32 +0000</pubDate></item><item><title>Anduril and Palantir battlefield communication system has flaws, Army memo says</title><link>https://www.cnbc.com/2025/10/03/anduril-palantir-ngc2-deep-flaws-army.html</link><description>&lt;doc fingerprint="a573ccbb7c3e5585"&gt;
  &lt;main&gt;
    &lt;p&gt;The much-needed modernization of the U.S. Army's battlefield communications network being undertaken by Anduril, Palantir and others is rife with "fundamental security" problems and vulnerabilities, and should be treated as a "very high risk," according to a recent internal Army memo.&lt;/p&gt;
    &lt;p&gt;The two Silicon Valley companies, led by allies of U.S. President Donald Trump, have gained access to the Pentagon's lucrative flow of contracts on the promise of quickly providing less expensive and more sophisticated weapons than the Pentagon's longstanding arms providers.&lt;/p&gt;
    &lt;p&gt;But the September memo from the Army's chief technology officer about the NGC2 platform that connects soldiers, sensors, vehicles and commanders with real-time data paints a bleak picture of the initial product.&lt;/p&gt;
    &lt;p&gt;"We cannot control who sees what, we cannot see what users are doing, and we cannot verify that the software itself is secure," the memo says.&lt;/p&gt;
    &lt;p&gt;Palantir and Anduril did not comment for this story.&lt;/p&gt;
    &lt;p&gt;The assessment, seen by Reuters and first reported by Breaking Defense, comes just months after defense drone and software maker Anduril was awarded a $100 million to create a prototype of NGC2 with partners including Palantir, Microsoft and several smaller contractors.&lt;/p&gt;
    &lt;p&gt;The Army should treat the NGC2 prototype version as “very high risk” because of the “likelihood of an adversary gaining persistent undetectable access," wrote Gabrielle Chiulli, the Army chief technology officer authorizing official.&lt;/p&gt;
    &lt;p&gt;Despite the early September memo's scathing critique, Leonel Garciga, Army chief information officer and Chiulli's supervisor, said in a statement to Reuters that the report was part of a process that helped in "triaging cybersecurity vulnerabilities" and mitigating them.&lt;/p&gt;
    &lt;p&gt;In March, the 4th Infantry Division used the system in live-fire artillery training at Fort Carson, Colorado, in an exercise Anduril described as demonstrating faster and more reliable performance than legacy systems.&lt;/p&gt;
    &lt;p&gt;The Army memo identifies some major security gaps.&lt;/p&gt;
    &lt;p&gt;The report says the system allows any authorized user to access all applications and data regardless of their clearance level or operational need. As a result, "Any user can potentially access and misuse sensitive" classified information, the memo states, with no logging to track their actions.&lt;/p&gt;
    &lt;p&gt;Other deficiencies highlighted in the memo include the hosting of third-party applications that have not undergone Army security assessments. One application revealed 25 high-severity code vulnerabilities. Three additional applications under review each contain over 200 vulnerabilities requiring assessment, according to the document.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=45464269</guid><pubDate>Fri, 03 Oct 2025 15:46:11 +0000</pubDate></item><item><title>Cancelling async Rust</title><link>https://sunshowers.io/posts/cancelling-async-rust/</link><description>&lt;doc fingerprint="310499976ca2b6bc"&gt;
  &lt;main&gt;
    &lt;head rend="h1"&gt;Cancelling async Rust&lt;/head&gt;
    &lt;p&gt;This is an edited, written version of my RustConf 2025 talk about cancellations in async Rust. Like the written version of my RustConf 2023 talk, I’ve tried to retain the feel of a talk while making it readable as a standalone blog entry. Some links:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Video of the talk on YouTube.&lt;/item&gt;
      &lt;item&gt;Slides on Google Slides.&lt;/item&gt;
      &lt;item&gt;Repository with links and notes on GitHub.&lt;/item&gt;
      &lt;item&gt;Coverage on Linux Weekly News.&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h2"&gt;Introduction#&lt;/head&gt;
    &lt;p&gt;Let’s start with a simple example – you decide to read from a channel in a loop and gather a bunch of messages:&lt;/p&gt;
    &lt;code&gt;loop {
    match rx.recv().await {
        Ok(msg) =&amp;gt; process(msg),
        Err(_) =&amp;gt; return,
    }
}
&lt;/code&gt;
    &lt;p&gt;All good, nothing wrong with this, but you realize sometimes the channel is empty for long periods of time, so you add a timeout and print a message:&lt;/p&gt;
    &lt;code&gt;loop {
    match timeout(Duration::from_secs(5), rx.recv()).await {
        Ok(Ok(msg)) =&amp;gt; process(msg),
        Ok(Err(_)) =&amp;gt; return,
        Err(_) =&amp;gt; println!("no messages for 5 seconds"),
    }
}
&lt;/code&gt;
    &lt;p&gt;There’s nothing wrong with this code—it behaves as expected.&lt;/p&gt;
    &lt;p&gt;Now you realize you need to write a bunch of messages out to a channel in a loop:&lt;/p&gt;
    &lt;code&gt;loop {
    let msg = next_message();
    match tx.send(msg).await {
        Ok(_) =&amp;gt; println!("sent successfully"),
        Err(_) =&amp;gt; return,
    }
}
&lt;/code&gt;
    &lt;p&gt;But sometimes the channel gets too full and blocks, so you add a timeout and print a message:&lt;/p&gt;
    &lt;code&gt;loop {
    let msg = next_message();
    match timeout(Duration::from_secs(5), tx.send(msg)).await {
        Ok(Ok(_)) =&amp;gt; println!("sent successfully"),
        Ok(Err(_)) =&amp;gt; return,
        Err(_) =&amp;gt; println!("no space for 5 seconds"),
    }
}
&lt;/code&gt;
    &lt;p&gt;It turns out that this code is often incorrect, because not all messages make their way to the channel.&lt;/p&gt;
    &lt;p&gt;Hi, I’m Rain, and this post is about cancelling async Rust. This post is split into three parts:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;What is cancellation? It’s an extremely powerful part of async Rust but also one that is very hard to reason thoroughly about.&lt;/item&gt;
      &lt;item&gt;Analyzing cancellations: Going deep into their mechanics and providing some helpful ways to think about them.&lt;/item&gt;
      &lt;item&gt;What can be done? Solutions, including practical guidance, and real bugs we’ve found and fixed in production codebases.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Before we begin, I want to lay my cards on the table – I really love async Rust!&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;
        &lt;p&gt;I gave a talk at RustConf a couple years ago talking about how async Rust is a great fit for signal handling in complex applications.&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;I’m also the author of cargo-nextest, a next-generation test runner for Rust, where async Rust is the best way I know of to express some really complex algorithms that I wouldn’t know how to express otherwise. I wrote a blog post about this a few years ago.&lt;/p&gt;
      &lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Now, I work at Oxide Computer Company, where we make cloud-in-a-box computers. We make vertically integrated systems where you provide power and networking on one end, and the software you want to run on the other end, and we take care of everything in between.&lt;/p&gt;
    &lt;p&gt;Of course, we use Rust everywhere, and in particular we use async Rust extensively for our higher-level software, such as storage, networking and the customer-facing management API. But along the way we’ve encountered a number of issues around async cancellation, and a lot of this post is about what we learned along the way.&lt;/p&gt;
    &lt;head rend="h2"&gt;1. What is cancellation?#&lt;/head&gt;
    &lt;p&gt;What does cancellation mean? Logically, a cancellation is exactly what it sounds like: you start some work, and then change your mind and decide to stop doing that work.&lt;/p&gt;
    &lt;p&gt;As you might imagine this is a useful thing to do:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;You may have started a large download or a long network request&lt;/item&gt;
      &lt;item&gt;Maybe you’ve started reading a file, similar to the &lt;code&gt;head&lt;/code&gt;command.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;But then you change your mind: you want to cancel it rather than continue it to completion.&lt;/p&gt;
    &lt;head rend="h3"&gt;Cancellations in synchronous Rust#&lt;/head&gt;
    &lt;p&gt;Before we talk about async Rust, it’s worth thinking about how you’d do cancellations in synchronous Rust.&lt;/p&gt;
    &lt;p&gt;One option is to have some kind of flag you periodically check, maybe stored in an atomic:&lt;/p&gt;
    &lt;code&gt;while !should_cancel.load(Ordering::Relaxed) {
    expensive_operation();
}
&lt;/code&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;The code that wishes to perform the cancellation can set that flag.&lt;/item&gt;
      &lt;item&gt;Then, the code which checks that flag can exit early.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;This approach is fine for smaller bits of code but doesn’t really scale well to large chunks of code since you’d have to sprinkle these checks everywhere.&lt;/p&gt;
    &lt;p&gt;A related option, if you’re working with a framework as part of your work, is to panic with a special payload of some kind.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;If that feels strange to you, you’re not alone! But the Salsa framework for incremental computation, used by—among other things—rust-analyzer, uses this approach.&lt;/item&gt;
      &lt;item&gt;Something I learned recently was that this only works on build targets which have a notion of panic unwinding, or being able to bubble up the panic. Not all platforms support this, and in particular, Wasm doesn’t. This means that Salsa cancellations don’t work if you build rust-analyzer for Wasm.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;A third option is to kill the whole process. This is a very heavyweight approach, but an effective one in case you spawn processes to do your work.&lt;/p&gt;
    &lt;p&gt;Rather than kill the whole process, can you kill a single thread?&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;While some OSes have APIs to perform this action, they tend to warn very strongly against it. That’s because in general, most code is just not ready for a thread disappearing from underneath.&lt;/item&gt;
      &lt;item&gt;In particular, thread killing is not permitted by safe Rust, since it can cause serious corruption. For example, Rust mutexes would likely stay locked forever.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;All of these options are suboptimal or of limited use in some way. In general, the way I think about it is that there isn’t a universal protocol for cancellation in synchronous Rust.&lt;/p&gt;
    &lt;p&gt;In contrast, there is such a protocol in async Rust, and in fact cancellations are extraordinarily easy to perform in async Rust.&lt;/p&gt;
    &lt;p&gt;Why is that so? To understand that, let’s look at what a future is.&lt;/p&gt;
    &lt;head rend="h3"&gt;What is a future?#&lt;/head&gt;
    &lt;p&gt;Here’s a simple example of a future:&lt;/p&gt;
    &lt;code&gt;// This creates a state machine.
let future = async {
    let data = request().await;
    process(data).await
};

// Nothing executes yet. `future` is just a struct in memory.
&lt;/code&gt;
    &lt;p&gt;In this future, you first perform a network request which returns some data, and then you process it.&lt;/p&gt;
    &lt;p&gt;The Rust compiler looks at this future and generates a state machine, which is just a struct or enum in memory:&lt;/p&gt;
    &lt;code&gt;// The compiler generates something like:
enum MyFuture {
    Start,
    WaitingForNetwork(NetworkFuture),
    WaitingForProcess(ProcessFuture, Data),
    Done(Result),
}

// It's just data, no running code!
&lt;/code&gt;
    &lt;p&gt;If you’ve written async Rust before the &lt;code&gt;async&lt;/code&gt; and &lt;code&gt;await&lt;/code&gt; keywords, you’ve probably written code like it by hand. It’s basically just an enum describing all the possible states the future can be in.&lt;/p&gt;
    &lt;p&gt;The compiler also generates an implementation of the &lt;code&gt;Future&lt;/code&gt; trait for this future:&lt;/p&gt;
    &lt;code&gt;impl Future for MyFuture {
    fn poll(/* ... */) -&amp;gt; Poll&amp;lt;Self::Output&amp;gt; {
        match self {
            Start =&amp;gt; { /* ... */ }
            WaitingForNetwork(fut) =&amp;gt; { /* ... */ }
            // etc
        }
    }
}
&lt;/code&gt;
    &lt;p&gt;and when you call &lt;code&gt;.await&lt;/code&gt; on the future, it gets translated down to this underlying &lt;code&gt;poll&lt;/code&gt; function. It is only when &lt;code&gt;await&lt;/code&gt; or this &lt;code&gt;poll&lt;/code&gt; function is called that something actually happens.&lt;/p&gt;
    &lt;p&gt;Note that this is diametrically opposed to how async works in other languages like Go, JavaScript, or C#. In those languages, when you create a future to await on, it starts doing its thing, immediately, in the background:&lt;/p&gt;
    &lt;code&gt;// JavaScript: starts running immediately
const promise = fetch('/api/data');
&lt;/code&gt;
    &lt;p&gt;That’s regardless of whether you await it or not.&lt;/p&gt;
    &lt;p&gt;In Rust, this &lt;code&gt;get&lt;/code&gt; call does nothing until you actually call &lt;code&gt;.await&lt;/code&gt; on it:&lt;/p&gt;
    &lt;code&gt;// Rust: just data, does nothing!
let future = reqwest::get("/api/data");
&lt;/code&gt;
    &lt;p&gt;I know I sound a bit like a broken record here, but if you can take away one thing from this post, it would be that futures are passive, and completely inert until awaited or polled.&lt;/p&gt;
    &lt;head rend="h3"&gt;The universal protocol#&lt;/head&gt;
    &lt;p&gt;So what does the universal protocol to cancel futures look like? It is simply to drop the future, or to not await it, or poll it any more. Since a future is just a state machine, you can throw it away at any time the poll function isn’t actively being called.&lt;/p&gt;
    &lt;code&gt;let future = some_async_work();
drop(future); // cancelled
&lt;/code&gt;
    &lt;p&gt;The upshot of all this is that any Rust future can be cancelled at any await point.&lt;/p&gt;
    &lt;p&gt;Given how hard cancellation tends to be in synchronous environments, the ability to easily cancel futures in async Rust is extraordinarily powerful—in many ways its greatest strength!&lt;/p&gt;
    &lt;p&gt;But there is a flip side, which is that cancelling futures is far, far too easy. This is for two reasons.&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;
        &lt;p&gt;First, it’s just way too easy to quietly drop a future. As we’re going to see, there are all kinds of code patterns that lead to silently dropping futures.&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Now this wouldn’t be so bad, if not for the second reason: that cancellation of parent futures propagates down to child futures.&lt;/p&gt;
        &lt;p&gt;Because of Rust’s single ownership model, child futures are owned by parent ones. If a parent future is dropped or cancelled, the same happens to the child.&lt;/p&gt;
        &lt;p&gt;To figure out whether a child future’s cancellation can cause issues, you have to look at its parent, and grandparent, and so on. Reasoning about cancellation becomes a very complicated non-local operation.&lt;/p&gt;
      &lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h2"&gt;2. Analyzing cancellations#&lt;/head&gt;
    &lt;p&gt;I’m going to cover some examples in a bit, but before we do that I want to talk about a couple terms, some of which you might have seen references to already.&lt;/p&gt;
    &lt;head rend="h3"&gt;Cancel safety and cancel correctness#&lt;/head&gt;
    &lt;p&gt;The first term is cancel safety. You might have seen mentions of this in the Tokio documentation. Cancel safety, as generally defined, means the property of a future that can be cancelled (i.e. dropped) without any side effects.&lt;/p&gt;
    &lt;p&gt;For example, a Tokio sleep future is cancel safe: you can just stop waiting on the sleep and it’s completely fine.&lt;/p&gt;
    &lt;code&gt;let future = tokio::time::sleep();
drop(future); // this has no side effects
&lt;/code&gt;
    &lt;p&gt;An example of a future that is not cancel safe is Tokio’s MPSC send, which sends a message over a channel:&lt;/p&gt;
    &lt;code&gt;let message = /* ... */;
let future = sender.send(message);
drop(future); // message is lost!
&lt;/code&gt;
    &lt;p&gt;If this future is dropped, the message is lost forever.&lt;/p&gt;
    &lt;p&gt;The important thing is that cancel safety is a local property of an individual future.&lt;/p&gt;
    &lt;p&gt;But cancel safety is not all that one needs to care about. What actually matters is the context the cancellation happens in, or in other words whether the cancellation actually causes some kind of larger property in the system to be violated.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;For example, if you drop a future which sends a message, but for whatever reason you don’t care about the message any more, it’s not really a bug!&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;To capture this I tend to use a different term called cancel correctness, which I define as a global property of system correctness in the face of cancellations. (This isn’t a standard term, but it’s a framing I’ve found really helpful in understanding cancellations.)&lt;/p&gt;
    &lt;p&gt;When is cancel correctness violated? It requires three things:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;
        &lt;p&gt;The system has a cancel-unsafe future somewhere within it. As we’ll see, many APIs that are cancel-unsafe can be reworked to be cancel-safe. If there aren’t any cancel-unsafe futures in the system, then the system is cancel correct.&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;A cancel-unsafe future is actually cancelled. This may sound a bit trivial, but if cancel-unsafe futures are always run to completion, then the system can’t have cancel correctness bugs.&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;&lt;p&gt;Cancelling the future violates some property of a system. This could be data loss as with&lt;/p&gt;&lt;code&gt;Sender::send&lt;/code&gt;, some kind of invariant violation, or some kind of cleanup that must be performed but isn’t.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;So a lot of making Rust async robust is about trying to tackle one of these three things.&lt;/p&gt;
    &lt;p&gt;I want to zoom in for a second on invariant violations and talk about an example of a Tokio API that is very prone to cancel correctness issues: Tokio mutexes.&lt;/p&gt;
    &lt;head rend="h3"&gt;The pain of Tokio mutexes#&lt;/head&gt;
    &lt;p&gt;The way Tokio mutexes work is: you create a mutex, you lock it which gives you mutable access to the data underneath, and then you unlock it by releasing the mutex.&lt;/p&gt;
    &lt;code&gt;let guard = mutex.lock().await;
// Access guard.data, protected by the mutex...
drop(guard);
&lt;/code&gt;
    &lt;p&gt;If you look at the &lt;code&gt;lock&lt;/code&gt; function’s documentation, in the “cancel safety” section it says:&lt;/p&gt;
    &lt;quote&gt;
      &lt;p&gt;This method uses a queue to fairly distribute locks in the order they were requested. Cancelling a call to lock makes you lose your place in the queue.&lt;/p&gt;
    &lt;/quote&gt;
    &lt;p&gt;Okay, so not totally cancel safe, but the only kind of unsafety is fairness, which doesn’t sound too bad.&lt;/p&gt;
    &lt;p&gt;But the problems lie in what you actually do with the mutex. In practice, most uses of mutexes are in order to temporarily violate invariants that are otherwise upheld when a lock isn’t held.&lt;/p&gt;
    &lt;p&gt;I’ll use a real world example of a cancel correctness bug that we found at my job at Oxide: we had code to manage a bunch of data sent over by our computers, which we call sleds. The shared state was guarded by a mutex, and a typical operation was:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Obtain a lock on the mutex.&lt;/item&gt;
      &lt;item&gt;Obtain the sled-specific data by value, moving it to an invalid &lt;code&gt;None&lt;/code&gt;state.&lt;/item&gt;
      &lt;item&gt;Perform an action.&lt;/item&gt;
      &lt;item&gt;Set the sled-specific data back to the next valid state.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Here’s a rough sketch of what that looks like:&lt;/p&gt;
    &lt;code&gt;let guard = mutex.lock().await;
// guard.data is Option&amp;lt;T&amp;gt;: Some to begin with
let data = guard.data.take(); // guard.data is now None

let new_data = process_data(data);
guard.data = Some(new_data); // guard.data is Some again
&lt;/code&gt;
    &lt;p&gt;This is all well and good, but the problem is that the action being performed actually had an await point within it:&lt;/p&gt;
    &lt;code&gt;let guard = mutex.lock().await;
// guard.data is Option&amp;lt;T&amp;gt;: Some to begin with
let data = guard.data.take(); // guard.data is now None

// DANGER: cancellation here leaves data in None state!
let new_data = process_data(data).await;
guard.data = Some(new_data); // guard.data is Some again
&lt;/code&gt;
    &lt;p&gt;If the code that operated on the mutex got cancelled at that await point, then the data would be stuck in the invalid &lt;code&gt;None&lt;/code&gt; state. Not great!&lt;/p&gt;
    &lt;p&gt;And keep in mind the non-local reasoning aspect: when doing this analysis, you need to look at the whole chain of callers.&lt;/p&gt;
    &lt;head rend="h3"&gt;Cancellation patterns#&lt;/head&gt;
    &lt;p&gt;Now that we’ve talked about some of the bad things that can happen during cancellations, it’s worth asking what kinds of code patterns lead to futures being cancelled.&lt;/p&gt;
    &lt;p&gt;The most straightforward example, and maybe a bit of a silly one, is that you create a future but simply forget to call &lt;code&gt;.await&lt;/code&gt; on it.&lt;/p&gt;
    &lt;code&gt;some_async_work(); // missing .await
&lt;/code&gt;
    &lt;p&gt;Now Rust actually warns you if you don’t call &lt;code&gt;.await&lt;/code&gt; on the future:&lt;/p&gt;
    &lt;code&gt;warning: unused implementer of `Future` that must be used
   |
11 |     some_async_work();
   |     ^^^^^^^^^^^^^^^^^
   |
   = note: futures do nothing unless you `.await` or poll them
&lt;/code&gt;
    &lt;p&gt;But a code pattern I’ve sometimes made mistakes with is that the future returns a &lt;code&gt;Result&lt;/code&gt;, and you want to ignore the result so you assign it to an underscore like so:&lt;/p&gt;
    &lt;code&gt;let _ = some_async_work(); // future returns Result
&lt;/code&gt;
    &lt;p&gt;If I forget to call &lt;code&gt;.await&lt;/code&gt; on the future, Rust doesn’t warn me about it at all, and then I’m left scratching my head about why this code didn’t run. I know this sounds really silly and basic, but I’ve made this mistake a bunch of times.&lt;/p&gt;
    &lt;p&gt;(After my talk, it was pointed out to me that Clippy 1.67 and above have a &lt;code&gt;let_underscore_future&lt;/code&gt; warn-by-default lint for this. Hooray!)&lt;/p&gt;
    &lt;p&gt;Another example of futures being cancelled is &lt;code&gt;try&lt;/code&gt; operations, such as Tokio’s &lt;code&gt;try_join&lt;/code&gt; macro. For example:&lt;/p&gt;
    &lt;code&gt;async fn do_stuff_async() -&amp;gt; Result&amp;lt;(), &amp;amp;'static str&amp;gt; {
    // async work
}

async fn more_async_work() -&amp;gt; Result&amp;lt;(), &amp;amp;'static str&amp;gt; {
    // more here
}

let res = tokio::try_join!(
    do_stuff_async(),
    more_async_work(),
);

// ...
&lt;/code&gt;
    &lt;p&gt;If you call &lt;code&gt;try_join&lt;/code&gt; with a bunch of futures, and all of them succeed, it’s all good. But if one of them fails, the rest simply get cancelled.&lt;/p&gt;
    &lt;p&gt;In fact, at Oxide we had a pretty bad bug around this: we had code to stop a bunch of services, all expressed as futures. We used &lt;code&gt;try_join&lt;/code&gt;:&lt;/p&gt;
    &lt;code&gt;try_join!(
    stop_service_a(),
    stop_service_b(),
    stop_service_c(),
)?;
&lt;/code&gt;
    &lt;p&gt;If one of these operations failed for whatever reason, we would stop running the code to wait for the other services to exit. Oops!&lt;/p&gt;
    &lt;p&gt;But perhaps the most well-known source of cancellations is Tokio’s &lt;code&gt;select&lt;/code&gt; macro. Select is this incredibly beautiful operation. It is called with a set of futures, and it drives all of them forward concurrently:&lt;/p&gt;
    &lt;code&gt;tokio::select! {
    result1 = future1 =&amp;gt; handle_result1(result1),
    result2 = future2 =&amp;gt; handle_result2(result2),
}
&lt;/code&gt;
    &lt;p&gt;Each future has a code block associated with it (above, &lt;code&gt;handle_result1&lt;/code&gt; and &lt;code&gt;handle_result2&lt;/code&gt;). If one of the futures completes, the corresponding code block is called. But also, all of the other futures are always cancelled!&lt;/p&gt;
    &lt;p&gt;For a variety of reasons, select statements in general, and select loops in particular, are particularly prone to cancel correctness issues. So a lot of the documentation about cancel safety talks about select loops. But I want to emphasize here that select is not the only source of cancellations, just a particularly notable one.&lt;/p&gt;
    &lt;head rend="h2"&gt;3. What can be done?#&lt;/head&gt;
    &lt;p&gt;So, now that we’ve looked at all of these issues with cancellations, what can be done about it?&lt;/p&gt;
    &lt;p&gt;First, I want to break the bad news to you – there is no general, fully reliable solution for this in Rust today. But in our experience there are a few patterns that have been successful at reducing the likelihood of cancellation bugs.&lt;/p&gt;
    &lt;p&gt;Going back to our definition of cancel correctness, there are three prongs all of which come together to produce a bug:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;A cancel-unsafe future exists&lt;/item&gt;
      &lt;item&gt;This cancel-unsafe future is cancelled&lt;/item&gt;
      &lt;item&gt;The cancellation violates a system property&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Most solutions we’ve come up with try and tackle one of these prongs.&lt;/p&gt;
    &lt;head rend="h3"&gt;Making futures cancel-safe#&lt;/head&gt;
    &lt;p&gt;Let’s look at the first prong: the system has a cancel-unsafe future somewhere in it. Can we use code patterns to make futures be cancel-safe? It turns out we can! I’ll give you two examples here.&lt;/p&gt;
    &lt;p&gt;The first is MPSC sends. Let’s come back to the example from earlier where we would lose messages entirely:&lt;/p&gt;
    &lt;code&gt;loop {
    let msg = next_message();
    match timeout(Duration::from_secs(5), tx.send(msg)).await {
        Ok(Ok(_)) =&amp;gt; println!("sent successfully"),
        Ok(Err(_)) =&amp;gt; return,
        Err(_) =&amp;gt; println!("no space for 5 seconds"),
    }
}
&lt;/code&gt;
    &lt;p&gt;Can we find a way to make this cancel safe?&lt;/p&gt;
    &lt;p&gt;In this case, yes, and we do so by breaking up the operation into two parts:&lt;/p&gt;
    &lt;code&gt;loop {
    let msg = next_message();
    loop {
        match timeout(Duration::from_secs(5), tx.reserve()).await {
            Ok(Ok(permit)) =&amp;gt; { permit.send(msg); break; }
            Ok(Err(_)) =&amp;gt; return,
            Err(_) =&amp;gt; println!("no space for 5 seconds"),
        }
    }
}
&lt;/code&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;The first component is the operation to reserve a permit or slot in the channel. This is an initial async operation that’s cancel-safe.&lt;/item&gt;
      &lt;item&gt;The second is to actually send the message, which is an operation that becomes infallible.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;(I want to put an asterisk here that reserve is not entirely cancel-safe, since Tokio’s MPSC follows a first-in-first-out pattern and dropping the future means losing your place in line. Keep this in mind for now.)&lt;/p&gt;
    &lt;p&gt;The second is with Tokio’s &lt;code&gt;AsyncWrite&lt;/code&gt;.&lt;/p&gt;
    &lt;p&gt;If you’ve written synchronous Rust you’re probably familiar with the &lt;code&gt;write_all&lt;/code&gt; method, which writes an entire buffer out:&lt;/p&gt;
    &lt;code&gt;use std::io::Write;

let buffer: &amp;amp;[u8] = /* ... */;
writer.write_all(buffer)?;
&lt;/code&gt;
    &lt;p&gt;In synchronous Rust, this is a great API. But within async Rust, the &lt;code&gt;write_all&lt;/code&gt; pattern is absolutely not cancel safe! If the future is dropped before completion, you have no idea how much of this buffer was written out.&lt;/p&gt;
    &lt;code&gt;use tokio::io::AsyncWriteExt;

let buffer: &amp;amp;[u8] = /* ... */;
writer.write_all(buffer).await?; // Not cancel-safe!
&lt;/code&gt;
    &lt;p&gt;But there’s an alternative API that is cancel-safe, called &lt;code&gt;write_all_buf&lt;/code&gt;. This API is carefully designed to enable the reporting of partial progress, and it doesn’t just accept a buffer, but rather something that looks like a cursor on top of it:&lt;/p&gt;
    &lt;code&gt;use tokio::io::AsyncWriteExt;

let mut buffer: io::Cursor&amp;lt;&amp;amp;[u8]&amp;gt; = /* ... */;
writer.write_all_buf(&amp;amp;mut buffer).await?;
&lt;/code&gt;
    &lt;p&gt;When part of the buffer is written out, the cursor is advanced by that number of bytes. So if you call &lt;code&gt;write_all_buf&lt;/code&gt; in a loop, you’ll be resuming from this partial progress, which works great.&lt;/p&gt;
    &lt;head rend="h3"&gt;Not cancelling futures#&lt;/head&gt;
    &lt;p&gt;Going back to the three prongs: the second prong is about actually cancelling futures. What code patterns can be used to not cancel futures? Here are a couple of examples.&lt;/p&gt;
    &lt;p&gt;The first one is, in a place like a select loop, resume futures rather than cancelling them each time. You’d typically achieve this by pinning a future, and then polling a mutable reference to that future. For example:&lt;/p&gt;
    &lt;code&gt;let mut future = Box::pin(channel.reserve());
loop {
    tokio::select! {
        result = &amp;amp;mut future =&amp;gt; break result,
        _ = other_condition =&amp;gt; continue,
    }
}
&lt;/code&gt;
    &lt;p&gt;Coming back to our example of MPSC sends, the one asterisk with &lt;code&gt;reserve&lt;/code&gt; is that cancelling it makes you lose your place in line. Instead, if you pin the &lt;code&gt;reserve&lt;/code&gt; future and poll a mutable reference to it, you don’t lose your place in line.&lt;/p&gt;
    &lt;p&gt;(Does the difference here matter? It depends, but you can now have this strategy available to you.)&lt;/p&gt;
    &lt;p&gt;The second example is to use tasks. I mentioned earlier that futures are Rust are diametrically opposed to similar notions in languages like JavaScript. Well, there’s an alternative in async Rust that’s much closer to the JavaScript idea, and that’s tasks.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Unlike futures which are driven by the caller, tasks are driven by the runtime (such as Tokio).&lt;/item&gt;
      &lt;item&gt;With Tokio, dropping a handle to a task does not cause it to be cancelled, which means they’re a good place to run cancel-unsafe code.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;A fun example is that at Oxide, we have an HTTP server called Dropshot. Previously, whenever an HTTP request came in, we’d use a future for it, and drop the future if the TCP connection was closed.&lt;/p&gt;
    &lt;code&gt;// Before: Future cancelled on TCP close
handle_request(req).await;
&lt;/code&gt;
    &lt;p&gt;This was really bad because future cancellations could happen due to the behavior of not just the parent future, but of a process that was running across a network! This is a rather extreme form of non-local reasoning.&lt;/p&gt;
    &lt;p&gt;We addressed this by spinning up a task for each HTTP request, and by running the code to completion even if the connection is closed:&lt;/p&gt;
    &lt;code&gt;// After: Task runs to completion
tokio::spawn(handle_request(req));
&lt;/code&gt;
    &lt;head rend="h3"&gt;Systematic solutions?#&lt;/head&gt;
    &lt;p&gt;The last thing I want to say is that this sucks!&lt;/p&gt;
    &lt;p&gt;The promise of Rust is that you don’t need to do this kind of non-local reasoning—that you can analyze small bits of code for local correctness, and scale that up to global correctness. Almost everything in Rust, from &lt;code&gt;&amp;amp;&lt;/code&gt; and &lt;code&gt;&amp;amp;mut&lt;/code&gt; to &lt;code&gt;unsafe&lt;/code&gt;, is geared towards making that possible. Future cancellations fly directly in the face of that, and I think they’re probably the least Rusty part of Rust. This is all really unfortunate.&lt;/p&gt;
    &lt;p&gt;Can we come up with something more systematic than this kind of ad-hoc reasoning?&lt;/p&gt;
    &lt;p&gt;There doesn’t exist anything in safe Rust today, but there are a few different ideas people have come up with. I wanted to give a nod to those ideas:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Async drop would let you run async code when a future is cancelled. This would handle some, though not all, of the cases we discussed today.&lt;/item&gt;
      &lt;item&gt;There’s also a couple different proposals for what are called linear types, where you could force some code to be run on drop, or mark a particular future as non-cancellable (once it’s been created it must be driven to completion).&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;All of these options have really significant implementation challenges, though. This blog post from boats covers some of these solutions, and the implementation challenges with them.&lt;/p&gt;
    &lt;head rend="h2"&gt;Conclusion#&lt;/head&gt;
    &lt;p&gt;In this post, we:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Saw that futures are passive&lt;/item&gt;
      &lt;item&gt;Introduced cancel safety and cancel correctness as concepts&lt;/item&gt;
      &lt;item&gt;Examined some bugs that can occur with cancellation&lt;/item&gt;
      &lt;item&gt;Looked at some recommendations you can use to mitigate the downsides of cancellation&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Some of the recommendations are:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Avoid Tokio mutexes&lt;/item&gt;
      &lt;item&gt;Rewrite APIs to make futures cancel-safe&lt;/item&gt;
      &lt;item&gt;Find ways to ensure that cancel-unsafe futures are driven to completion&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;There’s a very deep well of complexity here, a lot more than I can cover in one blog post:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Why are futures passive, anyway?&lt;/item&gt;
      &lt;item&gt;Cooperative cancellation: cancellation tokens&lt;/item&gt;
      &lt;item&gt;Actor model as an alternative to Tokio mutexes&lt;/item&gt;
      &lt;item&gt;Task aborts&lt;/item&gt;
      &lt;item&gt;Structured concurrency&lt;/item&gt;
      &lt;item&gt;Relationship to panic safety and mutex poisoning&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;If you’re curious about any of these, check out this link where I’ve put together a collection of documents and blog posts about these concepts. In particular, I’d recommend reading these two Oxide RFDs:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;RFD 397 Challenges with async/await in the control plane by David Pacheco&lt;/item&gt;
      &lt;item&gt;RFD 400 Dealing with cancel safety in async Rust by myself&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Thank you for reading this post to the end! And thanks to many of my coworkers at Oxide for reviewing the talk and the RFDs linked above, and for suggestions and constructive feedback.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=45464632</guid><pubDate>Fri, 03 Oct 2025 16:18:29 +0000</pubDate></item><item><title>Germany must stand firmly against client-side scanning in Chat Control [pdf]</title><link>https://signal.org/blog/pdfs/germany-chat-control.pdf</link><description></description><guid isPermaLink="false">https://news.ycombinator.com/item?id=45464921</guid><pubDate>Fri, 03 Oct 2025 16:44:02 +0000</pubDate></item><item><title>The collapse of the econ PhD job market</title><link>https://www.chrisbrunet.com/p/the-collapse-of-the-econ-phd-job</link><description>&lt;doc fingerprint="2a4080db19b566a2"&gt;
  &lt;main&gt;&lt;p&gt;For decades, a doctorate in economics was a golden ticket. It promised a path to tenure, or at worst, a lucrative role at a central bank, think tank, or tech firm.&lt;/p&gt;&lt;p&gt;Not anymore.&lt;/p&gt;&lt;p&gt;The economics job market is in freefall, and the profession’s own data proves it.&lt;/p&gt;&lt;p&gt;Unlike most fields, economics has a bizarrely centralized hiring ritual. Once a year, in the fall, every employer posts openings at the same time. Every candidate applies at the same time. The entire profession runs through one clearinghouse: the American Economic Association’s “Job Openings for Economists” (JOE). This makes economics PhD market uniquely measurable, and the numbers are brutal.&lt;/p&gt;&lt;head rend="h3"&gt;Job postings for PhD economists are down 30 percent in just three years&lt;/head&gt;&lt;p&gt;The JOE data shows few jobs in 2022, fewer still in 2023, and fewer still in 2024.&lt;/p&gt;&lt;p&gt;This year’s trajectory suggests 2025 will be even worse:&lt;/p&gt;&lt;p&gt;Extrapolating, the 2025 market looks set to bottom out around 1,000 openings:&lt;/p&gt;&lt;p&gt;I think my freehand projection is a very conservative approximation of reality—actual numbers may come in slightly higher or lower, of course, but this reasonably looks like what the market is on track for, barring a miracle.&lt;/p&gt;&lt;p&gt;Just three years ago, there were 1,477 openings.&lt;/p&gt;&lt;p&gt;The fall to ~1,000 this year will represent a 32% collapse.&lt;/p&gt;&lt;p&gt;Most economics PhD students aren’t looking for just any job, though, they want a tenure-track position in academia. According to polling data from the 2025 Webinar on the Economics PhD Job Market, 94% of candidates from the past four cohorts reported being “very interested” or “somewhat interested” in becoming an assistant professor, dwarfing all non-academic options.&lt;/p&gt;&lt;p&gt;Subsetting the JOE data to permanent academic positions (tenure-track or tenured) yields a nearly identical trend: openings dropped from 631 in 2022 to about 400 in 2025, a 35% decline over three years:&lt;/p&gt;&lt;p&gt;Again, please forgive my Microsoft Paint skills:&lt;/p&gt;&lt;p&gt;The JOE data is confirmed by Econ Job Market (EJM) data, a nonprofit 501(c)(3) whose stated mission is “to improve the flow of information in the job market for academic economists, by providing a central repository for job-market materials.”&lt;/p&gt;&lt;p&gt;EJM data makes the pattern robust: nearly all interview invitations are sent out during a concentrated few weeks in December, and the volume of those invitations has collapsed from 3,835 down to 2,502… a 34.8% decline.&lt;/p&gt;&lt;p&gt;As a result, the AEA’s own Job Market Committee quietly admitted in its 2025 report that last year was “challenging” for candidates.&lt;/p&gt;&lt;head rend="h2"&gt;While Supply of Tenure-Track Jobs Plummets, Demand Rises&lt;/head&gt;&lt;p&gt;EJM data show that the cumulative number of views on job ads is higher than ever, with 2025 easily on track to set a new record.&lt;/p&gt;&lt;p&gt;That isn’t surprising: according to the 2024 NSF Survey of Doctorate Recipients, 1,385 Americans earned economics PhDs in 2024, more than in 2023, more than in 2022, and more than in 2021.&lt;/p&gt;&lt;p&gt;You now have 1,385 brand-new PhDs chasing just 400 tenure-track jobs.&lt;/p&gt;&lt;p&gt;At first glance, that ratio might not look catastrophic. But here’s the catch:&lt;/p&gt;&lt;p&gt;They’re not competing only against each other. An equally large wave of international candidates floods the U.S. market every year. American universities routinely hire from London, Oxford, Cambridge, Toronto, Paris, Barcelona, and beyond.&lt;/p&gt;&lt;p&gt;Furthermore, the new graduates aren’t competing just with their own cohort. They’re thrown into the same bucket as the leftovers from every prior cycle: post-docs clinging to hope, visiting professors chasing stability, lecturers desperate to upgrade, assistant professors stranded at second-tier schools. The “new supply” is just the visible tip; the true applicant pool is a rolling backlog several times larger.&lt;/p&gt;&lt;p&gt;The result? According to EJM, 5,341 candidates participated in the 2024–25 market, the largest applicant pool ever recorded:&lt;/p&gt;&lt;p&gt;Yet the AEA’s Survey of the Labor Market for New Ph.D. Hires in Economics found that only 99 fresh PhD secured a tenure-track job in America.&lt;/p&gt;&lt;p&gt;That’s a ~7% placement rate for American PhD students.&lt;/p&gt;&lt;p&gt;Put differently: if 100 students spend six years earning an econ PhD in America (the current U.S. median time to degree is 5.8 years, not counting the growing detour of “pre-docs”), only seven will get a tenure-track job.&lt;/p&gt;&lt;p&gt;Even if we allow for survey response gaps and use the most charitable assumptions, the best possible placement rate for fresh Econ PhDs is likely no higher than 10–20%, maybe 25%? My methodology isn’t perfect, but no matter what, that’s still catastrophic.&lt;/p&gt;&lt;p&gt;And these jobs aren’t evenly distributed. A massively disproportionate share go to graduates of Harvard, MIT, Stanford, Chicago, Princeton, Yale, Berkeley, and Penn. That means for every grad student outside the top 10 programs, the odds of landing tenure track are significantly less than 5%.&lt;/p&gt;&lt;head rend="h2"&gt;Beyond academia is even more grim&lt;/head&gt;&lt;p&gt;Government has long been the second-largest employer of economics PhDs, traditionally offering stable if less glamorous careers at agencies like the Federal Reserve, Treasury, Bureau of Labor Statistics, or Congressional Budget Office. But even here, the number of available positions has fallen sharply. Federal hiring freezes, budget constraints, and shifting political priorities mean that many agencies are cutting back.&lt;/p&gt;&lt;p&gt;International organizations once served as the safety net for economists who missed out on academia or Washington. The IMF, World Bank, and OECD hired tons of econ PhDs. Today, those doors are far more scarce, and the competition is global: an American graduate is just as likely to be measured against candidates from LSE, Sciences Po, or Peking University.&lt;/p&gt;&lt;p&gt;Oh yeah, and they have hiring freezes too:&lt;/p&gt;&lt;p&gt;Outside academia, government, or IGOs, the tech industry used to provide a reliable fallback. Tech giants like Amazon, Microsoft, Netflix, and Airbnb built entire teams of economists to optimize pricing, design experiments, and model consumer behavior.&lt;/p&gt;&lt;p&gt;That avenue, too, has begun to shrink. Tech hiring, which exploded during the pandemic, has collapsed. Today, demand is not just weak but structurally below trend, as firms automate more of the work that junior economists once did.&lt;/p&gt;&lt;p&gt;‘‘What does the modal economist, or any non CS or DS person really, have to offer to a tech firm in 2025? Not all, but many tech companies are actively downsizing and laying off tons of workers with tech experience that you have to compete against. And few firms will really care about causal inference and any other data analytics jobs can be filled by data science masters grads with deeper programming skills and cheaper salary expectations. Not to mention there is a focus on developing and using AI these days and your intro to machine learning class isn’t going to cut it.’’&lt;/p&gt;&lt;p&gt;— Anonymous economist&lt;/p&gt;&lt;p&gt;The only seemingly stable landing spot left for economists is in banking and finance, but even here hiring is stagnant and remains well below its pre-pandemic trend. Counterintuitively, most private-sector banks and investment firms do not rely heavily on PhDs in economics. They prefer MBAs, statisticians, or computer scientists, leaving economics doctorates as niche hires rather than a core part of the workforce.&lt;/p&gt;&lt;head rend="h2"&gt;Four Structural Reasons Behind Decline of Demand for Economics professors &lt;/head&gt;&lt;p&gt;REASON 1: Declining undergraduate enrollment in economics&lt;/p&gt;&lt;p&gt;Benjamin Hansen, an econ professor at the University of Oregon, recently tweeted out His department’s own data show a steady fall in the number of declared majors, which has now translated into fewer degrees conferred.&lt;/p&gt;&lt;p&gt;National statistics confirm the trend: the number of students graduating with economics degrees is now slipping after years of steady growth.&lt;/p&gt;&lt;p&gt;Because universities hire faculty in proportion to student demand, this drop in majors eventually trickles down into fewer faculty lines.&lt;/p&gt;&lt;p&gt;REASON 2: The looming demographic cliff&lt;/p&gt;&lt;p&gt;The decline in majors is compounded by a larger demographic shift. The U.S. is approaching a “demographic cliff,” as the number of 18-year-olds begins to shrink in the 2020s and 2030s. Fewer college-aged students overall means fiercer competition among departments for enrollments.&lt;/p&gt;&lt;p&gt;REASON 3: The rise of artificial intelligence&lt;/p&gt;&lt;p&gt;Bryan Caplan, professor of economics at George Mason University, gave ChatGPT his graduate-level Labor Economics final exam. The AI earned a “D” (this was 2 years ago), but soon enough, we all know it will be smart enough to earn an A. The technology is improving rapidly, and universities know it, and so does the private sector. Tasks once reserved for graduate students and junior faculty—data cleaning, econometric modeling, even writing referee reports—are now being automated.&lt;/p&gt;&lt;p&gt;REASON 4: Lying About Inflation&lt;/p&gt;&lt;p&gt;If you were there during the pandemic money printing, you remember the sequence all too well: first the confident insistence that government spending wouldn’t fuel inflation, then the soothing claim that inflation was merely “transitory,” and finally the outright gaslighting that prices weren’t rising at all. Each step was wrong, and each was delivered with smug certainty. Ordinary people—who watched their rent, groceries, and gas bills skyrocket—saw a profession more invested in protecting Democratic policy narratives than in telling the truth. The result is a self-inflicted torching of trust.&lt;/p&gt;&lt;head rend="h2"&gt;Is an Economics PhD still a good deal?&lt;/head&gt;&lt;p&gt;The answer is no. An economics PhD is no longer an investment. It is a gamble with terrible odds. A handful of winners still exist, almost all of them minted at Harvard, MIT, Princeton, or Chicago. For everyone else, the degree is a trap: six or more years of grinding work that too often ends with being overeducated, underpaid, and locked out of the profession you trained to join.&lt;/p&gt;&lt;p&gt;‘‘My advice is to do something other than go for a Ph.D in economics … In hindsight, my decision to go to graduate school was a mistake. My primary motivation was intellectual curiosity, and econ grad school worked against that.’’&lt;/p&gt;&lt;p&gt;—&lt;/p&gt;&lt;p&gt;After I wrote this entire article, I came across a similar one published last month by the New York Times:&lt;/p&gt;&lt;p&gt;It essentially just blamed the ‘‘bull market for economists being over’’ on the same three core reasons as I did:&lt;/p&gt;&lt;list rend="ul"&gt;&lt;item&gt;&lt;p&gt;‘‘Universities and nonprofits have scaled back hiring amid declining state budgets and federal funding cuts.’’&lt;/p&gt;&lt;/item&gt;&lt;item&gt;&lt;p&gt;‘‘At the same time, the Trump administration has laid off government economists and frozen hiring for new ones.’’&lt;/p&gt;&lt;/item&gt;&lt;item&gt;&lt;p&gt;‘‘Tech companies also have grown stingier, and their need for high-level economists — once seemingly insatiable — has waned.’’&lt;/p&gt;&lt;/item&gt;&lt;/list&gt;&lt;p&gt;Much more interesting than the NYT article was this commentary on it from&lt;/p&gt;, a PhD economist trained at UC Berkeley:&lt;p&gt;He begins by engaging with the NYT article, then runs through the same JOE data I did, ultimately landing on a similar diagnosis: the collapse is driven largely by federal hiring freezes and the looming demographic cliff. From there, though, his piece becomes more distinctive and interesting, exploring the social dynamics and internal hierarchies of the profession. His conclusion is bleak for the discipline itself, but notably optimistic about the future of Substack:&lt;/p&gt;&lt;quote&gt;&lt;p&gt;Do I think the PhD job market will bounce back?&lt;/p&gt;&lt;p&gt;Prognosticating too eagerly is a good way to land yourself a place in the Irving Fisher Hall of Forever Being Remembered For Having Said One Stupid Thing.4 A 16% fall in jobs, while devastating, is not yet apocalyptic. (By comparison, historian job ads have fallen closer to 50% since their 2008 peak.) But for things to get better requires a causal mechanism. Reinstating science and academic funding would require either Republicans to reverse their stance on the value of higher education, or for Democrats to win back the Senate. I don’t have a great sense of if either will happen.5&lt;/p&gt;&lt;p&gt;In this case, prediction may be less important than preparation. Placement chairs need to own up to the harshness of the labor market, and urge job market candidates to start prepping non-academic options. (Better yet, admissions chairs should consider paring back cohort sizes.) Candidates who would like a proper job after graduating should be networking, hard. And candidates resolutely committed to academia should steel themselves for long hibernations as post docs, to wait out the coming storm.&lt;/p&gt;&lt;p&gt;On second thought, I will venture one dark prediction, for at least the near future.&lt;/p&gt;&lt;p&gt;We’re going to see a lot more Substacks.&lt;/p&gt;&lt;/quote&gt;&lt;p&gt;The wager, then, is that the future of intellectual life will be increasingly decentralized. Platforms like Substack are already siphoning off the kind of energy and analysis that once flowed into journals or policy shops.&lt;/p&gt;&lt;p&gt;As for the economics profession, the only real fix would be radical: every PhD program would have to coordinate and act like a cartel to slash admissions to dramatically reduce supply. Without that discipline, the system will keep flooding the market with useless doctorates, a Ponzi scheme destined to collapse under its own weight.&lt;/p&gt;&lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=45464984</guid><pubDate>Fri, 03 Oct 2025 16:49:57 +0000</pubDate></item><item><title>Depot (YC W23) Is Hiring a Principal Design Engineer (Remote US/EU)</title><link>https://www.ycombinator.com/companies/depot/jobs/qg8iVTz-principal-design-engineer</link><description>&lt;doc fingerprint="7cdcf65b3f542330"&gt;
  &lt;main&gt;
    &lt;p&gt;Build faster. Waste less time.&lt;/p&gt;
    &lt;p&gt;At Depot, we are on a mission to redefine software collaboration and accelerate developers everywhere. We are creating a build performance and developer platform unlike any other, combining performance, empathy, and centralized collaboration to enable companies to iterate exponentially faster.&lt;/p&gt;
    &lt;p&gt;We are embarking on the next phase of Depot, which aims to redefine the software development process. Everyone at Depot is inspired by the opportunity to help developers ship and collaborate faster than ever before. We are all builders and care deeply about the quality of our work.&lt;/p&gt;
    &lt;p&gt;We believe that by focusing on performance, empathy, and quality, we are creating a gravitational pull towards Depot, both the team and the product. This is the foundation on which all other things are built.&lt;/p&gt;
    &lt;p&gt;We are looking to hire our first Design Engineer who can further advance our mission to provide not just the fastest place to collaborate on software, but the highest quality as well.&lt;/p&gt;
    &lt;p&gt;For this role, we expect you to be a seasoned expert, have robust design skills, sharp product thinking, and the ability to engage deeply in technical discussions. We work as a small team where engineers and designers work side by side to test ideas, build proof of concepts, and ultimately ship quality solutions to customers. You will be a key contributor and have ownership &amp;amp; autonomy to see projects through from beginning to end.&lt;/p&gt;
    &lt;p&gt;Please note: We are an equal opportunity employer and remote-only company. At this time, we can only support hiring within North America and Europe for this role.&lt;/p&gt;
    &lt;p&gt;We are a fully remote and globally distributed team across the US, Europe, and Canada currently. As a remote startup, there is a collection of things we value and expect from folks:&lt;/p&gt;
    &lt;p&gt;Depot is a build acceleration and developer productivity platform that saves companies like PostHog, Wistia, Semgrep, and Secoda thousands of hours in build time every week.&lt;/p&gt;
    &lt;p&gt;We are developers. We started Depot because we were frustrated with the constant pain of slow build performance. We were fed up waiting for builds and annoyed by the lack of tooling and providers that actually made builds performant. So, we went and built the solution we had always wanted.&lt;/p&gt;
    &lt;p&gt;Slow builds are the dam standing in the way between mediocrity and innovation. They’re wasteful, expensive, and a drain on developer happiness &amp;amp; productivity. They slow down innovation.&lt;/p&gt;
    &lt;p&gt;Taking a 40-minute build down to a minute, changes everything. We help folks save literal years in build time every single week.&lt;/p&gt;
    &lt;p&gt;And we’re just getting started. For us, it’s all about iteration speed and keeping developers in their flow state. Our mission is to be relentless in accelerating software development.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=45465078</guid><pubDate>Fri, 03 Oct 2025 17:00:08 +0000</pubDate></item><item><title>Ants trapped in a Soviet nuclear bunker survived for years</title><link>https://www.sciencealert.com/ants-trapped-in-an-old-soviet-nuclear-bunker-survived-for-years-by-turning-on-their-own</link><description>&lt;doc fingerprint="3e211792082b4bea"&gt;
  &lt;main&gt;
    &lt;p&gt;Even in a hopeless place, ants will find a way. No food, no light, no escape? No problem.&lt;/p&gt;
    &lt;p&gt;In the woods of western Poland lies a dismantled Soviet nuclear base, complete with two underground bunkers where nuclear ammunition was once kept. After the military complex was abandoned, these eerie human-made caves became great roosting places for overwintering bats.&lt;/p&gt;
    &lt;p&gt;In early 2010s, volunteers started visiting the bunkers to monitor the bat population in winter, and made a discovery of a different sort: A large mass of wood ants (Formica polyctena) trapped on the bunker floor, surviving without a queen or any of their usual creature comforts.&lt;/p&gt;
    &lt;p&gt;When it was first found in 2013, this 'colony' of underground ants already included up to a million live workers and several more million dead. They were not reproducing, though. Instead, the population was being replenished through sheer accident.&lt;/p&gt;
    &lt;p&gt;In the ceiling of the bunker sat a rusted ventilation pipe, connecting the dark cavern to the forest above. There, a giant ant colony had built a mound right above the bunker; as the metal rusted through, some of their ranks started falling into the concrete cavern below.&lt;/p&gt;
    &lt;p&gt;"In total darkness, they have constructed an earthen mound, which they have maintained all-year-round by moulding it and keeping the nest entrances open," researchers wrote in a study in 2016, noting these ants are "a far cry from a fully functional colony".&lt;/p&gt;
    &lt;p&gt;Investigating the limits of ant living conditions is a subject of keen interest for some entomologists. So, for several years, researchers made repeated trips to the bunker and watched in fascination as this isolated population continued to grow and survive despite a lack of light, heat, or obvious nourishment.&lt;/p&gt;
    &lt;p&gt;Now, scientists finally know how these trapped insects pulled it off: the mass consumption of their own imprisoned nest mates.&lt;/p&gt;
    &lt;p&gt;Cannibalism was obviously suspected; wood ants are, after all, the only major food source available in this tight spot, apart from the occasional dead mouse or bat. Plus, this particular species is known to consume their own fallen dead during territorial "ant wars" when food is often scarce.&lt;/p&gt;
    &lt;p&gt;To confirm this hunch, a team of researchers collected corpses from several ant 'cemeteries' scattered within the bunker. Closely examining 150 dead worker ants, the team noticed the vast majority of bodies (roughly 93 percent) had gnawed holes and bite marks.&lt;/p&gt;
    &lt;p&gt;The authors say these are clear signs of mass consumption, with practically no other organism in the bunker capable of making these marks.&lt;/p&gt;
    &lt;p&gt;"The survival and growth of the bunker 'colony' through the years, without producing own offspring, was possible owing to continuous supply of new workers from the upper nest and accumulation of nestmate corpses," the researchers concluded in their study.&lt;/p&gt;
    &lt;p&gt;"The corpses served as an inexhaustible source of food which substantially allowed survival of the ants trapped down in otherwise extremely unfavourable conditions."&lt;/p&gt;
    &lt;p&gt;It seems that wood ants can handle remarkable adversity in their bid for survival. Although luckily for this colony, they no longer have to turn on their own: In 2016, researchers installed a wooden boardwalk (below) in the bunker, connecting the ventilation pipe to the ground. Within four months, nearly all the trapped ants had deserted the bunker floor.&lt;/p&gt;
    &lt;p&gt;Now, when any ants are unfortunate enough to fall into the dark chamber, they don't have to resort to cannibalism. They can just calmly walk the plank, all the way home.&lt;/p&gt;
    &lt;p&gt;The research was published in the Journal of Hymenoptera Research.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=45465091</guid><pubDate>Fri, 03 Oct 2025 17:01:27 +0000</pubDate></item><item><title>Simple Hotkey Daemon for macOS, Ported to Zig</title><link>https://github.com/jackielii/skhd.zig</link><description>&lt;doc fingerprint="b607defb1717a1dc"&gt;
  &lt;main&gt;
    &lt;p&gt;Simple Hotkey Daemon for macOS, ported from skhd to Zig.&lt;/p&gt;
    &lt;p&gt;This implementation is fully compatible with the original skhd configuration format - your existing &lt;code&gt;.skhdrc&lt;/code&gt; files will work without modification. Additionally, it includes new features like process groups and command definitions (&lt;code&gt;.define&lt;/code&gt;) for cleaner configs, key forwarding/remapping, and improved error reporting.&lt;/p&gt;
    &lt;p&gt;The easiest way to install skhd.zig:&lt;/p&gt;
    &lt;code&gt;brew install jackielii/tap/skhd-zig&lt;/code&gt;
    &lt;p&gt;Download the latest release for your architecture:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;skhd-arm64-macos.tar.gz&lt;/code&gt;- For Apple Silicon Macs&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;skhd-x86_64-macos.tar.gz&lt;/code&gt;- For Intel Macs&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Extract and install:&lt;/p&gt;
    &lt;code&gt;tar -xzf skhd-*.tar.gz
sudo cp skhd /usr/local/bin/&lt;/code&gt;
    &lt;p&gt;If you need builds with different optimization levels (Debug, ReleaseSafe, ReleaseFast, ReleaseSmall), you can download them directly from GitHub Actions:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Go to the CI workflow in Actions tab. Filter by branch &lt;code&gt;main&lt;/code&gt;.&lt;/item&gt;
      &lt;item&gt;Click on the latest successful run&lt;/item&gt;
      &lt;item&gt;Scroll down to the "Artifacts" section&lt;/item&gt;
      &lt;item&gt;Download the build artifact for your desired optimization level: &lt;list rend="ul"&gt;&lt;item&gt;&lt;code&gt;skhd-Debug&lt;/code&gt;- Debug build with full debugging symbols&lt;/item&gt;&lt;item&gt;&lt;code&gt;skhd-ReleaseSafe&lt;/code&gt;- Release build with safety checks and runtime safety&lt;/item&gt;&lt;item&gt;&lt;code&gt;skhd-ReleaseFast&lt;/code&gt;- Optimized for performance (recommended for daily use)&lt;/item&gt;&lt;item&gt;&lt;code&gt;skhd-ReleaseSmall&lt;/code&gt;- Optimized for binary size&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
    &lt;/list&gt;
    &lt;code&gt;# Clone the repository
git clone https://github.com/jackielii/skhd.zig
cd skhd.zig

# Build in release mode
zig build -Doptimize=ReleaseFast

# Install (copy to /usr/local/bin)
sudo cp zig-out/bin/skhd /usr/local/bin/&lt;/code&gt;
    &lt;p&gt;After installation, run skhd as a service for automatic startup:&lt;/p&gt;
    &lt;code&gt;# Install and start the service
skhd --install-service
skhd --start-service

# Check if skhd is running properly
skhd --status

# Restart service (useful for restarting after giving accessibility permissions)
skhd --restart-service

# Stop service
skhd --stop-service

# Uninstall service
skhd --uninstall-service&lt;/code&gt;
    &lt;p&gt;The service will:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Start automatically on login&lt;/item&gt;
      &lt;item&gt;Create logs at &lt;code&gt;/tmp/skhd_$USER.log&lt;/code&gt;&lt;/item&gt;
      &lt;item&gt;Use your config from &lt;code&gt;~/.config/skhd/skhdrc&lt;/code&gt;or&lt;code&gt;~/.skhdrc&lt;/code&gt;&lt;/item&gt;
      &lt;item&gt;Automatically reload on config changes&lt;/item&gt;
    &lt;/list&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Event capturing: Uses macOS Core Graphics Event Tap for system-wide keyboard event interception&lt;/item&gt;
      &lt;item&gt;Hotkey mapping: Maps key combinations to shell commands with full modifier support&lt;/item&gt;
      &lt;item&gt;Process-specific bindings: Different commands for different applications&lt;/item&gt;
      &lt;item&gt;Key forwarding/remapping: Remap keys to other key combinations&lt;/item&gt;
      &lt;item&gt;Modal system: Multi-level modal hotkey system with capture modes&lt;/item&gt;
      &lt;item&gt;Configuration file: Compatible with original skhd configuration format&lt;/item&gt;
      &lt;item&gt;Hot reloading: Automatic config reload on file changes&lt;/item&gt;
    &lt;/list&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Process groups: Define named groups of applications for cleaner configs&lt;/item&gt;
      &lt;item&gt;Command definitions: Define reusable commands with placeholders to reduce repetition&lt;/item&gt;
      &lt;item&gt;Key Forwarding: Forward / remap key binding to another key binding&lt;/item&gt;
      &lt;item&gt;Mode activation with command: Execute a command when switching modes (e.g., &lt;code&gt;cmd - w ; window : echo "Window mode"&lt;/code&gt;)&lt;/item&gt;
    &lt;/list&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;--version&lt;/code&gt;/&lt;code&gt;-v&lt;/code&gt;- Display version information&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;--help&lt;/code&gt;- Show usage information&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;-c&lt;/code&gt;/&lt;code&gt;--config&lt;/code&gt;- Specify config file location&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;-o&lt;/code&gt;/&lt;code&gt;--observe&lt;/code&gt;- Observe mode (echo keycodes and modifiers)&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;-V&lt;/code&gt;/&lt;code&gt;--verbose&lt;/code&gt;- Debug output with detailed logging&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;-k&lt;/code&gt;/&lt;code&gt;--key&lt;/code&gt;- Synthesize keypress for testing&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;-t&lt;/code&gt;/&lt;code&gt;--text&lt;/code&gt;- Synthesize text input&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;-r&lt;/code&gt;/&lt;code&gt;--reload&lt;/code&gt;- Signal reload to running instance&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;-h&lt;/code&gt;/&lt;code&gt;--no-hotload&lt;/code&gt;- Disable hotloading&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;-P&lt;/code&gt;/&lt;code&gt;--profile&lt;/code&gt;- Profile event handling (Debug and ReleaseSafe builds only)&lt;/item&gt;
    &lt;/list&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;--install-service&lt;/code&gt;- Install launchd service&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;--uninstall-service&lt;/code&gt;- Remove launchd service&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;--start-service&lt;/code&gt;- Start as service&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;--restart-service&lt;/code&gt;- Restart service&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;--stop-service&lt;/code&gt;- Stop service&lt;/item&gt;
      &lt;item&gt;PID file management (&lt;code&gt;/tmp/skhd_$USER.pid&lt;/code&gt;)&lt;/item&gt;
      &lt;item&gt;Service logging (&lt;code&gt;/tmp/skhd_$USER.log&lt;/code&gt;)&lt;/item&gt;
    &lt;/list&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Blacklisting: Exclude applications from hotkey processing&lt;/item&gt;
      &lt;item&gt;Shell customization: Use custom shell for command execution&lt;/item&gt;
      &lt;item&gt;Left/right modifier distinction: Support for lcmd, rcmd, lalt, ralt, etc.&lt;/item&gt;
      &lt;item&gt;Special key support: Function keys, media keys, arrow keys&lt;/item&gt;
      &lt;item&gt;Passthrough mode: Execute command but still send keypress to application&lt;/item&gt;
      &lt;item&gt;Config includes: Load additional config files with &lt;code&gt;.load&lt;/code&gt;directive&lt;/item&gt;
      &lt;item&gt;Comprehensive error reporting: Detailed error messages with line numbers&lt;/item&gt;
    &lt;/list&gt;
    &lt;code&gt;# Build the project (creates executable in zig-out/bin/)
zig build

# Build in release mode with optimizations
zig build -Doptimize=ReleaseFast

# Run the application
zig build run

# Run with arguments
zig build run -- -V -c ~/.config/skhd/skhdrc

# Run tests
zig build test&lt;/code&gt;
    &lt;p&gt;skhd.zig looks for configuration files in the following order:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Path specified with &lt;code&gt;-c&lt;/code&gt;flag&lt;/item&gt;
      &lt;item&gt;
        &lt;code&gt;~/.config/skhd/skhdrc&lt;/code&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;code&gt;~/.skhdrc&lt;/code&gt;
      &lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The configuration syntax is fully compatible with the original skhd. See SYNTAX.md for the complete syntax reference and grammar.&lt;/p&gt;
    &lt;code&gt;# Use custom shell (skips interactive shell overhead)
.shell "/bin/dash"

# Blacklist applications (skip hotkey processing)
.blacklist [
    "dota2"
    "Microsoft Remote Desktop"
    "VMware Fusion"
]

# Load additional config files
.load "~/.config/skhd/extra.skhdrc"

# Define process groups for reuse (New in skhd.zig!)
.define terminal_apps ["kitty", "wezterm", "terminal"]
.define native_apps ["kitty", "wezterm", "chrome", "whatsapp"]
.define browser_apps ["chrome", "safari", "firefox", "edge"]

# Define reusable commands with placeholders (New in skhd.zig!)
.define yabai_focus : yabai -m window --focus {{1}} || yabai -m display --focus {{1}}
.define yabai_swap : yabai -m window --swap {{1}} || (yabai -m window --display {{1}} &amp;amp;&amp;amp; yabai -m display --focus {{1}})
.define toggle_app : open -a "{{1}}" || osascript -e 'tell app "{{1}}" to quit'
.define resize_window : yabai -m window --resize {{1}}:{{2}}:{{3}}
.define toggle_scratchpad : yabai -m window --toggle {{1}} || open -a "{{2}}"&lt;/code&gt;
    &lt;code&gt;# Basic format: modifier - key : command
cmd - a : echo "Command+A pressed"

# Multiple modifiers
cmd + shift - t : open -a Terminal

# Different modifier combinations
ctrl - h : echo "Control+H"
alt - space : echo "Alt+Space"
shift - f1 : echo "Shift+F1"&lt;/code&gt;
    &lt;code&gt;# Basic modifiers
cmd     # Command key
ctrl    # Control key
alt     # Alt/Option key
shift   # Shift key
fn      # Function key

# Left/right specific modifiers
lcmd, rcmd    # Left/right Command
lctrl, rctrl  # Left/right Control
lalt, ralt    # Left/right Alt
lshift, rshift # Left/right Shift

# Special modifier combinations
hyper   # cmd + shift + alt + ctrl
meh     # shift + alt + ctrl&lt;/code&gt;
    &lt;code&gt;# Navigation keys
cmd - left : echo "Left arrow"
cmd - right : echo "Right arrow"
cmd - up : echo "Up arrow"
cmd - down : echo "Down arrow"

# Special keys
cmd - space : echo "Space"
cmd - return : echo "Return/Enter"
cmd - tab : echo "Tab"
cmd - escape : echo "Escape"
cmd - delete : echo "Delete/Backspace"
cmd - home : echo "Home"
cmd - end : echo "End"
cmd - pageup : echo "Page Up"
cmd - pagedown : echo "Page Down"

# Function keys
cmd - f1 : echo "F1"
cmd - f12 : echo "F12"

# Media keys
sound_up : echo "Volume Up"
sound_down : echo "Volume Down"
mute : echo "Mute"
brightness_up : echo "Brightness Up"
brightness_down : echo "Brightness Down"&lt;/code&gt;
    &lt;code&gt;# Different commands for different applications
cmd - n [
    "terminal" : echo "New terminal window"
    "safari"   : echo "New safari window"
    "finder"   : echo "New finder window"
    *          : echo "New window in other apps"
]&lt;/code&gt;
    &lt;code&gt;# Keyboard layout fixes
0xa | 0x32             # UK keyboard § to `
shift - 0xa | shift - 0x32  # shift - § to ~

# Function key navigation (for laptop keyboards)
fn - j | down
fn - k | up
fn - h | left
fn - l | right

# When you have cmd - number for yabai spaces,
# and you still want the cmd - number to work in applications
ctrl - 1 | cmd - 1
ctrl - 2 | cmd - 2
ctrl - 3 | cmd - 3&lt;/code&gt;
    &lt;code&gt;# Execute command but still send keypress to application
cmd - p -&amp;gt; : echo "This runs but Cmd+P still goes to app"&lt;/code&gt;
    &lt;code&gt;# Window management mode with anybar visual indicator
# Install anybar: brew install --cask anybar

# Define window management mode for warp/stack operations
# Use anybar to indicate the mode: https://github.com/tonsky/AnyBar
:: winmode @ : echo -n "red" | nc -4u -w0 localhost 1738
:: default : echo -n "hollow" | nc -4u -w0 localhost 1738

# Enter window mode with meh + m (shift + alt + ctrl + m)
meh - w ; winmode
winmode &amp;lt; escape ; default
winmode &amp;lt; meh - w ; default

# Alternative: Enter window mode AND show notification (New in skhd.zig!)
# This executes the command when switching to the mode
# It allows for different commands to execute and switch to another mode
meh - w ; winmode : osascript -e 'display notification "Window mode active" with title "skhd"'
winmode &amp;lt; escape ; default : osascript -e 'display notification "Normal mode" with title "skhd"'

# Focus operations - basic hjkl for focus
winmode &amp;lt; h : yabai -m window --focus west || yabai -m display --focus west
winmode &amp;lt; j : yabai -m window --focus south || yabai -m display --focus south
winmode &amp;lt; k : yabai -m window --focus north || yabai -m display --focus north
winmode &amp;lt; l : yabai -m window --focus east || yabai -m display --focus east

# Move operations - shift + hjkl for moving
winmode &amp;lt; shift - h : yabai -m window --move rel:-80:0
winmode &amp;lt; shift - j : yabai -m window --move rel:0:80
winmode &amp;lt; shift - k : yabai -m window --move rel:0:-80
winmode &amp;lt; shift - l : yabai -m window --move rel:80:0

# Warp operations - alt + shift + hjkl for warping
winmode &amp;lt; alt + shift - h : yabai -m window --warp west
winmode &amp;lt; alt + shift - j : yabai -m window --warp south
winmode &amp;lt; alt + shift - k : yabai -m window --warp north
winmode &amp;lt; alt + shift - l : yabai -m window --warp east

# Stack operations - ctrl + shift + hjkl for stacking
winmode &amp;lt; ctrl + shift - h : yabai -m window --stack west
winmode &amp;lt; ctrl + shift - j : yabai -m window --stack south
winmode &amp;lt; ctrl + shift - k : yabai -m window --stack north
winmode &amp;lt; ctrl + shift - l : yabai -m window --stack east

# Stack management shortcuts
winmode &amp;lt; s : yabai -m window --insert stack  # Toggle stack mode
winmode &amp;lt; u : yabai -m window --toggle float; yabai -m window --toggle float  # Unstack window
winmode &amp;lt; n : yabai -m window --focus stack.next  # Navigate stack next
winmode &amp;lt; p : yabai -m window --focus stack.prev  # Navigate stack prev

# Resize submode
winmode &amp;lt; r ; resize
:: resize @ : echo -n "orange" | nc -4u -w0 localhost 1738
resize &amp;lt; h : yabai -m window --resize left:-20:0
resize &amp;lt; j : yabai -m window --resize bottom:0:20
resize &amp;lt; k : yabai -m window --resize top:0:-20
resize &amp;lt; l : yabai -m window --resize right:20:0
resize &amp;lt; escape ; winmode&lt;/code&gt;
    &lt;code&gt;# Focus windows using command definitions (New in skhd.zig!)
cmd - h : @yabai_focus("west")
cmd - j : @yabai_focus("south")
cmd - k : @yabai_focus("north")
cmd - l : @yabai_focus("east")

# Move/swap windows using command definitions
cmd + shift - h : @yabai_swap("west")
cmd + shift - j : @yabai_swap("south")
cmd + shift - k : @yabai_swap("north")
cmd + shift - l : @yabai_swap("east")

# Resize windows using command definitions
cmd + ctrl - h : @resize_window("left", "-20", "0")
cmd + ctrl - l : @resize_window("right", "20", "0")

# Switch spaces
cmd - 1 : yabai -m space --focus 1
cmd - 2 : yabai -m space --focus 2&lt;/code&gt;
    &lt;code&gt;# Quick app launching (traditional way)
alt - return : open -a Terminal
alt - b : open -a Safari

# Toggle apps using command definitions (New in skhd.zig!)
alt - f : @toggle_app("Finder")
alt - c : @toggle_app("Visual Studio Code")

# Scratchpad apps with yabai (New in skhd.zig!)
# In yabairc: yabai -m rule --add app="^YouTube Music$" scratchpad=music grid=11:11:1:1:9:9
alt - m : @toggle_scratchpad("music", "YouTube Music")
alt - n : @toggle_scratchpad("notes", "Notes")&lt;/code&gt;
    &lt;code&gt;# Linux-style word navigation and deletion
ctrl - backspace [
    @native_apps ~         # Terminal apps handle natively
    *            | alt - backspace  # Other apps: delete word
]

ctrl - left [
    @native_apps ~         # Terminal apps handle natively
    *            | alt - left       # Other apps: move word left
]

ctrl - right [
    @native_apps ~         # Terminal apps handle natively
    *            | alt - right      # Other apps: move word right
]

# Home/End key behavior (with shift for selection)
home [
    @native_apps ~         # Terminal apps handle natively
    *            | cmd - left       # Other apps: line start
]

shift - home [
    @native_apps ~         # Terminal apps handle natively
    *            | cmd + shift - left  # Other apps: select to line start
]

# Ctrl+Home/End for document navigation
ctrl - home [
    @native_apps ~         # Terminal apps handle natively
    *            | cmd - up         # Other apps: document start
]

ctrl - end [
    @native_apps ~         # Terminal apps handle natively
    *            | cmd - down       # Other apps: document end
]&lt;/code&gt;
    &lt;p&gt;Important: The logging and profiling behavior differs between build modes:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;ReleaseFast builds (installed via Homebrew or built with &lt;code&gt;-Doptimize=ReleaseFast&lt;/code&gt;):&lt;list rend="ul"&gt;&lt;item&gt;Only show errors and warnings, even with &lt;code&gt;-V&lt;/code&gt;/&lt;code&gt;--verbose&lt;/code&gt;flag&lt;/item&gt;&lt;item&gt;Profiling (&lt;code&gt;-P&lt;/code&gt;/&lt;code&gt;--profile&lt;/code&gt;) is disabled - all tracing code is compiled out for maximum performance&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;Only show errors and warnings, even with &lt;/item&gt;
      &lt;item&gt;ReleaseSafe builds (built with &lt;code&gt;-Doptimize=ReleaseSafe&lt;/code&gt;):&lt;list rend="ul"&gt;&lt;item&gt;Show errors, warnings, and info messages with &lt;code&gt;-V&lt;/code&gt;/&lt;code&gt;--verbose&lt;/code&gt;flag&lt;/item&gt;&lt;item&gt;Profiling (&lt;code&gt;-P&lt;/code&gt;/&lt;code&gt;--profile&lt;/code&gt;) is available for production debugging&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;Show errors, warnings, and info messages with &lt;/item&gt;
      &lt;item&gt;Debug builds (default &lt;code&gt;zig build&lt;/code&gt;):&lt;list rend="ul"&gt;&lt;item&gt;Show all log levels including debug messages with &lt;code&gt;-V&lt;/code&gt;/&lt;code&gt;--verbose&lt;/code&gt;flag&lt;/item&gt;&lt;item&gt;Profiling (&lt;code&gt;-P&lt;/code&gt;/&lt;code&gt;--profile&lt;/code&gt;) is available with full trace details&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;Show all log levels including debug messages with &lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;However, command output will be shown if verbose flag is specified in release builds.&lt;/p&gt;
    &lt;p&gt;This is a trade-off between convenience and performance:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Performance mode (default): Command output is discarded for faster execution&lt;/item&gt;
      &lt;item&gt;Verbose mode (&lt;code&gt;-V&lt;/code&gt;): Command output is preserved, which may add slight overhead but helps with trouble shooting&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;To debug hotkey events and see detailed logging:&lt;/p&gt;
    &lt;code&gt;# Verbose logging for troubleshooting config issues
# Note: In release builds, verbose mode only shows errors and warnings.
# To see debug/info logs, use a debug build:
zig build run -- -V&lt;/code&gt;
    &lt;p&gt;Performance: The event loop is allocation-free in release builds, ensuring consistent low-latency hotkey processing.&lt;/p&gt;
    &lt;code&gt;# Test key combinations and hex code (observe mode)
skhd -o

# Profile event handling (show after CTRL+C)
# Note: Profiling works in Debug and ReleaseSafe builds only
zig build &amp;amp;&amp;amp; ./zig-out/bin/skhd -P
# or for production debugging:
zig build -Doptimize=ReleaseSafe &amp;amp;&amp;amp; ./zig-out/bin/skhd -P

# Test specific keypress
skhd -k "cmd + shift - t"

# Test text synthesis
skhd -t "hello world"

# Reload config of running instance
skhd -r

# Debug memory allocations with real-time tracking
zig build alloc -- -V&lt;/code&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Fork the repository&lt;/item&gt;
      &lt;item&gt;Create a feature branch&lt;/item&gt;
      &lt;item&gt;Make your changes&lt;/item&gt;
      &lt;item&gt;Run tests: &lt;code&gt;zig build test&lt;/code&gt;&lt;/item&gt;
      &lt;item&gt;Submit a pull request&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;This project maintains compatibility with the original skhd license.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=45465276</guid><pubDate>Fri, 03 Oct 2025 17:18:21 +0000</pubDate></item><item><title>Email was the user interface for the first AI recommendation engines</title><link>https://buttondown.com/blog/ringo-email-as-an-ai-interface</link><description>&lt;doc fingerprint="a69329413b20cfa9"&gt;
  &lt;main&gt;
    &lt;p&gt;Spinning the radio dials like mini roulette wheels was, in 1993, the best way to discover new music. Static, a snatch of a familiar song, a news report, then ah wait that sounds interesting. You’d walk into a record store with that song stuck in your head, and with any luck would walk out after a conversation with the clerk a few tapes richer, a few dozen dollars poorer.&lt;/p&gt;
    &lt;p&gt;One year later, everything had changed. For in 1994, the best way to discover new music was to email an AI.&lt;/p&gt;
    &lt;p&gt;“This sounds ****in’ moronic,” said one Dave Dell in response to the idea, convinced his love of Lustmord meant the AI couldn’t possibly match his tastes. Even he acquiesced: “I'll try it anyways.”&lt;/p&gt;
    &lt;p&gt;By the time The Cranberries released their hit single “Zombie” that September, over two thousand Daves had tried their luck, emailing Ringo with their favorite artists. To their surprise, they’d get a reply from what appeared to be early artificial intelligence, filled with recommendations of new music they’d love. Enough that, seven years later, science fiction writer Cory Doctorow would reminisce that “half the music in my collection came out of Ringo,” that nascent music AI.&lt;/p&gt;
    &lt;p&gt;Yet incredibly, Ringo was little more than those couple thousand users’ recommendations, averaged and redistributed via email. An email that users would quickly come to think of as a human, a friend, one in a quick succession of email-powered crowdsourced recommendation AIs.&lt;/p&gt;
    &lt;p&gt;It all started with what MIT assistant professor Paul Resnick called “A deceptively simple idea,” in 1994.&lt;/p&gt;
    &lt;p&gt;“People who agreed in the past are likely to agree again,” he postulated, an idea that’d been christened Social Filtering by MIT Thomas Malone seven years earlier. If you and another person both like the same song, or book, or author, there’s a pretty good chance that if one of you likes a new artist, the other will like it as well. The more overlapping agreements you have, the better one’s tastes should be predictive of another’s.&lt;/p&gt;
    &lt;p&gt;And, maybe, social filtering could be an organizing principle of the internet.&lt;/p&gt;
    &lt;p&gt;For as the nascent world wide web grew exponentially from a single website in 1991 and ten in 1992 to 623 sites in 1993 and over 10,000 by the end of 1994, the ancient prophecy that “knowledge shall increase” suddenly seemed more an omen of content overload than a portent of good things. Cataloguing and categorization could only go so far. It would be easy enough to find another Cranberries album once you knew you liked them. Finding the next new band that you’d love required something beyond lists. What good was infinite knowledge and limitless content without a way to discover it?&lt;/p&gt;
    &lt;p&gt;“The exploding volume of digital information makes it difficult for the user, equipped with only search capability, to keep up with the fast pace of information generation,” wrote Stanford’s Tak W. Yan and Hector Garcia-Molina, in their stab at solving the same problem. “There is a need for technology to help us wade through all the information to find the items we really want and need, and to rid us of the things we do not want to be bothered with,” as MIT Media Lab’s Upendra Shardanand summarized the issue.&lt;/p&gt;
    &lt;p&gt;Maybe the best option would be to ask someone else. We like getting recommendations from others, after all. “Choice under uncertainty is an opportunity to benefit from other more knowledgeable people,” wrote a Bellcore research team of their stab at the same problem in 1993.&lt;/p&gt;
    &lt;p&gt;Social filtering, teams from Xerox and Bell, Stanford and MIT alike agreed, seemed the perfect discovery mechanism of the future. That is, if they could gather everyone’s preferences and turn them into predictions accurately.&lt;/p&gt;
    &lt;p&gt;The idea behind Tapestry’s social filtering&lt;/p&gt;
    &lt;p&gt;Decades before the explosion of email newsletters, newsgroups were filling up early inboxes at a time when hard drives cost as much as $4,000 per gigabyte. Storage wasn’t the only scarce resource; no one had time to read every rant and reply in their inboxes.&lt;/p&gt;
    &lt;p&gt;Automatic filters were too restrictive—and they weren’t intelligent. Intelligence was when a friend read a message that hit the spot, and forwarded it on to you. It was when a colleague deleted a message, a silent vote that others might also deem that message irrelevant, or when they saved or replied to was a message in a vote towards its relevance.&lt;/p&gt;
    &lt;p&gt;Therein lay an idea: “More effective filtering can be done by involving humans in the filtering process,” postulated David Goldberg, David Nichols, Brian Oki, and Douglas Terry of the Xerox PARC team. That, in 1992, was the insight behind Tapestry, a short-lived collaborative email app inside Xerox PARC.&lt;/p&gt;
    &lt;p&gt;Tapestry sorted newsgroup emails with ratings. When you read an email or other document that you liked, you’d add an endorsement that Tapestry would store in a database alongside others’ endorsements. The next time someone searched for a message or document, they’d first see the messages that had the most endorsements, or could filter by specific users’ endorsements to follow the likes of a particular tastemaker.&lt;/p&gt;
    &lt;p&gt;“Eager readers will read all the documents ... in order to get immediate access,” the team surmised, while “more casual readers will wait for the eager readers to annotate, and read documents based on their reviews.”&lt;/p&gt;
    &lt;p&gt;SIFT’s social filtering model&lt;/p&gt;
    &lt;p&gt;Tapestry, it seems, never left Xerox’ bounds. But two years later, in February 1994, a Stanford team took up the mantle with SIFT, or Stanford Information Filtering Tool. It, too, sorted through messages based on crowdsourced wisdom. But it didn’t require a new app. SIFT, instead, was built around email.&lt;/p&gt;
    &lt;p&gt;“Email communications is the lowest common denominator of network connectivity,” wrote the team. “By having an email interface, a SIFT server is accessible from users with less powerful machines, with limited network capability, or behind Internet-access firewalls,” features that, to this day, make email one of the most universally accessible bits of the internet, even behind corporate firewalls and government censorships.&lt;/p&gt;
    &lt;p&gt;A SIFT email preview in an early browser&lt;/p&gt;
    &lt;p&gt;SIFT put email front and center. You’d sign up with an early web form and choose a topic of interest, like “underwater archeology.” SIFT would then regularly email you a list of articles and their first few lines to see what piqued your interest—an early curated email newsletter of top headlines. You’d then reply again with the articles you wanted to read, and SIFT would both email you the full messages, and store your choices as votes to help it refine what it’d recommend next time.&lt;/p&gt;
    &lt;p&gt;SIFT had some hits and some misses, and users were surprisingly accepting when things went wrong. “Well, nothing is perfect,” surmised Jiří Peterka in an early review. But SIFT clearly hit a nerve. “Within ten days of the announcement, we received well over a thousand profiles,” reported the team. By November, ten months after launch, SIFT was matching 45,000 articles each week to over 13,000 subscribers’ profiles.&lt;/p&gt;
    &lt;p&gt;Meanwhile, on opposite coasts, a Bell team was pondering decision paralysis. “Future users of the national information infrastructure will be overwhelmed with choices,” wrote Bellcore researchers Will Hill, Larry Stead, Mark Rosenstein and George Furnas in their 1995 writeup of the project. The best way out was to ask an expert, they decided. “When making a choice in the absence of decisive first-hand knowledge, choosing as other like-minded, similarly-situated people have successfully chosen in the past is a good strategy.”&lt;/p&gt;
    &lt;p&gt;So a team from the same Bell roots as UNIX and C++ and the transistor itself decided to harness social filtering to help you figure out which movie to rent from Blockbuster.&lt;/p&gt;
    &lt;p&gt;Movies lent themselves well to the model. There were a limited number of movies to sort and recommend, and existing expert ratings from the likes of Roger Ebert to pre-seed the database. If people would share their favorite movies, the system could match them with others who liked the same movies, and recommend other movies those people liked.&lt;/p&gt;
    &lt;p&gt;And it all ran over email.&lt;/p&gt;
    &lt;p&gt;An example videos@bellcore.com email&lt;/p&gt;
    &lt;p&gt;“The Internet email interface is currently a subject-line command interface,” the team wrote. For a few short months, from October 1993 to May 1994, you could email the subject “ratings” to videos@bellcore.com, and receive a reply with an overwhelming 500 movies.&lt;/p&gt;
    &lt;p&gt;Reply with your reviews of the movies you’d watched on a 1 to 10 scale, and Bellcore’s server would parse your reply and add your ratings to a database. Then, it’d look for “correlations between the new user's ratings and ratings from a random subsample of known users,” then “evaluate every unseen movie, sort them by highest prediction and skim off the top to recommend.”&lt;/p&gt;
    &lt;p&gt;Minutes later, you’d get back a reply, recommending you watch Alien and Blade Runner, say, along with a list of people who shared your tastes. It was a recommendation engine and nascent social network in one, where you just might find your next favorite movie and make a friend.&lt;/p&gt;
    &lt;p&gt;“Virtual communities may also sprout up around other domains such as music, books and catalog products,” predicted the team.&lt;/p&gt;
    &lt;p&gt;It didn’t take long. Two months after videos@bellcore.com shut down, a new MIT project launched: Ringo. “Our system, in our opinion, tackled the much more difficult problem domain of music,” wrote co-founder Upendra Shardanand in his master’s thesis.&lt;/p&gt;
    &lt;p&gt;The ingredients were in place. Social filtering had been proven out by Tapestry and SIFT. “The user interface for videos@bellcore.com system was used as a reference when designing the e-mail interface for Ringo,” said Shardanand. Along with that, Ringo added email-based accounts to learn from your preferences over time, and a constrained Pearson Correlation algorithm to rate “commonality between two users when computing the weights ... proportional to the number of artists both users have rated in common.”&lt;/p&gt;
    &lt;p&gt;That, and a personality. Ringo’s original emails were written as if they came from a person, such as “I recommend that you check out these artists...” It got toned down over time, partly to ensure people sent clear, precise instructions that Ringo could understand instead of fluent, natural language—but it quickly became clear that people thought of Ringo as a friend.&lt;/p&gt;
    &lt;p&gt;You’d email Ringo to sign up, and it’d reply with a more manageable list of 125 artists that you’d rate from 1 (“Pass the earplugs,” in Ringo’s description of its lowest rating) to 7 (“BOOM! One of my FAVORITE few!”). Ringo would then match your favorites to others with similar tastes, and reply with the eight artists it thought you’d like most.&lt;/p&gt;
    &lt;p&gt;The first email promoting Ringo, on a USENET group&lt;/p&gt;
    &lt;p&gt;On July 1, 1994—four years and 11 months before Napster’s launch—Ringo opened its inbox to the world. Shardanand marketed it on USENET groups. “The more users that use Ringo, the better Ringo's predictions,” he wrote, “so tell a friend.” Soon enough, Ringo was spreading by word-of-mouth in early email newsletters and other Usenet groups.&lt;/p&gt;
    &lt;p&gt;It worked—but it wasn’t always right. “In the first couple weeks of Ringo’s life, Ringo was relatively incompetent,” Shardanand recalled, and yet that, somehow, didn’t dampen people’s enthusiasm for the email bot they quickly came to love.&lt;/p&gt;
    &lt;p&gt;Example Ringo artist suggestions&lt;/p&gt;
    &lt;p&gt;“People would see the suggestions, and say things like ‘That one’s about right, that’s right, well that one I’d probably rate lower, but wow, it’s working,’” he recalled. “I watched them score artists, then I saw the poor suggestions, and was thinking, ‘You’ve got to be kidding.’ It’s as if they expected it [to] work, and therefore it did.”&lt;/p&gt;
    &lt;p&gt;Even when it came back with no recommendations, people were impressed. “It said there weren't enough participants out there like me,” Pat Anders recalled months after Ringo’s launch. “I was flattered.”&lt;/p&gt;
    &lt;p&gt;Others, though, found magic in the recommendations. “RINGO always came up with a great selection,” said Joe Morris. “I got turned on to a bunch of stuff I would of never found otherwise.” As did Cory Doctorow, with a music library still years later influenced by Ringo’s recommendations.&lt;/p&gt;
    &lt;p&gt;For it wasn’t simple recommendations over email. It was trust in a system that seemed greater than the sum of its parts. “A fellow Media Labber commented that possibly it is because people see Ringo’s suggestions as a ‘reflection of themselves,’” said Shardanand. “Once you have decided that there must be a logical connection between what you have told the system about your tastes and the system’s recommendations, then you are much more inclined to believe the predictions to be right.”&lt;/p&gt;
    &lt;p&gt;“I am largely of the opinion that great AI consists of aggregated human decisions, not machine generated decisions,” said Cory Doctorow, reminiscing about Ringo’s music recommendations.&lt;/p&gt;
    &lt;p&gt;For in every take on email-powered social filtering, the secret ingredient wasn’t the interface, nor was it the algorithm. It was in the crowdsourced data, and the system’s ability to match you with others of similar taste.&lt;/p&gt;
    &lt;p&gt;Some folks defied classification, felt that AI recommendations would devalue their unique tastes. Others embraced the crowdsourced models, found comfort in peeking in an AI-filtered mirror.&lt;/p&gt;
    &lt;p&gt;An early web form to sign up for Ringo&lt;/p&gt;
    &lt;p&gt;The services themselves faded with time. SIFT grew into a commercial project that sold ads for early newsletters, while the Stanford Library Project itself later provided the primary funding for Larry Page and Sergey Brin as they developed the ideas behind PageRank that turned into Google search (itself another way to harness the wisdom of the crowds).&lt;/p&gt;
    &lt;p&gt;Ringo later launched on the web first as HOMR (Helpful Online Music Service) then as Firefly (a community website for collaborative filtering that, fun fact, pitched RSS-competitor ICE to Microsoft), and won second place in MIT’s 1995 student business competition. The magic faded as it left email behind, though, and when Microsoft acquired it for $40 million in 1998, the only thing the software giant kept was their email-based login that, over time, morphed into Microsoft Passport.&lt;/p&gt;
    &lt;p&gt;31 years after those early crowdsourced email tools provided people’s first interactions with AI, today’s GPTs are eerily reminiscent of both those early app’s crowdsourced wisdom, and of our credulity to seemingly intelligent agents that mirror our preferences. The social filtering lives on, in ever less personal ways, in Google’s PageRank, Facebook’s feed algorithm, Netflix’s suggestions, and Spotify’s Daily Mix playlists.&lt;/p&gt;
    &lt;p&gt;And, in a roundabout way, email newsletters’ staying power may be due to the same selection bias and sorting powers that inspired social filtering-powered software. If you read something you like, there’s a fair chance you’ll continue to like the other things that person writes. Newsletters are the easiest way to select into that author’s filter bubble and find new things you like from their recommendations.&lt;/p&gt;
    &lt;p&gt;“As the information barrage continues to accelerate, agents will be as indispensable as E-mail,” predicted Ringo’s Shardanand in a foreshadowing of today’s AI and MCP servers and agents. People, it turned out though, were what was indispensable to email and recommendations you’d love.&lt;/p&gt;
    &lt;p&gt;Image Credits: Header image by Samuel Regan-Asante via Unsplash.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=45465392</guid><pubDate>Fri, 03 Oct 2025 17:27:02 +0000</pubDate></item><item><title>ICE Wants to Build Out a 24/7 Social Media Surveillance Team</title><link>https://www.wired.com/story/ice-social-media-surveillance-24-7-contract/</link><description>&lt;doc fingerprint="f5bc5ade2ba8abd9"&gt;
  &lt;main&gt;
    &lt;p&gt;United States immigration authorities are moving to dramatically expand their social media surveillance, with plans to hire nearly 30 contractors to sift through posts, photos, and messages—raw material to be transformed into intelligence for deportation raids and arrests.&lt;/p&gt;
    &lt;p&gt;Federal contracting records reviewed by WIRED show that the agency is seeking private vendors to run a multiyear surveillance program out of two of its little-known targeting centers. The program envisions stationing nearly 30 private analysts at Immigration and Customs Enforcement facilities in Vermont and Southern California. Their job: Scour Facebook, TikTok, Instagram, YouTube, and other platforms, converting posts and profiles into fresh leads for enforcement raids.&lt;/p&gt;
    &lt;p&gt;The initiative is still at the request-for-information stage, a step agencies use to gauge interest from contractors before an official bidding process. But draft planning documents show the scheme is ambitious: ICE wants a contractor capable of staffing the centers around the clock, constantly processing cases on tight deadlines, and supplying the agency with the latest and greatest subscription-based surveillance software.&lt;/p&gt;
    &lt;p&gt;The facilities at the heart of this plan are two of ICE’s three targeting centers, responsible for producing leads that feed directly into the agency’s enforcement operations. The National Criminal Analysis and Targeting Center sits in Williston, Vermont. It handles cases across much of the eastern US. The Pacific Enforcement Response Center, based in Santa Ana, California, oversees the western region and is designed to run 24 hours a day, seven days a week.&lt;/p&gt;
    &lt;p&gt;Internal planning documents show that each site would be staffed with a mix of senior analysts, shift leads, and rank-and-file researchers. Vermont would see a team of a dozen contractors, including a program manager and 10 analysts. California would host a larger, nonstop watch floor with 16 staff. At all times, at least one senior analyst and three researchers would be on duty at the Santa Ana site.&lt;/p&gt;
    &lt;p&gt;Together, these teams would operate as intelligence arms of ICE’s Enforcement and Removal Operations division. They will receive tips and incoming cases, research individuals online, and package the results into dossiers that could be used by field offices to plan arrests.&lt;/p&gt;
    &lt;p&gt;The scope of information contractors are expected to collect is broad. Draft instructions specify open-source intelligence: public posts, photos, and messages on platforms from Facebook to Reddit to TikTok. Analysts may also be tasked with checking more obscure or foreign-based sites, such as Russia’s VKontakte.&lt;/p&gt;
    &lt;p&gt;They would also be armed with powerful commercial databases such as LexisNexis Accurint and Thomson Reuters CLEAR, which knit together property records, phone bills, utilities, vehicle registrations, and other personal details into searchable files.&lt;/p&gt;
    &lt;table&gt;
      &lt;row&gt;
        &lt;cell role="head"&gt;Got a Tip?&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;cell&gt;Are you a current or former government employee or contractor who wants to talk about immigration enforcement? We'd like to hear from you. Using a nonwork phone or computer, contact the reporter securely on Signal at dell.3030.&lt;/cell&gt;
      &lt;/row&gt;
    &lt;/table&gt;
    &lt;p&gt;The plan calls for strict turnaround times. Urgent cases, such as suspected national security threats or people on ICE’s Top Ten Most Wanted list, must be researched within 30 minutes. High-priority cases get one hour; lower-priority leads must be completed within the workday. ICE expects at least three-quarters of all cases to meet those deadlines, with top contractors hitting closer to 95 percent.&lt;/p&gt;
    &lt;p&gt;The plan goes beyond staffing. ICE also wants algorithms, asking contractors to spell out how they might weave artificial intelligence into the hunt—a solicitation that mirrors other recent proposals. The agency has also set aside more than a million dollars a year to arm analysts with the latest surveillance tools.&lt;/p&gt;
    &lt;p&gt;ICE did not immediately respond to a request for comment.&lt;/p&gt;
    &lt;p&gt;Earlier this year, The Intercept revealed that ICE had floated plans for a system that could automatically scan social media for “negative sentiment” toward the agency and flag users thought to show a “proclivity for violence.” Procurement records previously reviewed by 404 Media identified software used by the agency to build dossiers on flagged individuals, compiling personal details, family links, and even using facial recognition to connect images across the web. Observers warned it was unclear how such technology could distinguish genuine threats from political speech.&lt;/p&gt;
    &lt;p&gt;ICE’s main investigative database, built by Palantir Technologies, already uses algorithmic analysis to filter huge populations and generate leads. The new contract would funnel fresh social media and open-source inputs directly into that system, further automating the process.&lt;/p&gt;
    &lt;p&gt;Planning documents say some restrictions are necessary to head off abuse. Contractors are barred from creating fake profiles, interacting with people online, or storing personal data on their own networks. All analysis must remain on ICE servers. Past experience, however, shows such guardrails can be flimsy, honored more in paperwork than in practice. Other documents obtained by 404 Media this summer revealed that police in Medford, Oregon, performed license plate reader searches for ICE’s Homeland Security Investigations division, while HSI agents later ran searches in federal databases at the request of local police—an informal back-and=forth that effectively gave ICE access to tools it wasn’t authorized to use.&lt;/p&gt;
    &lt;p&gt;Other surveillance contracts have raised similar alarms. In September 2024, ICE signed a $2 million contract with Paragon, an Israeli spyware company whose flagship product, Graphite, can allegedly remotely hack messaging apps like WhatsApp and Signal. The Biden White House quickly froze the deal under an executive order restricting spyware use, but ICE reactivated it in August 2025 under the Trump administration. Last month, 404 Media filed a freedom of information lawsuit demanding ICE release the contract and related records, citing widespread concern that the tool could be used to target immigrants, journalists, and activists.&lt;/p&gt;
    &lt;p&gt;The Electronic Privacy Information Center has similarly sued ICE, calling its reliance on data brokers a “significant threat to privacy and liberty.” The American Civil Liberties Union has argued that buying bulk datasets—such as smartphone location trails gathered from ordinary apps—helps ICE sidestep warrant requirements and helps it pull in vast amounts of data with no clear link to its enforcement mandate.&lt;/p&gt;
    &lt;p&gt;The newly proposed social media program is only the latest in a string of surveillance contracts ICE has pursued over the past few years.&lt;/p&gt;
    &lt;p&gt;In 2020 and 2021, ICE bought access to ShadowDragon’s SocialNet, a tool that aggregates data from more than 200 social networks and services into searchable maps of a person’s connections. Around the same time, the agency contracted with Babel Street for Locate X, which supplies location histories from ordinary smartphone apps, letting investigators reconstruct people’s movements without a warrant. ICE also adopted LexisNexis Accurint, used by agents to look up addresses, vehicles, and associates, though the scale of spending on that service is unclear. In September, ICE signed a multimillion-dollar contract with Clearview AI, a facial recognition company that built its database by scraping billions of images from social media and the public web.&lt;/p&gt;
    &lt;p&gt;Throughout, ICE has leaned on Palantir’s Investigative Case Management system to combine disparate streams of data into a single investigative platform. Recent contract updates show the system lets agents search people using hundreds of categories, from immigration status and country of origin to scars, tattoos, and license-plate reader data. Each surveillance contract ICE signs adds another layer—location trails, social networks, financial records, biometric identifiers—feeding into Palantir’s hub. ICE’s new initiative is about scaling up the human side of the equation, stationing analysts around the clock to convert the firehose of data into raid-ready leads.&lt;/p&gt;
    &lt;p&gt;ICE argues it needs these tools to modernize enforcement. Its planning documents note that “previous approaches … which have not incorporated open web sources and social media information, have had limited success.” The agency suggests that tapping social media and open web data helps identify aliases, track movements, and detect patterns that traditional methods often miss.&lt;/p&gt;
    &lt;p&gt;With plenty of historical analogs to choose from, privacy advocates warn that any surveillance that starts as a method of capturing immigrants could soon be deployed for ulterior purposes. ICE’s proposal to track “negative sentiment” is a clear example of how the agency’s threat monitoring bleeds into the policing of dissent. By drawing in the online activity of not only its targets but also friends, family, and community members, ICE is certain to collect far more information outside its mandate than it is likely to publicly concede.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=45465964</guid><pubDate>Fri, 03 Oct 2025 18:13:16 +0000</pubDate></item><item><title>PEP 810 – Explicit lazy imports</title><link>https://pep-previews--4622.org.readthedocs.build/pep-0810/</link><description>&lt;doc fingerprint="d0220610caa1e4dc"&gt;
  &lt;main&gt;
    &lt;head rend="h1"&gt;PEP 810 – Explicit lazy imports&lt;/head&gt;
    &lt;list rend="dl"&gt;
      &lt;item rend="dt-1"&gt;Author:&lt;/item&gt;
      &lt;item rend="dd-1"&gt;Pablo Galindo &amp;lt;pablogsal at python.org&amp;gt;, Germán Méndez Bravo &amp;lt;german.mb at gmail.com&amp;gt;, Thomas Wouters &amp;lt;thomas at python.org&amp;gt;, Dino Viehland &amp;lt;dinoviehland at gmail.com&amp;gt;, Brittany Reynoso &amp;lt;brittanyrey at gmail.com&amp;gt;, Noah Kim &amp;lt;noahbkim at gmail.com&amp;gt;, Tim Stumbaugh &amp;lt;me at tjstum.com&amp;gt;&lt;/item&gt;
      &lt;item rend="dt-2"&gt;Discussions-To:&lt;/item&gt;
      &lt;item rend="dd-2"&gt;Discourse thread&lt;/item&gt;
      &lt;item rend="dt-3"&gt;Status:&lt;/item&gt;
      &lt;item rend="dd-3"&gt;Draft&lt;/item&gt;
      &lt;item rend="dt-4"&gt;Type:&lt;/item&gt;
      &lt;item rend="dd-4"&gt;Standards Track&lt;/item&gt;
      &lt;item rend="dt-5"&gt;Created:&lt;/item&gt;
      &lt;item rend="dd-5"&gt;02-Oct-2025&lt;/item&gt;
      &lt;item rend="dt-6"&gt;Python-Version:&lt;/item&gt;
      &lt;item rend="dd-6"&gt;3.15&lt;/item&gt;
      &lt;item rend="dt-7"&gt;Post-History:&lt;/item&gt;
      &lt;item rend="dd-7"&gt;03-Oct-2025&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h2"&gt;Abstract&lt;/head&gt;
    &lt;p&gt;This PEP introduces syntax for lazy imports as an explicit language feature. Lazy imports defer the loading and execution of a module until the first time the imported name is used, in contrast to ‘normal’ imports, which eagerly load and execute a module at the point of the import statement.&lt;/p&gt;
    &lt;p&gt;By allowing developers to mark individual imports as lazy with explicit syntax, Python programs can reduce startup time, memory usage, and unnecessary work. This is particularly beneficial for command-line tools, test suites, and applications with large dependency graphs.&lt;/p&gt;
    &lt;p&gt;This proposal preserves full backwards compatibility: normal import statements remain unchanged, and lazy imports are enabled only where explicitly requested.&lt;/p&gt;
    &lt;head rend="h2"&gt;Motivation&lt;/head&gt;
    &lt;p&gt;The dominant convention in Python code is to place all imports at the module level, typically at the beginning of the file. This avoids repetition, makes dependencies clear and minimizes runtime overhead by only evaluating an import statement once per module.&lt;/p&gt;
    &lt;p&gt;A major drawback with this approach is that importing the first module for an execution of Python (the “main” module) often triggers an immediate cascade of imports, and optimistically loads many dependencies that may never be used. The effect is especially costly for command-line tools with multiple subcommands, where even running the command with &lt;code&gt;--help&lt;/code&gt; can load dozens of unnecessary modules and
take several seconds. This basic example demonstrates what must be loaded just to get helpful feedback to the user on how to run the program at
all. Inefficiently, the user incurs this overhead again when they figure out the command
they want and invoke the program “for real.”&lt;/p&gt;
    &lt;p&gt;A somewhat common way to delay imports is to move the imports into functions (inline imports), but this practice requires more work to implement and maintain, and can be subverted by a single inadvertent top-level import. Additionally, it obfuscates the full set of dependencies for a module. Analysis of the Python standard library shows that approximately 17% of all imports outside tests (nearly 3500 total imports across 730 files) are already placed inside functions or methods specifically to defer their execution. This demonstrates that developers are already manually implementing lazy imports in performance-sensitive code, but doing so requires scattering imports throughout the codebase and makes the full dependency graph harder to understand at a glance.&lt;/p&gt;
    &lt;p&gt;The standard library provides the &lt;code&gt;LazyLoader&lt;/code&gt; class to solve some of these inefficiency
problems. It permits imports at the module level to work mostly like inline
imports do. Many scientific Python libraries have adopted a similar pattern, formalized
in SPEC 1. There’s also the
third-party lazy_loader package.
Imports used solely for static type checking are another source of potentially unneeded
imports, and there are similarly disparate approaches to minimizing the overhead.
The various approaches used here to defer or remove eager imports do not cover
all potential use-cases for a general lazy import mechanism. There is no clear standard,
and there are several drawbacks including runtime overhead in unexpected places,
or worse runtime introspection.&lt;/p&gt;
    &lt;p&gt;This proposal introduces syntax for lazy imports with a design that is local, explicit, controlled, and granular. Each of these qualities is essential to making the feature predictable and safe to use in practice.&lt;/p&gt;
    &lt;p&gt;The behavior is local: laziness applies only to the specific import marked with the &lt;code&gt;lazy&lt;/code&gt; keyword, and it does not cascade recursively into other
imports. This ensures that developers can reason about the effect of laziness
by looking only at the line of code in front of them, without worrying about
whether imported modules will themselves behave differently. A &lt;code&gt;lazy import&lt;/code&gt;
is an isolated decision each time it is used, not a global shift in semantics.&lt;/p&gt;
    &lt;p&gt;The semantics are explicit. When a name is imported lazily, the binding is created in the importing module immediately, but the target module is not loaded until the first time the name is accessed. After this point, the binding is indistinguishable from one created by a normal import. This clarity reduces surprises and makes the feature accessible to developers who may not be deeply familiar with Python’s import machinery.&lt;/p&gt;
    &lt;p&gt;Lazy imports are controlled, in the sense that deferred loading is only triggered by the importing code itself. In the general case, a library will only experience lazy imports if its own authors choose to mark them as such. This avoids shifting responsibility onto downstream users and prevents accidental surprises in library behavior. Since library authors typically manage their own import subgraphs, they retain predictable control over when and how laziness is applied.&lt;/p&gt;
    &lt;p&gt;The mechanism is also granular. It is introduced through explicit syntax on individual imports, rather than a global flag or implicit setting. This allows developers to adopt it incrementally, starting with the most performance-sensitive areas of a codebase. As this feature is introduced to the community, we want to make the experience of onboarding optional, progressive, and adaptable to the needs of each project.&lt;/p&gt;
    &lt;p&gt;In addition to the new lazy import syntax, we also propose a way to control lazy imports at the application level: globally disabling or enabling lazy imports, and selectively disabling. This global lazy imports flag is provided for debugging, testing, and experimentation, and is not expected to be the common way to control lazy imports.&lt;/p&gt;
    &lt;p&gt;The design of lazy imports provides several concrete advantages:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Command-line tools are often invoked directly by a user, so latency — in particular startup latency — is quite noticeable. These programs are also typically short-lived processes (contrasted with, e.g., a web server). Most conventions would have a CLI with multiple subcommands import every dependency up front, even if the user only requests &lt;code&gt;tool --help&lt;/code&gt;(or&lt;code&gt;tool subcommand --help&lt;/code&gt;). With lazy imports, only the code paths actually reached will import a module. This can reduce startup time by 50–70% in practice, providing a visceral improvement to a common user experience and improving Python’s competitiveness in domains where fast startup matters most.&lt;/item&gt;
      &lt;item&gt;Type annotations frequently require imports that are never used at runtime. The common workaround is to wrap them in &lt;code&gt;if TYPE_CHECKING:&lt;/code&gt;blocks [1]. With lazy imports, annotation-only imports impose no runtime penalty, eliminating the need for such guards and making annotated codebases cleaner.&lt;/item&gt;
      &lt;item&gt;Large applications often import thousands of modules, and each module creates function and type objects, incurring memory costs. In long-lived processes, this noticeably raises baseline memory usage. Lazy imports defer these costs until a module is needed, keeping unused subsystems unloaded. Memory savings of 30–40% have been observed in real workloads.&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h2"&gt;Rationale&lt;/head&gt;
    &lt;p&gt;The design of this proposal is centered on clarity, predictability, and ease of adoption. Each decision was made to ensure that lazy imports provide tangible benefits without introducing unnecessary complexity into the language or its runtime.&lt;/p&gt;
    &lt;p&gt;It is also worth noting that while this PEP outlines one specific approach, we list alternate implementation strategies for some of the core aspects and semantics of the proposal. If the community expresses a strong preference for a different technical path that still preserves the same core semantics or there is fundamental disagreement over the specific option, we have included the brainstorming we have already completed in preparation for this proposal as reference.&lt;/p&gt;
    &lt;p&gt;The choice to introduce a new &lt;code&gt;lazy&lt;/code&gt; keyword reflects the need for explicit
syntax. Import behavior is too fundamental to be left implicit or hidden behind
global flags or environment variables. By marking laziness directly at the
import site, the intent is immediately visible to both readers and tools. This
avoids surprises, reduces the cognitive burden of reasoning about imports, and
keeps lazy import semantics in line with Python’s tradition of explicitness.&lt;/p&gt;
    &lt;p&gt;Another important decision is to represent lazy imports with proxy objects in the module’s namespace, rather than by modifying dictionary lookup. Earlier approaches experimented with embedding laziness into dictionaries, but this blurred abstractions and risked affecting unrelated parts of the runtime. The dictionary is a fundamental data structure in Python—literally every object is built on top of dicts—and adding hooks to dictionaries would prevent critical optimizations and complicate the entire runtime. The proxy approach is simpler: it behaves like a placeholder until first use, at which point it resolves the import and rebinds the name. From then on, the binding is indistinguishable from a normal import. This makes the mechanism easy to explain and keeps the rest of the interpreter unchanged.&lt;/p&gt;
    &lt;p&gt;Compatibility for library authors was also a key concern. Many maintainers need a migration path that allows them to support both new and old versions of Python at once. For this reason, the proposal includes the &lt;code&gt;__lazy_modules__&lt;/code&gt;
global as a transitional mechanism. A module can declare which imports should
be treated as lazy (by listing the module names as strings), and on Python 3.15
or later those imports will become lazy automatically, as if they were imported
with the &lt;code&gt;lazy&lt;/code&gt; keyword. On earlier versions the
declaration is ignored, leaving imports eager. This gives authors a practical
bridge until they can rely on the keyword as the canonical syntax.&lt;/p&gt;
    &lt;p&gt;Finally, the feature is designed to be adopted incrementally. Nothing changes unless a developer explicitly opts in, and adoption can begin with just a few imports in performance-sensitive areas. This mirrors the experience of gradual typing in Python: a mechanism that can be introduced progressively, without forcing projects to commit globally from day one. Notably, the adoption can also be done from the “outside in”, permitting CLI authors to introduce lazy imports and speed up user-facing tools, without requiring changes to every library the tool might use.&lt;/p&gt;
    &lt;p&gt;By combining explicit syntax, a simple runtime model, a compatibility layer, and gradual adoption, this proposal balances performance improvements with the clarity and stability that Python users expect.&lt;/p&gt;
    &lt;head rend="h3"&gt;Other design decisions&lt;/head&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;The scope of laziness is deliberately local and non-recursive. A lazy import only affects the specific statement where it appears; it does not cascade into other modules or submodules. This choice is crucial for predictability. When developers read code, they can reason about import behavior line by line, without worrying about hidden laziness deeper in the dependency graph. The result is a feature that is powerful but still easy to understand in context.&lt;/item&gt;
      &lt;item&gt;In addition, it is useful to provide a mechanism to activate or deactivate lazy imports at a global level. While the primary design centers on explicit syntax, there are scenarios—such as large applications, testing environments, or frameworks—where enabling laziness consistently across many modules provides the most benefit. A global switch makes it easy to experiment with or enforce consistent behavior, while still working in combination with the filtering API to respect exclusions or tool-specific configuration. This ensures that global adoption can be practical without reducing flexibility or control.&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h2"&gt;Specification&lt;/head&gt;
    &lt;head rend="h3"&gt;Grammar&lt;/head&gt;
    &lt;p&gt;A new soft keyword &lt;code&gt;lazy&lt;/code&gt; is added. A soft keyword is a context-sensitive keyword
that only has special meaning in specific grammatical contexts; elsewhere it can be
used as a regular identifier (e.g., as a variable name). The &lt;code&gt;lazy&lt;/code&gt; keyword only
has special meaning when it appears before import statements:&lt;/p&gt;
    &lt;code&gt;import_name:
    | 'lazy'? 'import' dotted_as_names

import_from:
    | 'lazy'? 'from' ('.' | '...')* dotted_name 'import' import_from_targets
    | 'lazy'? 'from' ('.' | '...')+ 'import' import_from_targets
&lt;/code&gt;
    &lt;head rend="h4"&gt;Syntax restrictions&lt;/head&gt;
    &lt;p&gt;The soft keyword is only allowed at the global (module) level, not inside functions, class bodies, with &lt;code&gt;try&lt;/code&gt;/&lt;code&gt;with&lt;/code&gt; blocks, or &lt;code&gt;import *&lt;/code&gt;. Import
statements that use the soft keyword are potentially lazy. Imports that
can’t be lazy are unaffected by the global lazy imports flag, and instead
are always eager.&lt;/p&gt;
    &lt;p&gt;Examples of syntax errors:&lt;/p&gt;
    &lt;code&gt;# SyntaxError: lazy import not allowed inside functions
def foo():
    lazy import json

# SyntaxError: lazy import not allowed inside classes
class Bar:
    lazy import json

# SyntaxError: lazy import not allowed inside try/except blocks
try:
    lazy import json
except ImportError:
    pass

# SyntaxError: lazy import not allowed inside with blocks
with suppress(ImportError):
    lazy import json

# SyntaxError: lazy from ... import * is not allowed
lazy from json import *
&lt;/code&gt;
    &lt;head rend="h3"&gt;Semantics&lt;/head&gt;
    &lt;p&gt;When the &lt;code&gt;lazy&lt;/code&gt; keyword is used, the import becomes potentially lazy.
Unless lazy imports are disabled or suppressed (see below), the module is
not loaded immediately at the import statement; instead, a lazy proxy object
is created and bound to the name. The actual module is loaded on first use
of that name.&lt;/p&gt;
    &lt;p&gt;Example:&lt;/p&gt;
    &lt;code&gt;import sys

lazy import json

print('json' in sys.modules)  # False - module not loaded yet

# First use triggers loading
result = json.dumps({"hello": "world"})

print('json' in sys.modules)  # True - now loaded
&lt;/code&gt;
    &lt;p&gt;A module may contain a &lt;code&gt;__lazy_modules__&lt;/code&gt; attribute, which is a sequence of
fully qualified module names (strings) to make potentially lazy (as if the
&lt;code&gt;lazy&lt;/code&gt; keyword was used). This attribute is checked on each &lt;code&gt;import&lt;/code&gt;
statement to determine whether the import should be made potentially lazy.
When a module is made lazy this way, from-imports using that module are also
lazy, but not necessarily imports of sub-modules.&lt;/p&gt;
    &lt;p&gt;The normal (non-lazy) import statement will check the global lazy imports flag. If it is “enabled”, all imports are potentially lazy (except for imports that can’t be lazy, as mentioned above.)&lt;/p&gt;
    &lt;p&gt;Example:&lt;/p&gt;
    &lt;code&gt;__lazy_modules__ = ["json"]
import json
print('json' in sys.modules)  # False
result = json.dumps({"hello": "world"})
print('json' in sys.modules)  # True
&lt;/code&gt;
    &lt;p&gt;If the global lazy imports flag is set to “disabled”, no potentially lazy import is ever imported lazily, and the behavior is equivalent to a regular import statement: the import is eager (as if the lazy keyword was not used).&lt;/p&gt;
    &lt;p&gt;For a potentially lazy import, the lazy imports filter (if set) is called with the name of the module doing the import, the name of the module being imported, and (if applicable) the fromlist. If the lazy import filter returns &lt;code&gt;True&lt;/code&gt;, the potentially lazy import becomes a lazy import. Otherwise, the
import is not lazy, and the normal (eager) import continues.&lt;/p&gt;
    &lt;head rend="h3"&gt;Lazy import mechanism&lt;/head&gt;
    &lt;p&gt;When an import is lazy, &lt;code&gt;__lazy_import__&lt;/code&gt; is called instead of
&lt;code&gt;__import__&lt;/code&gt;. &lt;code&gt;__lazy_import__&lt;/code&gt; has the same function signature as
&lt;code&gt;__import__&lt;/code&gt;. It adds the module name to &lt;code&gt;sys.lazy_modules&lt;/code&gt;, a set of
fully-qualified module names which have been lazily imported at some point (primarily for
diagnostics and introspection), and returns a “lazy module object.”&lt;/p&gt;
    &lt;p&gt;The implementation of &lt;code&gt;from ... import&lt;/code&gt; (the &lt;code&gt;IMPORT_FROM&lt;/code&gt; bytecode
implementation) checks if the module it’s fetching from is a lazy module
object, and if so, returns a lazy object for each name instead.&lt;/p&gt;
    &lt;p&gt;The end result of this process is that lazy imports (regardless of how they are enabled) result in lazy objects being assigned to global variables.&lt;/p&gt;
    &lt;p&gt;Lazy module objects do not appear in &lt;code&gt;sys.modules&lt;/code&gt;, they’re just listed in
the &lt;code&gt;sys.lazy_modules&lt;/code&gt; set. Under normal operation lazy objects should
only end up stored in global variables, and the common ways to access those
variables (regular variable access, module attributes) will resolve lazy
imports (“reify”) and replace them when they’re accessed.&lt;/p&gt;
    &lt;p&gt;It is still possible to expose lazy objects through other means, like debuggers. This is not considered a problem.&lt;/p&gt;
    &lt;head rend="h3"&gt;Reification&lt;/head&gt;
    &lt;p&gt;When a lazy object is first used, it needs to be reified. This means resolving the import at that point in the program and replacing the lazy object with the concrete one. Reification imports the module in the same way as it would have been if it had been imported eagerly, barring intervening changes to the import system (e.g. to &lt;code&gt;sys.path&lt;/code&gt;, &lt;code&gt;sys.meta_path&lt;/code&gt;,
&lt;code&gt;sys.path_hooks&lt;/code&gt; or &lt;code&gt;__import__&lt;/code&gt;).&lt;/p&gt;
    &lt;p&gt;Reification still calls &lt;code&gt;__import__&lt;/code&gt; to resolve the import. When the
module is first reified, it’s removed from &lt;code&gt;sys.lazy_modules&lt;/code&gt; (even if
there are still other unreified lazy references to it). When a package is
reified and submodules in the package were also previously lazily imported,
those submodules are not automatically reified but they are added to the
reified package’s globals (unless the package already assigned something
else to the name of the submodule).&lt;/p&gt;
    &lt;p&gt;If reification fails (e.g., due to an &lt;code&gt;ImportError&lt;/code&gt;), the exception is enhanced
with chaining to show both where the lazy import was defined and where it was first
accessed (even though it propagates from the code that triggered reification).
This provides clear debugging information:&lt;/p&gt;
    &lt;code&gt;# app.py - has a typo in the import
lazy from json import dumsp  # Typo: should be 'dumps'

print("App started successfully")
print("Processing data...")

# Error occurs here on first use
result = dumsp({"key": "value"})
&lt;/code&gt;
    &lt;p&gt;The traceback shows both locations:&lt;/p&gt;
    &lt;code&gt;App started successfully
Processing data...
Traceback (most recent call last):
  File "app.py", line 2, in &amp;lt;module&amp;gt;
    lazy from json import dumsp
ImportError: deferred import of 'json.dumsp' raised an exception during resolution

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "app.py", line 8, in &amp;lt;module&amp;gt;
    result = dumsp({"key": "value"})
             ^^^^^
ImportError: cannot import name 'dumsp' from 'json'. Did you mean: 'dump'?
&lt;/code&gt;
    &lt;p&gt;This exception chaining clearly shows: (1) where the lazy import was defined, (2) that it was deferred, and (3) where the actual access happened that triggered the error.&lt;/p&gt;
    &lt;p&gt;Reification does not automatically occur when a module that was previously lazily imported is subsequently eagerly imported. Reification does not immediately resolve all lazy objects (e.g. &lt;code&gt;lazy from&lt;/code&gt; statements) that referenced the module.
It only resolves the lazy object being accessed.&lt;/p&gt;
    &lt;p&gt;Accessing a lazy object (from a global variable or a module attribute) reifies the object. Accessing a module’s &lt;code&gt;__dict__&lt;/code&gt; reifies all lazy objects
in that module. Operations that indirectly access &lt;code&gt;__dict__&lt;/code&gt; (such as :func`dir`)
also trigger this behavior.&lt;/p&gt;
    &lt;p&gt;Example using &lt;code&gt;__dict__&lt;/code&gt; from external code:&lt;/p&gt;
    &lt;code&gt;# my_module.py
import sys
lazy import json

print('json' in sys.modules)  # False - still lazy

# main.py
import sys
import my_module

# Accessing __dict__ from external code DOES reify all lazy imports
d = my_module.__dict__

print('json' in sys.modules)  # True - reified by __dict__ access
print(type(d['json']))  # &amp;lt;class 'module'&amp;gt;
&lt;/code&gt;
    &lt;p&gt;However, calling &lt;code&gt;globals()&lt;/code&gt; does not trigger reification — it returns
the module’s dictionary, and accessing lazy objects through that dictionary
still returns lazy proxy objects that need to be manually reified upon use.
A lazy object can be resolved explicitly by calling the &lt;code&gt;get&lt;/code&gt; method.
Other, more indirect ways of accessing arbitrary globals (e.g. inspecting
&lt;code&gt;frame.f_globals&lt;/code&gt;) also do not reify all the objects.&lt;/p&gt;
    &lt;p&gt;Example using &lt;code&gt;globals()&lt;/code&gt;:&lt;/p&gt;
    &lt;code&gt;import sys
lazy import json

# Calling globals() does NOT trigger reification
g = globals()

print('json' in sys.modules)  # False - still lazy
print(type(g['json']))  # &amp;lt;class 'lazy_import'&amp;gt;

# Explicitly reify using the get() method
resolved = g['json'].get()

print(type(resolved))  # &amp;lt;class 'module'&amp;gt;
print('json' in sys.modules)  # True - now loaded
&lt;/code&gt;
    &lt;head rend="h2"&gt;Implementation&lt;/head&gt;
    &lt;head rend="h3"&gt;Bytecode and adaptive specialization&lt;/head&gt;
    &lt;p&gt;Lazy imports are implemented through modifications to four bytecode instructions: &lt;code&gt;IMPORT_NAME&lt;/code&gt;, &lt;code&gt;IMPORT_FROM&lt;/code&gt;, &lt;code&gt;LOAD_GLOBAL&lt;/code&gt;, and &lt;code&gt;LOAD_NAME&lt;/code&gt;.&lt;/p&gt;
    &lt;p&gt;The &lt;code&gt;lazy&lt;/code&gt; syntax sets a flag in the &lt;code&gt;IMPORT_NAME&lt;/code&gt; instruction’s oparg
(&lt;code&gt;oparg &amp;amp; 0x01&lt;/code&gt;). The interpreter checks this flag and calls
&lt;code&gt;_PyEval_LazyImportName()&lt;/code&gt; instead of &lt;code&gt;_PyEval_ImportName()&lt;/code&gt;, creating a lazy
import object rather than executing the import immediately. The &lt;code&gt;IMPORT_FROM&lt;/code&gt;
instruction checks whether its source is a lazy import (&lt;code&gt;PyLazyImport_CheckExact()&lt;/code&gt;)
and creates a lazy object for the attribute rather than accessing it immediately.&lt;/p&gt;
    &lt;p&gt;When a lazy object is accessed, it must be reified. The &lt;code&gt;LOAD_GLOBAL&lt;/code&gt; instruction
(used in function scopes) and &lt;code&gt;LOAD_NAME&lt;/code&gt; instruction (used at module and class level) both
check whether the object being loaded is a lazy import. If so, they call
&lt;code&gt;_PyImport_LoadLazyImportTstate()&lt;/code&gt; to perform the actual import and store the
module in &lt;code&gt;sys.modules&lt;/code&gt;.&lt;/p&gt;
    &lt;p&gt;This check incurs a very small cost on each access. However, Python’s adaptive interpreter can specialize &lt;code&gt;LOAD_GLOBAL&lt;/code&gt; after observing that a lazy import has been reified.
After several executions, &lt;code&gt;LOAD_GLOBAL&lt;/code&gt; becomes &lt;code&gt;LOAD_GLOBAL_MODULE&lt;/code&gt;, which
accesses the module dictionary directly without checking for lazy imports.&lt;/p&gt;
    &lt;p&gt;Examples of the bytecode generated:&lt;/p&gt;
    &lt;code&gt;lazy import json  # IMPORT_NAME with flag set
&lt;/code&gt;
    &lt;p&gt;Generates:&lt;/p&gt;
    &lt;code&gt;IMPORT_NAME              1 (json + lazy)
&lt;/code&gt;
    &lt;code&gt;lazy from json import dumps  # IMPORT_NAME + IMPORT_FROM
&lt;/code&gt;
    &lt;p&gt;Generates:&lt;/p&gt;
    &lt;code&gt;IMPORT_NAME              1 (json + lazy)
IMPORT_FROM              1 (dumps)
&lt;/code&gt;
    &lt;code&gt;lazy import json
x = json  # Module-level access
&lt;/code&gt;
    &lt;p&gt;Generates:&lt;/p&gt;
    &lt;code&gt;LOAD_NAME                0 (json)
&lt;/code&gt;
    &lt;code&gt;lazy import json

def use_json():
    return json.dumps({})  # Function scope
&lt;/code&gt;
    &lt;p&gt;Before any calls:&lt;/p&gt;
    &lt;code&gt;LOAD_GLOBAL              0 (json)
LOAD_ATTR                2 (dumps)
&lt;/code&gt;
    &lt;p&gt;After several calls, &lt;code&gt;LOAD_GLOBAL&lt;/code&gt; specializes to &lt;code&gt;LOAD_GLOBAL_MODULE&lt;/code&gt;:&lt;/p&gt;
    &lt;code&gt;LOAD_GLOBAL_MODULE       0 (json)
LOAD_ATTR_MODULE         2 (dumps)
&lt;/code&gt;
    &lt;head rend="h3"&gt;Lazy imports filter&lt;/head&gt;
    &lt;p&gt;This PEP adds two new functions to the &lt;code&gt;sys&lt;/code&gt; module to manage the lazy imports filter:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;sys.set_lazy_imports_filter(func)&lt;/code&gt;- Sets the filter function. The&lt;code&gt;func&lt;/code&gt;parameter must have the signature:&lt;code&gt;func(importer: str, name: str, fromlist: tuple[str, ...] | None) -&amp;gt; bool&lt;/code&gt;&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;sys.get_lazy_imports_filter()&lt;/code&gt;- Returns the currently installed filter function, or&lt;code&gt;None&lt;/code&gt;if no filter is set.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The filter function is called for every potentially lazy import, and must return &lt;code&gt;True&lt;/code&gt; if the import should be lazy. This allows for fine-grained
control over which imports should be lazy, useful for excluding modules with
known side-effect dependencies or registration patterns.&lt;/p&gt;
    &lt;p&gt;The filter mechanism serves as a foundation that tools, debuggers, linters, and other ecosystem utilities can leverage to provide better lazy import experiences. For example, static analysis tools could detect modules with side effects and automatically configure appropriate filters. In the future (out of scope for this PEP), this foundation may enable better ways to declaratively specify which modules are safe for lazy importing, such as package metadata, type stubs with lazy-safety annotations, or configuration files. The current filter API is designed to be flexible enough to accommodate such future enhancements without requiring changes to the core language specification.&lt;/p&gt;
    &lt;p&gt;Example:&lt;/p&gt;
    &lt;code&gt;import sys

def exclude_side_effect_modules(importer, name, fromlist):
    """
    Filter function to exclude modules with import-time side effects.

    Args:
        importer: Name of the module doing the import
        name: Name of the module being imported
        fromlist: Tuple of names being imported (for 'from' imports), or None

    Returns:
        True to allow lazy import, False to force eager import
    """
    # Modules known to have important import-time side effects
    side_effect_modules = {'legacy_plugin_system', 'metrics_collector'}

    if name in side_effect_modules:
        return False  # Force eager import

    return True  # Allow lazy import

# Install the filter
sys.set_lazy_imports_filter(exclude_side_effect_modules)

# These imports are checked by the filter
lazy import data_processor        # Filter returns True -&amp;gt; stays lazy
lazy import legacy_plugin_system  # Filter returns False -&amp;gt; imported eagerly

print('data_processor' in sys.modules)       # False - still lazy
print('legacy_plugin_system' in sys.modules) # True - loaded eagerly

# First use of data_processor triggers loading
result = data_processor.transform(data)
print('data_processor' in sys.modules)       # True - now loaded
&lt;/code&gt;
    &lt;head rend="h3"&gt;Global lazy imports control&lt;/head&gt;
    &lt;p&gt;The global lazy imports flag can be controlled through:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;The &lt;code&gt;-X lazy_imports=&amp;lt;mode&amp;gt;&lt;/code&gt;command-line option&lt;/item&gt;
      &lt;item&gt;The &lt;code&gt;PYTHON_LAZY_IMPORTS=&amp;lt;mode&amp;gt;&lt;/code&gt;environment variable&lt;/item&gt;
      &lt;item&gt;The &lt;code&gt;sys.set_lazy_imports(mode)&lt;/code&gt;function (primarily for testing)&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Where &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; can be:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;"default"&lt;/code&gt;(or unset): Only explicitly marked lazy imports are lazy&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;"enabled"&lt;/code&gt;: All module-level imports (except in&lt;code&gt;try&lt;/code&gt;or&lt;code&gt;with&lt;/code&gt;blocks and&lt;code&gt;import *&lt;/code&gt;) become potentially lazy&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;"disabled"&lt;/code&gt;: No imports are lazy, even those explicitly marked with&lt;code&gt;lazy&lt;/code&gt;keyword&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;When the global flag is set to &lt;code&gt;"enabled"&lt;/code&gt;, all imports at the global level of
all modules are potentially lazy except for those inside a &lt;code&gt;try&lt;/code&gt; or
&lt;code&gt;with&lt;/code&gt; block or any wild card (&lt;code&gt;from ... import *&lt;/code&gt;) import.&lt;/p&gt;
    &lt;p&gt;If the global lazy imports flag is set to &lt;code&gt;"disabled"&lt;/code&gt;, no potentially lazy
import is ever imported lazily, the import filter is never called, and the
behavior is equivalent to a regular &lt;code&gt;import&lt;/code&gt; statement:
the import is eager (as if the lazy keyword was not used).&lt;/p&gt;
    &lt;head rend="h2"&gt;Backwards Compatibility&lt;/head&gt;
    &lt;p&gt;Lazy imports are opt-in. Existing programs continue to run unchanged unless a project explicitly enables laziness (via &lt;code&gt;lazy&lt;/code&gt; syntax, &lt;code&gt;__lazy_modules__&lt;/code&gt;,
or an interpreter-wide switch).&lt;/p&gt;
    &lt;head rend="h3"&gt;Unchanged semantics&lt;/head&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Regular &lt;code&gt;import&lt;/code&gt;and&lt;code&gt;from ... import ...&lt;/code&gt;statements remain eager unless explicitly made potentially lazy by the local or global mechanisms provided.&lt;/item&gt;
      &lt;item&gt;Dynamic import APIs remain eager and unchanged: &lt;code&gt;__import__()&lt;/code&gt;and&lt;code&gt;importlib.import_module()&lt;/code&gt;.&lt;/item&gt;
      &lt;item&gt;Import hooks and loaders continue to run under the standard import protocol when a lazy object is reified.&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h3"&gt;Observable behavioral shifts (opt-in only)&lt;/head&gt;
    &lt;p&gt;These changes are limited to bindings explicitly made lazy:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Error timing. Exceptions that would have occurred during an eager import (for example &lt;code&gt;ImportError&lt;/code&gt;or&lt;code&gt;AttributeError&lt;/code&gt;for a missing member) now occur at the first use of the lazy name.&lt;quote&gt;# With eager import - error at import statement import broken_module # ImportError raised here # With lazy import - error deferred lazy import broken_module print("Import succeeded") broken_module.foo() # ImportError raised here on first use&lt;/quote&gt;&lt;/item&gt;
      &lt;item&gt;Side-effect timing. Import-time side effects in lazily imported modules occur at first use of the binding, not at module import time.&lt;/item&gt;
      &lt;item&gt;Import order. Because modules are imported on first use, the order in which modules are imported may differ from how they appear in code.&lt;/item&gt;
      &lt;item&gt;Presence in ``sys.modules``. A lazily imported module does not appear in &lt;code&gt;sys.modules&lt;/code&gt;until first use. After reification, it must appear in&lt;code&gt;sys.modules&lt;/code&gt;. If some other code eagerly imports the same module before first use, the lazy binding resolves to that existing (lazy) module object when it is first used.&lt;/item&gt;
      &lt;item&gt;Proxy visibility. Before first use, the bound name refers to a lazy proxy. Indirect introspection that touches the value may observe a proxy lazy object representation. After first use, the name is rebound to the real object and becomes indistinguishable from an eager import.&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h3"&gt;Thread-safety and reification&lt;/head&gt;
    &lt;p&gt;First use of a lazy binding follows the existing import-lock discipline. Exactly one thread performs the import and atomically rebinds the importing module’s global to the resolved object. Concurrent readers thereafter observe the real object.&lt;/p&gt;
    &lt;p&gt;Lazy imports are thread-safe and have no special considerations for free-threading. A module that would normally be imported in the main thread may be imported in a different thread if that thread triggers the first access to the lazy import. This is not a problem: the import lock ensures thread safety regardless of which thread performs the import.&lt;/p&gt;
    &lt;p&gt;Subinterpreters are supported. Each subinterpreter maintains its own &lt;code&gt;sys.lazy_modules&lt;/code&gt; and import state, so lazy imports in one subinterpreter do
not affect others.&lt;/p&gt;
    &lt;head rend="h3"&gt;Typing and tools&lt;/head&gt;
    &lt;p&gt;Type checkers and static analyzers may treat &lt;code&gt;lazy&lt;/code&gt; imports as ordinary
imports for name resolution. At runtime, annotation-only imports can be marked
&lt;code&gt;lazy&lt;/code&gt; to avoid startup overhead. IDEs and debuggers should be prepared to
display lazy proxies before first use and the real objects thereafter.&lt;/p&gt;
    &lt;head rend="h2"&gt;Security Implications&lt;/head&gt;
    &lt;p&gt;There are no known security vulnerabilities introduced by lazy imports.&lt;/p&gt;
    &lt;head rend="h2"&gt;How to Teach This&lt;/head&gt;
    &lt;p&gt;The new &lt;code&gt;lazy&lt;/code&gt; keyword will be documented as part of the language standard.&lt;/p&gt;
    &lt;p&gt;As this feature is opt-in, new Python users should be able to continue using the language as they are used to. For experienced developers, we expect them to leverage lazy imports for the variety of benefits listed above (decreased latency, decreased memory usage, etc) on a case-by-case basis. Developers interested in the performance of their Python binary will likely leverage profiling to understand the import time overhead in their codebase and mark the necessary imports as &lt;code&gt;lazy&lt;/code&gt;. In addition,
developers can mark imports that will only be used for type annotations as &lt;code&gt;lazy&lt;/code&gt;.&lt;/p&gt;
    &lt;p&gt;Below is guidance on how to best take advantage of lazy imports and how to avoid incompatibilities:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;When adopting lazy imports, users should be aware that eliding an import until it is used will result in side effects not being executed. In turn, users should be wary of modules that rely on import time side effects. Perhaps the most common reliance on import side effects is the registry pattern, where population of some external registry happens implicitly during the importing of modules, often via decorators but sometimes implemented via metaclasses or &lt;code&gt;__init_subclass__&lt;/code&gt;. Instead, registries of objects should be constructed via explicit discovery processes (e.g. a well-known function to call).&lt;quote&gt;# Problematic: Plugin registers itself on import # my_plugin.py from plugin_registry import register_plugin @register_plugin("MyPlugin") class MyPlugin: pass # In main code: lazy import my_plugin # Plugin NOT registered yet - module not loaded! # Better: Explicit discovery # plugin_registry.py def discover_plugins(): from my_plugin import MyPlugin register_plugin(MyPlugin) # In main code: plugin_registry.discover_plugins() # Explicit loading&lt;/quote&gt;&lt;/item&gt;
      &lt;item&gt;Always import needed submodules explicitly. It is not enough to rely on a different import to ensure a module has its submodules as attributes. Plainly, unless there is an explicit &lt;code&gt;from . import bar&lt;/code&gt;in&lt;code&gt;foo/__init__.py&lt;/code&gt;, always use&lt;code&gt;import foo.bar; foo.bar.Baz&lt;/code&gt;, not&lt;code&gt;import foo; foo.bar.Baz&lt;/code&gt;. The latter only works (unreliably) because the attribute&lt;code&gt;foo.bar&lt;/code&gt;is added as a side effect of&lt;code&gt;foo.bar&lt;/code&gt;being imported somewhere else.&lt;/item&gt;
      &lt;item&gt;Users who are moving imports into functions to improve startup time, should instead consider keeping them where they are but adding the &lt;code&gt;lazy&lt;/code&gt;keyword. This allows them to keep dependencies clear and avoid the overhead of repeatedly re-resolving the import but will still speed up the program.&lt;quote&gt;# Before: Inline import (repeated overhead) def process_data(data): import json # Re-resolved on every call return json.dumps(data) # After: Lazy import at module level lazy import json def process_data(data): return json.dumps(data) # Loaded once on first call&lt;/quote&gt;&lt;/item&gt;
      &lt;item&gt;Avoid using wild card (star) imports, as those are always eager.&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h2"&gt;FAQ&lt;/head&gt;
    &lt;p&gt;Q: How does this differ from the rejected PEP 690?&lt;/p&gt;
    &lt;p&gt;A: PEP 810 takes an explicit, opt-in approach instead of PEP 690’s implicit global approach. The key differences are:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Explicit syntax: &lt;code&gt;lazy import foo&lt;/code&gt;clearly marks which imports are lazy&lt;/item&gt;
      &lt;item&gt;Local scope: Laziness only affects the specific import statement, not cascading to dependencies&lt;/item&gt;
      &lt;item&gt;Simpler implementation: Uses proxy objects instead of modifying core dictionary behavior&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Q: What happens when lazy imports encounter errors?&lt;/p&gt;
    &lt;p&gt;A: Import errors (&lt;code&gt;ImportError&lt;/code&gt;, &lt;code&gt;ModuleNotFoundError&lt;/code&gt;, syntax errors) are
deferred until first use of the lazy name. This is similar to moving an import
into a function. The error will occur with a clear traceback pointing to the
first access of the lazy object.&lt;/p&gt;
    &lt;p&gt;The implementation provides enhanced error reporting through exception chaining. When a lazy import fails during reification, the original exception is preserved and chained, showing both where the import was defined and where it was first used:&lt;/p&gt;
    &lt;code&gt;Traceback (most recent call last):
  File "test.py", line 1, in &amp;lt;module&amp;gt;
    lazy import broken_module
ImportError: deferred import of 'broken_module' raised an exception during resolution

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "test.py", line 3, in &amp;lt;module&amp;gt;
    broken_module.foo()
    ^^^^^^^^^^^^^
  File "broken_module.py", line 2, in &amp;lt;module&amp;gt;
    1/0
ZeroDivisionError: division by zero
&lt;/code&gt;
    &lt;p&gt;Q: How do lazy imports affect modules with import-time side effects?&lt;/p&gt;
    &lt;p&gt;A: Side effects are deferred until first use. This is generally desirable for performance, but may require code changes for modules that rely on import-time registration patterns. We recommend:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Use explicit initialization functions instead of import-time side effects&lt;/item&gt;
      &lt;item&gt;Call initialization functions explicitly when needed&lt;/item&gt;
      &lt;item&gt;Avoid relying on import order for side effects&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Q: Can I use lazy imports with &lt;code&gt;from ... import ...&lt;/code&gt; statements?&lt;/p&gt;
    &lt;p&gt;A: Yes, as long as you don’t use &lt;code&gt;from ... import *&lt;/code&gt;. Both &lt;code&gt;lazy import foo&lt;/code&gt;
and &lt;code&gt;lazy from foo import bar&lt;/code&gt; are supported. The &lt;code&gt;bar&lt;/code&gt; name will be bound
to a lazy object that resolves to &lt;code&gt;foo.bar&lt;/code&gt; on first use.&lt;/p&gt;
    &lt;p&gt;Q: Does &lt;code&gt;lazy from module import Class&lt;/code&gt; load the entire module or just the class?&lt;/p&gt;
    &lt;p&gt;A: It loads the entire module, not just the class. This is because Python’s import system always executes the complete module file—there’s no mechanism to execute only part of a &lt;code&gt;.py&lt;/code&gt; file. When you first access &lt;code&gt;Class&lt;/code&gt;, Python:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Loads and executes the entire &lt;code&gt;module.py&lt;/code&gt;file&lt;/item&gt;
      &lt;item&gt;Extracts the &lt;code&gt;Class&lt;/code&gt;attribute from the resulting module object&lt;/item&gt;
      &lt;item&gt;Binds &lt;code&gt;Class&lt;/code&gt;to the name in your namespace&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;This is identical to eager &lt;code&gt;from module import Class&lt;/code&gt; behavior. The only difference
with lazy imports is that steps 1-3 happen on first use instead of at the import
statement.&lt;/p&gt;
    &lt;code&gt;# heavy_module.py
print("Loading heavy_module")  # This ALWAYS runs when module loads

class MyClass:
    pass

class UnusedClass:
    pass  # Also gets defined, even though we don't import it

# app.py
lazy from heavy_module import MyClass

print("Import statement done")  # heavy_module not loaded yet
obj = MyClass()                  # NOW "Loading heavy_module" prints
                                 # (and UnusedClass gets defined too)
&lt;/code&gt;
    &lt;p&gt;Key point: Lazy imports defer when a module loads, not what gets loaded. You cannot selectively load only parts of a module—Python’s import system doesn’t support partial module execution.&lt;/p&gt;
    &lt;p&gt;Q: What about type annotations and &lt;code&gt;TYPE_CHECKING&lt;/code&gt; imports?&lt;/p&gt;
    &lt;p&gt;A: Lazy imports eliminate the common need for &lt;code&gt;TYPE_CHECKING&lt;/code&gt; guards. You can write:&lt;/p&gt;
    &lt;code&gt;lazy from collections.abc import Sequence, Mapping  # No runtime cost

def process(items: Sequence[str]) -&amp;gt; Mapping[str, int]:
    ...
&lt;/code&gt;
    &lt;p&gt;Instead of:&lt;/p&gt;
    &lt;code&gt;from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from collections.abc import Sequence, Mapping

def process(items: Sequence[str]) -&amp;gt; Mapping[str, int]:
    ...
&lt;/code&gt;
    &lt;p&gt;Q: What’s the performance overhead of lazy imports?&lt;/p&gt;
    &lt;p&gt;A: The overhead is minimal:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Zero overhead after first use thanks to the adaptive interpreter optimizing the slow path away.&lt;/item&gt;
      &lt;item&gt;Small one-time cost to create the proxy object.&lt;/item&gt;
      &lt;item&gt;Reification (first use) has the same cost as a regular import.&lt;/item&gt;
      &lt;item&gt;No ongoing performance penalty unlike &lt;code&gt;importlib.util.LazyLoader&lt;/code&gt;.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Benchmarking with the pyperformance suite shows the implementation is performance neutral when lazy imports are not used.&lt;/p&gt;
    &lt;p&gt;Q: Can I mix lazy and eager imports of the same module?&lt;/p&gt;
    &lt;p&gt;A: Yes. If module &lt;code&gt;foo&lt;/code&gt; is imported both lazily and eagerly in the same
program, the eager import takes precedence and both bindings resolve to the same
module object.&lt;/p&gt;
    &lt;p&gt;Q: How do I migrate existing code to use lazy imports?&lt;/p&gt;
    &lt;p&gt;A: Migration is incremental:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Identify slow-loading modules using profiling tools&lt;/item&gt;
      &lt;item&gt;Add &lt;code&gt;lazy&lt;/code&gt;keyword to imports that aren’t needed immediately&lt;/item&gt;
      &lt;item&gt;Test that side-effect timing changes don’t break functionality&lt;/item&gt;
      &lt;item&gt;Use &lt;code&gt;__lazy_modules__&lt;/code&gt;for compatibility with older Python versions&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Q: What about star imports (&lt;code&gt;from module import *&lt;/code&gt;)?&lt;/p&gt;
    &lt;p&gt;A: Wild card (star) imports cannot be lazy - they remain eager. This is because the set of names being imported cannot be determined without loading the module. Using the &lt;code&gt;lazy&lt;/code&gt; keyword with star imports will be a syntax error. If lazy imports are globally
enabled, star imports will still be eager.&lt;/p&gt;
    &lt;p&gt;Q: How do lazy imports interact with import hooks and custom loaders?&lt;/p&gt;
    &lt;p&gt;A: Import hooks and loaders work normally. When a lazy object is first used, the standard import protocol runs, including any custom hooks or loaders that were in place at reification time.&lt;/p&gt;
    &lt;p&gt;Q: What happens in multi-threaded environments?&lt;/p&gt;
    &lt;p&gt;A: Lazy import reification is thread-safe. Only one thread will perform the actual import, and the binding is atomically updated. Other threads will see either the lazy proxy or the final resolved object.&lt;/p&gt;
    &lt;p&gt;Q: Can I force reification of a lazy import without using it?&lt;/p&gt;
    &lt;p&gt;A: Yes, accessing a module’s &lt;code&gt;__dict__&lt;/code&gt; will reify all lazy objects in that
module. Individual lazy objects can be resolved by calling their &lt;code&gt;get()&lt;/code&gt; method.&lt;/p&gt;
    &lt;p&gt;Q: What’s the difference between &lt;code&gt;globals()&lt;/code&gt; and &lt;code&gt;mod.__dict__&lt;/code&gt; for lazy imports?&lt;/p&gt;
    &lt;p&gt;A: Calling &lt;code&gt;globals()&lt;/code&gt; returns the module’s dictionary without reifying lazy
imports — you’ll see lazy proxy objects when accessing them through the returned
dictionary. However, accessing &lt;code&gt;mod.__dict__&lt;/code&gt; from external code reifies all lazy
imports in that module first. This design ensures:&lt;/p&gt;
    &lt;code&gt;# In your module:
lazy import json

g = globals()
print(type(g['json']))  # &amp;lt;class 'lazy_import'&amp;gt; - your problem

# From external code:
import sys
mod = sys.modules['your_module']
d = mod.__dict__
print(type(d['json']))  # &amp;lt;class 'module'&amp;gt; - reified for external access
&lt;/code&gt;
    &lt;p&gt;This distinction means adding lazy imports and calling &lt;code&gt;globals()&lt;/code&gt; is your
responsibility to manage, while external code accessing &lt;code&gt;mod.__dict__&lt;/code&gt; always
sees fully loaded modules.&lt;/p&gt;
    &lt;p&gt;Q: Why not use &lt;code&gt;importlib.util.LazyLoader&lt;/code&gt; instead?&lt;/p&gt;
    &lt;p&gt;A: &lt;code&gt;LazyLoader&lt;/code&gt; has significant limitations:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Requires verbose setup code for each lazy import&lt;/item&gt;
      &lt;item&gt;Has ongoing performance overhead on every attribute access&lt;/item&gt;
      &lt;item&gt;Doesn’t work well with &lt;code&gt;from ... import&lt;/code&gt;statements&lt;/item&gt;
      &lt;item&gt;Less clear and standard than dedicated syntax&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Q: Will this break tools like &lt;code&gt;isort&lt;/code&gt; or &lt;code&gt;black&lt;/code&gt;?&lt;/p&gt;
    &lt;p&gt;A: Tools will need updates to recognize the &lt;code&gt;lazy&lt;/code&gt; keyword, but the changes
should be minimal since the import structure remains the same. The keyword
appears at the beginning, making it easy to parse.&lt;/p&gt;
    &lt;p&gt;Q: How do I know if a library is compatible with lazy imports?&lt;/p&gt;
    &lt;p&gt;A: Most libraries should work fine with lazy imports. Libraries that might have issues:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Those with essential import-time side effects (registration, monkey-patching)&lt;/item&gt;
      &lt;item&gt;Those that expect specific import ordering&lt;/item&gt;
      &lt;item&gt;Those that modify global state during import&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;When in doubt, test lazy imports with your specific use cases.&lt;/p&gt;
    &lt;p&gt;Q: What happens if I globally enable lazy imports mode and a library doesn’t work correctly?&lt;/p&gt;
    &lt;p&gt;A: Note: This is an advanced feature. You can use the lazy imports filter to exclude specific modules that are known to have problematic side effects:&lt;/p&gt;
    &lt;code&gt;import sys

def my_filter(importer, name, fromlist):
    # Don't lazily import modules known to have side effects
    if name in {'problematic_module', 'another_module'}:
        return False  # Import eagerly
    return True  # Allow lazy import

sys.set_lazy_imports_filter(my_filter)
&lt;/code&gt;
    &lt;p&gt;The filter function receives the importer module name, the module being imported, and the fromlist (if using &lt;code&gt;from ... import&lt;/code&gt;). Returning &lt;code&gt;False&lt;/code&gt; forces an eager import.&lt;/p&gt;
    &lt;p&gt;Alternatively, set the global mode to &lt;code&gt;"disabled"&lt;/code&gt; via &lt;code&gt;-X lazy_imports=disabled&lt;/code&gt;
to turn off all lazy imports for debugging.&lt;/p&gt;
    &lt;p&gt;Q: Can I use lazy imports inside functions?&lt;/p&gt;
    &lt;p&gt;A: No, the &lt;code&gt;lazy&lt;/code&gt; keyword is only allowed at module level. For function-level
lazy loading, use traditional inline imports or move the import to module level
with &lt;code&gt;lazy&lt;/code&gt;.&lt;/p&gt;
    &lt;p&gt;Q: What about forwards compatibility with older Python versions?&lt;/p&gt;
    &lt;p&gt;A: Use the &lt;code&gt;__lazy_modules__&lt;/code&gt; global for compatibility:&lt;/p&gt;
    &lt;code&gt;# Works on Python 3.15+ as lazy, eager on older versions
__lazy_modules__ = ['expensive_module', 'expensive_module_2']
import expensive_module
from expensive_module_2 import MyClass
&lt;/code&gt;
    &lt;p&gt;The &lt;code&gt;__lazy_modules__&lt;/code&gt; attribute is a list of module name strings. When an import
statement is executed, Python checks if the module name being imported appears in
&lt;code&gt;__lazy_modules__&lt;/code&gt;. If it does, the import is treated as if it had the &lt;code&gt;lazy&lt;/code&gt;
keyword (becoming potentially lazy). On Python versions before 3.15 that don’t
support lazy imports, the &lt;code&gt;__lazy_modules__&lt;/code&gt; attribute is simply ignored and
imports proceed eagerly as normal.&lt;/p&gt;
    &lt;p&gt;This provides a migration path until you can rely on the &lt;code&gt;lazy&lt;/code&gt; keyword. For
maximum predictability, it’s recommended to define &lt;code&gt;__lazy_modules__&lt;/code&gt; once,
before any imports. But as it is checked on each import, it can be modified between
&lt;code&gt;import&lt;/code&gt; statements.&lt;/p&gt;
    &lt;p&gt;Q: How do explicit lazy imports interact with PEP-649/PEP-749&lt;/p&gt;
    &lt;p&gt;A: If an annotation is not stringified, it is an expression that is evaluated at a later time. It will only be resolved if the annotation is accessed. In the example below, the &lt;code&gt;fake_typing&lt;/code&gt; module is only loaded
when the user inspects the &lt;code&gt;__annotations__&lt;/code&gt; dictionary. The
&lt;code&gt;fake_typing&lt;/code&gt; module would also be loaded if the user uses
&lt;code&gt;annotationlib.get_annotations()&lt;/code&gt; or &lt;code&gt;getattr&lt;/code&gt; to access the annotations.&lt;/p&gt;
    &lt;code&gt;lazy from fake_typing import MyFakeType
def foo(x: MyFakeType):
  pass
print(foo.__annotations__)  # Triggers loading the fake_typing module
&lt;/code&gt;
    &lt;p&gt;Q: How do lazy imports interact with &lt;code&gt;dir()&lt;/code&gt;, &lt;code&gt;getattr()&lt;/code&gt;, and module introspection?&lt;/p&gt;
    &lt;p&gt;A: Accessing lazy imports through normal attribute access or &lt;code&gt;getattr()&lt;/code&gt; will trigger
reification. Calling &lt;code&gt;dir()&lt;/code&gt; on a module will reify all lazy imports in that module
to ensure the directory listing is complete. This is similar to accessing &lt;code&gt;mod.__dict__&lt;/code&gt;.&lt;/p&gt;
    &lt;code&gt;lazy import json

# Before any access
# json not in sys.modules

# Any of these trigger reification:
dumps_func = json.dumps
dumps_func = getattr(json, 'dumps')
dir(json)
# Now json is in sys.modules
&lt;/code&gt;
    &lt;p&gt;Q: Do lazy imports work with circular imports?&lt;/p&gt;
    &lt;p&gt;A: Lazy imports don’t automatically solve circular import problems. If two modules have a circular dependency, making the imports lazy might help only if the circular reference isn’t accessed during module initialization. However, if either module accesses the other during import time, you’ll still get an error.&lt;/p&gt;
    &lt;p&gt;Example that works (deferred access in functions):&lt;/p&gt;
    &lt;code&gt;# user_model.py
lazy import post_model

class User:
    def get_posts(self):
        # OK - post_model accessed inside function, not during import
        return post_model.Post.get_by_user(self.name)

# post_model.py
lazy import user_model

class Post:
    @staticmethod
    def get_by_user(username):
        return f"Posts by {username}"
&lt;/code&gt;
    &lt;p&gt;This works because neither module accesses the other at module level—the access happens later when &lt;code&gt;get_posts()&lt;/code&gt; is called.&lt;/p&gt;
    &lt;p&gt;Example that fails (access during import):&lt;/p&gt;
    &lt;code&gt;# module_a.py
lazy import module_b

result = module_b.get_value()  # Error! Accessing during import

def func():
    return "A"

# module_b.py
lazy import module_a

result = module_a.func()  # Circular dependency error here

def get_value():
    return "B"
&lt;/code&gt;
    &lt;p&gt;This fails because &lt;code&gt;module_a&lt;/code&gt; tries to access &lt;code&gt;module_b&lt;/code&gt; at import time, which
then tries to access &lt;code&gt;module_a&lt;/code&gt; before it’s fully initialized.&lt;/p&gt;
    &lt;p&gt;The best practice is still to avoid circular imports in your code design.&lt;/p&gt;
    &lt;p&gt;Q: Will lazy imports affect the performance of my hot paths?&lt;/p&gt;
    &lt;p&gt;A: After first use, lazy imports have zero overhead thanks to the adaptive interpreter. The interpreter specializes the bytecode (e.g., &lt;code&gt;LOAD_GLOBAL&lt;/code&gt; becomes &lt;code&gt;LOAD_GLOBAL_MODULE&lt;/code&gt;)
which eliminates the lazy check on subsequent accesses. This means once a lazy import
is reified, accessing it is just as fast as a normal import.&lt;/p&gt;
    &lt;code&gt;lazy import json

def use_json():
    return json.dumps({"test": 1})

# First call triggers reification
use_json()

# After 2-3 calls, bytecode is specialized
use_json()
use_json()
&lt;/code&gt;
    &lt;p&gt;You can observe the specialization using &lt;code&gt;dis.dis(use_json, adaptive=True)&lt;/code&gt;:&lt;/p&gt;
    &lt;code&gt;=== Before specialization ===
LOAD_GLOBAL              0 (json)
LOAD_ATTR                2 (dumps)

=== After 3 calls (specialized) ===
LOAD_GLOBAL_MODULE       0 (json)
LOAD_ATTR_MODULE         2 (dumps)
&lt;/code&gt;
    &lt;p&gt;The specialized &lt;code&gt;LOAD_GLOBAL_MODULE&lt;/code&gt; and &lt;code&gt;LOAD_ATTR_MODULE&lt;/code&gt; instructions are
optimized fast paths with no overhead for checking lazy imports.&lt;/p&gt;
    &lt;p&gt;Q: What about &lt;code&gt;sys.modules&lt;/code&gt;? When does a lazy import appear there?&lt;/p&gt;
    &lt;p&gt;A: A lazily imported module does not appear in &lt;code&gt;sys.modules&lt;/code&gt; until it’s reified
(first used). Once reified, it appears in &lt;code&gt;sys.modules&lt;/code&gt; just like any eager import.&lt;/p&gt;
    &lt;code&gt;import sys
lazy import json

print('json' in sys.modules)  # False

result = json.dumps({"key": "value"})  # First use

print('json' in sys.modules)  # True
&lt;/code&gt;
    &lt;head rend="h2"&gt;Reference Implementation&lt;/head&gt;
    &lt;p&gt;A reference implementation is available at: https://github.com/LazyImportsCabal/cpython/tree/lazy&lt;/p&gt;
    &lt;head rend="h2"&gt;Alternate Implementation Ideas&lt;/head&gt;
    &lt;p&gt;Here are some alternative design decisions that were considered during the development of this PEP. While the current proposal represents what we believe to be the best balance of simplicity, performance, and maintainability, these alternatives offer different trade-offs that may be valuable for implementers to consider or for future refinements.&lt;/p&gt;
    &lt;head rend="h3"&gt;Leveraging a Subclass of Dict&lt;/head&gt;
    &lt;p&gt;Instead of updating the internal dict object to directly add the fields needed to support lazy imports, we could create a subclass of the dict object to be used specifically for Lazy Import enablement. This would still be a leaky abstraction though - methods can be called directly such as &lt;code&gt;dict.__getitem__&lt;/code&gt;
and it would impact the performance of globals lookup in the interpreter.&lt;/p&gt;
    &lt;head rend="h3"&gt;Alternate Keyword Names&lt;/head&gt;
    &lt;p&gt;For this PEP, we decided to propose &lt;code&gt;lazy&lt;/code&gt; for the explicit keyword as it felt the most familar to those
already focused on optimizing import overhead. We also considered a variety of other
options to support explicit lazy imports. The most compelling alternates were &lt;code&gt;defer&lt;/code&gt; and &lt;code&gt;delay&lt;/code&gt;.&lt;/p&gt;
    &lt;head rend="h2"&gt;Rejected Ideas&lt;/head&gt;
    &lt;head rend="h3"&gt;Modification of the Dict Object&lt;/head&gt;
    &lt;p&gt;The initial PEP for lazy imports (PEP 690) relied heavily on the modification of the internal dict object to support lazy imports. We recognize that this data structure is highly tuned, heavily used across the codebase, and very performance sensitive. Because of the importance of this data structure and the desire to keep the implementation of lazy imports encapsulated from users who may have no interest in the feature, we’ve decided to invest in an alternate approach.&lt;/p&gt;
    &lt;p&gt;The dictionary is the foundational data structure in Python. Every object’s attributes are stored in a dict, and dicts are used throughout the runtime for namespaces, keyword arguments, and more. Adding any kind of hook or special behavior to dicts to support lazy imports would:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Prevent critical interpreter optimizations including future JIT compilation&lt;/item&gt;
      &lt;item&gt;Add complexity to a data structure that must remain simple and fast&lt;/item&gt;
      &lt;item&gt;Affect every part of Python, not just import behavior&lt;/item&gt;
      &lt;item&gt;Violate separation of concerns—the hash table shouldn’t know about the import system&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Past decisions that violated this principle of keeping core abstractions clean have caused significant pain in the CPython ecosystem, making optimization difficult and introducing subtle bugs.&lt;/p&gt;
    &lt;head rend="h3"&gt;Placing the &lt;code&gt;lazy&lt;/code&gt; Keyword in the Middle of From Imports&lt;/head&gt;
    &lt;p&gt;While we found &lt;code&gt;from foo lazy import bar&lt;/code&gt; to be a really intuitive placement for the new explicit syntax,
we quickly learned that placing the &lt;code&gt;lazy&lt;/code&gt; keyword here is already syntactically allowed in Python. This
is because &lt;code&gt;from . lazy import bar&lt;/code&gt; is legal syntax (because whitespace
does not matter.)&lt;/p&gt;
    &lt;head rend="h3"&gt;Placing the &lt;code&gt;lazy&lt;/code&gt; Keyword at the End of Import Statements&lt;/head&gt;
    &lt;p&gt;We discussed appending lazy to the end of import statements like such &lt;code&gt;import foo lazy&lt;/code&gt; or
&lt;code&gt;from foo import bar, baz lazy&lt;/code&gt; but ultimately decided that this approach provided less clarity.
For example, if multiple modules are imported in a single statement, it is unclear if the lazy binding
applies to all of the imported objects or just a subset of the items.&lt;/p&gt;
    &lt;head rend="h3"&gt;Returning a Proxy Dict from &lt;code&gt;globals()&lt;/code&gt;&lt;/head&gt;
    &lt;p&gt;An alternative to reifying on &lt;code&gt;globals()&lt;/code&gt; or exposing lazy objects would be to
return a proxy dictionary that automatically reifies lazy objects when they’re
accessed through the proxy. This would seemingly give the best of both worlds:
&lt;code&gt;globals()&lt;/code&gt; returns immediately without reification cost, but accessing items
through the result would automatically resolve lazy imports.&lt;/p&gt;
    &lt;p&gt;However, this approach is fundamentally incompatible with how &lt;code&gt;globals()&lt;/code&gt; is used
in practice. Many standard library functions and built-ins expect &lt;code&gt;globals()&lt;/code&gt; to
return a real &lt;code&gt;dict&lt;/code&gt; object, not a proxy:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;exec(code, globals())&lt;/code&gt;requires a real dict&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;eval(expr, globals())&lt;/code&gt;requires a real dict&lt;/item&gt;
      &lt;item&gt;Functions that check &lt;code&gt;type(globals()) is dict&lt;/code&gt;would break&lt;/item&gt;
      &lt;item&gt;Dictionary methods like &lt;code&gt;.update()&lt;/code&gt;would need special handling&lt;/item&gt;
      &lt;item&gt;Performance would suffer from the indirection on every access&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The proxy would need to be so transparent that it would be indistinguishable from a real dict in almost all cases, which is extremely difficult to achieve correctly. Any deviation from true dict behavior would be a source of subtle bugs.&lt;/p&gt;
    &lt;head rend="h3"&gt;Reifying lazy imports when &lt;code&gt;globals()&lt;/code&gt; is called&lt;/head&gt;
    &lt;p&gt;Calling &lt;code&gt;globals()&lt;/code&gt; returns the module’s namespace dictionary without triggering
reification of lazy imports. Accessing lazy objects through the returned dictionary
yields the lazy proxy objects themselves. This is an intentional design decision
for several reasons:&lt;/p&gt;
    &lt;p&gt;The key distinction: Adding a lazy import and calling &lt;code&gt;globals()&lt;/code&gt; is the
module author’s concern and under their control. However, accessing &lt;code&gt;mod.__dict__&lt;/code&gt;
from external code is a different scenario — it crosses module boundaries and affects
someone else’s code. Therefore, &lt;code&gt;mod.__dict__&lt;/code&gt; access reifies all lazy imports to
ensure external code sees fully realized modules, while &lt;code&gt;globals()&lt;/code&gt; preserves lazy
objects for the module’s own introspection needs.&lt;/p&gt;
    &lt;p&gt;Technical challenges: It is impossible to safely reify on-demand when &lt;code&gt;globals()&lt;/code&gt;
is called because we cannot return a proxy dictionary — this would break common usages
like passing the result to &lt;code&gt;exec()&lt;/code&gt; or other built-ins that expect a real dictionary.
The only alternative would be to eagerly reify all lazy imports whenever &lt;code&gt;globals()&lt;/code&gt;
is called, but this behavior would be surprising and potentially expensive.&lt;/p&gt;
    &lt;p&gt;Performance concerns: It is impractical to cache whether a reification scan has been performed with just the globals dictionary reference, whereas module attribute access (the primary use case) can efficiently cache reification state in the module object itself.&lt;/p&gt;
    &lt;p&gt;Use case rationale: The chosen design makes sense precisely because of this distinction: adding a lazy import and calling &lt;code&gt;globals()&lt;/code&gt; is your problem to manage, while having lazy
imports visible in &lt;code&gt;mod.__dict__&lt;/code&gt; becomes someone else’s problem. By reifying on
&lt;code&gt;__dict__&lt;/code&gt; access but not on &lt;code&gt;globals()&lt;/code&gt;, we ensure external code always sees
fully loaded modules while giving module authors control over their own introspection.&lt;/p&gt;
    &lt;p&gt;Note that three options were considered:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Calling &lt;code&gt;globals()&lt;/code&gt;or&lt;code&gt;mod.__dict__&lt;/code&gt;traverses and resolves all lazy objects before returning&lt;/item&gt;
      &lt;item&gt;Calling &lt;code&gt;globals()&lt;/code&gt;or&lt;code&gt;mod.__dict__&lt;/code&gt;returns the dictionary with lazy objects present&lt;/item&gt;
      &lt;item&gt;Calling &lt;code&gt;globals()&lt;/code&gt;returns the dictionary with lazy objects, but&lt;code&gt;mod.__dict__&lt;/code&gt;reifies everything&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;We chose the third option because it properly delineates responsibility: if you add lazy imports to your module and call &lt;code&gt;globals()&lt;/code&gt;, you’re responsible for handling the lazy objects.
But external code accessing your module’s &lt;code&gt;__dict__&lt;/code&gt; shouldn’t need to know about your
lazy imports—it gets fully resolved modules.&lt;/p&gt;
    &lt;head rend="h2"&gt;Acknowledgements&lt;/head&gt;
    &lt;p&gt;We would like to thank Paul Ganssle, Yury Selivanov, Łukasz Langa, Lysandros Nikolaou, Pradyun Gedam, Mark Shannon, Hana Joo and the Python Google team, the Python team(s) @ Meta, the Python @ HRT team, the Bloomberg Python team, the Scientific Python community, everyone who participated in the initial discussion of PEP 690, and many others who provided valuable feedback and insights that helped shape this PEP.&lt;/p&gt;
    &lt;head rend="h2"&gt;Footnotes&lt;/head&gt;
    &lt;head rend="h2"&gt;Copyright&lt;/head&gt;
    &lt;p&gt;This document is placed in the public domain or under the CC0-1.0-Universal license, whichever is more permissive.&lt;/p&gt;
    &lt;p&gt;Source: https://github.com/python/peps/blob/main/peps/pep-0810.rst&lt;/p&gt;
    &lt;p&gt;Last modified: 2025-10-03 19:42:39 GMT&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=45466086</guid><pubDate>Fri, 03 Oct 2025 18:24:58 +0000</pubDate></item></channel></rss>