<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>Hacker News: Front Page</title><link>https://raw.githubusercontent.com/Prabesh01/hnrss-content-extract/refs/heads/main/out/rss.xml</link><description>Hacker News RSS</description><atom:link href="https://raw.githubusercontent.com/Prabesh01/hnrss-content-extract/refs/heads/main/out/rss.xml" rel="self"/><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><language>en</language><lastBuildDate>Fri, 05 Dec 2025 22:10:15 +0000</lastBuildDate><item><title>Netflix to Acquire Warner Bros</title><link>https://about.netflix.com/en/news/netflix-to-acquire-warner-bros</link><description>&lt;doc fingerprint="7a920551567ba73c"&gt;
  &lt;main&gt;&lt;p&gt;Business&lt;/p&gt;05 December 2025&lt;p&gt;Transaction Unites Warner Bros.’ Iconic Franchises and Storied Libraries with Netflix’s Leading Entertainment Service, Creating an Extraordinary Offering for Consumers&lt;/p&gt;&lt;p&gt;Netflix to Maintain Warner Bros.’ Current Operations&lt;/p&gt;&lt;p&gt;Combination Will Offer More Choice and Greater Value for Consumers, Create More Opportunities for the Creative Community and Generate Shareholder Value&lt;/p&gt;&lt;p&gt;Acquisition Will Strengthen the Entertainment Industry&lt;/p&gt;&lt;p&gt;HOLLYWOOD, Calif., Dec. 5, 2025 -- Today, Netflix, Inc. (the Company) and Warner Bros. Discovery, Inc. (WBD) announced they have entered into a definitive agreement under which Netflix will acquire Warner Bros., including its film and television studios, HBO Max and HBO.&lt;/p&gt;&lt;p&gt;The cash and stock transaction is valued at $27.75 per WBD share (subject to a collar as detailed below), with a total enterprise value of approximately $82.7 billion (equity value of $72.0 billion). The transaction is expected to close after the previously announced separation of WBD’s Global Networks division, Discovery Global, into a new publicly-traded company, which is now expected to be completed in Q3 2026.&lt;/p&gt;&lt;p&gt;This acquisition brings together two pioneering entertainment businesses, combining Netflix’s innovation, global reach and best-in-class streaming service with Warner Bros.’ century-long legacy of world-class storytelling. Beloved franchises, shows and movies such as The Big Bang Theory, The Sopranos, Game of Thrones, The Wizard of Oz and the DC Universe will join Netflix’s extensive portfolio including Wednesday, Money Heist, Bridgerton, Adolescence and Extraction, creating an extraordinary entertainment offering for audiences worldwide.&lt;/p&gt;&lt;p&gt;“Our mission has always been to entertain the world,” said Ted Sarandos, co-CEO of Netflix. “By combining Warner Bros.’ incredible library of shows and movies—from timeless classics like Casablanca and Citizen Kane to modern favorites like Harry Potter and Friends—with our culture-defining titles like Stranger Things, KPop Demon Hunters and Squid Game, we'll be able to do that even better. Together, we can give audiences more of what they love and help define the next century of storytelling.”&lt;/p&gt;&lt;p&gt;“This acquisition will improve our offering and accelerate our business for decades to come,” continued Greg Peters, co-CEO of Netflix. “Warner Bros. has helped define entertainment for more than a century and continues to do so with phenomenal creative executives and production capabilities. With our global reach and proven business model, we can introduce a broader audience to the worlds they create—giving our members more options, attracting more fans to our best-in-class streaming service, strengthening the entire entertainment industry and creating more value for shareholders.”&lt;/p&gt;&lt;p&gt;“Today’s announcement combines two of the greatest storytelling companies in the world to bring to even more people the entertainment they love to watch the most,” said David Zaslav, President and CEO of Warner Bros. Discovery. “For more than a century, Warner Bros. has thrilled audiences, captured the world’s attention, and shaped our culture. By coming together with Netflix, we will ensure people everywhere will continue to enjoy the world’s most resonant stories for generations to come.”&lt;/p&gt;&lt;p&gt;Combination Will Offer More Choice, More Opportunities, More Value&lt;/p&gt;&lt;list rend="ul"&gt;&lt;item&gt;&lt;p&gt;Complementary strengths and assets: Warner Bros.’ studios are world-class, with Warner Bros. recognized as a leading supplier of television titles and filmed entertainment. HBO and HBO Max also provide a compelling, complementary offering for consumers. Netflix expects to maintain Warner Bros.’ current operations and build on its strengths, including theatrical releases for films.&lt;/p&gt;&lt;/item&gt;&lt;item&gt;&lt;p&gt;More choice and greater value for consumers: By adding the deep film and TV libraries and HBO and HBO Max programming, Netflix members will have even more high-quality titles from which to choose. This also allows Netflix to optimize its plans for consumers, enhancing viewing options and expanding access to content.&lt;/p&gt;&lt;/item&gt;&lt;item&gt;&lt;p&gt;A stronger entertainment industry: This acquisition will enhance Netflix’s studio capabilities, allowing the Company to significantly expand U.S. production capacity and continue to grow investment in original content over the long term which will create jobs and strengthen the entertainment industry.&lt;/p&gt;&lt;/item&gt;&lt;item&gt;&lt;p&gt;More opportunities for the creative community: By uniting Netflix’s member experience and global reach with Warner Bros.’ renowned franchises and extensive library, the Company will create greater value for talent—offering more opportunities to work with beloved intellectual property, tell new stories and connect with a wider audience than ever before.&lt;/p&gt;&lt;/item&gt;&lt;item&gt;&lt;p&gt;More value for shareholders: By offering members a wider selection of quality series and films, Netflix expects to attract and retain more members, drive more engagement and generate incremental revenue and operating income. The Company also expects to realize at least $2-3 billion of cost savings per year by the third year and expects the transaction to be accretive to GAAP earnings per share by year two.&lt;/p&gt;&lt;/item&gt;&lt;/list&gt;&lt;p&gt;Transaction Details and Timing&lt;/p&gt;&lt;p&gt;Under the terms of the agreement, each WBD shareholder will receive $23.25 in cash and $4.501 in shares of Netflix common stock for each share of WBD common stock outstanding at the closing of the transaction. The transaction values Warner Bros. Discovery at $27.75 per share, implying a total equity value of approximately $72.0 billion and an enterprise value of approximately $82.7 billion&lt;/p&gt;&lt;p&gt;In June 2025, WBD announced plans to separate its Streaming &amp;amp; Studios and Global Networks divisions into two separate publicly traded companies. This separation is now expected to be completed in Q3 2026, prior to the closing of this transaction. The newly separated publicly traded company holding the Global Networks division, Discovery Global, will include premier entertainment, sports and news television brands around the world including CNN, TNT Sports in the U.S., and Discovery, free-to-air channels across Europe, and digital products such as Discovery+ and Bleacher Report.&lt;/p&gt;&lt;p&gt;The stock component is subject to a collar under which WBD shareholders will receive Netflix stock valued at $4.50 per share, provided the 15-day volume weighted average price (“VWAP”) of Netflix stock price (measured three trading days prior to closing) falls between $97.91 and $119.67. If the VWAP is below $97.91, WBD shareholders will receive 0.0460 Netflix shares for each WBD share. If the VWAP is above $119.67, WBD shareholders will receive 0.0376 Netflix shares for each WBD share.&lt;/p&gt;&lt;p&gt;The transaction was unanimously approved by the Boards of Directors of both Netflix and WBD. In addition to the completion of the separation of Discovery Global (WBD’s Global Networks business), completion of the transaction is subject to required regulatory approvals, approval of WBD shareholders and other customary closing conditions. The transaction is expected to close in 12-18 months.&lt;/p&gt;&lt;p&gt;Moelis &amp;amp; Company LLC is acting as Netflix’s financial advisor and Skadden, Arps, Slate, Meagher &amp;amp; Flom LLP is serving as legal counsel. Wells Fargo is acting as an additional financial advisor and, along with BNP and HSBC, is providing committed debt financing related to the transaction.&lt;/p&gt;&lt;p&gt;Allen &amp;amp; Company, J.P. Morgan and Evercore are serving as financial advisors to Warner Bros. Discovery and Wachtell Lipton, Rosen &amp;amp; Katz and Debevoise &amp;amp; Plimpton LLP are serving as legal counsel.&lt;/p&gt;&lt;p&gt;1 Reflects a 10% symmetrical collar.&lt;/p&gt;&lt;p&gt;Webcast&lt;/p&gt;&lt;p&gt;Netflix will conduct a conference call today at 5:00am PT/8:00am ET to discuss the contents of this release. A link to the live webcast of the conference call will be available at https://ir.netflix.net/.&lt;/p&gt;&lt;p&gt;Contacts&lt;/p&gt;&lt;p&gt;Netflix&lt;/p&gt;&lt;p&gt;Lowell Singer&lt;/p&gt;&lt;p&gt;VP, Investor Relations&lt;/p&gt;&lt;p&gt;(818) 434-2141&lt;/p&gt;&lt;p&gt;Emily Feingold&lt;/p&gt;&lt;p&gt;VP, Communications&lt;/p&gt;&lt;p&gt;(323) 287-0756&lt;/p&gt;&lt;p&gt;Warner Bros. Discovery&lt;/p&gt;&lt;p&gt;Andrew Slabin&lt;/p&gt;&lt;p&gt;Investor Relations&lt;/p&gt;&lt;p&gt;(212) 548-5544&lt;/p&gt;&lt;p&gt;andrew.slabin@wbd.com&lt;/p&gt;&lt;p&gt;Peter Lee&lt;/p&gt;&lt;p&gt;Investor Relations&lt;/p&gt;&lt;p&gt;(212) 548-5907&lt;/p&gt;&lt;p&gt;peter.lee@wbd.com&lt;/p&gt;&lt;p&gt;Robert Gibbs&lt;/p&gt;&lt;p&gt;Press Contact&lt;/p&gt;&lt;p&gt;(347) 268-3017&lt;/p&gt;&lt;p&gt;IMPORTANT INFORMATION AND WHERE TO FIND IT&lt;/p&gt;&lt;p&gt;In connection with the proposed transaction (the “Merger”) between Netflix, Inc. (“Netflix”) and Warner Bros. Discovery, Inc. (“WBD”), Netflix intends to file with the U.S. Securities and Exchange Commission (the “SEC”) a registration statement on Form S-4 (the “Registration Statement”), which will include a prospectus with respect to the shares of Netflix’s common stock to be issued in the Merger and a proxy statement for WBD’s stockholders (the “Proxy Statement/Prospectus”), and WBD intends to file with the SEC the proxy statement. The definitive proxy statement (if and when available) will be mailed to stockholders of WBD. WBD also intends to file a registration statement for a newly formed subsidiary (“Discovery Global”), which is contemplated to own certain assets and businesses of WBD not being acquired by Netflix in connection with the Merger. Each of Netflix and WBD may also file with or furnish to the SEC other relevant documents regarding the Merger. This communication is not a substitute for the Registration Statement, the Proxy Statement/Prospectus or any other document that Netflix or WBD may file with the SEC or mail to WBD’s stockholders in connection with the Merger.&lt;/p&gt;&lt;p&gt;INVESTORS AND SECURITY HOLDERS OF NETFLIX AND WBD ARE URGED TO READ THE REGISTRATION STATEMENT AND THE PROXY STATEMENT/PROSPECTUS INCLUDED WITHIN THE REGISTRATION STATEMENT WHEN THEY BECOME AVAILABLE, AS WELL AS ANY OTHER RELEVANT DOCUMENTS FILED WITH THE SEC IN CONNECTION WITH THE MERGER OR INCORPORATED BY REFERENCE INTO THE REGISTRATION STATEMENT AND THE PROXY STATEMENT/PROSPECTUS (INCLUDING ANY AMENDMENTS OR SUPPLEMENTS THERETO), BECAUSE THEY WILL CONTAIN IMPORTANT INFORMATION REGARDING NETFLIX, WBD, THE MERGER AND RELATED MATTERS.&lt;/p&gt;&lt;p&gt;The documents filed by Netflix with the SEC also may be obtained free of charge at Netflix’s website at https://ir.netflix.net/home/default.aspx. The documents filed by WBD with the SEC also may be obtained free of charge at WBD’s website at https://ir.wbd.com.&lt;/p&gt;&lt;p&gt;PARTICIPANTS IN THE SOLICITATION&lt;/p&gt;&lt;p&gt;Netflix, WBD and certain of their respective directors and executive officers may be deemed to be participants in the solicitation of proxies from the stockholders of WBD in connection with the Merger under the rules of the SEC.&lt;/p&gt;&lt;p&gt;Information about the interests of the directors and executive officers of Netflix and WBD and other persons who may be deemed to be participants in the solicitation of stockholders of WBD in connection with the Merger and a description of their direct and indirect interests, by security holdings or otherwise, will be included in the Proxy Statement/Prospectus, which will be filed with the SEC.&lt;/p&gt;&lt;p&gt;Information about WBD’s directors and executive officers is set forth in WBD’s proxy statement for its 2025 Annual Meeting of Stockholders on Schedule 14A filed with the SEC on April 23, 2025, WBD’s Annual Report on Form 10-K for the year ended December 31, 2024, and any subsequent filings with the SEC. Information about Netflix’s directors and executive officers is set forth in Netflix’s proxy statement for its 2025 Annual Meeting of Stockholders on Schedule 14A filed with the SEC on April 17, 2025, and any subsequent filings with the SEC. Additional information regarding the direct and indirect interests of those persons and other persons who may be deemed participants in the Merger may be obtained by reading the Proxy Statement/Prospectus regarding the Merger when it becomes available. Free copies of these documents may be obtained as described above.&lt;/p&gt;&lt;p&gt;NO OFFER OR SOLICITATION&lt;/p&gt;&lt;p&gt;This communication is for informational purposes only and does not constitute, or form a part of, an offer to sell or the solicitation of an offer to buy any securities or a solicitation of any vote or approval, nor shall there be any sale of securities in any jurisdiction in which such offer, solicitation or sale would be unlawful prior to registration or qualification under the securities laws of any such jurisdiction. No offer of securities shall be made except by means of a prospectus meeting the requirements of Section 10 of the Securities Act of 1933, as amended, and otherwise in accordance with applicable law.&lt;/p&gt;&lt;p&gt;CAUTIONARY NOTE REGARDING FORWARD LOOKING STATEMENTS&lt;/p&gt;&lt;p&gt;This document contains “forward-looking statements” within the meaning of the federal securities laws, including Section 27A of the U.S. Securities Act of 1933, as amended, and Section 21E of the Securities Exchange Act of 1934, as amended. These forward-looking statements are based on Netflix’s and WBD’s current expectations, estimates and projections about the expected date of closing of the Merger and the potential benefits thereof, their respective businesses and industries, management’s beliefs and certain assumptions made by Netflix and WBD, all of which are subject to change. All forward-looking statements by their nature address matters that involve risks and uncertainties, many of which are beyond our control and are not guarantees of future results, such as statements about the consummation of the Merger and the anticipated benefits thereof. These and other forward-looking statements, including the failure to consummate the Merger or to make or take any filing or other action required to consummate the transaction on a timely matter or at all, are not guarantees of future results and are subject to risks, uncertainties and assumptions that could cause actual results to differ materially from those expressed in any forward-looking statements. Accordingly, there are or will be important factors that could cause actual results to differ materially from those indicated in such statements and, therefore, you should not place undue reliance on any such statements and caution must be exercised in relying on forward-looking statements. Important risk factors that may cause such a difference include, but are not limited to: (i) the completion of the Merger on anticipated terms and timing, including obtaining stockholder and regulatory approvals, completing the separation of WBD’s Global Networks business and Streaming and Studios business, anticipated tax treatment, unforeseen liabilities, future capital expenditures, revenues, expenses, earnings, synergies, economic performance, indebtedness, financial condition, losses, future prospects, business and management strategies, expansion and growth of WBD’s and Netflix’s businesses and other conditions to the completion of the Merger; (ii) failure to realize the anticipated benefits of the Merger, including as a result of delay in completing the transaction or integrating the businesses of Netflix and WBD; (iii) Netflix’s and WBD’s ability to implement their business strategies; (iv) consumer viewing trends; (v) potential litigation relating to the Merger that could be instituted against Netflix, WBD or their respective directors; (vi) the risk that disruptions from the Merger will harm Netflix’s or WBD’s business, including current plans and operations; (vii) the ability of Netflix or WBD to retain and hire key personnel; (viii) potential adverse reactions or changes to business relationships resulting from the announcement, pendency or completion of the Merger; (ix) uncertainty as to the long-term value of Netflix’s common stock; (x) legislative, regulatory and economic developments affecting Netflix’s and WBD’s businesses; (xi) general economic and market developments and conditions; (xii) the evolving legal, regulatory and tax regimes under which Netflix and WBD operate; (xiii) potential business uncertainty, including changes to existing business relationships, during the pendency of the Merger that could affect Netflix’s or WBD’s financial performance; (xiv) restrictions during the pendency of the Merger that may impact Netflix’s or WBD’s ability to pursue certain business opportunities or strategic transactions; and (xv) failure to receive the approval of the stockholders of WBD. These risks, as well as other risks associated with the Merger, will be more fully discussed in the Registration Statement and Proxy Statement/Prospectus to be filed with the SEC in connection with the Merger and the registration statement to be filed with the SEC in connection with the separation. While the list of factors presented here is, and the list of factors presented in the Registration Statement and Proxy Statement/Prospectus will be, considered representative, no such list should be considered to be a complete statement of all potential risks and uncertainties. Unlisted factors may present significant additional obstacles to the realization of forward-looking statements. Consequences of material differences in results as compared with those anticipated in the forward-looking statements could include, among other things, business disruption, operational problems, financial loss, legal liability to third parties and similar risks, any of which could have a material adverse effect on Netflix’s or WBD’s consolidated financial condition, results of operations or liquidity. The forward-looking statements included in this communication are made only as of the date hereof. Neither Netflix nor WBD assumes any obligation to publicly provide revisions or updates to any forward-looking statements, whether as a result of new information, future developments or otherwise, should circumstances change, except as otherwise required by securities and other applicable laws.&lt;/p&gt;&lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=46160315</guid><pubDate>Fri, 05 Dec 2025 12:21:19 +0000</pubDate></item><item><title>Making RSS More Fun</title><link>https://matduggan.com/making-rss-more-fun/</link><description>&lt;doc fingerprint="2b4893113586319f"&gt;
  &lt;main&gt;
    &lt;p&gt;I don't like RSS readers. I know, this is blasphemous especially on a website where I'm actively encouraging you to subscribe through RSS. As someone writing stuff, RSS is great for me. I don't have to think about it, the requests are pretty light weight, I don't need to think about your personal data or what client you are using. So as a protocol RSS is great, no notes.&lt;/p&gt;
    &lt;p&gt;However as something I'm going to consume, it's frankly a giant chore. I feel pressured by RSS readers, where there is this endlessly growing backlog of things I haven't read. I rarely want to read all of a websites content from beginning to end, instead I like to jump between them. I also don't really care if the content is chronological, like an old post about something interesting isn't less compelling to me than a newer post.&lt;/p&gt;
    &lt;p&gt;What I want, as a user experience, is something akin to TikTok. The whole appeal of TikTok, for those who haven't wasted hours of their lives on it, is that I get served content based on an algorithm that determines what I might think is useful or fun. However what I would like is to go through content from random small websites. I want to sit somewhere and passively consume random small creators content, then upvote some of that content and the service should show that more often to other users. That's it. No advertising, no collecting tons of user data about me, just a very simple "I have 15 minutes to kill before the next meeting, show me some random stuff."&lt;/p&gt;
    &lt;p&gt;In this case the "algorithm" is pretty simple: if more people like a thing, more people see it. But with Google on its way to replacing search results with LLM generated content, I just wanted to have something that let me play around with the small web the way that I used to.&lt;/p&gt;
    &lt;p&gt;There actually used to be a service like this called StumbleUpon which was more focused on pushing users towards popular sites. It has been taken down, presumably because there was no money in a browser plugin that sent users to other websites whose advertising you didn't control.&lt;/p&gt;
    &lt;head rend="h3"&gt;TL;DR&lt;/head&gt;
    &lt;p&gt;You can go download the Firefox extension now and try this out and skip the rest of this if you want. https://timewasterpro.xyz/ If you hate it or find problems, let me know on Mastodon. https://c.im/@matdevdug&lt;/p&gt;
    &lt;head rend="h3"&gt;Functionality&lt;/head&gt;
    &lt;p&gt;So I wanted to do something pretty basic. You hit a button, get served a new website. If you like the website, upvote it, otherwise downvote it. If you think it has objectionable content then hit report. You have to make an account (because I couldn't think of another way to do it) and then if you submit links and other people like it, you climb a Leaderboard.&lt;/p&gt;
    &lt;p&gt;On the backend I want to (very slowly so I don't cost anyone a bunch of money) crawl a bunch of RSS feeds, stick the pages in a database and then serve them up to users. Then I want to track what sites get upvotes and return those more often to other users so that "high quality" content shows up more often. "High quality" would be defined by the community or just me if I'm the only user.&lt;/p&gt;
    &lt;p&gt;It's pretty basic stuff, most of it copied from tutorials scattered around the Internet. However I really want to drive home to users that this is not a Serious Thing. I'm not a company, this isn't a new social media network, there are no plans to "grow" this concept beyond the original idea unless people smarter than me ping with me ideas. So I found this amazing CSS library: https://sakofchit.github.io/system.css/&lt;/p&gt;
    &lt;p&gt;The Apple's System OS design from the late-80s to the early 90s was one of my personal favorites and I think would send a strong signal to a user that this is not a professional, modern service.&lt;/p&gt;
    &lt;p&gt;Great, the basic layout works. Let's move on!&lt;/p&gt;
    &lt;head rend="h3"&gt;Backend&lt;/head&gt;
    &lt;p&gt;So I ended up doing FastAPI because it's very easy to write. I didn't want to spend a ton of time writing the API because I doubt I nailed the API design on the first round. I use sqlalchemy for the database. The basic API layout is as follows:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;admin - mostly just generating read-only reports of like "how many websites are there"&lt;/item&gt;
      &lt;item&gt;leaderboard - So this is my first attempt at trying to get users involved. Submit a website that other people like? Get points, climb leaderboard.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The source for the RSS feeds came from the (very cool) Kagi small web Github. https://github.com/kagisearch/smallweb. Basically I assume that websites that have submitted their RSS feeds here are cool with me (very rarely) checking for new posts and adding them to my database. If you want the same thing as this does, but as an iFrame, that's the Kagi small web service.&lt;/p&gt;
    &lt;p&gt;The scraping work is straightforward. We make a background worker, they grab 5 feeds every 600 seconds, they check for new content on each feed and then wait until the 600 seconds has elapsed to grab 5 more from the smallweb list of RSS feeds. Since we have a lot of feeds, this ends up look like we're checking for new content less than once a day which is the interval that I want.&lt;/p&gt;
    &lt;p&gt;Then we write it out to a sqlite database and basically track "has this URL been reported", if so, put it into a review queue and then how many times this URL has been liked or disliked. I considered a "real" database but honestly sqlite is getting more and more scalable every day and its impossible to beat the immediate start up and functionality. Plus very easy to back up to encrypted object storage which is super nice for a hobby project where you might wipe the prod database at any moment.&lt;/p&gt;
    &lt;p&gt;In terms of user onboarding I ended up doing the "make an account with an email, I send a link to verify the email". I actually hate this flow and I don't really want to know a users email. I never need to contact you and there's not a lot associated with your account, which makes this especially silly. I have a ton of email addresses and no real "purpose" in having them. I'd switch to Login with Apple, which is great from a security perspective but not everybody has an Apple ID.&lt;/p&gt;
    &lt;p&gt;I also did a passkey version, which worked fine but the OSS passkey handling was pretty rough still and most people seem to be using a commercial service that handled the "do you have the passkey? Great, if not, fall back to email" flow. I don't really want to do a big commercial login service for a hobby application.&lt;/p&gt;
    &lt;p&gt;Auth is a JWT, which actually was a pain and I regret doing it. I don't know why I keep reaching for JWTs, they're a bad user experience and I should stop.&lt;/p&gt;
    &lt;head rend="h3"&gt;Can I just have the source code?&lt;/head&gt;
    &lt;p&gt;I'm more than happy to release the source code once I feel like the product is in a somewhat stable shape. I'm still ripping down and rewriting relatively large chunks of it as I find weird behavior I don't like or just decide to do things a different way.&lt;/p&gt;
    &lt;p&gt;In the end it does seem to do whats on the label. We have over 600,000 individual pages indexed.&lt;/p&gt;
    &lt;head rend="h3"&gt;So how is it to use?&lt;/head&gt;
    &lt;p&gt;Honestly I've been pretty pleased. But there are some problems.&lt;/p&gt;
    &lt;p&gt;First I couldn't find a reliable way of switching the keyboard shortcuts to be Mac/Windows specific. I found some options for querying platform but they didn't seem to work, so I ended up just hardcoding them as Alt which is not great.&lt;/p&gt;
    &lt;p&gt;The other issue is that when you are making an extension, you spend a long time working with these manifests.json. The specific part I really wasn't sure about was:&lt;/p&gt;
    &lt;code&gt;"browser_specific_settings": {
    "gecko": {
      "id": "[email protected]",
      "strict_min_version": "80.0",
      "data_collection_permissions": {
        "required": ["authenticationInfo"]
      }
    }
  }&lt;/code&gt;
    &lt;p&gt;I'm not entirely sure if that's all I'm doing? I think so from reading the docs.&lt;/p&gt;
    &lt;p&gt;Anyway I built this mostly for me. I have no idea if anybody else will enjoy it. But if you are bored I encourage you to give it a try. It should be pretty light weight and straight-forward if you crack open the extension and look at it. I'm not loading any analytics into the extension so basically until people complain about it, I don't really know if its going well or not.&lt;/p&gt;
    &lt;head rend="h3"&gt;Future stuff&lt;/head&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;I need to sort stuff into categories so that you get more stuff in genres you like. I don't 100% know how to do that, maybe there is a way to scan a website to determine the "types" of content that is on there with machine learning? I'm still looking into it.&lt;/item&gt;
      &lt;item&gt;There's a lot of junk in there. I think if we reach a certain number of downvotes I might put it into a special "queue".&lt;/item&gt;
      &lt;item&gt;I want to ensure new users see the "best stuff" early on but there isn't enough data to determine "best vs worst".&lt;/item&gt;
      &lt;item&gt;I wish there were more independent photography and science websites. Also more crafts. That's not really a "future thing", just me putting a hope out into the universe. Non-technical beta testers get overwhelmed by technical content.&lt;/item&gt;
    &lt;/list&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=46160698</guid><pubDate>Fri, 05 Dec 2025 13:00:28 +0000</pubDate></item><item><title>Most technical problems are people problems</title><link>https://blog.joeschrag.com/2023/11/most-technical-problems-are-really.html</link><description>&lt;doc fingerprint="2ed1d053672c65da"&gt;
  &lt;main&gt;
    &lt;p&gt;I once worked at a company which had an enormous amount of technical debt - millions of lines of code, no unit tests, based on frameworks that were well over a decade out of date. On one specific project, we had a market need to get some Windows-only modules running on Linux, and rather than cross-compiling, another team had simply copied &amp;amp; pasted a few hundred thousand lines of code, swapping Windows-specific components for Linux-specific.&lt;/p&gt;
    &lt;p&gt;For the non-technical reader, this is an enormous problem because now two versions of the code exist. So, all features &amp;amp; bug fixes must be solved in two separate codebases that will grow apart over time. When I heard about this, a young &amp;amp; naive version of me set out to fix the situation....&lt;/p&gt;
    &lt;head rend="h2"&gt;People Problems&lt;/head&gt;
    &lt;p&gt;Tech debt projects are always a hard sell to management, because even if everything goes flawlessly, the code just does roughly what it did before. This project was no exception, and the optics weren't great. I did as many engineers do and "ignored the politics", put my head down, and got it done. But, the project went long, and I lost a lot of clout in the process.&lt;/p&gt;
    &lt;p&gt;I realized I was essentially trying to solve a people problem with a technical solution. Most of the developers at this company were happy doing the same thing today that they did yesterday...and five years ago. As Andrew Harmel-Law points out, code tends to follow the personalities of the people that wrote it. The code was calcified because the developers were also. Personality types who dislike change tend not to design their code with future change in mind.&lt;/p&gt;
    &lt;p&gt;Most technical problems are really people problems. Think about it. Why does technical debt exist? Because requirements weren't properly clarified before work began. Because a salesperson promised an unrealistic deadline to a customer. Because a developer chose an outdated technology because it was comfortable. Because management was too reactive and cancelled a project mid-flight. Because someone's ego wouldn't let them see a better way of doing things.&lt;/p&gt;
    &lt;p&gt;The core issue with the project was that admitting the need for refactoring was also to admit that the way the company was building software was broken and that individual skillsets were sorely out of date. My small team was trying to fix one module of many, while other developers were writing code as they had been for decades. I had one developer openly tell me, "I don't want to learn anything new." I realized that you'll never clean up tech debt faster than others create it. It is like triage in an emergency room, you must stop the bleeding first, then you can fix whatever is broken.&lt;/p&gt;
    &lt;head rend="h2"&gt;An Ideal World&lt;/head&gt;
    &lt;p&gt;The project also disabused me of the engineer's ideal of a world in which engineering problems can be solved in a vacuum - staying out of "politics" and letting the work speak for itself - a world where deadlines don't exist...and let's be honest, neither do customers. This ideal world rarely exists. The vast majority of projects have non-technical stakeholders, and telling them "just trust me; we're working on it" doesn't cut it. I realized that the perception that your team is getting a lot done is just as important as getting a lot done.&lt;/p&gt;
    &lt;p&gt;Non-technical people do not intuitively understand the level of effort required or the need for tech debt cleanup; it must be communicated effectively by engineering - in both initial estimates &amp;amp; project updates. Unless leadership has an engineering background, the value of the technical debt work likely needs to be quantified and shown as business value.&lt;/p&gt;
    &lt;head rend="h2"&gt;Heads Up&lt;/head&gt;
    &lt;p&gt;Perhaps these are the lessons that prep one for more senior positions. In my opinion, anyone above senior engineer level needs to know how to collaborate cross-functionally, regardless of whether they choose a technical or management track. Schools teach Computer Science, not navigating personalities, egos, and personal blindspots.&lt;/p&gt;
    &lt;p&gt;I have worked with some incredible engineers, better than myself - the type that have deep technical knowledge on just about any technology you bring up. When I was younger, I wanted to be that engineer - the "engineer's engineer". But I realize now, that is not my personality. I'm too ADD for that. :)&lt;/p&gt;
    &lt;p&gt;For all of their (considerable) strengths, more often than not, those engineers shy away from the interpersonal. The tragedy is that they are incredibly productive ICs, but may fail with bigger initiatives because they are only one person - a single processor core can only go so fast. Perhaps equally valuable is the "heads up coder" - the person who is deeply technical, but also able to pick their head up &amp;amp; see project risks coming (technical &amp;amp; otherwise) and steer the team around them.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=46160773</guid><pubDate>Fri, 05 Dec 2025 13:07:59 +0000</pubDate></item><item><title>Cloudflare outage on December 5, 2025</title><link>https://blog.cloudflare.com/5-december-2025-outage/</link><description>&lt;doc fingerprint="e418bb5fc591a8cb"&gt;
  &lt;main&gt;
    &lt;div&gt;
      &lt;p&gt;On December 5, 2025, at 08:47 UTC (all times in this blog are UTC), a portion of Cloudflareâs network began experiencing significant failures. The incident was resolved at 09:12 (~25 minutes total impact), when all services were fully restored.&lt;/p&gt;
      &lt;p&gt;A subset of customers were impacted, accounting for approximately 28% of all HTTP traffic served by Cloudflare. Several factors needed to combine for an individual customer to be affected as described below.&lt;/p&gt;
      &lt;p&gt;The issue was not caused, directly or indirectly, by a cyber attack on Cloudflareâs systems or malicious activity of any kind. Instead, it was triggered by changes being made to our body parsing logic while attempting to detect and mitigate an industry-wide vulnerability disclosed this week in React Server Components.&lt;/p&gt;
      &lt;p&gt;Any outage of our systems is unacceptable, and we know we have let the Internet down again following the incident on November 18. We will be publishing details next week about the work we are doing to stop these types of incidents from occurring.&lt;/p&gt;
      &lt;p&gt;The graph below shows HTTP 500 errors served by our network during the incident timeframe (red line at the bottom), compared to unaffected total Cloudflare traffic (green line at the top).&lt;/p&gt;
      &lt;p&gt;Cloudflare's Web Application Firewall (WAF) provides customers with protection against malicious payloads, allowing them to be detected and blocked. To do this, Cloudflareâs proxy buffers HTTP request body content in memory for analysis. Before today, the buffer size was set to 128KB.&lt;/p&gt;
      &lt;p&gt;As part of our ongoing work to protect customers who use React against a critical vulnerability, CVE-2025-55182, we started rolling out an increase to our buffer size to 1MB, the default limit allowed by Next.js applications, to make sure as many customers as possible were protected.&lt;/p&gt;
      &lt;p&gt;This first change was being rolled out using our gradual deployment system. During rollout, we noticed that our internal WAF testing tool did not support the increased buffer size. As this internal test tool was not needed at that time and had no effect on customer traffic, we made a second change to turn it off.&lt;/p&gt;
      &lt;p&gt;This second change of turning off our WAF testing tool was implemented using our global configuration system. This system does not perform gradual rollouts, but rather propagates changes within seconds to the entire fleet of servers in our network and is under review following the outage we experienced on November 18.Â &lt;/p&gt;
      &lt;p&gt;Unfortunately, in our FL1 version of our proxy, under certain circumstances, the second change of turning off our WAF rule testing tool caused an error state that resulted in 500 HTTP error codes to be served from our network.&lt;/p&gt;
      &lt;p&gt;As soon as the change propagated to our network, code execution in our FL1 proxy reached a bug in our rules module which led to the following Lua exception: &lt;/p&gt;
      &lt;quote&gt;
        &lt;code&gt;[lua] Failed to run module rulesets callback late_routing: /usr/local/nginx-fl/lua/modules/init.lua:314: attempt to index field 'execute' (a nil value)&lt;/code&gt;
      &lt;/quote&gt;
      &lt;p&gt;resulting in HTTP code 500 errors being issued.&lt;/p&gt;
      &lt;p&gt;The issue was identified shortly after the change was applied, and was reverted at 09:12, after which all traffic was served correctly.&lt;/p&gt;
      &lt;p&gt;Customers that have their web assets served by our older FL1 proxy AND had the Cloudflare Managed Ruleset deployed were impacted. All requests for websites in this state returned an HTTP 500 error, with the small exception of some test endpoints such as &lt;code&gt;/cdn-cgi/trace&lt;/code&gt;.&lt;/p&gt;
      &lt;p&gt;Customers that did not have the configuration above applied were not impacted. Customer traffic served by our China network was also not impacted.&lt;/p&gt;
      &lt;p&gt;Cloudflareâs rulesets system consists of sets of rules which are evaluated for each request entering our system. A rule consists of a filter, which selects some traffic, and an action which applies an effect to that traffic. Typical actions are â&lt;code&gt;block&lt;/code&gt;â, â&lt;code&gt;log&lt;/code&gt;â, or â&lt;code&gt;skip&lt;/code&gt;â. Another type of action is â&lt;code&gt;execute&lt;/code&gt;â, which is used to trigger evaluation of another ruleset.&lt;/p&gt;
      &lt;p&gt;Our internal logging system uses this feature to evaluate new rules before we make them available to the public. A top level ruleset will execute another ruleset containing test rules. It was these test rules that we were attempting to disable.&lt;/p&gt;
      &lt;p&gt;We have a killswitch subsystem as part of the rulesets system which is intended to allow a rule which is misbehaving to be disabled quickly. This killswitch system receives information from our global configuration system mentioned in the prior sections. We have used this killswitch system on a number of occasions in the past to mitigate incidents and have a well-defined Standard Operating Procedure, which was followed in this incident.&lt;/p&gt;
      &lt;p&gt;However, we have never before applied a killswitch to a rule with an action of â&lt;code&gt;execute&lt;/code&gt;â. When the killswitch was applied, the code correctly skipped the evaluation of the execute action, and didnât evaluate the sub-ruleset pointed to by it. However, an error was then encountered while processing the overall results of evaluating the ruleset:&lt;/p&gt;
      &lt;quote&gt;
        &lt;code&gt;if rule_result.action == "execute" then
  rule_result.execute.results = ruleset_results[tonumber(rule_result.execute.results_index)]
end&lt;/code&gt;
      &lt;/quote&gt;
      &lt;p&gt;This code expects that, if the ruleset has action=âexecuteâ, the ârule_result.executeâ object will exist. However, because the rule had been skipped, the rule_result.execute object did not exist, and Lua returned an error due to attempting to look up a value in a nil value.&lt;/p&gt;
      &lt;p&gt;This is a straightforward error in the code, which had existed undetected for many years. This type of code error is prevented by languages with strong type systems. In our replacement for this code in our new FL2 proxy, which is written in Rust, the error did not occur.&lt;/p&gt;
      &lt;div&gt;
        &lt;head rend="h3"&gt;What about the changes being made after the incident on November 18, 2025?&lt;/head&gt;
      &lt;/div&gt;
      &lt;p&gt;We made an unrelated change that caused a similar, longer availability incident two weeks ago on November 18, 2025. In both cases, a deployment to help mitigate a security issue for our customers propagated to our entire network and led to errors for nearly all of our customer base.&lt;/p&gt;
      &lt;p&gt;We have spoken directly with hundreds of customers following that incident and shared our plans to make changes to prevent single updates from causing widespread impact like this. We believe these changes would have helped prevent the impact of todayâs incident but, unfortunately, we have not finished deploying them yet.&lt;/p&gt;
      &lt;p&gt;We know it is disappointing that this work has not been completed yet. It remains our first priority across the organization. In particular, the projects outlined below should help contain the impact of these kinds of changes:&lt;/p&gt;
      &lt;list rend="ul"&gt;
        &lt;item&gt;
          &lt;p&gt;Enhanced Rollouts &amp;amp; Versioning: Similar to how we slowly deploy software with strict health validation, data used for rapid threat response and general configuration needs to have the same safety and blast mitigation features. This includes health validation and quick rollback capabilities among other things.&lt;/p&gt;
        &lt;/item&gt;
        &lt;item&gt;
          &lt;p&gt;Streamlined break glass capabilities: Ensure that critical operations can still be achieved in the face of additional types of failures. This applies to internal services as well as all standard methods of interaction with the Cloudflare control plane used by all Cloudflare customers.&lt;/p&gt;
        &lt;/item&gt;
        &lt;item&gt;
          &lt;p&gt;"Fail-Open" Error Handling: As part of the resilience effort, we are replacing the incorrectly applied hard-fail logic across all critical Cloudflare data-plane components. If a configuration file is corrupt or out-of-range (e.g., exceeding feature caps), the system will log the error and default to a known-good state or pass traffic without scoring, rather than dropping requests. Some services will likely give the customer the option to fail open or closed in certain scenarios. This will include drift-prevention capabilities to ensure this is enforced continuously.&lt;/p&gt;
        &lt;/item&gt;
      &lt;/list&gt;
      &lt;p&gt;Before the end of next week we will publish a detailed breakdown of all the resiliency projects underway, including the ones listed above. While that work is underway, we are locking down all changes to our network in order to ensure we have better mitigation and rollback systems before we begin again.&lt;/p&gt;
      &lt;p&gt;These kinds of incidents, and how closely they are clustered together, are not acceptable for a network like ours. On behalf of the team at Cloudflare we want to apologize for the impact and pain this has caused again to our customers and the Internet as a whole.&lt;/p&gt;
      &lt;table&gt;
        &lt;row&gt;
          &lt;cell&gt;
            &lt;p&gt;Time (UTC)&lt;/p&gt;
          &lt;/cell&gt;
          &lt;cell&gt;
            &lt;p&gt;Status&lt;/p&gt;
          &lt;/cell&gt;
          &lt;cell&gt;
            &lt;p&gt;Description&lt;/p&gt;
          &lt;/cell&gt;
        &lt;/row&gt;
        &lt;row&gt;
          &lt;cell&gt;
            &lt;p&gt;08:47&lt;/p&gt;
          &lt;/cell&gt;
          &lt;cell&gt;
            &lt;p&gt;INCIDENT start&lt;/p&gt;
          &lt;/cell&gt;
          &lt;cell&gt;
            &lt;p&gt;Configuration change deployed and propagated to the network&lt;/p&gt;
          &lt;/cell&gt;
        &lt;/row&gt;
        &lt;row&gt;
          &lt;cell&gt;
            &lt;p&gt;08:48&lt;/p&gt;
          &lt;/cell&gt;
          &lt;cell&gt;
            &lt;p&gt;Full impact&lt;/p&gt;
          &lt;/cell&gt;
          &lt;cell&gt;
            &lt;p&gt;Change fully propagated&lt;/p&gt;
          &lt;/cell&gt;
        &lt;/row&gt;
        &lt;row&gt;
          &lt;cell&gt;
            &lt;p&gt;08:50&lt;/p&gt;
          &lt;/cell&gt;
          &lt;cell&gt;
            &lt;p&gt;INCIDENT declared&lt;/p&gt;
          &lt;/cell&gt;
          &lt;cell&gt;
            &lt;p&gt;Automated alerts&lt;/p&gt;
          &lt;/cell&gt;
        &lt;/row&gt;
        &lt;row&gt;
          &lt;cell&gt;
            &lt;p&gt;09:11&lt;/p&gt;
          &lt;/cell&gt;
          &lt;cell&gt;
            &lt;p&gt;Change reverted&lt;/p&gt;
          &lt;/cell&gt;
          &lt;cell&gt;
            &lt;p&gt;Configuration change reverted and propagation start&lt;/p&gt;
          &lt;/cell&gt;
        &lt;/row&gt;
        &lt;row&gt;
          &lt;cell&gt;
            &lt;p&gt;09:12&lt;/p&gt;
          &lt;/cell&gt;
          &lt;cell&gt;
            &lt;p&gt;INCIDENT end&lt;/p&gt;
          &lt;/cell&gt;
          &lt;cell&gt;
            &lt;p&gt;Revert fully propagated, all traffic restored&lt;/p&gt;
          &lt;/cell&gt;
        &lt;/row&gt;
      &lt;/table&gt;
    &lt;/div&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=46162656</guid><pubDate>Fri, 05 Dec 2025 15:35:43 +0000</pubDate></item><item><title>Framework Laptop 13 gets ARM processor with 12 cores via upgrade kit</title><link>https://www.notebookcheck.net/Framework-Laptop-13-gets-ARM-processor-with-12-cores-via-upgrade-kit.1177930.0.html</link><description>&lt;doc fingerprint="f36d19f305b9d557"&gt;
  &lt;main&gt;
    &lt;head rend="h1"&gt;Framework Laptop 13 gets ARM processor with 12 cores via upgrade kit&lt;/head&gt;
    &lt;p&gt;The Qualcomm Snapdragon X Plus and Snapdragon X Elite have proven that ARM processors have earned a place in the laptop market, as devices like the Lenovo IdeaPad Slim 5 stand out with their long battery life and an affordable price point.&lt;/p&gt;
    &lt;p&gt;MetaComputing is now offering an alternative to Intel, AMD and the Snapdragon X series. Specifically, the company has introduced a mainboard that can be installe in the Framework Laptop 13 or in a mini PC case. This mainboard is equipped with a CIX CP8180 ARM chipset, which is also found inside the Minisforum MS-R1. This processor has a total of eight ARM Cortex-A720 performance cores, the two fastest can hit boost clock speeds of up to 2.6 GHz. Moreover, there are four Cortex-A520 efficiency cores.&lt;/p&gt;
    &lt;p&gt;Additionally, there’s an ARM Immortalis-G720 GPU with ten cores and an AI accelerator with a performance of 30 TOPS. This chipset is likely slower than the Snapdragon X Elite or a current flagship smartphone chip, but it should still provide enough performance for many everyday tasks. Either way, this mainboard upgrade might only be interesting for developers for the most part, because early tests show that the SoC already draws about 16 watts at idle, which means battery life will likely be fairly short when combined with the 55Wh battery of the Framework Laptop 13.&lt;/p&gt;
    &lt;head rend="h2"&gt;Price and availability&lt;/head&gt;
    &lt;p&gt;The MetaComputing ARM AI PC Kit is available now at the manufacturer’s official online shop. The base model with 16GB RAM, 1TB SSD and a mini PC case costs $549. The mainboard can be installed in a previously purchased Framework Laptop 13. Users who don’t own a Framework Laptop can order a bundle including the notebook for $999. MetaComputing charges an additional $100 for 32GB RAM. Shipping is free worldwide, but these list prices do not include import fees or taxes.&lt;/p&gt;
    &lt;head rend="h2"&gt;Source(s)&lt;/head&gt;
    &lt;p&gt;MetaComputing (press release | product page)&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=46162872</guid><pubDate>Fri, 05 Dec 2025 15:49:56 +0000</pubDate></item><item><title>I'm Peter Roberts, immigration attorney who does work for YC and startups. AMA</title><link>https://news.ycombinator.com/item?id=46163121</link><description>&lt;doc fingerprint="d376f89b34beef3b"&gt;
  &lt;main&gt;
    &lt;div&gt;
      &lt;p&gt;As usual, there are countless immigration topics and I'll be guided by whatever you're concerned with. Please remember that I can't provide legal advice on specific cases for obvious liability reasons because I won't have access to all the facts. Please stick to a factual discussion in your questions and comments and I'll do the same in my answers!&lt;/p&gt;
      &lt;p&gt;Previous threads we've done: https://news.ycombinator.com/submitted?id=proberts.&lt;/p&gt;
    &lt;/div&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=46163121</guid><pubDate>Fri, 05 Dec 2025 16:04:20 +0000</pubDate></item><item><title>Gemini 3 Pro: the frontier of vision AI</title><link>https://blog.google/technology/developers/gemini-3-pro-vision/</link><description>&lt;doc fingerprint="78df88171d739a97"&gt;
  &lt;main&gt;
    &lt;head rend="h1"&gt;Gemini 3 Pro: the frontier of vision AI&lt;/head&gt;
    &lt;p&gt;Gemini 3 Pro represents a generational leap from simple recognition to true visual and spatial reasoning. It is our most capable multimodal model ever, delivering state-of-the-art performance across document, spatial, screen and video understanding.&lt;/p&gt;
    &lt;p&gt;This model sets new highs on vision benchmarks such as MMMU Pro and Video MMMU for complex visual reasoning, as well as use-case-specific benchmarks across document, spatial, screen and long video understanding.&lt;/p&gt;
    &lt;head rend="h2"&gt;1. Document understanding&lt;/head&gt;
    &lt;p&gt;Real-world documents are messy, unstructured, and difficult to parse — often filled with interleaved images, illegible handwritten text, nested tables, complex mathematical notation and non-linear layouts. Gemini 3 Pro represents a major leap forward in this domain, excelling across the entire document processing pipeline — from highly accurate Optical Character Recognition (OCR) to complex visual reasoning.&lt;/p&gt;
    &lt;head rend="h3"&gt;Intelligent perception&lt;/head&gt;
    &lt;p&gt;To truly understand a document, a model must accurately detect and recognize text, tables, math formulas, figures and charts regardless of noise or format.&lt;/p&gt;
    &lt;p&gt;A fundamental capability is "derendering" — the ability to reverse-engineer a visual document back into structured code (HTML, LaTeX, Markdown) that would recreate it. As illustrated below, Gemini 3 demonstrates accurate perception across diverse modalities including converting an 18th-century merchant log into a complex table, or transforming a raw image with mathematical annotation into precise LaTeX code.&lt;/p&gt;
    &lt;p&gt;Example 1: Handwritten Complex Table from 18th century Albany Merchant’s Handbook&lt;/p&gt;
    &lt;p&gt;Example 2: Reconstructing equations from an image&lt;/p&gt;
    &lt;p&gt;Example 3: Reconstructing Florence Nightingale's original Polar Area Diagram into an interactive chart (with a toggle!)&lt;/p&gt;
    &lt;head rend="h3"&gt;Sophisticated reasoning&lt;/head&gt;
    &lt;p&gt;Users can rely on Gemini 3 to perform complex, multi-step reasoning across tables and charts — even in long reports. In fact, the model notably outperforms the human baseline on the CharXiv Reasoning benchmark (80.5%).&lt;/p&gt;
    &lt;p&gt;To illustrate this, imagine a user analyzing the 62-page U.S. Census Bureau "Income in the United States: 2022" report with the following prompt: “Compare the 2021–2022 percent change in the Gini index for "Money Income" versus "Post-Tax Income", and what caused the divergence in the post-tax measure, and in terms of "Money Income", does it show the lowest quintile's share rising or falling?”&lt;/p&gt;
    &lt;p&gt;Swipe through the images below to see the model's step-by-step reasoning.&lt;/p&gt;
    &lt;p&gt;Visual Extraction: To answer the Gini Index Comparison question, Gemini located and cross-referenced this info in Figure 3 about “Money Income decreased by 1.2 percent” and in Table B-3 about “Post-Tax Income increased by 3.2 percent”&lt;/p&gt;
    &lt;p&gt;Causal Logic: Crucially, Gemini 3 does not stop at the numbers; it correlates this gap with the text’s policy analysis, correctly identifying Lapse of ARPA Policies and the end of Stimulus Payments are the main causes.&lt;/p&gt;
    &lt;p&gt;Numerical Comparison: To compare the lowest quantile’s share rising or falling, Gemini3 looked at table A-3, and compared the number of 2.9 and 3.0, and concluded that “the share of aggregate household income held by the lowest quintile was rising.”&lt;/p&gt;
    &lt;p&gt;Final Model Answer&lt;/p&gt;
    &lt;head rend="h2"&gt;2. Spatial understanding&lt;/head&gt;
    &lt;p&gt;Gemini 3 Pro is our strongest spatial understanding model so far. Combined with its strong reasoning, this enables the model to make sense of the physical world.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Pointing capability: Gemini 3 has the ability to point at specific locations in images by outputting pixel-precise coordinates. Sequences of 2D points can be strung together to perform complex tasks, such as estimating human poses or reflecting trajectories over time.&lt;/item&gt;
      &lt;item&gt;Open vocabulary references: Gemini 3 identifies objects and their intent using an open vocabulary. The most direct application is robotics: the user can ask a robot to generate spatially grounded plans like, “Given this messy table, come up with a plan on how to sort the trash.” This also extends to AR/XR devices, where the user can request an AI assistant to “Point to the screw according to the user manual.”&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h2"&gt;3. Screen understanding&lt;/head&gt;
    &lt;p&gt;Gemini 3.0 Pro’s spatial understanding really shines through its screen understanding of desktop and mobile OS screens. This reliability helps make computer use agents robust enough to automate repetitive tasks. UI understanding capabilities can also enable tasks like QA testing, user onboarding and UX analytics. The following computer use demo shows the model perceiving and clicking with high precision.&lt;/p&gt;
    &lt;head rend="h2"&gt;4. Video understanding&lt;/head&gt;
    &lt;p&gt;Gemini 3 Pro takes a massive leap forward in how AI understands video, the most complex data format we interact with. It is dense, dynamic, multimodal and rich with context.&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;High frame rate understanding: We have optimized the model to be much stronger at understanding fast-paced actions when sampling at &amp;gt;1 frames-per-second. Gemini 3 Pro can capture rapid details — vital for tasks like analyzing golf swing mechanics.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;By processing video at 10 FPS—10x the default speed—Gemini 3 Pro catches every swing and shift in weight, unlocking deep insights into player mechanics.&lt;/p&gt;
    &lt;p&gt;2. Video reasoning with “thinking” mode: We upgraded "thinking" mode to go beyond object recognition toward true video reasoning. The model can now better trace complex cause-and-effect relationships over time. Instead of just identifying what is happening, it understands why it is happening.&lt;/p&gt;
    &lt;p&gt;3. Turning long videos into action: Gemini 3 Pro bridges the gap between video and code. It can extract knowledge from long-form content and immediately translate it into functioning apps or structured code.&lt;/p&gt;
    &lt;head rend="h2"&gt;5. Real-world applications&lt;/head&gt;
    &lt;p&gt;Here are a few ways we think various fields will benefit from Gemini 3’s capabilities.&lt;/p&gt;
    &lt;head rend="h3"&gt;Education&lt;/head&gt;
    &lt;p&gt;Gemini 3.0 Pro’s enhanced vision capabilities drive significant gains in the education field, particularly for diagram-heavy questions central to math and science. It successfully tackles the full spectrum of multimodal reasoning problems found from middle school through post-secondary curriculums. This includes visual reasoning puzzles (like Math Kangaroo) and complex chemistry and physics diagrams.&lt;/p&gt;
    &lt;p&gt;Gemini 3’s visual intelligence also powers the generative capabilities of Nano Banana Pro. By combining advanced reasoning with precise generation, the model, for example, can help users identify exactly where they went wrong in a homework problem.&lt;/p&gt;
    &lt;p&gt;Prompt: “Here is a photo of my homework attempt. Please check my steps and tell me where I went wrong. Instead of explaining in text, show me visually on my image.” (Note: Student work is shown in blue; model corrections are shown in red). [See prompt in Google AI Studio]&lt;/p&gt;
    &lt;head rend="h3"&gt;Medical and biomedical imaging&lt;/head&gt;
    &lt;p&gt;Gemini 3 Pro 1 stands as our most capable general model for medical and biomedical imagery understanding, achieving state-of-the-art performance across major public benchmarks in MedXpertQA-MM (a difficult expert-level medical reasoning exam), VQA-RAD (radiology imagery Q&amp;amp;A) and MicroVQA (multimodal reasoning benchmarks for microscopy based biological research).&lt;/p&gt;
    &lt;p&gt;Input image from MicroVQA - a benchmark for microscopy-based biological research&lt;/p&gt;
    &lt;head rend="h3"&gt;Law and finance&lt;/head&gt;
    &lt;p&gt;Gemini 3 Pro’s enhanced document understanding helps professionals in finance and law tackle highly complex workflows. Finance platforms can seamlessly analyze dense reports filled with charts and tables, while legal platforms benefit from the model's sophisticated document reasoning.&lt;/p&gt;
    &lt;head rend="h2"&gt;6. Media resolution control&lt;/head&gt;
    &lt;p&gt;Gemini 3 Pro improves the way it processes visual inputs by preserving the native aspect ratio of images. This drives significant quality improvements across the board.&lt;lb/&gt;Additionally, developers gain granular control over performance and cost via the new media_resolution parameter. This allows you to tune visual token usage to balance fidelity against consumption:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;High resolution: Maximizes fidelity for tasks requiring fine detail, such as dense OCR or complex document understanding.&lt;/item&gt;
      &lt;item&gt;Low resolution: Optimizes for cost and latency on simpler tasks, such as general scene recognition or long-context tasks.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;For specific recommendations, refer to our Gemini 3.0 Documentation Guide.&lt;/p&gt;
    &lt;head rend="h2"&gt;Build with Gemini 3 Pro&lt;/head&gt;
    &lt;p&gt;We are excited to see what you build with these new capabilities. To get started, check out our developer documentation or play with the model in Google AI Studio today.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=46163308</guid><pubDate>Fri, 05 Dec 2025 16:15:10 +0000</pubDate></item><item><title>Patterns for Defensive Programming in Rust</title><link>https://corrode.dev/blog/defensive-programming/</link><description>&lt;doc fingerprint="2c79df8a6ea533d8"&gt;
  &lt;main&gt;
    &lt;p&gt;I have a hobby.&lt;/p&gt;
    &lt;p&gt;Whenever I see the comment &lt;code&gt;// this should never happen&lt;/code&gt; in code, I try to find out the exact conditions under which it could happen.
And in 90% of cases, I find a way to do just that.
More often than not, the developer just hasn’t considered all edge cases or future code changes.&lt;/p&gt;
    &lt;p&gt;In fact, the reason why I like this comment so much is that it often marks the exact spot where strong guarantees fall apart. Often, violating implicit invariants that aren’t enforced by the compiler are the root cause.&lt;/p&gt;
    &lt;p&gt;Yes, the compiler prevents memory safety issues, and the standard library is best-in-class. But even the standard library has its warts and bugs in business logic can still happen.&lt;/p&gt;
    &lt;p&gt;All we can work with are hard-learned patterns to write more defensive Rust code, learned throughout years of shipping Rust code to production. I’m not talking about design patterns here, but rather small idioms, which are rarely documented, but make a big difference in the overall code quality.&lt;/p&gt;
    &lt;head rend="h2"&gt;Code Smell: Indexing Into a Vector&lt;/head&gt;
    &lt;p&gt;Here’s some innocent-looking code:&lt;/p&gt;
    &lt;code&gt;if !matching_users.is_empty   
&lt;/code&gt;
    &lt;p&gt;What if you refactor it and forget to keep the &lt;code&gt;is_empty()&lt;/code&gt; check?
The problem is that the vector indexing is decoupled from checking the length.
So &lt;code&gt;matching_users[0]&lt;/code&gt; can panic at runtime if the vector is empty.&lt;/p&gt;
    &lt;p&gt;Checking the length and indexing are two separate operations, which can be changed independently. That’s our first implicit invariant that’s not enforced by the compiler.&lt;/p&gt;
    &lt;p&gt;If we use slice pattern matching instead, we’ll only get access to the element if the correct &lt;code&gt;match&lt;/code&gt; arm is executed.&lt;/p&gt;
    &lt;code&gt;match matching_users.as_slice   
&lt;/code&gt;
    &lt;p&gt;Note how this automatically uncovered one more edge case: what if the list is empty? We hadn’t explicitly considered this case before. The compiler-enforced pattern matching requires us to think about all possible states! This is a common pattern in all robust Rust code: putting the compiler in charge of enforcing invariants.&lt;/p&gt;
    &lt;head rend="h2"&gt;Code Smell: Lazy use of &lt;code&gt;Default&lt;/code&gt;&lt;/head&gt;
    &lt;p&gt;When initializing an object with many fields, it’s tempting to use &lt;code&gt;..Default::default()&lt;/code&gt; to fill in the rest.
In practice, this is a common source of bugs.
You might forget to explicitly set a new field later when you add it to the struct (thus using the default value instead, which might not be what you want), or you might not be aware of all the fields that are being set to default values.&lt;/p&gt;
    &lt;p&gt;Instead of this:&lt;/p&gt;
    &lt;code&gt;let foo = Foo ;
&lt;/code&gt;
    &lt;p&gt;Do this:&lt;/p&gt;
    &lt;code&gt;let foo = Foo ;
&lt;/code&gt;
    &lt;p&gt;Yes, it’s slightly more verbose, but what you gain is that the compiler will force you to handle all fields explicitly. Now when you add a new field to &lt;code&gt;Foo&lt;/code&gt;, the compiler will remind you to set it here as well and reflect on which value makes sense.&lt;/p&gt;
    &lt;p&gt;If you still prefer to use &lt;code&gt;Default&lt;/code&gt; but don’t want to lose compiler checks, you can also destructure the default instance:&lt;/p&gt;
    &lt;code&gt;let Foo   =  default;
&lt;/code&gt;
    &lt;p&gt;This way, you get all the default values assigned to local variables and you can still override what you need:&lt;/p&gt;
    &lt;code&gt;let foo = Foo ;
&lt;/code&gt;
    &lt;p&gt;This pattern gives you the best of both worlds:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;You get default values without duplicating default logic&lt;/item&gt;
      &lt;item&gt;The compiler will complain when new fields are added to the struct&lt;/item&gt;
      &lt;item&gt;Your code automatically adapts when default values change&lt;/item&gt;
      &lt;item&gt;It’s clear which fields use defaults and which have custom values&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h2"&gt;Code Smell: Fragile Trait Implementations&lt;/head&gt;
    &lt;p&gt;Completely destructuring a struct into its components can also be a defensive strategy for API adherence. For example, let’s say you’re building a pizza ordering system and have an order type like this:&lt;/p&gt;
    &lt;p&gt;For your order tracking system, you want to compare orders based on what’s actually on the pizza - the &lt;code&gt;size&lt;/code&gt;, &lt;code&gt;toppings&lt;/code&gt;, and &lt;code&gt;crust_type&lt;/code&gt;. The &lt;code&gt;ordered_at&lt;/code&gt; timestamp shouldn’t affect whether two orders are considered the same.&lt;/p&gt;
    &lt;p&gt;Here’s the problem with the obvious approach:&lt;/p&gt;
    &lt;p&gt;Now imagine your team adds a field for customization options:&lt;/p&gt;
    &lt;p&gt;Your &lt;code&gt;PartialEq&lt;/code&gt; implementation still compiles, but is it correct?
Should &lt;code&gt;extra_cheese&lt;/code&gt; be part of the equality check?
Probably yes - a pizza with extra cheese is a different order!
But you’ll never know because the compiler won’t remind you to think about it.&lt;/p&gt;
    &lt;p&gt;Here’s the defensive approach using destructuring:&lt;/p&gt;
    &lt;p&gt;Now when someone adds the &lt;code&gt;extra_cheese&lt;/code&gt; field, this code won’t compile anymore.
The compiler forces you to decide: should &lt;code&gt;extra_cheese&lt;/code&gt; be included in the comparison or explicitly ignored with &lt;code&gt;extra_cheese: _&lt;/code&gt;?&lt;/p&gt;
    &lt;p&gt;This pattern works for any trait implementation where you need to handle struct fields: &lt;code&gt;Hash&lt;/code&gt;, &lt;code&gt;Debug&lt;/code&gt;, &lt;code&gt;Clone&lt;/code&gt;, etc.
It’s especially valuable in codebases where structs evolve frequently as requirements change.&lt;/p&gt;
    &lt;head rend="h2"&gt;Code Smell: &lt;code&gt;From&lt;/code&gt; Impls That Are Really &lt;code&gt;TryFrom&lt;/code&gt;&lt;/head&gt;
    &lt;p&gt;Sometimes there’s no conversion that will work 100% of the time. That’s fine. When that’s the case, resist the temptation to offer a &lt;code&gt;From&lt;/code&gt; implementation out of habit; use &lt;code&gt;TryFrom&lt;/code&gt; instead.&lt;/p&gt;
    &lt;p&gt;Here’s an example of &lt;code&gt;TryFrom&lt;/code&gt; in disguise:&lt;/p&gt;
    &lt;p&gt;The &lt;code&gt;unwrap_or_else&lt;/code&gt; is a hint that this conversion can fail in some way.
We set a default value instead, but is it really the right thing to do for all callers?
This should be a &lt;code&gt;TryFrom&lt;/code&gt; implementation instead, making the fallible nature explicit.
We fail fast instead of continuing with a potentially flawed business logic.&lt;/p&gt;
    &lt;head rend="h2"&gt;Code Smell: Non-Exhaustive Matches&lt;/head&gt;
    &lt;p&gt;It’s tempting to use &lt;code&gt;match&lt;/code&gt; in combination with a catch-all pattern like &lt;code&gt;_ =&amp;gt; {}&lt;/code&gt;, but this can haunt you later.
The problem is that you might forget to handle a new case that was added later.&lt;/p&gt;
    &lt;p&gt;Instead of:&lt;/p&gt;
    &lt;code&gt;match self  
&lt;/code&gt;
    &lt;p&gt;Use:&lt;/p&gt;
    &lt;code&gt;match self  
&lt;/code&gt;
    &lt;p&gt;By spelling out all variants explicitly, the compiler will warn you when a new variant is added, forcing you to handle it. Another case of putting the compiler to work.&lt;/p&gt;
    &lt;p&gt;If the code for two variants is the same, you can group them:&lt;/p&gt;
    &lt;code&gt;match self  
&lt;/code&gt;
    &lt;head rend="h2"&gt;Code Smell: &lt;code&gt;_&lt;/code&gt; Placeholders for Unused Variables&lt;/head&gt;
    &lt;p&gt;Using &lt;code&gt;_&lt;/code&gt; as a placeholder for unused variables can lead to confusion.
For example, you might get confused about which variable was skipped.
That’s especially true for boolean flags:&lt;/p&gt;
    &lt;code&gt;match self  
&lt;/code&gt;
    &lt;p&gt;In the above example, it’s not clear which variables were skipped and why. Better to use descriptive names for the variables that are not used:&lt;/p&gt;
    &lt;code&gt;match self  
&lt;/code&gt;
    &lt;p&gt;Even if you don’t use the variables, it’s clear what they represent and the code becomes more readable and easier to review without inline type hints.&lt;/p&gt;
    &lt;head rend="h2"&gt;Pattern: Temporary Mutability&lt;/head&gt;
    &lt;p&gt;If you only want your data to be mutable temporarily, make that explicit.&lt;/p&gt;
    &lt;code&gt;let mut data = get_vec;
data.sort;
let data = data;  // Shadow to make immutable

// Here `data` is immutable.
&lt;/code&gt;
    &lt;p&gt;This pattern is often called “temporary mutability” and helps prevent accidental modifications after initialization. See the Rust unofficial patterns book for more details.&lt;/p&gt;
    &lt;p&gt;You can go one step further and do the initialization part in a scope block:&lt;/p&gt;
    &lt;code&gt;let data = ;
// Here `data` is immutable
&lt;/code&gt;
    &lt;p&gt;This way, the mutable variable is confined to the inner scope, making it clear that it’s only used for initialization. In case you use any temporary variables during initialization, they won’t leak into the outer scope. In our case above, there were none, but imagine if we had a temporary vector to hold intermediate results:&lt;/p&gt;
    &lt;code&gt;let data = ;
&lt;/code&gt;
    &lt;p&gt;Here, &lt;code&gt;temp&lt;/code&gt; is only accessible within the inner scope, which prevents it from accidental use later on.&lt;/p&gt;
    &lt;p&gt;This is especially useful when you have multiple temporary variables during initialization that you don’t want accessible in the rest of the function. The scope makes it crystal clear that these variables are only meant for initialization.&lt;/p&gt;
    &lt;head rend="h2"&gt;Pattern: Defensively Handle Constructors&lt;/head&gt;
    &lt;p&gt;Tip for libraries&lt;/p&gt;
    &lt;p&gt;The following pattern is only truly helpful for libraries and APIs that need to be robust against future changes. In such a case, you want to ensure that all instances of a type are created through a constructor function that enforces validation logic. Because without that, future refactorings can easily lead to invalid states.&lt;/p&gt;
    &lt;p&gt;For application code, it’s probably best to keep things simple. You typically have all the call sites under control and can ensure that validation logic is always called.&lt;/p&gt;
    &lt;p&gt;Let’s say you have a simple type like the following:&lt;/p&gt;
    &lt;p&gt;Now you want to add validation logic to ensure invalid states are never created. One pattern is to return a &lt;code&gt;Result&lt;/code&gt; from the constructor:&lt;/p&gt;
    &lt;p&gt;But nothing stops someone from bypassing your validation by creating an instance directly:&lt;/p&gt;
    &lt;code&gt;let s = S ;
&lt;/code&gt;
    &lt;p&gt;This should not be possible! It is our implicit invariant that’s not enforced by the compiler: the validation logic is decoupled from struct construction. These are two separate operations, which can be changed independently and the compiler won’t complain.&lt;/p&gt;
    &lt;p&gt;To force external code to go through your constructor, add a private field:&lt;/p&gt;
    &lt;p&gt;Now code outside your module cannot construct &lt;code&gt;S&lt;/code&gt; directly because it cannot access the &lt;code&gt;_private&lt;/code&gt; field.
The compiler enforces that all construction must go through your &lt;code&gt;new()&lt;/code&gt; method, which includes your validation logic!&lt;/p&gt;
    &lt;p&gt;Why the underscore in &lt;code&gt;_private&lt;/code&gt;?&lt;/p&gt;
    &lt;p&gt;Note that the underscore prefix is just a naming convention to indicate the field is intentionally unused; it’s the lack of &lt;code&gt;pub&lt;/code&gt; that makes it private and prevents external construction.&lt;/p&gt;
    &lt;p&gt;For libraries that need to evolve over time, you can also use the &lt;code&gt;#[non_exhaustive]&lt;/code&gt; attribute instead:&lt;/p&gt;
    &lt;p&gt;This has the same effect of preventing construction outside your crate, but also signals to users that you might add more fields in the future. The compiler will prevent them from using struct literal syntax, forcing them to use your constructor.&lt;/p&gt;
    &lt;p&gt;&lt;code&gt;Should you use #[non_exhaustive]&lt;/code&gt; or &lt;code&gt;_private&lt;/code&gt;?&lt;/p&gt;
    &lt;p&gt;There’s a big difference between these two approaches:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;#[non_exhaustive]&lt;/code&gt;only works across crate boundaries. It prevents construction outside your crate.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;_private&lt;/code&gt;works at the module boundary. It prevents construction outside the module, but within the same crate.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;On top of that, some developers find &lt;code&gt;_private: ()&lt;/code&gt; more explicit about intent: “this struct has a private field that prevents construction.”&lt;/p&gt;
    &lt;p&gt;With &lt;code&gt;#[non_exhaustive]&lt;/code&gt;, the primary intent is signaling that fields might be added in the future, and preventing construction is more of a side effect.&lt;/p&gt;
    &lt;p&gt;But what about code within the same module? With the patterns above, code in the same module can still bypass your validation:&lt;/p&gt;
    &lt;code&gt;// Still compiles in the same module!
let s = S ;
&lt;/code&gt;
    &lt;p&gt;Rust’s privacy works at the module level, not the type level. Anything in the same module can access private items.&lt;/p&gt;
    &lt;p&gt;If you need to enforce constructor usage even within your own module, you need a more defensive approach using nested private modules:&lt;/p&gt;
    &lt;code&gt; 

// Re-export for public use
pub use  S;
&lt;/code&gt;
    &lt;p&gt;Now even code in your outer module cannot construct &lt;code&gt;S&lt;/code&gt; directly because &lt;code&gt;Seal&lt;/code&gt; is trapped in the private &lt;code&gt;inner&lt;/code&gt; module.
Only the &lt;code&gt;new()&lt;/code&gt; method, which lives in the same module as &lt;code&gt;Seal&lt;/code&gt;, can construct it.
The compiler guarantees that all construction, even internal construction, goes through your validation logic.&lt;/p&gt;
    &lt;p&gt;You could still access the public fields directly, though.&lt;/p&gt;
    &lt;code&gt;let s =  new.unwrap;
s.field1 = "".to_string; // Still possible to mutate fields directly
&lt;/code&gt;
    &lt;p&gt;To prevent that, you can make the fields private and provide getter methods instead:&lt;/p&gt;
    &lt;p&gt;Now the only way to create an instance of &lt;code&gt;S&lt;/code&gt; is through the &lt;code&gt;new()&lt;/code&gt; method, and the only way to access its fields is through the getter methods.&lt;/p&gt;
    &lt;head rend="h3"&gt;When to Use Each&lt;/head&gt;
    &lt;p&gt;To enforce validation through constructors:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;For external code: Add a private field like &lt;code&gt;_private: ()&lt;/code&gt;or use&lt;code&gt;#[non_exhaustive]&lt;/code&gt;&lt;/item&gt;
      &lt;item&gt;For internal code: Use nested private modules with a private “seal” type&lt;/item&gt;
      &lt;item&gt;Choose based on your needs: Most code only needs to prevent external construction; forcing internal construction is more defensive but also more complex&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The key insight is that by making construction impossible without access to a private type, you turn your validation logic from a convention into a guarantee enforced by the compiler. So let’s put that compiler to work!&lt;/p&gt;
    &lt;head rend="h2"&gt;Pattern: Use &lt;code&gt;#[must_use]&lt;/code&gt; on Important Types&lt;/head&gt;
    &lt;p&gt;The &lt;code&gt;#[must_use]&lt;/code&gt; attribute is often neglected.
That’s sad, because it’s such a simple yet powerful mechanism to prevent callers from accidentally ignoring important return values.&lt;/p&gt;
    &lt;p&gt;Now if someone creates a &lt;code&gt;Config&lt;/code&gt; but forgets to use it, the compiler will warn them
(even with a custom message!):&lt;/p&gt;
    &lt;code&gt;let config =  new;
// Warning: Configuration must be applied to take effect
config.with_timeout; 

// Correct usage:
let config =  new 
    .with_timeout;
apply_config;
&lt;/code&gt;
    &lt;p&gt;This is especially useful for guard types that need to be held for their lifetime and results from operations that must be checked. The standard library uses this extensively. For example, &lt;code&gt;Result&lt;/code&gt; is marked with &lt;code&gt;#[must_use]&lt;/code&gt;, which is why you get warnings if you don’t handle errors.&lt;/p&gt;
    &lt;head rend="h2"&gt;Code Smell: Boolean Parameters&lt;/head&gt;
    &lt;p&gt;Boolean parameters make code hard to read at the call site and are error-prone. We all know the scenario where we’re sure this will be the last boolean parameter we’ll ever add to a function.&lt;/p&gt;
    &lt;code&gt;// Too many boolean parameters
 

// At the call site, what do these booleans mean?
process_data;  // What does this do?
&lt;/code&gt;
    &lt;p&gt;It’s impossible to understand what this code does without looking at the function signature. Even worse, it’s easy to accidentally swap the boolean values.&lt;/p&gt;
    &lt;p&gt;Instead, use enums to make the intent explicit:&lt;/p&gt;
    &lt;code&gt; 

 

 

 

// Now the call site is self-documenting
process_data;
&lt;/code&gt;
    &lt;p&gt;This is much more readable and the compiler will catch mistakes if you pass the wrong enum type. You will notice that the enum variants can be more descriptive than just &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;.
And more often than not, there are more than two meaningful options; especially for programs which grow over time.&lt;/p&gt;
    &lt;p&gt;For functions with many options, you can configure them using a parameter struct:&lt;/p&gt;
    &lt;code&gt; 

 

 

// Usage with preset configurations
process_data;

// Or customize for specific needs
process_data;
&lt;/code&gt;
    &lt;p&gt;This approach scales much better as your function evolves. Adding new parameters doesn’t break existing call sites, and you can easily add defaults or make certain fields optional. The preset methods also document common use cases and make it easy to use the right configuration for different scenarios.&lt;/p&gt;
    &lt;p&gt;Rust is often criticized for not having named parameters, but using a parameter struct is arguably even better for larger functions with many options.&lt;/p&gt;
    &lt;head rend="h2"&gt;Clippy Lints for Defensive Programming&lt;/head&gt;
    &lt;p&gt;Many of these patterns can be enforced automatically using Clippy lints. Here are the most relevant ones:&lt;/p&gt;
    &lt;table&gt;
      &lt;row span="2"&gt;
        &lt;cell role="head"&gt;Lint&lt;/cell&gt;
        &lt;cell role="head"&gt;Description&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;
          &lt;code&gt;clippy::indexing_slicing&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Prevents direct indexing into slices and vectors&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;
          &lt;code&gt;clippy::fallible_impl_from&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Warns about &lt;code&gt;From&lt;/code&gt; implementations that can panic and should be &lt;code&gt;TryFrom&lt;/code&gt; instead.&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;
          &lt;code&gt;clippy::wildcard_enum_match_arm&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Disallows wildcard &lt;code&gt;_&lt;/code&gt; patterns.&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;
          &lt;code&gt;clippy::unneeded_field_pattern&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Identifies when you’re ignoring too many struct fields with &lt;code&gt;..&lt;/code&gt; unnecessarily.&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="2"&gt;
        &lt;cell&gt;
          &lt;code&gt;clippy::fn_params_excessive_bools&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Warns when a function has too many boolean parameters (4 or more by default).&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;cell&gt;
          &lt;code&gt;clippy::must_use_candidate&lt;/code&gt;
        &lt;/cell&gt;
        &lt;cell&gt;Suggests adding &lt;code&gt;#[must_use]&lt;/code&gt; to types that are good candidates for it.&lt;/cell&gt;
      &lt;/row&gt;
    &lt;/table&gt;
    &lt;p&gt;You can enable these in your project by adding them at the top of your crate, e.g.&lt;/p&gt;
    &lt;p&gt;Or in your &lt;code&gt;Cargo.toml&lt;/code&gt;:&lt;/p&gt;
    &lt;code&gt;[]
= "deny"
  = "deny"
  = "deny"
  = "deny"
  = "deny"
  = "deny"
  &lt;/code&gt;
    &lt;head rend="h2"&gt;Conclusion&lt;/head&gt;
    &lt;p&gt;Defensive programming in Rust is about leveraging the type system and compiler to catch bugs before they happen. By following these patterns, you can:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Make implicit invariants explicit and compiler-checked&lt;/item&gt;
      &lt;item&gt;Future-proof your code against refactoring mistakes&lt;/item&gt;
      &lt;item&gt;Reduce the surface area for bugs&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;It’s a skill that doesn’t come naturally and it’s not covered in most Rust books, but knowing these patterns can make the difference between code that works but is brittle, and code that is robust and maintainable for years to come.&lt;/p&gt;
    &lt;p&gt;Remember: if you find yourself writing &lt;code&gt;// this should never happen&lt;/code&gt;, take a step back and ask how the compiler could enforce that invariant for you instead.
The best bug is the one that never compiles in the first place.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=46163609</guid><pubDate>Fri, 05 Dec 2025 16:34:25 +0000</pubDate></item><item><title>Synadia and TigerBeetle Pledge $512k to the Zig Software Foundation</title><link>https://tigerbeetle.com/blog/2025-10-25-synadia-and-tigerbeetle-pledge-512k-to-the-zig-software-foundation/</link><description>&lt;doc fingerprint="bf70d8bf88a3ab96"&gt;
  &lt;main&gt;
    &lt;head rend="h1"&gt;Synadia and TigerBeetle Pledge $512,000 to the Zig Software Foundation&lt;/head&gt;
    &lt;p&gt;Synadia and TigerBeetle have together pledged $512,000 to the Zig Software Foundation over the next two years in support of the language, leadership, and communities building the future of simpler systems software.&lt;/p&gt;
    &lt;p&gt;I first saw Zig in 2018, seven years ago. Two years later, I chose Zig over C or Rust for TigerBeetle.&lt;/p&gt;
    &lt;p&gt;In 2020, I was following Rust closely. At the time, Rustâs default memory philosophy was to crash when out of memory (OOM). However, for TigerBeetle, I wanted explicit static allocation, following NASAâs Power of Ten Rules for Safety-Critical Code, which would become a part of TigerStyle, a methodology for creating safer software in less time.&lt;/p&gt;
    &lt;p&gt;What I learned is that if you could centralize resource allocation in time and space (the dimensions that prove tricky for humans writing software) then this could not only simplify memory management, to design away some of the need for a borrow checker in the first place, but, more importantly, also be a forcing function for propagating good design, to encourage teams to think through the explicit limits or physics of the software (you have no choice).&lt;/p&gt;
    &lt;p&gt;From a performance perspective, I didnât want TigerBeetle to be fearlessly multithreaded. Transaction processing workloads tend to have inherent contention, even to the point of power law, precluding partitioning and necessitating a single-threaded architecture. Therefore, Rustâs borrow checker, while a phenomenal tool for the class of problems it targets, made less sense for TigerBeetle. TigerBeetle never frees memory and never runs multithreaded, instead using explicit submission/completion queue interfaces by design.&lt;/p&gt;
    &lt;p&gt;Finally, while the borrow checker could achieve local memory safety, TigerBeetle needed more correctness properties. TigerBeetle needed to be always correct, and across literally thousands of invariants. As matklad would say, this is a harder problem! I had also spent enough time in memory safe languages to know that local memory safety is no guarantee of local correctness, let alone distributed system correctness. Per systems thinking, I believe that total correctness is a design problem, not a language problem. Language is valuable. But no human language can guarantee the next Hemingway or Nabokov. For this you need philosophy. Even then itâs not a guarantee but a probability.&lt;/p&gt;
    &lt;p&gt;With Rust off the table, the choice fell to C or Zig. A language of the past or future?&lt;/p&gt;
    &lt;p&gt;Zig was early, which gave me pause, but I felt that the quality of Andrew Kelleyâs design decisions in the language, the standard library (e.g. the unmanaged hashmap interface) and the cross-compilation toolchain, even five years ago, was already exceptional.&lt;/p&gt;
    &lt;p&gt;Andrewsâs philosophy resonated with what I wanted to explore in TigerStyle. No hidden memory allocations. No hidden control flow. No preprocessor. No macros. And then you get things like comptime, reducing the grammar and dimensionality of the language, while simultaneously multiplying its power. The primary benefit of Zig is the favorable ratio of expressivity to language complexity.&lt;/p&gt;
    &lt;p&gt;As a replacement for C, Zig fixed not only the small cuts, such as explicit alignment in the type system for Direct I/O, or safer casts, but the showstoppers of spatial memory safety through bounds checking, and, to a lesser degree (but not guarantee), temporal memory safety through the debug allocator.&lt;/p&gt;
    &lt;p&gt;Zig also enabled checked arithmetic by default in safe builds, which is something I believe only Ada and Swift do (remarkably, Rust disables checked arithmetic by default in safe buildsâa default I would love to see changed). TigerBeetle separates the data plane from the control plane by design, through batching, so the runtime cost of these safety checks was not material, being amortized in the data plane across bigger buffers. While a borrow checker or static allocation can simplify memory management, getting logic and arithmetic correct remains hard. Of course, you can enable checked arithmetic in other languages, but I appreciated Andrewâs concern for checked arithmetic and stricter operands by default.&lt;/p&gt;
    &lt;p&gt;In all these things, what impressed me most was Zigâs approach to safety when working with the metal. Not in terms of an on/off decision, but as a spectrum. Not aiming for 100% guarantees across 1 or 2 categories, but 90% and then across more categories. Not eliminating classes of bugs, but downgrading their probability. All while preserving the power-to-weight ratio of the language, to keep the language beautifully simple.&lt;/p&gt;
    &lt;p&gt;Many languages start simple and grow complex as features are added. Zigâs simplicity is unusual in that it comes from a subtractive discipline (e.g. no private fields) rather than a deferred complexity; minimizing surface area is part of the ethos of the language. The simplicity of Zig meant that we could hire great programmers from any language backgroundâthey could pick up Zig in a weekend. Indeed, Iâve never had to talk to a new hire about learning Zig.&lt;/p&gt;
    &lt;p&gt;Finally, there was the timing. Recognizing that TigerBeetle would take time to reach production (we shipped production in 2024, after 3.5 years of development), giving Zig time to mature, for our trajectories to intersect.&lt;/p&gt;
    &lt;p&gt;Investing in creating a database like TigerBeetle is a long term effort. Databases tend to have a long half life (e.g. Postgres is 30 years old). And so, while Zig being early in 2020 did give me pause, nevertheless Zigâs quality, philosophy and simplicity made sense for a multi-decade horizon.&lt;/p&gt;
    &lt;p&gt;How has the decision for Zig panned out?&lt;/p&gt;
    &lt;p&gt;TigerBeetle is tested end-to-end under some pretty extreme fuzzing. We did have three bugs that would have been prevented by the borrow checker, but these were caught by our fuzzers and online verification. We run a fuzzing fleet of 1,000 dedicated CPU cores 24/7. We invest in deterministic simulation testing (e.g. VOPR), as well as non-deterministic fault-injection harnesses (e.g. VÃ¶rtex). We engaged Kyle Kingsbury in one of the longest Jepsen audits to dateâfour times the typical duration. Through all this, Zigâs quality held up flawlessly.&lt;/p&gt;
    &lt;p&gt;Zig has also been a huge part of our success as a company. TigerBeetle is only 5 years old but is already migrating some of the largest brokerages, exchanges and wealth managements in their respective jurisdictions. Several of our key enterprise contracts were thanks to the CTOs and even CEOs of these companies also following Zig and seeing the quality we wanted to achieve with it. I donât think we could have written TigerBeetle as it is, in any other language, at least not to the same tight tolerances, let alone with the same velocity.&lt;/p&gt;
    &lt;p&gt;Zigâs language specification will only reach 1.0 when all experimental areas of the language (e.g. async I/O) are finally done. For TigerBeetle, we care only about the stable language features we use, testing our binaries end to end, as we would for any language. Nevertheless, upgrading to new versions, even with breaking changes, has only been a pleasure for us as a team. The upgrade work is usually fully paid for by compilation time reduction. For example, the upgrade from Zig 0.14.1 to Zig 0.15.2 (with the native x86_64 backend) makes debug builds 2x faster, and even LLVM release builds become 1.6x faster. With each release, you can literally feel the sheer amount of effort that the entire Zig core team put into making Zig the worldâs most powerful programming languageâand toolchain.&lt;/p&gt;
    &lt;p&gt;Back in 2020, from a production perspective, Zig was more or less a frontend to LLVM, the same compiler used by Rust, Swift and other languages. However, by not shying away from also investing in its own independent compiler backends and toolchain, by appreciating the value of replacing LLVM long term, Zig is becoming well positioned to gain a low-level precision and compilation speed that generic LLVM wonât always be able to match.&lt;/p&gt;
    &lt;p&gt;We want Andrew to take his time, to get these things right for the long term. Fred Brooks once said that conceptual integrity is âthe most important considerationâ in system design, that the design must proceed from one mind.&lt;/p&gt;
    &lt;p&gt;In this spirit, I am grateful for Andrewâs remarkably strong leadership (and taste) in the design of the language and toolchain. There can be thankless pressure on an open source project to give in to the tragedy of the commons. But if anything, in hindsight I think this is what Iâve most appreciated about choosing Zig for TigerBeetle, that Zig has a strong BDFL.&lt;/p&gt;
    &lt;p&gt;Of course, some may hear âBDFLâ and see governance risk. But I fear the opposite: conceptual risk, the harder problem. Brooks was rightâconceptual integrity is almost certainly doomed by committee. Whereas governance is easier solved: put it in the hands, not of the corporates, but of the people. The individuals who choose each day to continue to donate.&lt;/p&gt;
    &lt;p&gt;This is why our pledge today, along with all other ZSF donors, is a simple donation with no strings attached. The Zig Software Foundation is well managed, transparent and independent. We want it to remain this way. The last thing we want is some kind of foundation âseatâ. Andrew is Chef. We want to let him cook, and pay his core team sustainably (e.g. 92% percent of budget goes to directly paying contributors).&lt;/p&gt;
    &lt;p&gt;If cooking is one metaphor, then surfing is another. I believe that technology moves in waves. The art is not in paddling to the wave with a thousand surfers on it. But in spotting the swell before it breaks. And then enjoying the ride with the early adopters who did the same. River, Ghostty, Bun, Mach and many fellow surfers.&lt;/p&gt;
    &lt;p&gt;In fact, it was through Zig that I met Derek Collison, who like me had been sponsoring the language in his personal capacity since 2018. As a former CTO at VMware, Derek was responsible for backing antirez to work full time on Redis. Derek later went on to create NATS, founding Synadia.&lt;/p&gt;
    &lt;p&gt;As we were about to increase TigerBeetleâs yearly donation to Zig, I reached out to Derek, and we decided to do a joint announcement, following Mitchell Hashimotoâs lead. For each of our companies to donate $256,000 in monthly installments over the next two years, with Synadia matching TigerBeetle, for a total of $512,000âthe first installment already made.&lt;/p&gt;
    &lt;p&gt;Please consider donating or increasing your donation if you can. And if you are a CEO or CTO, please team up with another company to outmatch us! Thanks Andrew for creating something special, and to all who code for the joy of the craft:&lt;/p&gt;
    &lt;p&gt;Together we serve the users.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=46163671</guid><pubDate>Fri, 05 Dec 2025 16:38:30 +0000</pubDate></item><item><title>Onlook (YC W25) the Cursor for Designers Is Hiring a Founding Fullstack Engineer</title><link>https://news.ycombinator.com/item?id=46163977</link><description>&lt;doc fingerprint="be519058de7ce427"&gt;
  &lt;main&gt;
    &lt;div&gt;
      &lt;p&gt;Hey HN! I'm Daniel, building Onlook, the Cursor for Designers. We built an open-source collaborative canvas for code that lets designers and developers craft incredible web experiences together.&lt;/p&gt;
      &lt;p&gt;Since launching, Onlook hit #1 on Hacker News, was the #1 trending repo on GitHub—above DeepSeek + Anthropic—and has earned over 23,000 GitHub stars. We’re looking to bring on Onlook’s first Founding Engineers.&lt;/p&gt;
      &lt;p&gt;This role requires autonomy - you’ll be setting standards for one of the fastest-growing open source projects backed by YC ever. You’ll help design and build an uncompromising visual IDE loved by tens of thousands of designers and engineers around the world, and you'll have a heavy influence on the direction of where we take the company.&lt;/p&gt;
      &lt;p&gt;You’re a full-stack engineer based in the U.S. who is ultra comfortable in Typescript, NextJS, React, and Tailwind, and ready to jump-in and build.&lt;/p&gt;
      &lt;p&gt;The most important things we look for:&lt;/p&gt;
      &lt;p&gt;• Olympic-level dedication – you want to be the best in the world at what you do.&lt;/p&gt;
      &lt;p&gt;• Ownership – you like autonomy and control over the destiny of the company.&lt;/p&gt;
      &lt;p&gt;• Speed – you’re comfortable shipping and iterating quickly with feedback.&lt;/p&gt;
      &lt;p&gt;• Craft – you’re opinionated and are willing to defend your opinions.&lt;/p&gt;
      &lt;p&gt;Ideally, you:&lt;/p&gt;
      &lt;p&gt;• Are looking for a fast-paced, early startup environment.&lt;/p&gt;
      &lt;p&gt;• Are willing to put in long hours and go the extra mile.&lt;/p&gt;
      &lt;p&gt;• Are comfortable with any part of the stack, front-end, back-end, or database.&lt;/p&gt;
      &lt;p&gt;• Believe in open source and are ok with your work being very public.&lt;/p&gt;
      &lt;p&gt;The comp range for this role is $130k-200k, 1-5% equity, great healthcare + other perks, and an awesome office if you happen to be in SF. We're open to remote / hybrid candidates.&lt;/p&gt;
      &lt;p&gt;If you’d like to stand out, please share a project or piece of work that you’re most proud of. We love seeing people’s work. If you have a personal website, please include that as well.&lt;/p&gt;
      &lt;p&gt;If you're interested, email daniel@onlook.com with your Github / LinkedIn / Website or work samples and why you'd be a great addition to the team, or apply here: https://www.ycombinator.com/companies/onlook/jobs/e4gHv1n-fo...&lt;/p&gt;
      &lt;p&gt;Excited to meet, and build alongside you!&lt;/p&gt;
    &lt;/div&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=46163977</guid><pubDate>Fri, 05 Dec 2025 17:00:10 +0000</pubDate></item><item><title>Why we built Lightpanda in Zig</title><link>https://lightpanda.io/blog/posts/why-we-built-lightpanda-in-zig</link><description>&lt;doc fingerprint="a778501a8d23ae78"&gt;
  &lt;main&gt;
    &lt;head rend="h1"&gt;Why We Built Lightpanda in Zig&lt;/head&gt;
    &lt;p&gt;Because We're Not Smart Enough for C++ or Rust&lt;/p&gt;
    &lt;head rend="h3"&gt;Francis Bouvier&lt;/head&gt;
    &lt;head rend="h4"&gt;Cofounder &amp;amp; CEO&lt;/head&gt;
    &lt;head rend="h2"&gt;TL;DR&lt;/head&gt;
    &lt;p&gt;To be honest, when I began working on Lightpanda, I chose Zig because I’m not smart enough to build a big project in C++ or Rust.&lt;/p&gt;
    &lt;p&gt;I like simple languages. I like Zig for the same reasons I like Go, C, and the KISS principle. Not just because I believe in this philosophy, but because I’m not capable of handling complicated abstractions at scale.&lt;/p&gt;
    &lt;p&gt;Before Lightpanda, I was doing a lot of Go. But building a web browser from scratch requires a low-level systems programming language to ensure great performance, so Go wasn’t an option. And for a project like this, I wanted more safety and modern tooling than C.&lt;/p&gt;
    &lt;head rend="h2"&gt;Why We Built Lightpanda in Zig&lt;/head&gt;
    &lt;p&gt;Our requirements were performance, simplicity, and modern tooling. Zig seemed like the perfect balance: simpler than C++ and Rust, top-tier performance, and better tooling and safety than C.&lt;/p&gt;
    &lt;p&gt;As we built the first iterations of the browser and dug deeper into the language, we came to appreciate features where Zig particularly shines: comptime metaprogramming, explicit memory allocators, and best-in-class C interoperability. Not to mention the ongoing work on compilation times.&lt;/p&gt;
    &lt;p&gt;Of course it’s a big bet. Zig is a relatively new language with a small ecosystem. It’s pre-1.0 with regular breaking changes. But we’re very bullish on this language, and we’re not the only ones: Ghostty , Bun , TigerBeetle , and ZML are all building with Zig. And with Anthropic’s recent acquisition of Bun , big tech is taking notice.&lt;/p&gt;
    &lt;p&gt;Here’s what we’ve learned.&lt;/p&gt;
    &lt;head rend="h2"&gt;What Lightpanda Needs from a Language&lt;/head&gt;
    &lt;p&gt;Before diving into specifics, let’s talk about what building a browser for web automation requires.&lt;/p&gt;
    &lt;p&gt;First, we needed a JavaScript engine. Without one, a browser only sees static HTML: no client-side rendering and no dynamic content. We chose V8, Chrome’s JavaScript engine, because it’s state of the art, widely used (Node.js , Deno ), and relatively easy to embed.&lt;/p&gt;
    &lt;p&gt;V8 is written in C++, and doesn’t have a C API, which means any language integrating with it must handle C++ boundaries. Zig doesn’t interoperate directly with C++, but it has first-class C interop, and C remains the lingua franca of systems programming. We use C headers generated primarily from rusty_v8 , part of the Deno project , to bridge between V8’s C++ API and our Zig code.&lt;/p&gt;
    &lt;p&gt;Beyond integration, performance and memory control were essential. When you’re crawling thousands of pages or running automation at scale, every millisecond counts. We also needed precise control over short-lived allocations like DOM trees, JavaScript objects, and parsing buffers. Zig’s explicit allocator model fits that need perfectly.&lt;/p&gt;
    &lt;head rend="h2"&gt;Why Not C++?&lt;/head&gt;
    &lt;p&gt;C++ was the obvious option: it powers virtually every major browser engine. But here’s what gave us pause.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Four decades of features: C++ has accumulated enormous complexity over the years. There are multiple ways to do almost everything: template metaprogramming, multiple inheritance patterns, various initialization syntaxes. We wanted a language with one clear way to do things.&lt;/item&gt;
      &lt;item&gt;Memory management: Control comes with constant vigilance. Use-after-free bugs, memory leaks, and dangling pointers are real risks. Smart pointers help, but they add complexity and runtime overhead. Zig’s approach of passing allocators explicitly makes memory management clearer and enables patterns like arenas more naturally.&lt;/item&gt;
      &lt;item&gt;Build systems: Anyone who’s fought with CMake or dealt with header file dependencies knows this pain. For a small team trying to move quickly, we didn’t want to waste time debugging build configuration issues.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;We’re not saying C++ is bad. It powers incredible software. But for a small team starting from scratch, we wanted something simpler.&lt;/p&gt;
    &lt;head rend="h2"&gt;Why not Rust?&lt;/head&gt;
    &lt;p&gt;Many people ask this next. It’s a fair challenge. Rust is a more mature language than Zig, offers memory safety guarantees, has excellent tooling, and a growing ecosystem.&lt;/p&gt;
    &lt;p&gt;Rust would have been a viable choice. But for Lightpanda’s specific needs (and honestly, for our team’s experience level) it introduced friction we didn’t want.&lt;/p&gt;
    &lt;head rend="h3"&gt;The Unsafe Rust Problem&lt;/head&gt;
    &lt;p&gt;When you need to do things the borrow checker doesn’t like, you end up writing unsafe Rust, which is surprisingly hard. Zack from Bun explores this in depth in his article When Zig is safer and faster than Rust .&lt;/p&gt;
    &lt;p&gt;Browser engines and garbage-collected runtimes are classic examples of code that fights the borrow checker. You’re constantly juggling different memory regions: per-page arenas, shared caches, temporary buffers, objects with complex interdependencies. These patterns don’t map cleanly to Rust’s ownership model. You end up either paying performance costs (using indices instead of pointers, unnecessary clones) or diving into unsafe code where raw pointer ergonomics are poor and Miri becomes your constant companion.&lt;/p&gt;
    &lt;p&gt;Zig takes a different approach. Rather than trying to enforce safety through the type system and then providing an escape hatch, Zig is designed for scenarios where you’re doing memory-unsafe things. It gives you tools to make that experience better: non-null pointers by default, the GeneralPurposeAllocator that catches use-after-free bugs in debug mode, and pointer types with good ergonomics.&lt;/p&gt;
    &lt;head rend="h2"&gt;Why Zig Works for Lightpanda&lt;/head&gt;
    &lt;p&gt;Zig sits in an interesting space. It’s a simple language that’s easy to learn, where everything is explicit: no hidden control flow, no hidden allocations.&lt;/p&gt;
    &lt;head rend="h3"&gt;Explicit Memory Management with Allocators&lt;/head&gt;
    &lt;p&gt;Zig makes you choose how memory is managed through allocators. Every allocation requires you to specify which allocator to use. This might sound tedious at first, but it gives you precise control.&lt;/p&gt;
    &lt;p&gt;Here’s what this looks like in practice, using an arena allocator:&lt;/p&gt;
    &lt;code&gt;const std = @import("std");
 
pub fn loadPage(_allocator: std.mem.Allocator, url: []const u8) !void {
    // Create an arena allocator for this page load
    var arena = std.heap.ArenaAllocator.init(_allocator);
    defer arena.deinit(); // Everything gets freed here
 
    const allocator = arena.allocator();
 
    // All these allocations use the arena
    const dom_tree = try parseDom(allocator, url);
    const css_rules = try parseStyles(allocator, dom_tree);
    const js_context = try createJsContext(allocator);
 
    // Execute page, render, extract data...
    try executePage(js_context, dom_tree, css_rules);
 
    // Arena.deinit() frees everything at once, no leaks possible
}&lt;/code&gt;
    &lt;p&gt;This pattern matches browser workloads perfectly. Each page load gets its own arena. When the page is done, we throw away the entire memory chunk. No tracking individual allocations, no reference counting overhead, no garbage collection pauses. (Though we’re learning that single pages can grow large in memory, so we’re also exploring mid-lifecycle cleanup strategies). And you can chain arenas, to create short-lived objects inside a page lifecycle.&lt;/p&gt;
    &lt;head rend="h3"&gt;Compile-Time Metaprogramming&lt;/head&gt;
    &lt;p&gt;Zig’s comptime feature lets you write code that runs during compilation. We use this extensively to reduce boilerplate when bridging Zig and JavaScript.&lt;/p&gt;
    &lt;p&gt;When integrating V8, you need to expose native types to JavaScript. In most languages, this requires glue code for each type. To generate this glue you need some code generation, usually through Macros (Rust, C, C++). Macros are a completely different language, which has a lot of downsides. Zig’s comptime lets us automate this:&lt;/p&gt;
    &lt;code&gt;const Point = struct {
    x: i32,
    y: i32,
 
    pub fn moveUp(self: *Point) void {
        self.y += 1;
    }
 
    pub fn moveDown(self: *Point) void {
        self.y -= 1;
    }
};
 
// Our runtime can introspect this at compile time and generate bindings
 
runtime.registerType(Point, "Point");&lt;/code&gt;
    &lt;p&gt;The registerType function uses comptime reflection to:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Find all public methods on Point&lt;/item&gt;
      &lt;item&gt;Generate JavaScript wrapper functions&lt;/item&gt;
      &lt;item&gt;Create property getters/setters for x and y&lt;/item&gt;
      &lt;item&gt;Handle type conversions automatically&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;This eliminates manual binding code and makes adding new types simple by using the same language at compile time and runtime.&lt;/p&gt;
    &lt;head rend="h3"&gt;C Interop That Just Works&lt;/head&gt;
    &lt;p&gt;Zig’s C interop is a first-class feature: you can directly import C header files and call C functions without wrapper libraries.&lt;/p&gt;
    &lt;p&gt;For example, we use cURL as our HTTP library. We can just import libcurl C headers in Zig and use the C functions directly:&lt;/p&gt;
    &lt;code&gt;pub const c = @cImport({
    @cInclude("curl/curl.h");
});
 
pub fn init() !Http {
    try errorCheck(c.curl_global_init(c.CURL_GLOBAL_SSL));
    errdefer c.curl_global_cleanup();
    // business logic ...
}&lt;/code&gt;
    &lt;p&gt;It feels as simple as using C, except you are programming in Zig.&lt;/p&gt;
    &lt;p&gt;And with the build system it’s also very simple to add the C sources to build everything together (your zig code and the C libraries):&lt;/p&gt;
    &lt;code&gt;fn buildCurl(b: *Build, m: *Build.Module) !void {
    const curl = b.addLibrary(.{
        .name = "curl",
        .root_module = m,
    });
 
    const root = "vendor/curl/";
 
    curl.addIncludePath(b.path(root ++ "lib"));
    curl.addIncludePath(b.path(root ++ "include"));
    curl.addCSourceFiles(.{
        .flags = &amp;amp;.{
            // list of compilation flags (optional)
        },
        .files = &amp;amp;.{
            // list of C source files
    }});
}&lt;/code&gt;
    &lt;p&gt;This simplicity of importing C mitigates the fact that the Zig ecosystem is still small, as you can use all the existing C libraries.&lt;/p&gt;
    &lt;head rend="h3"&gt;The Build System Advantage&lt;/head&gt;
    &lt;p&gt;Zig includes its own build system written in Zig itself. This might sound unremarkable, but compared to CMake, it’s refreshingly straightforward. Adding dependencies, configuring compilation flags, and managing cross-compilation all happen in one place with clear semantics. Runtime, comptime, build system: everything is in Zig, which makes things easier.&lt;/p&gt;
    &lt;p&gt;Cross-compilation in particular is usually a difficult topic, but it’s very easy with Zig. Some projects like Uber use Zig mainly as a build system and toolchain.&lt;/p&gt;
    &lt;head rend="h3"&gt;Compile times matter&lt;/head&gt;
    &lt;p&gt;Zig compiles fast. Our full rebuild takes under a minute. Not as fast as Go or an interpreted language, but enough to have a feedback loop that makes development feel responsive. In that regard, Zig is considerably faster than Rust or C++.&lt;/p&gt;
    &lt;p&gt;This is a strong focus of the Zig team. They are also a small team and they need fast compilation for the development of the language, as Zig is written in Zig (self-hosted). For that purpose, they are developing native compiler backends (i.e. not using LLVM), which is very ambitious and yet successful: it’s already the default backend for x86 in debug mode, with a significant improvement in build times (3.5x faster for the Zig project itself ). And incremental compilation is on its way.&lt;/p&gt;
    &lt;head rend="h2"&gt;What We’ve Learned&lt;/head&gt;
    &lt;p&gt;After months of building Lightpanda in Zig, here’s what stands out.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;The learning curve is manageable. Zig’s simplicity means you can understand the entire language in a few weeks. Compared to Rust or C++, this makes a real difference.&lt;/item&gt;
      &lt;item&gt;The allocator model pays off. Being able to create arena allocators per page load, per request, or per task gives us fine-grained memory control without tracking individual allocations.&lt;/item&gt;
      &lt;item&gt;The community is small but helpful. Zig is still growing. The Discord community and ziggit.dev are active, and the language is simple enough that you can often figure things out by reading the standard library source.&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h2"&gt;Conclusion&lt;/head&gt;
    &lt;p&gt;Lightpanda wouldn’t exist without the work of the Zig Foundation and the community behind it. Zig has made it possible to build something as complex as a browser with a small team and a clear mental model, without sacrificing performance.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;If you’re curious about Zig’s design philosophy or want to see how its compiler and allocator model work, the official documentation is the best place to start.&lt;/item&gt;
      &lt;item&gt;You can also explore the Lightpanda source code and follow the project on GitHub&lt;/item&gt;
      &lt;item&gt;Sign up to test the cloud version&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h2"&gt;FAQ&lt;/head&gt;
    &lt;head rend="h3"&gt;Is Zig stable enough for production use?&lt;/head&gt;
    &lt;p&gt;Zig is still pre-1.0, which means breaking changes can happen between versions. That said, we’ve found it stable enough for our production use, especially since the ecosystem has largely standardized on tracking the latest tagged releases rather than main. The language itself is well-designed, and most changes between versions are improvements that are worth adapting to. Just be prepared to update code when upgrading Zig versions.&lt;/p&gt;
    &lt;head rend="h3"&gt;What’s the hardest part about learning Zig?&lt;/head&gt;
    &lt;p&gt;The allocator model takes adjustment if you’re coming from garbage-collected languages. You need to think about where memory comes from and when it gets freed. But compared to Rust’s borrow checker or C++‘s memory management, it’s relatively straightforward once you understand the patterns.&lt;/p&gt;
    &lt;head rend="h3"&gt;Can Zig really replace C++ for browser development?&lt;/head&gt;
    &lt;p&gt;For building a focused browser like Lightpanda, yes. For replacing Chromium or Firefox, that’s unlikely: those projects have millions of lines of C++ and decades of optimization. We’re more likely to see Rust complementing C++ in those projects over time, for example how Firefox is leveraging Servo . But for new projects where you control the codebase, Zig is absolutely viable.&lt;/p&gt;
    &lt;head rend="h3"&gt;Where can I learn more about Zig?&lt;/head&gt;
    &lt;p&gt;Start with the official Zig documentation . The Zig Learn site provides practical tutorials. And join the community on Discord or ziggit.dev where developers actively help newcomers. The language is simple enough that reading standard library source code is also a viable learning approach.&lt;/p&gt;
    &lt;head rend="h3"&gt;Francis Bouvier&lt;/head&gt;
    &lt;head rend="h4"&gt;Cofounder &amp;amp; CEO&lt;/head&gt;
    &lt;p&gt;Francis previously cofounded BlueBoard, an ecommerce analytics platform acquired by ChannelAdvisor in 2020. While running large automation systems he saw how limited existing browsers were for this kind of work. Lightpanda grew from his wish to give developers a faster and more reliable way to automate the web.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=46165249</guid><pubDate>Fri, 05 Dec 2025 18:29:50 +0000</pubDate></item><item><title>Show HN: SerpApi MCP Server</title><link>https://github.com/serpapi/serpapi-mcp</link><description>&lt;doc fingerprint="1f42f8624f8caf58"&gt;
  &lt;main&gt;
    &lt;p&gt;A Model Context Protocol (MCP) server implementation that integrates with SerpApi for comprehensive search engine results and data extraction.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Multi-Engine Search: Google, Bing, Yahoo, DuckDuckGo, YouTube, eBay, and more&lt;/item&gt;
      &lt;item&gt;Real-time Weather Data: Location-based weather with forecasts via search queries&lt;/item&gt;
      &lt;item&gt;Stock Market Data: Company financials and market data through search integration&lt;/item&gt;
      &lt;item&gt;Dynamic Result Processing: Automatically detects and formats different result types&lt;/item&gt;
      &lt;item&gt;Flexible Response Modes: Complete or compact JSON responses&lt;/item&gt;
      &lt;item&gt;JSON Responses: Structured JSON output with complete or compact modes&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;SerpApi MCP Server is available as a hosted service at mcp.serpapi.com. In order to connect to it, you need to provide an API key. You can find your API key on your SerpApi dashboard.&lt;/p&gt;
    &lt;p&gt;You can configure Claude Desktop to use the hosted server:&lt;/p&gt;
    &lt;code&gt;{
  "mcpServers": {
    "serpapi": {
      "url": "https://mcp.serpapi.com/YOUR_SERPAPI_API_KEY/mcp"
    }
  }
}&lt;/code&gt;
    &lt;code&gt;git clone https://github.com/serpapi/serpapi-mcp.git
cd serpapi-mcp
uv sync &amp;amp;&amp;amp; uv run src/server.py&lt;/code&gt;
    &lt;p&gt;Configure Claude Desktop:&lt;/p&gt;
    &lt;code&gt;{
  "mcpServers": {
    "serpapi": {
      "url": "http://localhost:8000/YOUR_SERPAPI_API_KEY/mcp"
    }
  }
}&lt;/code&gt;
    &lt;p&gt;Get your API key: serpapi.com/manage-api-key&lt;/p&gt;
    &lt;p&gt;Two methods are supported:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Path-based: &lt;code&gt;/YOUR_API_KEY/mcp&lt;/code&gt;(recommended)&lt;/item&gt;
      &lt;item&gt;Header-based: &lt;code&gt;Authorization: Bearer YOUR_API_KEY&lt;/code&gt;&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Examples:&lt;/p&gt;
    &lt;code&gt;# Path-based
curl "https://mcp.serpapi.com/your_key/mcp" -d '...'

# Header-based  
curl "https://mcp.serpapi.com/mcp" -H "Authorization: Bearer your_key" -d '...'&lt;/code&gt;
    &lt;p&gt;The MCP server has one main Search Tool that supports all SerpApi engines and result types. You can find all available parameters on the SerpApi API reference.&lt;/p&gt;
    &lt;p&gt;The parameters you can provide are specific for each API engine. Some sample parameters are provided below:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;params.q&lt;/code&gt;(required): Search query&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;params.engine&lt;/code&gt;: Search engine (default: "google_light")&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;params.location&lt;/code&gt;: Geographic filter&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;mode&lt;/code&gt;: Response mode - "complete" (default) or "compact"&lt;/item&gt;
      &lt;item&gt;...see other parameters on the SerpApi API reference&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Examples:&lt;/p&gt;
    &lt;code&gt;{"name": "search", "arguments": {"params": {"q": "coffee shops", "location": "Austin, TX"}}}
{"name": "search", "arguments": {"params": {"q": "weather in London"}}}
{"name": "search", "arguments": {"params": {"q": "AAPL stock"}}}
{"name": "search", "arguments": {"params": {"q": "news"}, "mode": "compact"}}
{"name": "search", "arguments": {"params": {"q": "detailed search"}, "mode": "complete"}}&lt;/code&gt;
    &lt;p&gt;Supported Engines: Google, Bing, Yahoo, DuckDuckGo, YouTube, eBay, and more.&lt;/p&gt;
    &lt;p&gt;Result Types: Answer boxes, organic results, news, images, shopping - automatically detected and formatted.&lt;/p&gt;
    &lt;code&gt;# Local development
uv sync &amp;amp;&amp;amp; uv run src/server.py

# Docker
docker build -t serpapi-mcp . &amp;amp;&amp;amp; docker run -p 8000:8000 serpapi-mcp

# Testing with MCP Inspector
npx @modelcontextprotocol/inspector
# Configure: URL mcp.serpapi.com/YOUR_KEY/mcp, Transport "Streamable HTTP transport"&lt;/code&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;"Missing API key": Include key in URL path &lt;code&gt;/{YOUR_KEY}/mcp&lt;/code&gt;or header&lt;code&gt;Bearer YOUR_KEY&lt;/code&gt;&lt;/item&gt;
      &lt;item&gt;"Invalid key": Verify at serpapi.com/dashboard&lt;/item&gt;
      &lt;item&gt;"Rate limit exceeded": Wait or upgrade your SerpApi plan&lt;/item&gt;
      &lt;item&gt;"No results": Try different query or engine&lt;/item&gt;
    &lt;/list&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Fork the repository&lt;/item&gt;
      &lt;item&gt;Create your feature branch: &lt;code&gt;git checkout -b feature/amazing-feature&lt;/code&gt;&lt;/item&gt;
      &lt;item&gt;Install dependencies: &lt;code&gt;uv install&lt;/code&gt;&lt;/item&gt;
      &lt;item&gt;Make your changes&lt;/item&gt;
      &lt;item&gt;Commit changes: &lt;code&gt;git commit -m 'Add amazing feature'&lt;/code&gt;&lt;/item&gt;
      &lt;item&gt;Push to branch: &lt;code&gt;git push origin feature/amazing-feature&lt;/code&gt;&lt;/item&gt;
      &lt;item&gt;Open a Pull Request&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;MIT License - see LICENSE file for details.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=46165251</guid><pubDate>Fri, 05 Dec 2025 18:30:06 +0000</pubDate></item><item><title>The Debug Adapter Protocol is a REPL protocol in disguise</title><link>https://zignar.net/2025/06/23/debug-adapter-protocol-is-a-repl-protocol/</link><description>&lt;doc fingerprint="2e2f5958e6fd13f8"&gt;
  &lt;main&gt;
    &lt;head rend="h1"&gt;The Debug Adapter Protocol is a REPL protocol in disguise&lt;/head&gt;
    &lt;p&gt;Table of content&lt;/p&gt;
    &lt;p&gt;A couple months back I created nluarepl. Itâs a REPL for the Neovim Lua interpreter with a little twist: Itâs using the Debug Adapter Protocol. And before that, I worked on hprofdap. Also a kind of a REPL using DAP that lets you inspect Java heap dumps (&lt;code&gt;.hprof&lt;/code&gt; files) using OQL.&lt;/p&gt;
    &lt;p&gt;As the name might imply, a REPL isnât the main use case for the Debug Adapter Protocol (DAP). From the DAP page:&lt;/p&gt;
    &lt;quote&gt;
      &lt;p&gt;The idea behind the Debug Adapter Protocol (DAP) is to abstract the way how the debugging support of development tools communicates with debuggers or runtimes into a protocol.&lt;/p&gt;
    &lt;/quote&gt;
    &lt;p&gt;But it works surprisingly well for a REPL interface to a language interpreter too.&lt;/p&gt;
    &lt;head rend="h2"&gt;Essentials Â¶&lt;/head&gt;
    &lt;p&gt;The typical REPL shows you a prompt after which you can enter an expression. You then hit &lt;code&gt;Enter&lt;/code&gt; to submit the expression, it
gets evaluated and youâre presented with the result or an error.&lt;/p&gt;
    &lt;p&gt;The Debug Adapter protocol defines a &lt;code&gt;evaluate&lt;/code&gt;
command which - as the name implies - evaluates expressions.&lt;/p&gt;
    &lt;p&gt;The definition for the payload the client needs to send looks like this:&lt;/p&gt;
    &lt;code&gt;interface EvaluateArguments {
/**
      * The expression to evaluate.
   */
: string;
   expression
// [...]
    }&lt;/code&gt;
    &lt;p&gt;With a few more optional properties.&lt;/p&gt;
    &lt;p&gt;The (important bit) of the response format definition looks like this:&lt;/p&gt;
    &lt;code&gt;interface EvaluateResponse extends Response {
: {
   body/**
          * The result of the evaluate request.
     */
: string;
     result
/**
          * The type of the evaluate result.
     * This attribute should only be returned by a debug adapter if the
     * corresponding capability `supportsVariableType` is true.
     */
?: string;
     type
/**
          * If `variablesReference` is &amp;gt; 0, the evaluate result is structured and its
     * children can be retrieved by passing `variablesReference` to the
     * `variables` request as long as execution remains suspended. See 'Lifetime
     * of Object References' in the Overview section for details.
     */
: number;
     variablesReference
// [...]
      }&lt;/code&gt;
    &lt;p&gt;&lt;code&gt;result&lt;/code&gt; is a string and there is optionally a type. The
neat bit is the &lt;code&gt;variablesReference&lt;/code&gt;. Itâs used to model
structured data - allowing to build a tree-like UI to drill down into
the details of a data structure.&lt;/p&gt;
    &lt;p&gt;Here is a demo to see it in action:&lt;/p&gt;
    &lt;p&gt;To get the data - or expand an option as shown in the demo above, the client must call the &lt;code&gt;variables&lt;/code&gt;
command with the &lt;code&gt;variablesReference&lt;/code&gt; as payload. The
response has an array of variables, where a variable looks like
this:&lt;/p&gt;
    &lt;code&gt;interface Variable {
/**
      * The variable's name.
   */
: string;
   name
/**
      * The variable's value.
   * This can be a multi-line text, e.g. for a function the body of a function.
   * For structured variables (which do not have a simple value), it is
   * recommended to provide a one-line representation of the structured object.
   * This helps to identify the structured object in the collapsed state when
   * its children are not yet visible.
   * An empty string can be used if no value should be shown in the UI.
   */
: string;
   value
/**
      * The type of the variable's value. Typically shown in the UI when hovering
   * over the value.
   * This attribute should only be returned by a debug adapter if the
   * corresponding capability `supportsVariableType` is true.
   */
?: string;
   type

/**
      * If `variablesReference` is &amp;gt; 0, the variable is structured and its children
   * can be retrieved by passing `variablesReference` to the `variables` request
   * as long as execution remains suspended. See 'Lifetime of Object References'
   * in the Overview section for details.
   */
: number;
   variablesReference
// [...]
    }&lt;/code&gt;
    &lt;p&gt;A &lt;code&gt;Variable&lt;/code&gt; is pretty similar to the initial
&lt;code&gt;evaluate&lt;/code&gt; result, except that it has both name and value. It
also again has a &lt;code&gt;variablesReference&lt;/code&gt; property, which means
that they can be arbitrarily deeply nested (and you can have cyclic
references).&lt;/p&gt;
    &lt;head rend="h2"&gt;Extras Â¶&lt;/head&gt;
    &lt;p&gt;This already covers most of the functionality of a typical REPL backend. One more feature thatâs nice to have is completion, and the Debug Adapter Protocol also has a &lt;code&gt;completions&lt;/code&gt;
command for that. Click on the link if youâre interested - I wonât
go into detail about that here.&lt;/p&gt;
    &lt;p&gt;Another untypical feature for a REPL that the Debug Adapter Protocol provides is finding the locations of a variable definition. Thatâs also implemented in nluarepl, although it only works for functions.&lt;/p&gt;
    &lt;head rend="h2"&gt;The Boilerplate Â¶&lt;/head&gt;
    &lt;p&gt;You might be wondering if there is anything in the Debug Adapter Protocol one must implement thatâs useless baggage if all you want is a REPL frontend or backend.&lt;/p&gt;
    &lt;p&gt;Yes, there are are a few things:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Thereâs the RPC mechanism, which is close to JSON-RPC, but not quite.&lt;/item&gt;
      &lt;item&gt;Breakpoint handling. You can send back a response that rejects all. (nluarepl implements log points - which is basically dynamic log statements you can create at runtime)&lt;/item&gt;
      &lt;item&gt;Session initialization. Here you can send back the capabilities.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;launch&lt;/code&gt;/&lt;code&gt;attach&lt;/code&gt;pseudo handling.&lt;/item&gt;
      &lt;item&gt;Disconnect/terminate handling. Not much needed here - you can use these to clean up any state.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The typical flow is that a client starts a debug session with a &lt;code&gt;initialize&lt;/code&gt; command. Then the debug adapter replies with its
capabilities and a normal client follows up sending breakpoints. After
that it typically follows up with a &lt;code&gt;launch&lt;/code&gt; command, which
in a normal scenario would launch the application you want to debug.&lt;/p&gt;
    &lt;p&gt;To give you an impression of what this entails, hereâs a snippet of the nluarepl code to implement the âdummyâ actions:&lt;/p&gt;
    &lt;code&gt;function Client:initialize(request)
---@type dap.Capabilities
   local capabilities = {
   supportsLogPoints = true,
     supportsConditionalBreakpoints = true,
     supportsCompletionsRequest = true,
     completionTriggerCharacters = {"."},
     }
   self:send_response(request, capabilities)
   self:send_event("initialized", {})
   end


function Client:disconnect(request)
debug.sethook()
   self:send_event("terminated", {})
   self:send_response(request, {})
   end


function Client:terminate(request)
debug.sethook()
   self:send_event("terminated", {})
   self:send_response(request, {})
   end

function Client:launch(request)
self:send_response(request, {})
   end&lt;/code&gt;
    &lt;head rend="h2"&gt;Motivation Â¶&lt;/head&gt;
    &lt;p&gt;Final question: Why would you do that?&lt;/p&gt;
    &lt;p&gt;Partly because of lazyness. From a development perspective I didnât want to have to implement another REPL UI. Going the DAP route let me focus on the evaluation parts. And from a user perspective - I also wanted to re-use UI elements from nvim-dap. Iâm used to that interface and have keymaps setup. I didnât want to have another slightly different interface with different keymaps or behavior.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=46165555</guid><pubDate>Fri, 05 Dec 2025 18:51:38 +0000</pubDate></item><item><title>Framework Sponsors CachyOS</title><link>https://discuss.cachyos.org/t/framework-sponsorship-for-cachyos/19376</link><description>&lt;doc fingerprint="63857c9793fee7fb"&gt;
  &lt;main&gt;
    &lt;div&gt;
      &lt;div&gt;
        &lt;p&gt;Hey CachyOS Community,&lt;/p&gt;
        &lt;p&gt;We have some massive news to share today. Framework, the company behind the modular and repairable laptop revolution, is now sponsoring CachyOS.&lt;/p&gt;
        &lt;p&gt;For an open-source project like ours, finding hardware partners who genuinely care about Linux is rare. Framework has not only provided us with a Framework Laptop 16 to help us optimize our kernel and packages on modern hardware, but they have also committed to a $250 monthly donation.&lt;/p&gt;
        &lt;p&gt;While we are still a community-driven project, this contribution amounts to about 10% of our total monthly donations. Every bit of support like this helps stabilize our infrastructure and fuels our ultimate goal: eventually working on CachyOS full-time to bring you the fastest, most optimized Linux experience possible.&lt;/p&gt;
        &lt;p&gt;Please go show them some love and check out their blog post regarding further sponsorships:&lt;/p&gt;
        &lt;p&gt;Thanks to Framework and thanks to all of you for using CachyOS!&lt;/p&gt;
      &lt;/div&gt;
      &lt;p&gt; 25 Likes &lt;/p&gt;
    &lt;/div&gt;
    &lt;div&gt;
      &lt;div&gt;recall
2&lt;/div&gt;
      &lt;div&gt;
        &lt;p&gt;Name a more iconic duo&lt;/p&gt;
        &lt;p&gt;[congratulations, its well deserved]&lt;/p&gt;
      &lt;/div&gt;
      &lt;p&gt; 5 Likes &lt;/p&gt;
    &lt;/div&gt;
    &lt;div&gt;
      &lt;div&gt;Rabcor
3&lt;/div&gt;
      &lt;div&gt;
        &lt;p&gt;This is fantastic news! Congratulations.&lt;/p&gt;
      &lt;/div&gt;
      &lt;p&gt; 1 Like &lt;/p&gt;
    &lt;/div&gt;
    &lt;div&gt;
      &lt;div&gt;Dagrod
4&lt;/div&gt;
      &lt;div&gt;
        &lt;p&gt;I’m impressed. Congratulations on this success, may it advance the project!&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div&gt;
      &lt;div&gt;cscs
5&lt;/div&gt;
      &lt;div&gt;
        &lt;p&gt;Someone tell cloudflare so they can match it. &lt;/p&gt;
      &lt;/div&gt;
      &lt;p&gt; 4 Likes &lt;/p&gt;
    &lt;/div&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=46166536</guid><pubDate>Fri, 05 Dec 2025 20:03:21 +0000</pubDate></item><item><title>Fizz Buzz in CSS</title><link>https://susam.net/fizz-buzz-in-css.html</link><description>&lt;doc fingerprint="9edcd0375f8732b9"&gt;
  &lt;main&gt;
    &lt;head rend="h1"&gt;Fizz Buzz in CSS&lt;/head&gt;
    &lt;p&gt;By Susam Pal on 06 Dec 2025&lt;/p&gt;
    &lt;p&gt;What is the smallest CSS code we can write to print the Fizz Buzz sequence? I think it can be done in four lines of CSS as shown below:&lt;/p&gt;
    &lt;code&gt;
 li { counter-increment: n }
li:not(:nth-child(5n))::before { content: counter(n) }
li:nth-child(3n)::before { content: "Fizz" }
li:nth-child(5n)::after { content: "Buzz" }
&lt;/code&gt;
    &lt;p&gt;Here is a complete working example: css-fizz-buzz.html.&lt;/p&gt;
    &lt;p&gt;I am neither a web developer nor a code-golfer. Seasoned code-golfers looking for a challenge can probably shrink this solution further. However, such wizards are also likely to scoff at any mention of counting lines of code, since CSS can be collapsed into a single line. The number of characters is probably more meaningful. The code can also be minified slightly by removing all whitespace:&lt;/p&gt;
    &lt;code&gt;$ curl -sS https://susam.net/css-fizz-buzz.html | sed -n '/counter/,/after/p' | tr -d '[:space:]'
li{counter-increment:n}li:not(:nth-child(5n))::before{content:counter(n)}li:nth-child(3n)::before{content:"Fizz"}li:nth-child(5n)::after{content:"Buzz"}&lt;/code&gt;
    &lt;p&gt;This minified version is composed of 152 characters:&lt;/p&gt;
    &lt;code&gt;$ curl -sS https://susam.net/css-fizz-buzz.html | sed -n '/counter/,/after/p' | tr -d '[:space:]' | wc -c
152&lt;/code&gt;
    &lt;p&gt;If you manage to create a shorter solution, please do leave a comment.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=46166708</guid><pubDate>Fri, 05 Dec 2025 20:18:22 +0000</pubDate></item><item><title>Advertising as a major source of human dissatisfaction (2019) [pdf]</title><link>https://www.andrewoswald.com/docs/AdvertisingMicheletal2019EasterlinVolume.pdf</link><description></description><guid isPermaLink="false">https://news.ycombinator.com/item?id=46166709</guid><pubDate>Fri, 05 Dec 2025 20:18:34 +0000</pubDate></item><item><title>Judge Signals Win for Software Freedom Conservancy in Vizio GPL Case</title><link>https://fossforce.com/2025/12/judge-signals-win-for-software-freedom-conservancy-in-vizio-gpl-case/</link><description>&lt;doc fingerprint="afc23b01dea7233b"&gt;
  &lt;main&gt;
    &lt;head rend="h3"&gt;A California judge has tentatively sided with Software Freedom Conservancy in its GPL case over Vizio’s SmartCast TVs, but the final outcome of this week’s hearing is still pending.&lt;/head&gt;
    &lt;p&gt;We’re waiting to hear the final outcome of a legal case involving the GPL that harkens back to the bad “good ol’ days” of Linux and open source.&lt;/p&gt;
    &lt;p&gt;This case involves an action brought against Vizio — a maker of relatively low‑cost flat panel TVs — by Software Freedom Conservancy, which claims that the company has been in violation of the General Public License, version 2 and Lesser General Public License, version 2.1 for many years. The case centers around the company’s SmartCast TVs, which employ Linux, BusyBox, and other software licensed under GPLv2 and LGPLv2.1, without making source code available.&lt;/p&gt;
    &lt;p&gt;SFC’s standing in the case is as a purchaser of a Vizio smart TV and not as a copyright holder.&lt;/p&gt;
    &lt;p&gt;SFC has reported that early Thursday morning Judge Sandy N. Leal of the Superior Court of California issued a tentative ruling supporting SFC’s claim that Vizio has a duty to provide SFC with the complete source code covered under open source licenses to a TV it purchased. Being tentative, the ruling isn’t final– such rulings are issued so that the parties know how the judge is leaning and can tailor their oral arguments — and it was issued before a hearing scheduled for 10 a.m. PST the same day.&lt;/p&gt;
    &lt;p&gt;So far there’s been no news coming out of that hearing, although we’ve reached out to SFC for a comment.&lt;/p&gt;
    &lt;head rend="h2"&gt;A Predictable Outcome&lt;/head&gt;
    &lt;p&gt;These days the GPL and other open source licenses have been court tested enough to make the outcome in a case like this somewhat predictable: the courts will support the terms of the license. This hasn’t always been the case. For many years after the first adoption of the GPL as a free software license, and even later when the term open source came into use, it wasn’t clear whether courts would support the terms of open source licensing.&lt;/p&gt;
    &lt;p&gt;That began to change in the first decade of the 21st century as cases were brought against violators of open source licenses, with license terms being upheld by the courts.&lt;/p&gt;
    &lt;p&gt;Then in September 2007 the Software Freedom Law Center filed the first-ever US GPL enforcement lawsuit. The defendant was Monsoon Multimedia, for its Hava place‑shifting devices that SFLC claimed shipped with BusyBox installed without provisions for the source code. That case was dismissed about a month later, after Monsoon agreed to publish source code, appoint a compliance officer, notify customers of their GPL rights, and pay an undisclosed sum.&lt;/p&gt;
    &lt;p&gt;Later that year, SFLC brought additional BusyBox-related GPL suits against other vendors, including Xterasys and Verizon, over failure to provide source code. Those were also settled with compliance commitments and payments.&lt;/p&gt;
    &lt;head rend="h2"&gt;Vizio: A Goliath in Disguise&lt;/head&gt;
    &lt;p&gt;In the case against Vizio, SFC is going against a company that can afford a deep pocket defense if it decides to play hardball. The Irvine, California-based company that was founded in 2002 as a designer of televisions, soundbars, and related software and accessories, was acquired by Walmart for $2.3 billion in a deal that was announced in February 2024 and closed that December.&lt;/p&gt;
    &lt;p&gt;While the acquisition was in progress, Bloomberg announced that Walmart planned to end sales of Vizio products at Amazon and Best Buy in order to turn the company into a private label brand available only at Walmart and Sam’s Club locations.&lt;/p&gt;
    &lt;p&gt;Christine Hall has been a journalist since 1971. In 2001, she began writing a weekly consumer computer column and started covering Linux and FOSS in 2002 after making the switch to GNU/Linux. Follow her on Twitter: @BrideOfLinux&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=46166994</guid><pubDate>Fri, 05 Dec 2025 20:42:04 +0000</pubDate></item><item><title>Perpetual Futures</title><link>https://www.bitsaboutmoney.com/archive/perpetual-futures-explained/</link><description>&lt;doc fingerprint="e285119581a6a7b8"&gt;
  &lt;main&gt;
    &lt;p&gt;Programming note: Bits about Money is supported by our readers. I generally forecast about one issue a month, and haven't kept that pace that this year. As a result, I'm working on about 3-4 for December.&lt;/p&gt;
    &lt;p&gt;Much financial innovation is in the ultimate service of the real economy. Then, we have our friends in crypto, who occasionally do intellectually interesting things which do not have a locus in the real economy. One of those things is perpetual futures (hereafter, perps), which I find fascinating and worthy of study, the same way that a virologist just loves geeking out about furin cleavage sites.&lt;/p&gt;
    &lt;p&gt;You may have read a lot about stablecoins recently. I may write about them (again; see past BAM issue) in the future, as there has in recent years been some uptake of them for payments. But it is useful to understand that a plurality of stablecoins collateralize perps. Some observers are occasionally strategic in whether they acknowledge this, but for payments use cases, it does not require a lot of stock to facilitate massive flows. And so of the $300 billion or so in stablecoins presently outstanding, about a quarter sit on exchanges. The majority of that is collateralizing perp positions.&lt;/p&gt;
    &lt;p&gt;Perps are the dominant way crypto trades, in terms of volume. (It bounces around but is typically 6-8 times larger than spot.) This is similar to most traditional markets: where derivatives are available, derivative volume swamps spot volume. The degree to which depends on the market, Schelling points, user culture, and similar. For example, in India, most retail investing in equity is actually through derivatives; this is not true of the U.S. In the U.S., most retail equity exposure is through the spot market, directly holding stocks or indirectly through ETFs or mutual funds. Most trading volume of the stock indexes, however, is via derivatives.&lt;/p&gt;
    &lt;head rend="h2"&gt;Beginning with the problem&lt;/head&gt;
    &lt;p&gt;The large crypto exchanges are primarily casinos, who use the crypto markets as a source of numbers, in the same way a traditional casino might use a roulette wheel or set of dice. The function of a casino is for a patron to enter it with money and, statistically speaking, exit it with less. Physical casinos are often huge capital investments with large ongoing costs, including the return on that speculative capital. If they could choose to be less capital intensive, they would do so, but they are partially constrained by market forces and partially by regulation.&lt;/p&gt;
    &lt;p&gt;A crypto exchange is also capital intensive, not because the website or API took much investment (relatively low, by the standards of financial software) and not because they have a physical plant, but because trust is expensive. Bettors, and the more sophisticated market makers, who are the primary source of action for bettors, need to trust that the casino will actually be able to pay out winnings. That means the casino needs to keep assets (generally, mostly crypto, but including a smattering of cash for those casinos which are anomalously well-regarded by the financial industry) on hand exceeding customer account balances.&lt;/p&gt;
    &lt;p&gt;Those assets are… sitting there, doing nothing productive. And there is an implicit cost of capital associated with them, whether nominal (and borne by a gambler) or material (and borne by a sophisticated market making firm, crypto exchange, or the crypto exchange’s affiliate which trades against customers [0]).&lt;/p&gt;
    &lt;p&gt;Perpetual futures exist to provide the risk gamblers seek while decreasing the total capital requirement (shared by the exchange and market makers) to profitably run the enterprise.&lt;/p&gt;
    &lt;head rend="h2"&gt;Perps predate crypto but found a home there&lt;/head&gt;
    &lt;p&gt;In the commodities futures markets, you can contract to either buy or sell some standardized, valuable thing at a defined time in the future. The overwhelming majority of contracts do not result in taking delivery; they’re cancelled by an offsetting contract before that specified date.&lt;/p&gt;
    &lt;p&gt;Given that speculation and hedging are such core use cases for futures, the financial industry introduced a refinement: cash-settled futures. Now there is a reference price for the valuable thing, with a great deal of intellectual effort put into making that reference price robust and fair (not always successfully). Instead of someone notionally taking physical delivery of pork bellies or barrels of oil, people who are net short the future pay people who are net long the future on delivery day. (The mechanisms of this clearing are fascinating but outside today’s scope.)&lt;/p&gt;
    &lt;p&gt;Back in the early nineties economist Robert Shiller proposed a refinement to cash settled futures: if you don’t actually want pork bellies or oil barrels for consumption in April, and we accept that almost no futures participants actually do, why bother closing out the contracts in April? Why fragment the liquidity for contracts between April, May, June, etc? Just keep the market going perpetually.&lt;/p&gt;
    &lt;p&gt;This achieved its first widespread popular use in crypto (Bitmex is generally credited as being the popularizer), and hereafter we’ll describe the standard crypto implementation. There are, of course, variations available.&lt;/p&gt;
    &lt;head rend="h2"&gt;Multiple settlements a day&lt;/head&gt;
    &lt;p&gt;Instead of all of a particular futures vintage settling on the same day, perps settle multiple times a day for a particular market on a particular exchange. The mechanism for this is the funding rate. At a high level: winners get paid by losers every e.g. 4 hours and then the game continues, unless you’ve been blown out due to becoming overleveraged or for other reasons (discussed in a moment).&lt;/p&gt;
    &lt;p&gt;Consider a toy example: a retail user buys 0.1 Bitcoin via a perp. The price on their screen, which they understand to be for Bitcoin, might be $86,000 each, and so they might pay $8,600 cash. Should the price rise to $90,000 before the next settlement, they will get +/- $400 of winnings credited to their account, and their account will continue to reflect exposure to 0.1 units of Bitcoin via the perp. They might choose to sell their future at this point (or any other). They’ll have paid one commission (and a spread) to buy, one (of each) to sell, and perhaps they’ll leave the casino with their winnings, or perhaps they’ll play another game.&lt;/p&gt;
    &lt;p&gt;Where did the money come from? Someone else was symmetrically short exposure to Bitcoin via a perp. It is, with some very important caveats incoming, a closed system: since no good or service is being produced except the speculation, winning money means someone else lost.&lt;/p&gt;
    &lt;p&gt;One fun wrinkle for funding rates: some exchanges cap the amount the rate can be for a single settlement period. This is similar in intent to traditional markets’ usage of circuit breakers: designed to automatically blunt out-of-control feedback loops. It is dissimilar in that it cannot actually break circuits: changes to funding rate can delay realization of losses but can’t prevent them, since they don’t prevent the realization of symmetrical gains.&lt;/p&gt;
    &lt;p&gt;Perp funding rates also embed an interest rate component. This might get quoted as 3 bps a day, or 1 bps every eight hours, or similar. However, because of the impact of leverage, gamblers are paying more than you might expect: at 10X leverage that’s 30 bps a day. Consumer finance legislation standardizes borrowing costs as APR rather than basis points per day so that an unscrupulous lender can’t bury a 200% APR in the fine print.&lt;/p&gt;
    &lt;head rend="h2"&gt;Convergence in prices via the basis trade&lt;/head&gt;
    &lt;p&gt;Prices for perps do not, as a fact of nature, exactly match the underlying. That is a feature for some users.&lt;/p&gt;
    &lt;p&gt;In general, when the market is exuberant, the perp will trade above spot (the underlying market). To close the gap, a sophisticated market participant should do the basis trade: make offsetting trades in perps and spot (short the perp and buy spot, here, in equal size). Because the funding rate is set against a reference price for the underlying, longs will be paying shorts more (as a percentage of the perp’s current market price). For some of them, that’s fine: the price of gambling went up, oh well. For others, that’s a market incentive to close out the long position, which involves selling it, which will decrease the price at the margin (in the direction of spot).&lt;/p&gt;
    &lt;p&gt;The market maker can wait for price convergence; if it happens, they can close the trade at a profit, while having been paid to maintain the trade. If the perp continues to trade rich, they can just continue getting the increased funding cost. To the extent this is higher than their own cost of capital, this can be extremely lucrative.&lt;/p&gt;
    &lt;p&gt;Flip the polarities of these to understand the other direction.&lt;/p&gt;
    &lt;p&gt;The basis trade, classically executed, is delta neutral: one isn’t exposed to the underlying itself. You don’t need any belief in Bitcoin’s future adoption story, fundamentals, market sentiment, halvings, none of that. You’re getting paid to provide the gambling environment, including a really important feature: the perp price needs to stay reasonably close to the spot price, close enough to continue attracting people who want to gamble. You are also renting access to your capital for leverage.&lt;/p&gt;
    &lt;p&gt;You are also underwriting the exchange: if they blow up, your collateral becoming a claim against the bankruptcy estate is the happy scenario. (As one motivating example: Galois Capital, a crypto hedge fund doing basis trades, had ~40% of its assets on FTX when it went down. They then wound down the fund, selling the bankruptcy claim for 16 cents on the dollar.)&lt;/p&gt;
    &lt;p&gt;Recall that the market can’t function without a system of trust saying that someone is good for it if a bettor wins. Here, the market maker is good for it, via the collateral it kept on the exchange.&lt;/p&gt;
    &lt;p&gt;Many market makers function across many different crypto exchanges. This is one reason they’re so interested in capital efficiency: fully collateralizing all potential positions they could take across the universe of venues they trade on would be prohibitively capital intensive, and if they do not pre-deploy capital, they miss profitable trading opportunities. [1]&lt;/p&gt;
    &lt;head rend="h2"&gt;Leverage and liquidations&lt;/head&gt;
    &lt;p&gt;Gamblers like risk; it amps up the fun. Since one has many casinos to choose from in crypto, the ones which only “regular” exposure to Bitcoin (via spot or perps) would be offering a less-fun product for many users than the ones which offer leverage. How much leverage? More leverage is always the answer to that question, until predictable consequences start happening.&lt;/p&gt;
    &lt;p&gt;In a standard U.S. brokerage account, Regulation T has, for almost 100 years now, set maximum leverage limits (by setting minimums for margins). These are 2X at position opening time and 4X “maintenance” (before one closes out the position). Your brokerage would be obligated to forcibly close your position if volatility causes you to exceed those limits.&lt;/p&gt;
    &lt;p&gt;As a simplified example, if you have $50k of cash, you’d be allowed to buy $100k of stock. You now have $50k of equity and a $50k loan: 2x leverage. Should the value of that stock decline to about $67k, you still owe the $50k loan, and so only have $17k remaining equity. You’re now on the precipice of being 4X leveraged, and should expect a margin call very soon, if your broker hasn’t “blown you out of the trade” already.&lt;/p&gt;
    &lt;p&gt;What part of that is relevant to crypto? For the moment, just focus on that number: 4X.&lt;/p&gt;
    &lt;p&gt;Perps are offered at 1X (non-levered exposure). But they’re routinely offered at 20X, 50X, and 100X. SBF, during his press tour / regulatory blitz about being a responsible financial magnate fleecing the customers in an orderly fashion, voluntarily self-limited FTX to 20X.&lt;/p&gt;
    &lt;p&gt;One reason perps are structurally better for exchanges and market makers is that they simplify the business of blowing out leveraged traders. The exact mechanics depend on the exchange, the amount, etc, but generally speaking you can either force the customer to enter a closing trade or you can assign their position to someone willing to bear the risk in return for a discount.&lt;/p&gt;
    &lt;p&gt;Blowing out losing traders is lucrative for exchanges except when it catastrophically isn’t. It is a priced service in many places. The price is quoted to be low (“a nominal fee of 0.5%” is one way Binance describes it) but, since it is calculated from the amount at risk, it can be a large portion of the money lost. If the account’s negative balance is less than the liquidation fee, wonderful, thanks for playing and the exchange / “the insurance fund” keeps the rest, as a tip.&lt;/p&gt;
    &lt;p&gt;In the case where the amount an account is negative by is more than the fee, that “insurance fund” can choose to pay the winners on behalf of the liquidated user, at management’s discretion. Management will usually decide to do this, because a casino with a reputation for not paying winners will not long remain a casino.&lt;/p&gt;
    &lt;p&gt;But tail risk is a real thing. The capital efficiency has a price: there physically does not exist enough money in the system to pay all winners given sufficiently dramatic price moves. Forced liquidations happen. Sophisticated participants withdraw liquidity (for reasons we’ll soon discuss) or the exchange becomes overwhelmed technically / operationally. The forced liquidations eat through the diminished / unreplenished liquidity in the book, and the magnitude of the move increases.&lt;/p&gt;
    &lt;p&gt;Then crypto gets reminded about automatic deleveraging (ADL), a detail to perp contracts that few participants understand.&lt;/p&gt;
    &lt;head rend="h2"&gt;We have altered the terms of your unregulated futures investment contract.&lt;/head&gt;
    &lt;p&gt;(Pray we do not alter them further.)&lt;/p&gt;
    &lt;p&gt;Risk in perps has to be symmetric: if (accounting for leverage) there are 100,000 units of Somecoin exposure long, then there are 100,000 units of Somecoin exposure short. This does not imply that the shorts or longs are sufficiently capitalized to actually pay for all the exposure in all instances.&lt;/p&gt;
    &lt;p&gt;In cases where management deems paying winners from the insurance fund would be too costly and/or impossible, they automatically deleverage some winners. In theory, there is a published process for doing this, because it would be confidence-costing to ADL non-affiliated accounts but pay out affiliated accounts, one’s friends or particularly important counterparties, etc. In theory.&lt;/p&gt;
    &lt;p&gt;In theory, one likely ADLs accounts which were quite levered before ones which were less levered, and one ADLs accounts which had high profits before ones with lower profits. In theory. [2]&lt;/p&gt;
    &lt;p&gt;So perhaps you understood, prior to a 20% move, that you were 4X leveraged. You just earned 80%, right? Ah, except you were only 2X leveraged, so you earned 40%. Why were you retroactively only 2X? That’s what automatic deleveraging means. Why couldn’t you get the other 40% you feel entitled to? Because the collective group of losers doesn’t have enough to pay you your winnings and the insurance fund was insufficient or deemed insufficient by management.&lt;/p&gt;
    &lt;p&gt;ADL is particularly painful for sophisticated market participants doing e.g. a basis trade, because they thought e.g. they were 100 units short via perps and 100 units long somewhere else via spot. If it turns out they were actually 50 units short via perps, but 100 units long, their net exposure is +50 units, and they have very possibly just gotten absolutely shellacked.&lt;/p&gt;
    &lt;p&gt;In theory, this can happen to the upside or the downside. In practice in crypto, this seems to usually happen after sharp decreases in prices, not sharp increases. For example, October 2025 saw widespread ADLing as (more than) $19 billion of liquidations happened, across a variety of assets. Alameda’s CEO Caroline Ellison testified that they lost over $100 million during the collapse of Terra’s stablecoin in 2022, but since FTX’s insurance fund was made up; when leveraged traders lost money, their positions were frequently taken up by Alameda. That was quite lucrative much of the time, but catastrophically expensive during e.g. the Terra blowup. Alameda was a good loser and paid the winners, though: with other customers’ assets that they “borrowed.”&lt;/p&gt;
    &lt;head rend="h2"&gt;An aside about liquidations&lt;/head&gt;
    &lt;p&gt;In the traditional markets, if one’s brokerage deems one’s assets are unlikely to be able to cover the margin loan from the brokerage one has used, one’s brokerage will issue a margin call. Historically that gave one a relatively short period (typically, a few days) to post additional collateral, either by moving in cash, by transferring assets from another brokerage, or by experiencing appreciation in the value of one’s assets. Brokerages have the option, and in some cases the requirement, to manage risk after or during a margin call by forcing trades on behalf of the customer to close positions.&lt;/p&gt;
    &lt;p&gt;It sometimes surprises crypto natives that, in the case where one’s brokerage account goes negative and all assets are sold, with a negative remaining balance, the traditional markets largely still expect you to pay that balance. This contrasts with crypto, where the market expectation for many years was that the customer was Daffy Duck with a gmail address and a pseudonymous set of numbered accounts recorded on a blockchain, and dunning them was a waste of time. Crypto exchanges have mostly, in the intervening years, either stepped up their game regarding KYC or pretended to do so, but the market expectation is still that a defaulting user will basically never successfully recover. (Note that the legal obligation to pay is not coextensive with users actually paying. The retail speculators with $25,000 of capital that the pattern day trade rules are worried about will often not have $5,000 to cover a deficiency. On the other end of the scale, when a hedge fund blows up, the fund entity is wiped out, but its limited partners—pension funds, endowments, family offices—are not on the hook to the prime broker, and nobody expects the general partner to start selling their house to make up the difference.)&lt;/p&gt;
    &lt;p&gt;So who bears the loss when the customer doesn’t, can’t, or won’t? The waterfall depends on market, product type, and geography, but as a sketch: brokerages bear the loss first, out of their own capital. They’re generally required to keep a reserve for this purpose.&lt;/p&gt;
    &lt;p&gt;A brokerage will, in the ordinary course of business, have obligations to other parties which would be endangered if they were catastrophically mismanaged and could not successfully manage risk during a downturn. (It’s been known to happen, and even can be associated with assets rather than liabilities.) In this case, most of those counterparties are partially insulated by structures designed to insure the peer group. These include e.g. clearing pools, guaranty funds capitalized by the member firms of a clearinghouse, the clearinghouse’s own capital, and perhaps mutualized insurance pools. That is the rough ordering of the waterfall, which varies depending geography/product/market.&lt;/p&gt;
    &lt;p&gt;One can imagine a true catastrophe which burns through each of those layers of protection, and in that case, the clearinghouse might be forced to assess members or allocate losses across survivors. That would be a very, very bad day, but contracts exist to be followed on very bad days.&lt;/p&gt;
    &lt;p&gt;One commonality with crypto, though: this system is also not fully capitalized against all possible events at all times. Unlike crypto, which for contingent reasons pays some lip service to being averse to credit even as it embraces leveraged trading, the traditional industry relies extensively on underwriting risk of various participants.&lt;/p&gt;
    &lt;head rend="h2"&gt;Will crypto successfully “export” perps?&lt;/head&gt;
    &lt;p&gt;Many crypto advocates believe that they have something which the traditional finance industry desperately needs. Perps are crypto’s most popular and lucrative product, but they probably won’t be adopted materially in traditional markets.&lt;/p&gt;
    &lt;p&gt;Existing derivatives products already work reasonably well at solving the cost of capital issue. Liquidations are not the business model of traditional brokerages. And learning, on a day when markets are 20% down, that you might be hedged or you might be bankrupt, is not a prospect which fills traditional finance professionals with the warm fuzzies.&lt;/p&gt;
    &lt;p&gt;And now you understand the crypto markets a bit better.&lt;/p&gt;
    &lt;p&gt;[0] Brokers trading with their own customers can happen in the ordinary course of business, but has been progressively discouraged in traditional finance, as it enables frontrunning.&lt;/p&gt;
    &lt;p&gt;Frontrunning, while it is understood in the popular parlance to mean “trading before someone else can trade” and often brought up in discussions of high frequency trading using very fast computers, does not historically mean that. It historically describes a single abusive practice: a broker could basically use the slowness of traditional financial IT systems to give conditional post-facto treatment to customer orders, taking the other side of them (if profitable) or not (if not). Frontrunning basically disappeared because customers now get order confirms almost instantly by computer not at end of day via a phone call. The confirm has the price the trade executed at on it.&lt;/p&gt;
    &lt;p&gt;In classic frontrunning, you sent the customer’s order to the market (at some price X), waited a bit, and then observed a later price Y. If Y was worse for the customer than X, well, them’s the breaks on Wall Street. If Y was better, you congratulated the customer on their investing acumen, and informed them that they had successfully transacted at Z, a price of your choosing between X and Y. You then fraudulently inserted a recorded transaction between the customer and yourself earlier in the day, at price Z, and assigned the transaction which happened at X to your own account, not to the customer’s account.&lt;/p&gt;
    &lt;p&gt;Frontrunning was a lucrative scam while it lasted, because (effectively) the customer takes 100% of the risk of the trade but the broker gets any percentage they want of the first day’s profits. This is potentially so lucrative that smart money (and some investors in his funds!) thought Madoff was doing it, thus generating the better-than-market stable returns for over a decade through malfeasance. Of frontrunning Madoff was entirely innocent.&lt;/p&gt;
    &lt;p&gt;Some more principled crypto participants have attempted to discourage exchanges from trading with their own customers. They have mostly been unsuccessful: Merit Peak Limited is Binance’s captive entity which does this. It also is occasionally described by U.S. federal agencies as running a sideline in money laundering, Alameda Research was FTX’s affiliated trading fund. Their management was criminally convicted of money laundering. etc, etc.&lt;/p&gt;
    &lt;p&gt;One of the reasons this behavior is so adaptive is because the billions of dollars sloshing around can be described to banks as “proprietary trading” and “running an OTC desk”, and an inattentive bank (like, say, Silvergate, as recounted here) might miss the customer fund flows they would have been formally unwilling to facilitate. This is a useful feature for sophisticated crypto participants, and so some of them do not draw attention to the elephant in the room, even though it is averse to their interests.&lt;/p&gt;
    &lt;p&gt;[1] Not all crypto trades are pre-funded. Crypto OTC transactions sometimes settle on T+1, with the OTC desk essentially extending credit in the fashion that a prime broker would in traditional markets. But most transactions on exchanges have to be paid immediately in cash already at the venue. This is very different from traditional equity market structure, where venues don’t typically receive funds flow at all, and settling/clearing happens after the fact, generally by a day or two.&lt;/p&gt;
    &lt;p&gt;[2] I note, for the benefit of readers of footnote 0, that there is often a substantial gap between the time when market dislocation happens and when a trader is informed they were ADLed. The implications of this are left as an exercise to the reader.&lt;/p&gt;
    &lt;head rend="h2"&gt;Want more essays in your inbox?&lt;/head&gt;
    &lt;p&gt;I write about the intersection of tech and finance, approximately biweekly. It's free.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=46167500</guid><pubDate>Fri, 05 Dec 2025 21:23:03 +0000</pubDate></item><item><title>A $20 drug in Europe requires a prescription and $800 in the U.S.</title><link>https://www.statnews.com/2025/10/31/why-miebo-costs-40-times-more-than-its-european-version/</link><description>&lt;doc fingerprint="2c4c90132f273fa2"&gt;
  &lt;main&gt;
    &lt;p&gt;A month’s supply of Miebo, Bausch &amp;amp; Lomb’s prescription dry eye drug, costs $800 or more in the U.S. before insurance. But the same drug — sold as EvoTears — has been available over-the-counter (OTC) in Europe since 2015 for about $20. I ordered it online from an overseas pharmacy for $32 including shipping, and it was delivered in a week.&lt;/p&gt;
    &lt;p&gt;This is, of course, both shocking and unsurprising. A 2021 RAND study found U.S. prescription drug prices are, on average, more than 2.5 times higher than in 32 other developed nations. Miebo exemplifies how some pharmaceutical companies exploit regulatory loopholes and patent protections, prioritizing profits over patients, eroding trust in health care. But there is a way to fix this loophole.&lt;/p&gt;
    &lt;p&gt;In December 2019, Bausch &amp;amp; Lomb, formerly a division of Valeant, acquired the exclusive license for the commercialization and development in the United States and Canada for NOV03, now called Miebo in the U.S. Rather than getting an approval for an OTC drug, like it is in Europe, Bausch secured U.S. Food and Drug Administration approval as a prescription medication, subsequently pricing it at a high level. Currently, according to GoodRx, a monthly supply of Miebo will cost $830.27 at Walgreens, and it’s listed at $818.38 on Amazon Pharmacy.&lt;/p&gt;
    &lt;p&gt;The strategy has paid off: Miebo’s 2024 sales — its first full year — hit $172 million, surpassing the company’s projections of $95 million. The company now forecasts sales to exceed $500 million annually. At European prices, those sales would be less than $20 million. Emboldened with Miebo’s early success, Bausch &amp;amp; Lomb raised the price another 4% in 2025, according to the drug price tracking firm 46brooklyn.&lt;/p&gt;
    &lt;p&gt;Bausch &amp;amp; Lomb has a track record of prioritizing profits over patients. As Valeant, its business model was simple: buy, gut, gouge, repeat. In 2015, it raised prices for Nitropress and Isuprel by over 200% and 500%, respectively, triggering a 2016 congressional hearing. Despite promises of reform, little has changed. When he was at Allergan, Bausch &amp;amp; Lomb’s current CEO, Brent Saunders, pledged “responsible pricing” but tried to extend patent protection for Allergan’s drug Restasis (another dry eye drug) through a dubious deal with the Mohawk Indian tribe, later rejected by courts.&lt;/p&gt;
    &lt;p&gt;Now at Bausch &amp;amp; Lomb, Saunders oversaw Miebo’s launch, claiming earlier this year in an investor call, “We are once again an innovation company.” But finding a way to get an existing European OTC drug to be a prescription drug in the U.S. with a new name and a 40-fold price increase is not true innovation — it’s a price-gouging strategy.&lt;/p&gt;
    &lt;p&gt;Bausch &amp;amp; Lomb could have pursued OTC approval in the U.S., leveraging its expertise in OTC eye drops and lotions. However, I could not find in transcripts or presentations any evidence that Baush &amp;amp; Lomb seriously pursued this. Prescription status, however, ensures much higher prices, protected by patents and limited competition. Even insured patients feel the ripple effects: Coupons may reduce out-of-pocket costs, but insurers pay hundreds per prescription, driving up premiums and the overall cost of health care for everyone.&lt;/p&gt;
    &lt;p&gt;In response to questions from STAT about why Miebo is an expensive prescription drug, a representative said in a statement, “The FDA determined that MIEBO acts at the cellular and molecular level of the eye, which meant it had to go through the same rigorous process as any new pharmaceutical — a full New Drug Application. Unlike in Europe, where all medical device eye drops are prescription-free and cleared through a highly predictable and fast pathway, we were required to design, enroll and complete extensive clinical trials involving thousands of patients, and provide detailed safety and efficacy data submissions. Those studies took years and significant investment, but they ensure that MIEBO meets the highest regulatory standards for safety and effectiveness.”&lt;/p&gt;
    &lt;p&gt;Bausch &amp;amp; Lomb’s carefully worded response expertly sidesteps the real issue. The FDA’s test for OTC status isn’t a drug’s mechanism of action — it’s whether patients can use it safely without a doctor. Miebo’s track record as an OTC product in Europe for nearly a decade shows it meets that standard. Bausch &amp;amp; Lomb provides no evidence, or even assertion, that it ever tried for OTC approval in the U.S. Instead, it pursued the prescription route — not because of regulatory necessity, but as a business strategy to secure patents and command an $800 price. In doing so, B&amp;amp;L is weaponizing a regulatory loophole against American patients, prioritizing profit over access, and leaving their “significant investment” as the cost of monopoly, not medical necessity.&lt;/p&gt;
    &lt;p&gt;Even if you accept Bausch &amp;amp; Lomb’s self-serving rationale, the answer is not to allow the loophole to persist, but to close it. The FDA could require any drug approved as OTC internationally be considered for OTC status in the United States before greenlighting it as a prescription product — and mandate retroactive review of cases like Miebo.&lt;/p&gt;
    &lt;p&gt;The FDA’s OTC monograph process, which assesses the safety and efficacy of nonprescription drugs, makes this feasible, though it may need to be adjusted slightly. Those changes might involve incorporating a mechanism to make sure that overseas OTC status triggers a review of U.S. prescription drugs containing the same active ingredients or formulations for potential OTC designation; developing criteria to assess equivalency in safety and efficacy standards between U.S. OTC requirements and those of other countries; and establishing a retroactive review pathway within the monograph process to handle existing prescription drugs already marketed OTC internationally.&lt;/p&gt;
    &lt;p&gt;EvoTears thrives abroad without safety concerns, countering industry claims of stricter U.S. standards. This reform would deter companies from repackaging OTC drugs as high-cost prescriptions, fostering competition and lowering prices.&lt;/p&gt;
    &lt;p&gt;While this tactic isn’t widespread, it joins loopholes like late-listed patents, picket fence patents, or pay-for-delay generic deals that undermine trust in an industry whose employees largely aim to save lives.&lt;/p&gt;
    &lt;p&gt;Miebo also shows how global reference pricing could save billions. Aligning with European prices could cut consumer costs while reducing doctor visits, pharmacy time, and administrative burdens. For patients who skip doses to afford groceries, lower prices would mean better access and health. Reforms like the 2022 Inflation Reduction Act’s Medicare price negotiations set a precedent, but targeted rules are urgently needed.&lt;/p&gt;
    &lt;p&gt;Unexplained differences in drug prices between the U.S. and other wealthy countries erode the public’s trust in health care. Companies like Bausch &amp;amp; Lomb exploit systemic gaps, leaving patients and payers to foot exorbitant bills. An OTC evaluation rule, with retroactive reviews, is a practical first step, signaling that patient access takes precedence over corporate greed.&lt;/p&gt;
    &lt;p&gt;Let’s end the price-gouging practices of outliers and build a health care system that puts patients first. Just as targeting criminal outliers fosters a law-abiding society, holding bad pharmaceutical actors accountable is crucial for restoring trust and integrity to our health care system. While broader approaches to making health care more fair, accessible, and affordable are needed, sometimes the way to save billions is to start by saving hundreds of millions.&lt;/p&gt;
    &lt;p&gt;David Maris is a six-time No. 1 ranked pharmaceutical analyst with more than two decades covering the industry. He currently runs Phalanx Investment Partners, a family office; is a partner in Wall Street Beats; and is co-author of the recently published book “The Fax Club Experiment.” He is currently working on his next book about health care in America.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=46167557</guid><pubDate>Fri, 05 Dec 2025 21:27:22 +0000</pubDate></item><item><title>Frank Gehry Died</title><link>https://www.bbc.co.uk/news/articles/c5y2p22z9gno</link><description>&lt;doc fingerprint="febd1c1ad7fbaf4"&gt;
  &lt;main&gt;
    &lt;head rend="h1"&gt;Legendary architect Frank Gehry dies aged 96&lt;/head&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Published&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Frank Gehry, one of the most influential architects of the last century, has died aged 96.&lt;/p&gt;
    &lt;p&gt;Gehry was acclaimed for his avant garde, experimental style of architecture. His titanium-covered design of the Guggenheim Museum in Bilbao, Spain, catapulted him to fame in 1997.&lt;/p&gt;
    &lt;p&gt;He built his daring reputation years before that when he redesigned his own home in Santa Monica, California, using materials like chain-link fencing, plywood and corrugated steel.&lt;/p&gt;
    &lt;p&gt;"Gehry is survived by two daughters from his first marriage, Leslie and Brina; his wife, Berta Isabel Aguilera, and their two sons, Alejandro and Samuel," his chief of staff Meaghan Lloyd told the BBC on Friday.&lt;/p&gt;
    &lt;p&gt;Born in Toronto in 1929, Gehry moved to Los Angeles as a teenager to study architecture at the University of Southern California.&lt;/p&gt;
    &lt;p&gt;After starting his own firm, he broke from the traditional architectural principles of symmetry, using unconventional geometric shapes and unfinished materials in a style now known as deconstructivism.&lt;/p&gt;
    &lt;p&gt;"I was rebelling against everything," Gehry said in an interview with The New York Times in 2012.&lt;/p&gt;
    &lt;p&gt;His work in Bilbao put him in high demand, and he went on to design iconic structures in cities all over the world: the Jay Pritzker Pavilion in Chicago's Millennium Park, the Gehry Tower in Germany, and the Louis Vuitton Foundation in Paris.&lt;/p&gt;
    &lt;p&gt;"He bestowed upon Paris and upon France his greatest masterpiece," said Bernard Arnault, the CEO of LVMH, the worlds largest luxury goods company which owns Louis Vuitton.&lt;/p&gt;
    &lt;p&gt;With a largely unpredictable style, no two of his works look the same. Prague's Dancing House, finished in 1996, looks like a glass building folding in on itself; his Hotel Marques in Spain, built in 2006, features thin sheets of wavy, multicoloured metal; his design for a business school in Sydney looks like a brown paper bag.&lt;/p&gt;
    &lt;p&gt;Gehry won the coveted Pritzker Architecture Prize for lifetime achievement in 1989, when he was 60.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=46167621</guid><pubDate>Fri, 05 Dec 2025 21:31:40 +0000</pubDate></item></channel></rss>