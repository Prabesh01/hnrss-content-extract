<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>Hacker News: Front Page</title><link>https://raw.githubusercontent.com/Prabesh01/hnrss-content-extract/refs/heads/main/out/rss.xml</link><description>Hacker News RSS</description><atom:link href="https://raw.githubusercontent.com/Prabesh01/hnrss-content-extract/refs/heads/main/out/rss.xml" rel="self"/><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><language>en</language><lastBuildDate>Tue, 04 Nov 2025 10:44:39 +0000</lastBuildDate><item><title>State of Terminal Emulators in 2025: The Errant Champions</title><link>https://www.jeffquast.com/post/state-of-terminal-emulation-2025/</link><description>&lt;doc fingerprint="b60308d6479438c4"&gt;
  &lt;main&gt;
    &lt;p&gt;This is a follow-up to my previous article, Terminal Emulators Battle Royale â Unicode Edition! from 2023, in which I documented Unicode support across terminal emulators. Since then, the ucs-detect tool and its supporting blessed library have been extended to automatically detect support of DEC Private Modes, sixel graphics, pixel size, and software version.&lt;/p&gt;
    &lt;p&gt;The ucs-detect program tests terminal cursor positioning by sending visible text followed by control sequences that request the cursor position. The terminal responds by writing the cursor location as simulated keyboard input. The ucs-detect program reads and compares these values against the Python wcwidth library result, logging any discrepancies.&lt;/p&gt;
    &lt;head rend="h2"&gt;The Width Problem&lt;/head&gt;
    &lt;p&gt;Terminal emulators face a fundamental challenge: mapping the vast breadth of Unicode scripts into a fixed-width grid while maintaining legibility. A terminal must predict whether each character occupies one cell or two, whether combining marks overlay previous characters, and how emoji sequences collapse into single glyphs.&lt;/p&gt;
    &lt;p&gt;These predictions fail routinely. Zero-width joiners, variation selectors, and grapheme clustering compound in complexity. When terminals and CLI applications guess wrong, text becomes unreadable - cursors misalign and corrupt output and so then also corrupt the location of our input.&lt;/p&gt;
    &lt;p&gt;Our results share which terminals have the best "Unicode support" -- the least likely to exhibit these kinds of problems.&lt;/p&gt;
    &lt;head rend="h2"&gt;The Gentleman Errant&lt;/head&gt;
    &lt;p&gt;Before presenting the latest results, Ghostty warrants particular attention, not only because it scored the highest among all terminals tested, but that it was publicly released only this year by Mitchell Hashimoto. It is a significant advancement. Developed from scratch in zig, the Unicode support implementation is thoroughly correct.&lt;/p&gt;
    &lt;p&gt;In 2023, Mitchell published Grapheme Clusters and Terminal Emulators, demonstrating a commitment to understanding and implementing the fundamentals. His recent announcement of libghostty provides a welcome alternative to libvte, potentially enabling a new generation of terminals on a foundation of strong Unicode support.&lt;/p&gt;
    &lt;head rend="h2"&gt;The Errant Champion&lt;/head&gt;
    &lt;p&gt;Kovid Goyal's Kitty scored just as well, only outranked by the arbitrary weights that are not necessarily fair. More important than scoring is Kovid's publication of a text-splitting algorithm description that closely matches the Python wcwidth specification. This is unsurprising since both are derived from careful interpretation of Unicode.org standards and that it scores so highly in our test.&lt;/p&gt;
    &lt;p&gt;Kitty and Ghostty are the only terminals that correctly support Variation Selector 15, I have not written much about it because it is not likely to see any practical use, but, it will be added to a future release of Python wcwidth now that there are multiple standards and reference implementations in agreement.&lt;/p&gt;
    &lt;head rend="h2"&gt;Testing Results&lt;/head&gt;
    &lt;p&gt;The first table, General Tabulated Summary describes unicode features of each terminal, then, a brief summary of DEC Private Modes, sixel support, and testing time.&lt;/p&gt;
    &lt;p&gt;The second table, DEC Private Modes Support (not pictured), contains the first feature capability matrix of DEC Private Modes for Terminals of any length. I hope this is useful most especially to developers of CLI libraries and applications.&lt;/p&gt;
    &lt;head rend="h2"&gt;The Long Road&lt;/head&gt;
    &lt;p&gt;The most notable finding relates to performance. That many terminals perform so slowly was surprising, so I have included the elapsed time in the results.&lt;/p&gt;
    &lt;p&gt;iTerm2 and Extraterm consume a majority of the CPU and perform so slowly that the test parameters were reduced to finish within the hour what many other terminals manage in a few minutes.&lt;/p&gt;
    &lt;p&gt;GNOME Terminal and its VTE-based derivatives also perform too slowly for a full test, taking over 5 hours while consuming very little CPU. Many terminals exhibit stalls or inefficiencies in their event loops that result in slow automatic responses, but we should be forgiving; nobody really considered the need to handle hundreds of automatic sequence replies per second!&lt;/p&gt;
    &lt;p&gt;I expected Python wcwidth to consume the most CPU resources during testing, as it is frequently called and always the "highest-level" language in the mix, but it keeps up pretty well for most terminals.&lt;/p&gt;
    &lt;p&gt;Earlier this year, I dedicated effort to optimizing the Python wcwidth implementation using techniques including bit vectors, bloom filters, and varying sizes of LRU caches. The results confirmed that the existing implementation performed best: a binary search with a functools.lru_cache decorator.&lt;/p&gt;
    &lt;p&gt;The LRU cache is effective because human languages typically use a small, repetitive subset of Unicode. The ucs-detect tool tests hundreds of languages from the UDHR dataset, excluding only those without any interesting zero or wide characters. This dataset provides an extreme but practical demonstration of LRU cache benefits when processing Unicode.&lt;/p&gt;
    &lt;p&gt;I previously considered distributing a C module with Python wcwidth for greater performance, but the existing Python implementation keeps up well enough with the fastest terminals. When fully exhausted the text scroll speed is fast enough to produce screen tearing artifacts.&lt;/p&gt;
    &lt;head rend="h2"&gt;Tilting at Edges&lt;/head&gt;
    &lt;p&gt;Terminology produces inconsistent results between executions. Our tests are designed to be deterministic, so these kinds of results suggest possible state corruption. Despite this issue, Terminology offers interesting visual effects that would be a welcome feature in other terminals.&lt;/p&gt;
    &lt;p&gt;iTerm2 reports "supported, but disabled, and cannot be changed" status for all DEC Private Modes queried, including fictional modes like 9876543. For this reason, the summary of DEC Private Modes shows only those modes that are changeable.&lt;/p&gt;
    &lt;p&gt;Konsole does not reply to queries about DEC Private modes, but does support several modes when they are enabled. For this reason, ucs-detect cannot automatically infer which DEC Modes Konsole supports.&lt;/p&gt;
    &lt;p&gt;Similarly, ucs-detect reports "No DEC Private Mode Support" for Contour. I investigated this discrepancy because Contour's author also authored a Mode 2027 specification dependent on this functionality. The issue was that Contour responded with a different mode number than the one queried. While developing a fix, Contour's latest release from December 2024 presented an additional complication: a bad escape key configuration. Each instance of being stuck in vi required typing CTRL + [ as a workaround!&lt;/p&gt;
    &lt;p&gt;Terminals based on libvte with software version label VTE/7600 continue to show identical performance with low scores in our tests, unchanged from 2023.&lt;/p&gt;
    &lt;p&gt;My attempt to discuss improving Unicode support in libvte received substantial criticism. However, recent libvte project issue Support Emoji Sequences is a positive indicator for improved language and Emoji support in 2026.&lt;/p&gt;
    &lt;head rend="h2"&gt;On Mode 2027&lt;/head&gt;
    &lt;p&gt;I included DEC Private Mode 2027 in the results to accompany Mitchell's table from his article, Grapheme Clusters and Terminal Emulators, and to verify for myself that it has limited utility.&lt;/p&gt;
    &lt;p&gt;In theory, a CLI program can query this mode to classify a terminal as "reasonably supporting" unicode, but not which specific features or version level. Since other terminals with similar capabilities do not respond to Mode 2027 queries, this binary indicator has limited utility.&lt;/p&gt;
    &lt;p&gt;The only practical approach to determining Unicode support of a terminal is to interactively test for specific features, codepoints, and at the Unicode version levels of interest, as ucs-detect does.&lt;/p&gt;
    &lt;head rend="h2"&gt;Beyond Fixed Widths&lt;/head&gt;
    &lt;p&gt;Terminals cannot reproduce many of the world's languages legibly when constrained to monospace cells. The measurements dictated by rapidly expanding Unicode standards and varying implementation levels create inherent tension.&lt;/p&gt;
    &lt;p&gt;The text sizing protocol published early this year represents a significant development. Kovid Goyal describes the motivation in a recent interview:&lt;/p&gt;
    &lt;quote&gt;And then my next windmill that I'm looking at is variable-sized text in the terminal. So when I'm catting a markdown file, I want to see the headings big.&lt;/quote&gt;
    &lt;p&gt;While this feature may enable more advanced typesetting-like capabilities in terminal apps, it also promises to increase accessibility. Allowing text to escape monospace constraints enables legible support of the diverse set of the world's languages.&lt;/p&gt;
    &lt;p&gt;For example, using Contour with ucs-detect --stop-at-error=lang, stopping to take a look at a result of the language KhÃ¼n:&lt;/p&gt;
    &lt;p&gt;In this case Contour and Python wcwidth disagree on measurement, but more important is the legibility. We can compare this given KhÃ¼n text to the Kate editor:&lt;/p&gt;
    &lt;p&gt;They are clearly different. I regret I cannot study it more carefully, but I suggest that terminals could more easily display complex scripts by switching to a variable size text mode, allowing the font engine to drive the text without careful processing of cell and cursor movement.&lt;/p&gt;
    &lt;p&gt;Although I have yet to experiment with it, I am encouraged to see some resolution to this problem by the progressive changes suggested by the text sizing protocol.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=45799478</guid><pubDate>Mon, 03 Nov 2025 14:40:51 +0000</pubDate></item><item><title>Ask HN: Who wants to be hired? (November 2025)</title><link>https://news.ycombinator.com/item?id=45800464</link><description>&lt;doc fingerprint="301182753412e0e7"&gt;
  &lt;main&gt;
    &lt;div&gt;
      &lt;p&gt;Share your information if you are looking for work. Please use this format:&lt;/p&gt;
      &lt;quote&gt;
        &lt;code&gt;  Location:
  Remote:
  Willing to relocate:
  Technologies:
  Résumé/CV:
  Email:
&lt;/code&gt;
      &lt;/quote&gt;
      &lt;p&gt; Please only post if you are personally looking for work. Agencies, recruiters, job boards, and so on, are off topic here.&lt;/p&gt;
      &lt;p&gt;Readers: please only email these addresses to discuss work opportunities.&lt;/p&gt;
      &lt;p&gt;There's a site for searching these posts at https://www.wantstobehired.com.&lt;/p&gt;
    &lt;/div&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=45800464</guid><pubDate>Mon, 03 Nov 2025 16:00:00 +0000</pubDate></item><item><title>Ask HN: Who is hiring? (November 2025)</title><link>https://news.ycombinator.com/item?id=45800465</link><description>&lt;doc fingerprint="3741985a3402e664"&gt;
  &lt;main&gt;
    &lt;div&gt;&lt;p&gt;Please state the location and include REMOTE for remote work, REMOTE (US) or similar if the country is restricted, and ONSITE when remote work is &lt;/p&gt;not&lt;p&gt; an option.&lt;/p&gt;&lt;p&gt;Please only post if you personally are part of the hiring company—no recruiting firms or job boards. One post per company. If it isn't a household name, explain what your company does.&lt;/p&gt;&lt;p&gt;Please only post if you are actively filling a position and are committed to responding to applicants.&lt;/p&gt;&lt;p&gt;Commenters: please don't reply to job posts to complain about something. It's off topic here.&lt;/p&gt;&lt;p&gt;Readers: please only email if you are personally interested in the job.&lt;/p&gt;&lt;p&gt;Searchers: try https://dheerajck.github.io/hnwhoishiring/, http://nchelluri.github.io/hnjobs/, https://hnresumetojobs.com, https://hnhired.fly.dev, https://kennytilton.github.io/whoishiring/, https://hnjobs.emilburzo.com, or this (unofficial) Chrome extension: https://chromewebstore.google.com/detail/hn-hiring-pro/mpfal....&lt;/p&gt;&lt;p&gt;Don't miss this other fine thread: Who wants to be hired? https://news.ycombinator.com/item?id=45800464&lt;/p&gt;&lt;/div&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=45800465</guid><pubDate>Mon, 03 Nov 2025 16:00:00 +0000</pubDate></item><item><title>Learning to read Arthur Whitney's C to become smart (2024)</title><link>https://needleful.net/blog/2024/01/arthur_whitney.html</link><description>&lt;doc fingerprint="2eb9d195bc6fba9c"&gt;
  &lt;main&gt;
    &lt;p&gt;Burger.&lt;/p&gt;
    &lt;head rend="h3"&gt;it's not working&lt;/head&gt;
    &lt;head rend="h5"&gt;Written January 19, 2024&lt;/head&gt;
    &lt;p&gt;Arthur Whitney is an esteemed computer scientist who led the design on a few well-known pieces of software:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;The A, K, and Q programming languages&lt;/item&gt;
      &lt;item&gt;kdb, a high-performance database built on K used in fintech&lt;/item&gt;
      &lt;item&gt;Shakti, which is like kdb but faster, designed for trillion-row datasets.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;I've never even seen a trillion numbers, much less calculated them, but kdb is apparently a standard tool on Wall Street. They probably care about money, so I'll assume kdb does its job well. His languages take significantly after APL, which was a very popular language for similar applications before the invention of (qwerty) keyboards.&lt;/p&gt;
    &lt;p&gt;But I'm not here to talk about boring things like "using software to make incomprehensible amounts of money in finance" or "human beings and their careers", I'm here to talk about how a guy writes C code weird. For a very simple version of the programming language K, there's a publicly available interpreter he wrote in a few days using about 50 lines of C to show the basics of interpreter writing. This is the C (specifically the January 16, 2024 version #2):&lt;/p&gt;
    &lt;head rend="h2"&gt;a.h&lt;/head&gt;
    &lt;code&gt;typedef char*s,c;s Q=(s)128;&amp;#13;
#define _(e...) ({e;})&amp;#13;
#define x(a,e...) _(s x=a;e)&amp;#13;
#define $(a,b) if(a)b;else&amp;#13;
#define i(n,e) {int $n=n;int i=0;for(;i&amp;lt;$n;++i){e;}}&amp;#13;
&amp;#13;
#define Q(e) if(Q==(e))return Q;&amp;#13;
#define Qs(e,s) if(e)return err(__func__,s);&amp;#13;
#define Qr(e) Qs(e,"rank")&amp;#13;
#define Qd(e) Qs(e,"domain")&amp;#13;
#define Qz(e) Qs(e,"nyi")&amp;#13;
&amp;#13;
#define _s(f,e,x...) s f(x){return _(e);}&amp;#13;
#define _i(f,e) _s(f,e,c x)&amp;#13;
#define f(f,e)  _s(f,e,s x)&amp;#13;
#define F(f,e)  _s(f,e,s a,s x)&amp;#13;
&amp;#13;
#define ax (256&amp;gt;x)&amp;#13;
#define ix (c)x&amp;#13;
#define nx x[-1]&amp;#13;
#define xi x[i]&amp;#13;
&amp;#13;
#define aa x(a,ax)&amp;#13;
#define ia x(a,ix)&amp;#13;
#define na x(a,nx)&amp;#13;
&amp;#13;
#define oo w("oo\n")&lt;/code&gt;
    &lt;head rend="h2"&gt;a.c&lt;/head&gt;
    &lt;code&gt;#include"a.h"//fF[+-!#,@] atom/vector 1byte(int/token) clang-13 -Os -oa a.c -w &amp;#13;
#define r(n,e) _(s r=m(n);i(n,r[i]=e)r)&amp;#13;
f(w,write(1,ax?&amp;amp;x:x,ax?1:strlen(x));x)F(err,w(a);w((s)58);w(x);w((s)10);Q)&amp;#13;
_i(wi,s b[5];sprintf(b,"%d ",x);w(b);0)&amp;#13;
f(W,Q(x)$(ax,wi(ix))i(nx,wi(xi))w(10);x)&amp;#13;
&amp;#13;
f(srt,Qz(1)0)f(uni,Qz(1)0)F(Cut,Qz(1)0)F(Drp,Qz(1)0)_i(m,s a=malloc(1+x);*a++=x;a)&amp;#13;
#define A(c) ((s)memchr(a,c,na)?:a+na)-a&amp;#13;
#define g(a,v) ax?255&amp;amp;a:r(nx,v)&amp;#13;
f(not,g(!ix,!xi))f(sub,g(-ix,-xi))F(At,Qr(aa)g(a[ix],a[xi]))F(_A,Qr(aa)g(A(ix),A(xi)))&amp;#13;
f(ind,Qr(!ax)0&amp;gt;ix?r(-ix,-ix-1-i):r(ix,i))F(Ind,Qr(!aa)Qd(1&amp;gt;ia)g(ix%ia,xi%ia))&amp;#13;
#define G(f,o) F(f,ax?aa?255&amp;amp;ia o ix:Ltn==f?f(sub(x),sub(a)):f(x,a):r(nx,(aa?ia:a[i])o xi))&amp;#13;
G(Ltn,&amp;lt;)G(Eql,==)G(Not,!=)G(Sum,+)G(Prd,*)G(And,&amp;amp;)G(Or,|)&amp;#13;
f(cat,Qr(!ax)r(1,ix))F(Cat,a=aa?cat(a):a;x=ax?cat(x):x;s r=m(na+nx);memcpy(r+na,x,nx);memcpy(r,a,na))&amp;#13;
f(at,At(x,0))f(rev,Qr(ax)At(x,ind(255&amp;amp;-nx)))f(cnt,Qr(ax)nx)&amp;#13;
F(Tak,Qr(!aa||ax)Qd(0&amp;gt;ia||ia&amp;gt;nx)At(x,ind(a)))F(Sub,Sum(a,sub(x)))F(Mtn,Ltn(x,a))f(qz,Qz(1)0)&amp;#13;
#define v(e) ((strchr(V,e)?:V)-V)&amp;#13;
s U[26],V=" +-*&amp;amp;|&amp;lt;&amp;gt;=~!@?#_^,",&amp;#13;
(*f[])()={0,abs,sub,qz ,qz,rev,qz ,qz, qz ,not,ind,at,uni,cnt,qz ,srt,cat},&amp;#13;
(*F[])()={0,Sum,Sub,Prd,And,Or,Ltn,Mtn,Eql,Not,Ind,At,_A ,Tak,Drp,Cut,Cat};&amp;#13;
_i(n,10u&amp;gt;x-48?x-48:26u&amp;gt;x-97?U[x-97]:0)&amp;#13;
f(e,s z=x;c i=*z++;!*z?n(i):v(i)?x(e(z),Q(x)f[v(i)](x)):x(e(z+1),Q(x)58==*z?U[i-97]=x:_(c f=v(*z);Qd(!f)F[f](n(i),x))))&amp;#13;
int main(){c b[99];while(1)if(w(32),b[read(0,b,99)-1]=0,*b)58==b[1]?e(b):W(e(b));}&lt;/code&gt;
    &lt;p&gt;This is the entire interpreter, and this is apparently how he normally writes code. Opinions on his coding style are divided, though general consensus seems to be that it's incomprehensible. As daunting as it is, I figured I should give it a chance for a few reasons.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;As I work on larger and larger codebases, scrolling up and down to track information has become a more common annoyance. Whitney's talked about coding the way he does to avoid exactly that: he wants to keep his logic on one screen. Perhaps learning to read code like this could give me ideas on writing my own code more compactly.&lt;/item&gt;
      &lt;item&gt;In a Hacker News comments section, somebody asked "would you rather spend 10 days reading 100,000 lines of code, or 4 days reading 1000?", and that raises a good point. The complexity of the code is because even a simple interpreter is pretty complex. Writing it in 500 lines wouldn't make the complexity go away, it just spreads it out. Does writing in this more compact format feel more daunting because you're exposed to more of the complexity at once? I think so. Does showing it all at once actually help you understand the whole thing faster? I don't know.&lt;/item&gt;
      &lt;item&gt;Reading code has become a more important part of my job than writing it, so I should challenge my reading skills, regardless.&lt;/item&gt;
      &lt;item&gt;It confuses people, and that's basically the same as being smart.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;So I'm going to go line by line and explain my understanding. I tried to use the notes provided in the repo only when I was stuck, which was a few times early on, but by the end I could understand it pretty well.&lt;/p&gt;
    &lt;head rend="h2"&gt;A reading of a.h&lt;/head&gt;
    &lt;code&gt;typedef char*s,c;&lt;/code&gt;
    &lt;p&gt;This already shows some funky C. It defines &lt;code&gt;s&lt;/code&gt; as &lt;code&gt;char *&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt; as &lt;code&gt;char&lt;/code&gt;, because the &lt;code&gt;*&lt;/code&gt; attaches to the name, not the type. It's an oddity of C syntax that I've never been a fan of. Otherwise this is pretty straight forward: &lt;code&gt;s&lt;/code&gt; is for string, and &lt;code&gt;c&lt;/code&gt; is for character.&lt;/p&gt;
    &lt;code&gt;s Q=(s)128;&lt;/code&gt;
    &lt;p&gt;Fuck. Shit. He assigned 128 to a string named &lt;code&gt;Q&lt;/code&gt;. What does it mean? &lt;code&gt;s&lt;/code&gt; is &lt;code&gt;char *&lt;/code&gt;. Why is Q a pointer to the address 128? I thought I must have misunderstood, and &lt;code&gt;s&lt;/code&gt; was actually a character or something, but it's clearly specified as &lt;code&gt;char *&lt;/code&gt;. &lt;code&gt;s&lt;/code&gt; is for string!&amp;#13;
I couldn't figure out the meaning, so I soon gave up and looked at the annotated code. The &lt;code&gt;char *&lt;/code&gt; is &lt;code&gt;unsigned long long&lt;/code&gt; in other versions, and they explain that the type is used for both integers and pointers. The code operates on vectors of 8-bit integers, either as ASCII or numbers, so it makes some sense to use &lt;code&gt;char *&lt;/code&gt; from a memory layout perspective, but I don't use pointers as integers very often.&lt;/p&gt;
    &lt;code&gt;#define _(e...) ({e;})&amp;#13;
#define x(a,e...) _(s x=a;e)&amp;#13;
#define $(a,b) if(a)b;else&amp;#13;
#define i(n,e) {int $n=n;int i=0;for(;i&amp;lt;$n;++i){e;}}&lt;/code&gt;
    &lt;p&gt;These are all pretty straight forward, with one subtle caveat I only realized from the annotated code. They're all macros to make common operations more compact: wrapping an expression in a block, defining a variable &lt;code&gt;x&lt;/code&gt; and using it, conditional statements, and running an expression &lt;code&gt;n&lt;/code&gt; times.&lt;/p&gt;
    &lt;p&gt;The subtle thing the annotations point out is the first macro, &lt;code&gt;({e;})&lt;/code&gt;. The parentheses around curly brackets make this a statement expression, a non-standard C extension that allows you to treat a block of statements as a single expression, if the last statement is an expression that provides a value. In other words, &lt;code&gt;int x = ({int a = func1(); int b = func2(a); a+b;});&lt;/code&gt; sets &lt;code&gt;x&lt;/code&gt; to whatever &lt;code&gt;a+b&lt;/code&gt; is. This is used everywhere in the code after this.&lt;/p&gt;
    &lt;code&gt;#define Q(e) if(Q==(e))return Q;&amp;#13;
#define Qs(e,s) if(e)return err(__func__,s);&amp;#13;
#define Qr(e) Qs(e,"rank")&amp;#13;
#define Qd(e) Qs(e,"domain")&amp;#13;
#define Qz(e) Qs(e,"nyi")&lt;/code&gt;
    &lt;p&gt;These are error macros using that mysterious &lt;code&gt;Q&lt;/code&gt; defined earlier. &lt;code&gt;Q&lt;/code&gt; seems to have been used to represent errors, possibly short for "Quit". The &lt;code&gt;Qr/d/z&lt;/code&gt; functions seem to be types of errors. I have no idea what "nyi" means (I figure it out later).&lt;/p&gt;
    &lt;code&gt;#define _s(f,e,x...) s f(x){return _(e);}&amp;#13;
#define _i(f,e) _s(f,e,c x)&amp;#13;
#define f(f,e)  _s(f,e,s x)&amp;#13;
#define F(f,e)  _s(f,e,s a,s x)&lt;/code&gt;
    &lt;p&gt;These replace function declarations, and we can see that &lt;code&gt;_&lt;/code&gt; macro being used to add an implicit return.&amp;#13;
&lt;code&gt;_s&lt;/code&gt; could be used like&lt;/p&gt;
    &lt;code&gt;_s(my_function, puts("I rock!!!"); x*5+e, s x, int e)&lt;/code&gt;
    &lt;p&gt;, which would create basically this standard C:&lt;/p&gt;
    &lt;code&gt;char *my_function(char *x, int e) {&amp;#13;
	puts("I rock!!!");&amp;#13;
	return x*5+e;&amp;#13;
}&lt;/code&gt;
    &lt;p&gt;All the macros except the base &lt;code&gt;_s&lt;/code&gt; also add implicit arguments like &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; and you bet it's hard to tell them apart.&lt;/p&gt;
    &lt;code&gt;#define ax (256&amp;gt;x)&lt;/code&gt;
    &lt;p&gt;This was another one that baffled me until I looked at the annotations. Remember how I said &lt;code&gt;s&lt;/code&gt; values were either integers or pointers? 256 is the cutoff value for these integers, which the annotations call atoms, so ax means "is &lt;code&gt;x&lt;/code&gt; an atom?"&lt;/p&gt;
    &lt;code&gt;#define ix (c)x&amp;#13;
#define nx x[-1]&amp;#13;
#define xi x[i]&lt;/code&gt;
    &lt;p&gt;These aren't too confusing. &lt;code&gt;ix&lt;/code&gt; casts &lt;code&gt;x&lt;/code&gt; to a &lt;code&gt;char&lt;/code&gt;. &lt;code&gt;nx&lt;/code&gt; implies &lt;code&gt;x&lt;/code&gt; is some sort of fat pointer, meaning there's probably a length at &lt;code&gt;x[-1]&lt;/code&gt;, but we'll see. &lt;code&gt;xi&lt;/code&gt; just indexes &lt;code&gt;x&lt;/code&gt; as a normal pointer, using our implicitly defined &lt;code&gt;i&lt;/code&gt; from the &lt;code&gt;i(...)&lt;/code&gt; macro.&lt;/p&gt;
    &lt;code&gt;#define aa x(a,ax)&amp;#13;
#define ia x(a,ix)&amp;#13;
#define na x(a,nx)&lt;/code&gt;
    &lt;p&gt;These copy &lt;code&gt;ax&lt;/code&gt;, &lt;code&gt;ix&lt;/code&gt;, and &lt;code&gt;nx&lt;/code&gt; respectively to work on the &lt;code&gt;a&lt;/code&gt; variable, which is an implicit argument in functions defined using the &lt;code&gt;F(f,e)&lt;/code&gt; macro. You remembered the &lt;code&gt;x(name, expression)&lt;/code&gt; macro for assigning to a locally-scoped &lt;code&gt;x&lt;/code&gt;, right?&lt;/p&gt;
    &lt;code&gt;#define oo w("oo\n")&lt;/code&gt;
    &lt;p&gt;It prints &lt;code&gt;oo&lt;/code&gt;. It's not used anywhere.&lt;/p&gt;
    &lt;head rend="h2"&gt;a reading of a.c&lt;/head&gt;
    &lt;p&gt;I wound up not needing to refer to the annotated code at all to understand this. The C code is mostly using everything in the headers to build the interpreter.&lt;/p&gt;
    &lt;code&gt;#define r(n,e) _(s r=m(n);i(n,r[i]=e)r)&lt;/code&gt;
    &lt;p&gt;We create a vector &lt;code&gt;r&lt;/code&gt; from &lt;code&gt;m(n)&lt;/code&gt; (which is defined later (it's malloc)), fill &lt;code&gt;r&lt;/code&gt; with the results of &lt;code&gt;e&lt;/code&gt;, and return it out of the statement expression.&lt;/p&gt;
    &lt;code&gt;f(w,write(1,ax?&amp;amp;x:x,ax?1:strlen(x));x)&lt;/code&gt;
    &lt;p&gt;This defines &lt;code&gt;s w(s x)&lt;/code&gt;, which is our print function. If &lt;code&gt;x&lt;/code&gt; is an atom (&lt;code&gt;ax?&lt;/code&gt;), we print it as a single character by getting its address (&lt;code&gt;&amp;amp;x&lt;/code&gt;) and providing a length of 1. If it's a vector, we print it as a string using &lt;code&gt;strlen&lt;/code&gt; to calculate how long it is, so now we also know vectors must be null-terminated here.&amp;#13;
&lt;code&gt;write&lt;/code&gt; and &lt;code&gt;strlen&lt;/code&gt; are standard functions that we call without including the headers, because fuck headers. Let the linker figure it out.&lt;/p&gt;
    &lt;code&gt;F(err,w(a);w((s)58);w(x);w((s)10);Q)&lt;/code&gt;
    &lt;p&gt;Our fancy shmancy error printing function, &lt;code&gt;s err(s a, s x)&lt;/code&gt;. The confusing thing is that &lt;code&gt;:&lt;/code&gt; and the newline are represented by their ASCII numbers 58 and 10, respectively. This just prints a message in the format &lt;code&gt;{a}:{x}\n&lt;/code&gt; and returns our special error value &lt;code&gt;Q&lt;/code&gt;.&lt;/p&gt;
    &lt;code&gt;_i(wi,s b[5];sprintf(b,"%d ",x);w(b);0)&lt;/code&gt;
    &lt;p&gt;Defines &lt;code&gt;s wi(c x)&lt;/code&gt;, which takes &lt;code&gt;x&lt;/code&gt; as a &lt;code&gt;char&lt;/code&gt;, formats it as an integer in up to &lt;code&gt;5*sizeof(char*)/sizeof(char)&lt;/code&gt; characters (40 on 64-bit machines), and writes that.&lt;/p&gt;
    &lt;code&gt;f(W,Q(x)$(ax,wi(ix))i(nx,wi(xi))w(10);x)&lt;/code&gt;
    &lt;p&gt;Another print function, &lt;code&gt;s W(s x)&lt;/code&gt; either writes &lt;code&gt;x&lt;/code&gt; as an integer or a list of integers. It also refuses to print the &lt;code&gt;Q&lt;/code&gt; vector.&lt;/p&gt;
    &lt;code&gt;f(srt,Qz(1)0) f(uni,Qz(1)0) F(Cut,Qz(1)0) F(Drp,Qz(1)0)&lt;/code&gt;
    &lt;p&gt;I figured out what &lt;code&gt;nyi&lt;/code&gt; means! It means "Not yet implemented", as we can see from these function definitions.&lt;/p&gt;
    &lt;code&gt;_i(m,s a=malloc(1+x);*a++=x;a)&lt;/code&gt;
    &lt;p&gt;And we find our previously-used function &lt;code&gt;s m(c x)&lt;/code&gt;, which allocates our buffer and returns a fat pointer (with the size at &lt;code&gt;x[-1]&lt;/code&gt;, hence the &lt;code&gt;1+x&lt;/code&gt; and &lt;code&gt;a++&lt;/code&gt;). &lt;code&gt;x&lt;/code&gt; is the length we're allocating here, which means our vectors are limited to 255 bytes. The repo suggests upgrading capacity as an exercise to the reader, which could be fun.&lt;/p&gt;
    &lt;code&gt;#define A(c) ((s)memchr(a,c,na)?:a+na)-a&lt;/code&gt;
    &lt;p&gt;This macro finds the first occurence of the character &lt;code&gt;c&lt;/code&gt; in our vector &lt;code&gt;a&lt;/code&gt; as an index into the string (hence the &lt;code&gt;-a&lt;/code&gt;, since &lt;code&gt;memchr&lt;/code&gt; returns a pointer). If the result is null, it just returns the length of the string (&lt;code&gt;a+na - a&lt;/code&gt;). We see another fun bit of non-standard syntax, &lt;code&gt;?:&lt;/code&gt;, which I had to look up. &lt;code&gt;a ?: b&lt;/code&gt; is equivalent to &lt;code&gt;a ? a : b&lt;/code&gt; without evaluating &lt;code&gt;a&lt;/code&gt; twice. Pretty snazzy!&lt;/p&gt;
    &lt;code&gt;#define g(a,v) ax?255&amp;amp;a:r(nx,v)&lt;/code&gt;
    &lt;p&gt;Strange little operation, I'll have to see it in action. If &lt;code&gt;x&lt;/code&gt; is an atom, it clamps &lt;code&gt;a&lt;/code&gt; to be an atom with a simple mask (&lt;code&gt;255&amp;amp;a&lt;/code&gt;), otherwise it creates a new vector the same size as &lt;code&gt;x&lt;/code&gt; filled with the result from &lt;code&gt;v&lt;/code&gt;.&lt;/p&gt;
    &lt;code&gt;f(not,g(!ix,!xi)) f(sub,g(-ix,-xi)) F(At,Qr(aa)g(a[ix],a[xi])) F(_A,Qr(aa)g(A(ix),A(xi)))&lt;/code&gt;
    &lt;p&gt;Ah, I see now. &lt;code&gt;g(a, v)&lt;/code&gt; lets us define functions that work on both atoms and vectors. If &lt;code&gt;x&lt;/code&gt; is an atom, it returns the atom result clamped within the correct bounds. Otherwise it allocates a new vector and computes the other expression.&amp;#13;
All the above functions work either on &lt;code&gt;x&lt;/code&gt; as an integer (&lt;code&gt;ix&lt;/code&gt;), or on every element of &lt;code&gt;x&lt;/code&gt; (&lt;code&gt;xi&lt;/code&gt;).&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;s not(s x)&lt;/code&gt;does boolean negation.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;s sub(s x)&lt;/code&gt;does arithmetic negation.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;s At(s a, s x)&lt;/code&gt;indexes into&lt;code&gt;a&lt;/code&gt;, either to get one value or to shuffle them into a new vector.&lt;code&gt;a&lt;/code&gt;has to be a vector.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;s _A(s a, s x)&lt;/code&gt;searches a vector&lt;code&gt;a&lt;/code&gt;for the value of&lt;code&gt;x&lt;/code&gt;and gives us the index, either one value or every value in the vector.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;This is a lot of functionality in such a small bit of code.&lt;/p&gt;
    &lt;code&gt;f(ind,Qr(!ax)0&amp;gt;ix?r(-ix,-ix-1-i):r(ix,i))&amp;#13;
F(Ind,Qr(!aa)Qd(1&amp;gt;ia)g(ix%ia,xi%ia))&lt;/code&gt;
    &lt;p&gt;These are some atom-only functions.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;s ind(s x)&lt;/code&gt;creates a vector of length |x| containing&lt;code&gt;0, 1... x-1&lt;/code&gt;if&lt;code&gt;x&lt;/code&gt;is positive, otherwise it contains&lt;code&gt;-x-1, -x-2... 0&lt;/code&gt;.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;s Ind(s a, s x)&lt;/code&gt;does&lt;code&gt;x&lt;/code&gt;modulo&lt;code&gt;a&lt;/code&gt;, either on&lt;code&gt;x&lt;/code&gt;as an integer or every value of the vector&lt;code&gt;x&lt;/code&gt;.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Honestly, I can buy that this method of coding produces fewer bugs, once you can actually write it, since you work only on small building blocks of the logic and reuse them. Like, where could a bug for &lt;code&gt;ind&lt;/code&gt; even be? Maybe an off-by-one in &lt;code&gt;-ix-1-i&lt;/code&gt;, but it's hard to miss what's happening once you can see the trees through the forest.&lt;/p&gt;
    &lt;code&gt;#define G(f,o) F(f,ax?aa?255&amp;amp;ia o ix:Ltn==f?f(sub(x),sub(a)):f(x,a):r(nx,(aa?ia:a[i])o xi))&lt;/code&gt;
    &lt;p&gt;That's too many trees! I can't understand this many nested ternary operators at the same time because I'm not the alien from Arrival. I process things in linear time. I have to chunk this up.&lt;/p&gt;
    &lt;code&gt;F(f, ax ?&amp;#13;
		aa ?&amp;#13;
			255 &amp;amp; ia o ix&amp;#13;
			: Ltn==f ? &amp;#13;
				f(sub(x),sub(a))&amp;#13;
				: f(x,a)&amp;#13;
		: r(nx,(aa?ia:a[i])o xi))&lt;/code&gt;
    &lt;p&gt;Okay, I see. It's 3 cases from 2 conditions: &lt;code&gt;x&lt;/code&gt; is an atom or a vector, and &lt;code&gt;a&lt;/code&gt; is an atom or a vector.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;x&lt;/code&gt;and&lt;code&gt;a&lt;/code&gt;are atoms: apply some operator&lt;code&gt;o&lt;/code&gt;to both values and clamp to 8 bits. I also didn't realize the bitwize and (&lt;code&gt;&amp;amp;&lt;/code&gt;) had a lower precedence than the operators this macro is used on, meaning it's always&lt;code&gt;`C 255 &amp;amp; (ia o ix)&lt;/code&gt;`.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;x&lt;/code&gt;is an atom and&lt;code&gt;a&lt;/code&gt;is a vector: run this function with the arguments swapped. If the function is&lt;code&gt;Ltn&lt;/code&gt;, also negate the arguments, since less-than depends on argument order.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;x&lt;/code&gt;is a vector: create a new vector, either applying&lt;code&gt;a&lt;/code&gt;or each value of&lt;code&gt;a&lt;/code&gt;to&lt;code&gt;x&lt;/code&gt;using the operator. It assumes vector&lt;code&gt;a&lt;/code&gt;is at least as long as&lt;code&gt;x&lt;/code&gt;, or it'll index past the end of&lt;code&gt;a&lt;/code&gt;.&lt;/item&gt;
    &lt;/list&gt;
    &lt;code&gt;G(Ltn,&amp;lt;)G(Eql,==)G(Not,!=)G(Sum,+)G(Prd,*)G(And,&amp;amp;)G(Or,|)&lt;/code&gt;
    &lt;p&gt;Using our fancy new macro, we quickly define seven new functions for the vectors, where they're all element-wise applications of binary operators.&lt;/p&gt;
    &lt;code&gt;f(cat,Qr(!ax)r(1,ix)) F(Cat,a=aa?cat(a):a;x=ax?cat(x):x;s r=m(na+nx);memcpy(r+na,x,nx);memcpy(r,a,na))&lt;/code&gt;
    &lt;p&gt;I was confused by the first function, but I see now these are &lt;code&gt;cat&lt;/code&gt; as in "concatenate". For an atom, it creates a vector of length 1 containing that atom. &lt;code&gt;Cat&lt;/code&gt; does the more complex work of joining two vectors together, running &lt;code&gt;cat&lt;/code&gt; on each value if it's an atom to get a list.&lt;/p&gt;
    &lt;code&gt;f(at,At(x,0)) f(rev,Qr(ax)At(x,ind(255&amp;amp;-nx))) f(cnt,Qr(ax)nx)&lt;/code&gt;
    &lt;p&gt;Some more simple functions. Lil &lt;code&gt;at&lt;/code&gt; gets the first item of &lt;code&gt;x&lt;/code&gt;; &lt;code&gt;rev&lt;/code&gt; reverses the list using our &lt;code&gt;ind&lt;/code&gt; function to generate the list of indeces in reverse, which is a little overkill but vectors are 256 bytes at max and memory is never freed so who cares; and &lt;code&gt;cnt&lt;/code&gt; gets the size of &lt;code&gt;x&lt;/code&gt;.&lt;/p&gt;
    &lt;code&gt;F(Tak,Qr(!aa||ax)Qd(0&amp;gt;ia||ia&amp;gt;nx)At(x,ind(a))) F(Sub,Sum(a,sub(x))) F(Mtn,Ltn(x,a)) f(qz,Qz(1)0)&lt;/code&gt;
    &lt;p&gt;Some more simple functions. &lt;code&gt;Tak&lt;/code&gt; returns the first &lt;code&gt;a&lt;/code&gt; characters from the vector &lt;code&gt;x&lt;/code&gt; as a new list; &lt;code&gt;Sub&lt;/code&gt; subtracts; &lt;code&gt;Mtn&lt;/code&gt; is "more than"; and &lt;code&gt;qz&lt;/code&gt; returns our "not yet implemented" error.&lt;/p&gt;
    &lt;code&gt;#define v(e) ((strchr(V,e)?:V)-V)&lt;/code&gt;
    &lt;p&gt;A shorthand to get the first occurence of a character from a string &lt;code&gt;V&lt;/code&gt;, returning an offset into the array or zero if it's not present. This seems ambiguous, since that's also the result if we match with the first character, but we'll see.&lt;/p&gt;
    &lt;code&gt;s U[26],V=" +-*&amp;amp;|&amp;lt;&amp;gt;=~!@?#_^,",&amp;#13;
(*f[])()={0,abs,sub,qz ,qz,rev,qz ,qz, qz ,not,ind,at,uni,cnt,qz ,srt,cat},&amp;#13;
(*F[])()={0,Sum,Sub,Prd,And,Or,Ltn,Mtn,Eql,Not,Ind,At,_A ,Tak,Drp,Cut,Cat};&lt;/code&gt;
    &lt;p&gt;Ah, we have seen. The first character of &lt;code&gt;V&lt;/code&gt; is a space, and it looks like the arrays of function pointers match up with the characters of &lt;code&gt;V&lt;/code&gt; to give us our functions, with space being null. However, I think &lt;code&gt;abs&lt;/code&gt; is from the standard library here, since it's not defined anywhere else? That seems like a bug. It'd work for atoms, but it'd break vectors.&amp;#13;
This also defines an array of 26 vectors, which I assume will be our variables. &lt;/p&gt;
    &lt;code&gt;_i(n, 10u&amp;gt;x-48? x-48 : 26u&amp;gt;x-97? U[x-97] : 0)&lt;/code&gt;
    &lt;p&gt;&lt;code&gt;s n(c x)&lt;/code&gt; reads a char and returns one of several things. I'll have to consult an ASCII table.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;If &lt;code&gt;x&lt;/code&gt;is between 48 and 57 (inclusive), we subtract 48 and return that. Meaning, if&lt;code&gt;x&lt;/code&gt;is an ASCII character representing 0-9, we subtract 48 so it's the integer 0-9, rather than the character. It's phrased strangely,&lt;code&gt;10u &amp;gt; x-48&lt;/code&gt;, instead of the more obvious&lt;code&gt;x&amp;gt;47&amp;amp;&amp;amp;58&amp;gt;x&lt;/code&gt;. Maybe it's because it's two characters shorter. Maybe Arthur wanted to show the length of the span of characters (10) more than the start and end, which this does once you understand it. Maybe he just thought the underflow trickery was neat.&lt;/item&gt;
      &lt;item&gt;If &lt;code&gt;x&lt;/code&gt;is between 97 and 122 (inclusive), it's a lowercase character of the alphabet in ASCII, in which case the function returns one of our variables from the&lt;code&gt;U&lt;/code&gt;array, mapping 'a' to 'z'.&lt;/item&gt;
      &lt;item&gt;Otherwise, the function returns 0.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;So it looks like this function is specifically to read values, either numerals or variables, all of which are one character.&lt;/p&gt;
    &lt;code&gt;f(e,s z=x;c i=*z++;!*z?n(i):v(i)?x(e(z),Q(x)f[v(i)](x)):x(e(z+1),Q(x)58==*z?U[i-97]=x:_(c f=v(*z);Qd(!f)F[f](n(i),x))))&lt;/code&gt;
    &lt;p&gt;Uh, let's spread this out a little.&lt;/p&gt;
    &lt;code&gt;f(e, s z=x; c i=*z++; !*z ? n(i)&amp;#13;
	: v(i) ? x(e(z), Q(x) f[v(i)](x))&amp;#13;
		: x(e(z+1), Q(x) 58==*z ? U[i-97]=x &amp;#13;
			: _(c f=v(*z); Qd(!f) F[f](n(i),x))))&lt;/code&gt;
    &lt;p&gt;Okay, easy. It's a recursive function that checks each character of vector &lt;code&gt;x&lt;/code&gt;, called &lt;code&gt;i&lt;/code&gt;.&amp;#13;
If we're at the end of the string, we check if &lt;code&gt;i&lt;/code&gt; is a value and return it.&amp;#13;
Otherwise, we first check if it's an operator (from our &lt;code&gt;V&lt;/code&gt; string). If it is, we evaluate the rest of the string, check for errors, and then apply the operation to the result from the rest of the evaluation.&amp;#13;
If it wasn't an operation, we evaluate the rest of the string, skipping one character. If the skipped character is a colon (ASCII 58), we assign the result of the evaluation to one of the slots in &lt;code&gt;U&lt;/code&gt; (if the character &lt;code&gt;i&lt;/code&gt; is not a lowercase ASCII letter, this will corrupt memory, so don't write bugs).&lt;/p&gt;
    &lt;p&gt;I'm pretty sure spaces are a syntax error in every location, and I don't see code to create array literals. If the skipped character is an operator, we instead apply that binary operator on the evaluation result and &lt;code&gt;n(i)&lt;/code&gt;, which is either a variable or a number.&amp;#13;
This means code is executed from right to left, with no operator precedent, which is standard for APL-type languages from what I understand.&amp;#13;
Because this language has only single-character variable names, numbers, and operators, this is all the tokenizing, parsing, and evaluation we need.&lt;/p&gt;
    &lt;code&gt;C int main(){c b[99]; while(1) if(w(32),b[read(0,b,99)-1]=0,*b) 58==b[1] ? e(b) : W(e(b));}&lt;/code&gt;
    &lt;p&gt;And finally, &lt;code&gt;main&lt;/code&gt;.&amp;#13;
In an infinite loop, we read up to 99 characters from a user, and then write the evaluated result of that text.&lt;/p&gt;
    &lt;p&gt;Et voila. We have a tiny interpreter for a simple array language. It's not exactly production-ready, but it does quite a lot in its tiny footprint.&lt;/p&gt;
    &lt;head rend="h2"&gt;Conclusions&lt;/head&gt;
    &lt;p&gt;I think I can say I understand this code pretty well, even more than most code I read. I don't know how much of that is because of the coding style, or because I spent eight hours writing several thousand words about fifty lines of code in a borderline-delusional fugue state brought on by drinking one small Starbucks™ Frapuccino® (Mocha® Flavored*) I bought from a gas station at 10 PM on a Thursday.&lt;/p&gt;
    &lt;p&gt;I had some fun dreams about macros with one-character names applying operations on scalars and vectors that morning (I went to sleep at 6:40 AM).&lt;/p&gt;
    &lt;p&gt;All in all, it was a fun exercise. To summarize my thoughts:&lt;/p&gt;
    &lt;head rend="h3"&gt;Good ideas&lt;/head&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Well-considered primitives. I've read and written a lot of macro-ridden C, but this feels like a proper little language designed with composable, useful macros that removed enough repetition to make common operations, like iteration, easy to decipher. In other languages, higher-order functions and similar constructs could be used the same way.&lt;/item&gt;
      &lt;item&gt;Fewer lines. I didn't have to scroll so much when I forgot what a macro or a function did! I have a wide screen monitor, I don't need lines limited to 10-20 characters of actual code most of the time. If people can read English in compact paragraphs, why not code?&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h3"&gt;Bad ideas&lt;/head&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Non-semantic types. I was completely baffled by the &lt;code&gt;char *&lt;/code&gt;being treated as an integer at first, and simply assumed I was misunderstanding the code somehow until I checked the annotated version. In my own code, I use types as one of the core building blocks. What the data is defines how I use it. For a full interpreter, this would be a custom type anyway, since right now it assumes&lt;code&gt;malloc&lt;/code&gt;will never give it a pointer to an address less than 256, which is probably true but not guaranteed, and also the integer 128 is reserved for invalid results, which is probably the bigger limitation.&lt;/item&gt;
      &lt;item&gt;Code golf. I can understand the large gains to density like macros, and even the medium gains like short names, but there's a point where the code becomes significantly harder to follow for very minor gains, such as the use of ASCII codes like &lt;code&gt;58&lt;/code&gt;instead of character literals like&lt;code&gt;':'&lt;/code&gt;, or the use of&lt;code&gt;10u&amp;gt;x-48&lt;/code&gt;instead of&lt;code&gt;x&amp;gt;48&amp;amp;&amp;amp;58&amp;gt;x&lt;/code&gt;for checking if&lt;code&gt;x&lt;/code&gt;is within a range. And while I think more code can be put on a line, I'm not throwing out my space key just yet, epecially between function declarations.&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h3"&gt;Ideas I'm ambivalent about&lt;/head&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Non-standard syntax. There's some very interesting features in this code that utilize GCC-specific extensions, like &lt;code&gt;a ?: b&lt;/code&gt;ternaries and statement expressions. I don't typically need to compile for everything on earth, so learning the tricks of one reasonably cross-platform compiler isn't a bad idea. At the same time, even using clang, the same compiler Arthur was using, I had to include&lt;code&gt;stdio.h&lt;/code&gt;due to not linking&lt;code&gt;sprintf&lt;/code&gt;otherwise. If I wanted to build using Visual Studio I'd just have to rewrite a bunch of stuff. Also, compiling without&lt;code&gt;-w&lt;/code&gt;generates almost three compiler warnings per line of code. Those are useful sometimes, if they aren't flooded!&lt;/item&gt;
      &lt;item&gt;Implicit arguments. Many of the density gains in this code come from using the variables &lt;code&gt;x&lt;/code&gt;,&lt;code&gt;a&lt;/code&gt;, and&lt;code&gt;i&lt;/code&gt;in nearly every context, allowing macros to use them by default and skip listing other parameters. I didn't find it to be a problem after a brief adjustment, but it's also a very small codebase. Implicit arguments are a feature in many dynamically typed languages, and in "point-free" or "tacit" programming, but it's fallen out of style due to its difficulty to parse at first glance. Whitney's languages all being based around tacit programming is surely an influence on his tendency to make arguments implicit.&lt;/item&gt;
      &lt;item&gt;Short names. Beyond the very first introduction, there'd be virtually no benefit to renaming &lt;code&gt;ax&lt;/code&gt;as&lt;code&gt;vector_is_atom(x)&lt;/code&gt;,&lt;code&gt;_(...)&lt;/code&gt;as 'execute(...)', or most other primitives after they're introduced. Most are small enough that you can parse what it does right away. However, this doesn't lend any signal as to why it does. You have to figure out what it does from context. For code that's meant to be read by another person, there should probably be some explanation as to why a primitive does what it does, even if it has a short name. This is especially true of more complex operations, like the evaluation function&lt;code&gt;e&lt;/code&gt;.&lt;/item&gt;
      &lt;item&gt;Nested ternary operators. Too confusing for me to follow without parentheses, especially without whitespace.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;This coding style feels most appropriate for "done" code, or code that's been worked out on paper or some other environment and is now being written down in a compact way. It's more like finalized mathematical notation than typical code. I don't see myself being able to effectively write code like this, since I tend to quickly jot down ideas, compile and run to validate, and edit what I've done based on the results. Making a small set of good primitives and building heavily on those requires basically having solved the problem before writing a single line. Otherwise you get bad primitives that cause more confusion than help, and adjusting those primitives would involve rewriting all the code that depends on them, which is all the code.&lt;/p&gt;
    &lt;p&gt;But I think that's my key takeaway: I tend to work out problems in the code, which can lead to messy results. I write the dumbest possible solution, and then have to try and refactor as I develop a better mental model of the problem. What I like most about this code isn't how few characters are used, or everything fitting in one screen. I like how it seems the code was well-understood before it was written. You can't refactor a 500-line jumble of C into code like this.&lt;/p&gt;
    &lt;p&gt;The real lesson is that I'm probably too quick to jump into coding things. I could spend more time working out how I want to model a problem in a more free-form way, like writing notation on paper, before jumping into the rigid world of programming syntax. With a clear mental model, I can then write code in terms of how I was thinking about the problem, instead of thinking about the problem in terms of how I wrote the code.&lt;/p&gt;
    &lt;head rend="h2"&gt;Next time&lt;/head&gt;
    &lt;p&gt;I think a fun exercise would be to extend this interpreter while maintaining its code style, to see how I fare actually working with it. The repository this came from has various suggested exercises, but my ideas would be adding the following:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Swapping the bytes for float vectors&lt;/item&gt;
      &lt;item&gt;Vectors longer than 255 values&lt;/item&gt;
      &lt;item&gt;Multi-character numbers&lt;/item&gt;
      &lt;item&gt;Array literals (you can do it with comma, but that runs &lt;code&gt;cat&lt;/code&gt;on every value, which isn't ideal)&lt;/item&gt;
      &lt;item&gt;Whitespace insensitivity&lt;/item&gt;
      &lt;item&gt;Memory management&lt;/item&gt;
      &lt;item&gt;The unimplemented functions&lt;/item&gt;
      &lt;item&gt;Multi-character variable names&lt;/item&gt;
      &lt;item&gt;Multi-character operators&lt;/item&gt;
      &lt;item&gt;Indication for syntax errors&lt;/item&gt;
    &lt;/list&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=45800777</guid><pubDate>Mon, 03 Nov 2025 16:23:11 +0000</pubDate></item><item><title>The Case That A.I. Is Thinking</title><link>https://www.newyorker.com/magazine/2025/11/10/the-case-that-ai-is-thinking</link><description>&lt;doc fingerprint="2f41991cbdb78dfb"&gt;
  &lt;main&gt;
    &lt;p&gt;Dario Amodei, the C.E.O. of the artificial-intelligence company Anthropic, has been predicting that an A.I. “smarter than a Nobel Prize winner” in such fields as biology, math, engineering, and writing might come online by 2027. He envisions millions of copies of a model whirring away, each conducting its own research: a “country of geniuses in a datacenter.” In June, Sam Altman, of OpenAI, wrote that the industry was on the cusp of building “digital superintelligence.” “The 2030s are likely going to be wildly different from any time that has come before,” he asserted. Meanwhile, the A.I. tools that most people currently interact with on a day-to-day basis are reminiscent of Clippy, the onetime Microsoft Office “assistant” that was actually more of a gadfly. A Zoom A.I. tool suggests that you ask it “What are some meeting icebreakers?” or instruct it to “Write a short message to share gratitude.” Siri is good at setting reminders but not much else. A friend of mine saw a button in Gmail that said “Thank and tell anecdote.” When he clicked it, Google’s A.I. invented a funny story about a trip to Turkey that he never took.&lt;/p&gt;
    &lt;p&gt;The rushed and uneven rollout of A.I. has created a fog in which it is tempting to conclude that there is nothing to see here—that it’s all hype. There is, to be sure, plenty of hype: Amodei’s timeline is science-fictional. (A.I. models aren’t improving that fast.) But it is another kind of wishful thinking to suppose that large language models are just shuffling words around. I used to be sympathetic to that view. I sought comfort in the idea that A.I. had little to do with real intelligence or understanding. I even celebrated its shortcomings—rooting for the home team. Then I began using A.I. in my work as a programmer, fearing that if I didn’t I would fall behind. (My employer, a trading firm, has several investments in and partnerships with A.I. companies, including Anthropic.) Writing code is, by many accounts, the thing that A.I. is best at; code has more structure than prose does, and it’s often possible to automatically validate that a given program works. My conversion was swift. At first, I consulted A.I. models in lieu of looking something up. Then I gave them small, self-contained problems. Eventually, I gave them real work—the kind I’d trained my whole career to do. I saw these models digest, in seconds, the intricate details of thousands of lines of code. They could spot subtle bugs and orchestrate complex new features. Finally, I was transferred to a fast-growing team that aims to make better use of A.I. tools, and to create our own.&lt;/p&gt;
    &lt;p&gt;The science-fiction author William Gibson is said to have observed that the future is already here, just not evenly distributed—which might explain why A.I. seems to have minted two cultures, one dismissive and the other enthralled. In our daily lives, A.I. “agents” that can book vacations or file taxes are a flop, but I have colleagues who compose much of their code using A.I. and sometimes run multiple coding agents at a time. Models sometimes make amateur mistakes or get caught in inane loops, but, as I’ve learned to use them effectively, they have allowed me to accomplish in an evening what used to take a month. Not too long ago, I made two iOS apps without knowing how to make an iOS app.&lt;/p&gt;
    &lt;p&gt;I once had a boss who said that a job interview should probe for strengths, not for the absence of weaknesses. Large language models have many weaknesses: they famously hallucinate reasonable-sounding falsehoods; they can be servile even when you’re wrong; they are fooled by simple puzzles. But I remember a time when the obvious strengths of today’s A.I. models—fluency, fluidity, an ability to “get” what someone is talking about—were considered holy grails. When you experience these strengths firsthand, you wonder: How convincing does the illusion of understanding have to be before you stop calling it an illusion?&lt;/p&gt;
    &lt;p&gt;On a brutally hot day this summer, my friend Max met up with his family at a playground. For some reason, a sprinkler for kids was switched off, and Max’s wife had promised everyone that her husband would fix it. Confronted by red-faced six- and seven-year-olds, Max entered a utility shed hoping to find a big, fat “On” switch. Instead, he found a maze of ancient pipes and valves. He was about to give up when, on a whim, he pulled out his phone and fed a photo into ChatGPT-4o, along with a description of his problem. The A.I. thought for a second, or maybe didn’t think, but all the same it said that he was looking at a backflow-preventer system typical of irrigation setups. Did he see that yellow ball valve toward the bottom? That probably controlled the flow. Max went for it, and cheers rang out across the playground as the water turned on.&lt;/p&gt;
    &lt;p&gt;Was ChatGPT mindlessly stringing words together, or did it understand the problem? The answer could teach us something important about understanding itself. “Neuroscientists have to confront this humbling truth,” Doris Tsao, a neuroscience professor at the University of California, Berkeley, told me. “The advances in machine learning have taught us more about the essence of intelligence than anything that neuroscience has discovered in the past hundred years.” Tsao is best known for decoding how macaque monkeys perceive faces. Her team learned to predict which neurons would fire when a monkey saw a specific face; even more strikingly, given a pattern of neurons firing, Tsao’s team could render the face. Their work built on research into how faces are represented inside A.I. models. These days, her favorite question to ask people is “What is the deepest insight you have gained from ChatGPT?” “My own answer,” she said, “is that I think it radically demystifies thinking.”&lt;/p&gt;
    &lt;p&gt;The most basic account of how we got here goes something like this. In the nineteen-eighties, a small team of cognitive psychologists and computer scientists tried to simulate thinking in a machine. Among the more famous of them were David Rumelhart, Geoffrey Hinton, and James McClelland, who went on to form a research group at U.C. San Diego. They saw the brain as a vast network in which neurons fire in patterns, causing other sets of neurons to fire, and so on; this dance of patterns is thinking. The brain learns by changing the strength of the connections between neurons. Crucially, the scientists mimicked this process by creating an artificial neural network, and by applying a simple algorithm called gradient descent to increase the accuracy of its predictions. (The algorithm could be compared to a hiker navigating from a mountaintop to a valley; a simple strategy for eventually finding one’s way is to insure that every step moves downhill.) The use of such algorithms in large networks is known as deep learning.&lt;/p&gt;
    &lt;p&gt;Other people in A.I. were skeptical that neural networks were sophisticated enough for real-world tasks, but, as the networks got bigger, they began to solve previously unsolvable problems. People would devote entire dissertations to developing techniques for distinguishing handwritten digits or for recognizing faces in images; then a deep-learning algorithm would digest the underlying data, discover the subtleties of the problem, and make those projects seem obsolete. Deep learning soon conquered speech recognition, translation, image captioning, board games, and even the problem of predicting how proteins will fold.&lt;/p&gt;
    &lt;p&gt;Today’s leading A.I. models are trained on a large portion of the internet, using a technique called next-token prediction. A model learns by making guesses about what it will read next, then comparing those guesses to whatever actually appears. Wrong guesses inspire changes in the connection strength between the neurons; this is gradient descent. Eventually, the model becomes so good at predicting text that it appears to know things and make sense. So that is something to think about. A group of people sought the secret of how the brain works. As their model grew toward a brain-like size, it started doing things that were thought to require brain-like intelligence. Is it possible that they found what they were looking for?&lt;/p&gt;
    &lt;p&gt;There is understandable resistance to such a simplistic and triumphant account of A.I. The case against it was well argued by Ted Chiang, who wrote an article for this magazine in early 2023 titled “ChatGPT Is a Blurry JPEG of the Web.” He meant it in a more or less deflationary way: that’s all ChatGPT is. You feed the whole internet to a program and it regurgitates it back to you imperfectly, like a copy of a copy of a photograph—but with just enough facility to fool you into believing that the program is intelligent. This spring, a similar argument was made in a book, “The AI Con,” by Emily M. Bender, a linguist, and Alex Hanna, a sociologist. Bender is perhaps best known for describing L.L.M.s as “stochastic parrots.” “Large language models do not, cannot, and will not ‘understand’ anything at all,” the writer Tyler Austin Harper declared in a book review in The Atlantic. Models “produce writing not by thinking but by making statistically informed guesses about which lexical item is likely to follow another.” Harper buttressed these technical arguments with moral ones. A.I. enriches the powerful, consumes enough energy to accelerate climate change, and marginalizes workers. He concluded that “the foundation of the AI industry is a scam.”&lt;/p&gt;
    &lt;p&gt;But the moral case against A.I. may ultimately be stronger than the technical one. “The ‘stochastic parrot’ thing has to be dead at some point,” Samuel J. Gershman, a Harvard cognitive scientist who is no A.I. hype man, told me. “Only the most hardcore skeptics can deny these systems are doing things many of us didn’t think were going to be achieved.” Jonathan Cohen, a cognitive neuroscientist at Princeton, emphasized the limitations of A.I., but argued that, in some cases, L.L.M.s seem to mirror one of the largest and most important parts of the human brain. “To a first approximation, your neocortex is your deep-learning mechanism,” Cohen said. Humans have a much larger neocortex than other animals, relative to body size, and the species with the largest neocortices—elephants, dolphins, gorillas, chimpanzees, dogs—are among the most intelligent.&lt;/p&gt;
    &lt;p&gt;In 2003, the machine-learning researcher Eric B. Baum published a book called “What Is Thought?” (I stumbled upon it in my college’s library stacks, drawn by the title.) The gist of Baum’s argument is that understanding is compression, and compression is understanding. In statistics, when you want to make sense of points on a graph, you can use a technique called linear regression to draw a “line of best fit” through them. If there’s an underlying regularity in the data—maybe you’re plotting shoe size against height—the line of best fit will efficiently express it, predicting where new points could fall. The neocortex can be understood as distilling a sea of raw experience—sounds, sights, and other sensations—into “lines of best fit,” which it can use to make predictions. A baby exploring the world tries to guess how a toy will taste or where food will go when it hits the floor. When a prediction is wrong, the connections between neurons are adjusted. Over time, those connections begin to capture regularities in the data. They form a compressed model of the world.&lt;/p&gt;
    &lt;p&gt;Artificial neural networks compress experience just like real neural networks do. One of the best open-source A.I. models, DeepSeek, is capable of writing novels, suggesting medical diagnoses, and sounding like a native speaker in dozens of languages. It was trained using next-token prediction on many terabytes of data. But when you download the model it is one six-hundredth of that. A distillation of the internet, compressed to fit on your laptop. Ted Chiang was right to call an early version of ChatGPT a blurry JPEG of the web—but, in my view, this is the very reason these models have become increasingly intelligent. Chiang noted in his piece that, to compress a text file filled with millions of examples of arithmetic, you wouldn’t create a zip file. You’d write a calculator program. “The greatest degree of compression can be achieved by understanding the text,” he wrote. Perhaps L.L.M.s are starting to do that.&lt;/p&gt;
    &lt;p&gt;It can seem unnatural, even repulsive, to imagine that a computer program actually understands, actually thinks. We usually conceptualize thinking as something conscious, like a Joycean inner monologue or the flow of sense memories in a Proustian daydream. Or we might mean reasoning: working through a problem step by step. In our conversations about A.I., we often conflate these different kinds of thinking, and it makes our judgments pat. ChatGPT is obviously not thinking, goes one argument, because it is obviously not having a Proustian reverie; ChatGPT clearly is thinking, goes another, because it can work through logic puzzles better than you can.&lt;/p&gt;
    &lt;p&gt;Something more subtle is going on. I do not believe that ChatGPT has an inner life, and yet it seems to know what it’s talking about. Understanding—having a grasp of what’s going on—is an underappreciated kind of thinking, because it’s mostly unconscious. Douglas Hofstadter, a professor of cognitive science and comparative literature at Indiana University, likes to say that cognition is recognition. Hofstadter became famous for a book about the mind and consciousness called “Gödel, Escher, Bach: An Eternal Golden Braid,” which won a Pulitzer Prize in 1980. Hofstadter’s theory, developed through decades of research, is that “seeing as” is the essence of thinking. You see one patch of color as a car and another as a key chain; you recognize the letter “A” no matter what font it is written in or how bad the handwriting might be. Hofstadter argued that the same process underlies more abstract kinds of perception. When a grand master examines a chess board, years of practice are channelled into a way of seeing: white’s bishop is weak; that endgame is probably a draw. You see an eddy in a river as a sign that it’s dangerous to cross. You see a meeting you’re in as an emperor-has-no-clothes situation. My nearly two-year-old son recognizes that late-morning stroller walks might be an opportunity for a croissant and makes demands accordingly. For Hofstadter, that’s intelligence in a nutshell.&lt;/p&gt;
    &lt;p&gt;Hofstadter was one of the original A.I. deflationists, and my own skepticism was rooted in his. He wrote that most A.I. research had little to do with real thinking, and when I was in college, in the two-thousands, I agreed with him. There were exceptions. He found the U.C.S.D. group interesting. And he admired the work of a lesser-known Finnish American cognitive scientist, Pentti Kanerva, who noticed some unusual properties in the mathematics of high-dimensional spaces. In a high-dimensional space, any two random points may be extremely far apart. But, counterintuitively, each point also has a large cloud of neighbors around it, so you can easily find your way to it if you get “close enough.” That reminded Kanerva of the way that memory works. In a 1988 book called “Sparse Distributed Memory,” Kanerva argued that thoughts, sensations, and recollections could be represented as coördinates in high-dimensional space. The brain seemed like the perfect piece of hardware for storing such things. Every memory has a sort of address, defined by the neurons that are active when you recall it. New experiences cause new sets of neurons to fire, representing new addresses. Two addresses can be different in many ways but similar in others; one perception or memory triggers other memories nearby. The scent of hay recalls a memory of summer camp. The first three notes of Beethoven’s Fifth beget the fourth. A chess position that you’ve never seen reminds you of old games—not all of them, just the ones in the right neighborhood.&lt;/p&gt;
    &lt;p&gt;Hofstadter realized that Kanerva was describing something like a “seeing as” machine. “Pentti Kanerva’s memory model was a revelation for me,” he wrote in a foreword to Kanerva’s book. “It was the very first piece of research I had ever run across that made me feel I could glimpse the distant goal of understanding how the brain works as a whole.” Every kind of thinking—whether Joycean, Proustian, or logical—depends on the relevant thing coming to mind at the right time. It’s how we figure out what situation we’re in.&lt;/p&gt;
    &lt;p&gt;Kanerva’s book receded from view, and Hofstadter’s own star faded—except when he occasionally poked up his head to criticize a new A.I. system. In 2018, he wrote of Google Translate and similar technologies: “There is still something deeply lacking in the approach, which is conveyed by a single word: understanding.” But GPT-4, which was released in 2023, produced Hofstadter’s conversion moment. “I’m mind-boggled by some of the things that the systems do,” he told me recently. “It would have been inconceivable even only ten years ago.” The staunchest deflationist could deflate no longer. Here was a program that could translate as well as an expert, make analogies, extemporize, generalize. Who were we to say that it didn’t understand? “They do things that are very much like thinking,” he said. “You could say they are thinking, just in a somewhat alien way.”&lt;/p&gt;
    &lt;p&gt;L.L.M.s appear to have a “seeing as” machine at their core. They represent each word with a series of numbers denoting its coördinates—its vector—in a high-dimensional space. In GPT-4, a word vector has thousands of dimensions, which describe its shades of similarity to and difference from every other word. During training, a large language model tweaks a word’s coördinates whenever it makes a prediction error; words that appear in texts together are nudged closer in space. This produces an incredibly dense representation of usages and meanings, in which analogy becomes a matter of geometry. In a classic example, if you take the word vector for “Paris,” subtract “France,” and then add “Italy,” the nearest other vector will be “Rome.” L.L.M.s can “vectorize” an image by encoding what’s in it, its mood, even the expressions on people’s faces, with enough detail to redraw it in a particular style or to write a paragraph about it. When Max asked ChatGPT to help him out with the sprinkler at the park, the model wasn’t just spewing text. The photograph of the plumbing was compressed, along with Max’s prompt, into a vector that captured its most important features. That vector served as an address for calling up nearby words and concepts. Those ideas, in turn, called up others as the model built up a sense of the situation. It composed its response with those ideas “in mind.”&lt;/p&gt;
    &lt;p&gt;A few months ago, I was reading an interview with an Anthropic researcher, Trenton Bricken, who has worked with colleagues to probe the insides of Claude, the company’s series of A.I. models. (Their research has not been peer-reviewed or published in a scientific journal.) His team has identified ensembles of artificial neurons, or “features,” that activate when Claude is about to say one thing or another. Features turn out to be like volume knobs for concepts; turn them up and the model will talk about little else. (In a sort of thought-control experiment, the feature representing the Golden Gate Bridge was turned up; when one user asked Claude for a chocolate-cake recipe, its suggested ingredients included “1/4 cup dry fog” and “1 cup warm seawater.”) In the interview, Bricken mentioned Google’s Transformer architecture, a recipe for constructing neural networks that underlies leading A.I. models. (The “T” in ChatGPT stands for “Transformer.”) He argued that the mathematics at the heart of the Transformer architecture closely approximated a model proposed decades earlier—by Pentti Kanerva, in “Sparse Distributed Memory.”&lt;/p&gt;
    &lt;p&gt;Should we be surprised by the correspondence between A.I. and our own brains? L.L.M.s are, after all, artificial neural networks that psychologists and neuroscientists helped develop. What’s more surprising is that when models practiced something rote—predicting words—they began to behave in such a brain-like way. These days, the fields of neuroscience and artificial intelligence are becoming entangled; brain experts are using A.I. as a kind of model organism. Evelina Fedorenko, a neuroscientist at M.I.T., has used L.L.M.s to study how brains process language. “I never thought I would be able to think about these kinds of things in my lifetime,” she told me. “I never thought we’d have models that are good enough.”&lt;/p&gt;
    &lt;p&gt;It has become commonplace to say that A.I. is a black box, but the opposite is arguably true: a scientist can probe the activity of individual artificial neurons and even alter them. “Having a working system that instantiates a theory of human intelligence—it’s the dream of cognitive neuroscience,” Kenneth Norman, a Princeton neuroscientist, told me. Norman has created computer models of the hippocampus, the brain region where episodic memories are stored, but in the past they were so simple that he could only feed them crude approximations of what might enter a human mind. “Now you can give memory models the exact stimuli you give to a person,” he said.&lt;/p&gt;
    &lt;p&gt;The Wright brothers studied birds during their early efforts to build an airplane. They noted that birds take off into the wind, even though a reasonable person might have assumed they’d want the wind at their backs, and that they warp the tips of their wings for balance. These findings influenced their rudimentary glider designs. Then they built a six-foot-long wind tunnel, which allowed them to test a set of artificial wings under precisely controlled conditions. Their next round of glider flights was far more successful. Strangely, it was only well after they’d made a working flying machine that it became possible to understand exactly how the birds do it.&lt;/p&gt;
    &lt;p&gt;A.I. enables scientists to place thinking itself in a wind tunnel. For a paper provocatively titled “On the Biology of a Large Language Model,” Anthropic researchers observed Claude responding to queries and described “circuits”—cascades of features that, together, perform complex computations. (Calling up the right memories is one step toward thinking; combining and manipulating them in circuits is arguably another.) One longstanding criticism of L.L.M.s has been that, because they must generate one token of their response at a time, they can’t plan or reason. But, when you ask Claude to finish a rhyming couplet in a poem, a circuit begins considering the last word of the new line, to insure that it will rhyme. It then works backward to compose the line as a whole. Anthropic researchers counted this as evidence that their models do engage in planning. Squint a little and you might feel, for the first time, that the inner workings of a mind are in view.&lt;/p&gt;
    &lt;p&gt;You really do have to squint, though. “The worry I have is that people flipped the bit from ‘I’m really skeptical of this’ to totally dropping their shields,” Norman, the Princeton neuroscientist, told me. “Many things still have to get figured out.” I’m one of the people that Norman is talking about. (Perhaps I am too easily moved by the seeming convergence of “Sparse Distributed Memory” and an Anthropic model.) In the past year or two, I started to believe what Geoffrey Hinton, who recently won a Nobel Prize for his A.I. research, told the journalist Karen Hao in 2020: “Deep learning is going to be able to do everything.” But we have also seen that larger models aren’t always better models. Curves plotting model performance against size have begun flattening out. It’s becoming difficult to find high-quality data that the models haven’t already digested, and computing power is increasingly expensive. When GPT-5 came out, in August, it was a merely incremental improvement—and so profound a disappointment that it threatened to pop the A.I. investment bubble. The moment demands a middle kind of skepticism: one that takes today’s A.I. models seriously without believing that there are no hard problems left.&lt;/p&gt;
    &lt;p&gt;Perhaps the most consequential of these problems is how to design a model that learns as efficiently as humans do. It is estimated that GPT-4 was exposed to trillions of words in training; children need only a few million to become fluent. Cognitive scientists tell us that a newborn’s brain has certain “inductive biases” that accelerate learning. (Of course, the brain is the result of millions of years of evolution—itself a sort of training data.) For instance, human babies have the expectation that the world is made of objects, and that other beings have beliefs and intentions. When Mama says “banana,” an infant connects that word to the entire yellow object she’s looking at—not just its tip or its peel. Infants perform little experiments: Can I eat this? How far can I throw that? They are motivated by emotions such as desire, curiosity, and frustration. Children are always trying to do something just beyond their ability. Their learning is efficient because it’s embodied, adaptive, deliberate, and continuous. Maybe truly understanding the world requires participating in it.&lt;/p&gt;
    &lt;p&gt;An A.I.’s experience, in comparison, is so impoverished that it can’t really be called “experience.” Large language models are trained on data that is already extraordinarily refined. “I think the reason they work is that they’re piggybacking on language,” Tsao, the U.C. Berkeley neuroscientist, told me. Language is like experience pre-chewed; other kinds of data are less dense with meaning. “Why is it that we haven’t had a comparable revolution in terms of reasoning about video data?” Gershman, the Harvard cognitive scientist, asked. “The kinds of vision models that we have still struggle with common-sense reasoning about physics.” A recent model from DeepMind can generate videos in which paints are mixed correctly and mazes are solved—but they also depict a glass bouncing, instead of shattering, and ropes defying physics by being smooshed into a knot. Ida Momennejad, a cognitive neuroscientist who now works for Microsoft Research, has done experiments in which an L.L.M. is given a virtual walk-through of a building and then asked questions about routes and shortcuts—spatial inferences that come easily to humans. With all but the most basic setups, the A.I.s tend to fail or hallucinate nonexistent paths. “Do they really do planning?” she said. “Not really.”&lt;/p&gt;
    &lt;p&gt;In my conversations with neuroscientists, I sensed a concern that the A.I. industry is racing ahead somewhat thoughtlessly. If the goal is to make artificial minds as capable as human minds are, then “we’re not training the systems in the right way,” Brenden M. Lake, a cognitive scientist at Princeton, told me. When an A.I. is done training, the neural network’s “brain” is frozen. If you tell the model some facts about yourself, it doesn’t rewire its neurons. Instead, it uses a crude substitute: it writes down a bit of text—“The user has a toddler and is studying French”—and considers that before other instructions you give. The human brain updates itself continuously, and there’s a beautiful theory about one of its ways of doing so: when you sleep, selected snapshots from your episodic memory are replayed for your neocortex in order to train it. Your high-dimensional thought space gets dimpled by the replayed memories; you wake up with a slightly new way of seeing.&lt;/p&gt;
    &lt;p&gt;The A.I. community has become so addicted to—and so financially invested in—breakneck progress that it sometimes pretends that advancement is inevitable and there’s no science left to do. Science has the inconvenient property of sometimes stalling out. Silicon Valley may call A.I. companies “labs,” and some employees there “researchers,” but fundamentally it has an engineering culture that does whatever works. “It’s just so remarkable how little the machine-learning community bothers looking at, let alone respects, the history and cognitive science that precedes it,” Cohen said.&lt;/p&gt;
    &lt;p&gt;Today’s A.I. models owe their success to decades-old discoveries about the brain, but they are still deeply unlike brains. Which differences are incidental and which are fundamental? Every group of neuroscientists has its pet theory. These theories can be put to the test in a way that wasn’t possible before. Still, no one expects easy answers. The problems that continue to plague A.I. models “are solved by carefully identifying ways in which the models don’t behave as intelligently as we want them to and then addressing them,” Norman said. “That is still a human-scientist-in-the-loop process.”&lt;/p&gt;
    &lt;p&gt;In the nineties, billions of dollars poured into the Human Genome Project on the assumption that sequencing DNA might solve medicine’s most vexing problems: cancer, hereditary conditions, even aging. It was a time of bluster and confidence—the era of Dolly the cloned sheep and “Jurassic Park”—when biotech was ascendant and the commentariat reckoned with whether humans should be playing God. Biologists soon found that the reality was more complicated. We didn’t cure cancer or discover the causes of Alzheimer’s or autism. We learned that DNA tells just one part of the story of life. In fact, one could argue that biology got swept up in a kind of gene fever, fixating on DNA because we had the means to study and understand it.&lt;/p&gt;
    &lt;p&gt;Still, nobody would claim that Francis Crick was wrong when, on the day in 1953 that he helped confirm the structure of DNA, he walked into a Cambridge pub talking about having discovered the secret of life. He and his colleagues did more to demystify life than almost anyone, ever. The decades following their discovery were among the most productive and exciting in the history of science. DNA became a household term; every high schooler learns about the double helix.&lt;/p&gt;
    &lt;p&gt;With A.I., we once again find ourselves in a moment of bluster and confidence. Sam Altman talks about raising half a trillion dollars to build Stargate, a new cluster of A.I. data centers, in the U.S. People discuss the race for superintelligence with a gravitas and an urgency that can seem ungrounded, even silly. But I suspect the reason that the Amodeis and Altmans of the world are making messianic pronouncements is that they believe that the basic picture of intelligence has been worked out; the rest is just details.&lt;/p&gt;
    &lt;p&gt;Even some neuroscientists believe that a crucial threshold has been crossed. “I really think it could be the right model for cognition,” Uri Hasson, a colleague of Cohen’s, Norman’s, and Lake’s at Princeton, said of neural networks. This upsets him as much as it excites him. “I have the opposite worry of most people,” he said. “My worry is not that these models are similar to us. It’s that we are similar to these models.” If simple training techniques can enable a program to behave like a human, maybe humans aren’t as special as we thought. Could it also mean that A.I. will surpass us not only in knowledge but also in judgment, ingenuity, cunning—and, as a result, power? To my surprise, Hasson told me that he is “worried these days that we might succeed in understanding how the brain works. Pursuing this question may have been a colossal mistake for humanity.” He likened A.I. researchers to nuclear scientists in the nineteen-thirties: “This is the most interesting time in the life of these people. And, at the same time, they know that what they are working on has grave implications for humanity. But they cannot stop because of the curiosity to learn.”&lt;/p&gt;
    &lt;p&gt;One of my favorite books by Hofstadter is a nerdy volume called “Fluid Concepts and Creative Analogies: Computer Models of the Fundamental Mechanisms of Thought.” When I was in college, it electrified me. The premise was that a question such as “What is thinking?” was not merely philosophical but, rather, had a real answer. In 1995, when the book was published, Hofstadter and his research group could only gesture at what the answer might be. Thinking back on the book, I wondered whether Hofstadter would feel excited that A.I. researchers may have attained what he had yearned for: a mechanical account of the rudiments of thinking. When we spoke, however, he sounded profoundly disappointed—and frightened. Current A.I. research “confirms a lot of my ideas, but it also takes away from the beauty of what humanity is,” he told me. “When I was younger, much younger, I wanted to know what underlay creativity, the mechanisms of creativity. That was a holy grail for me. But now I want it to remain a mystery.” Perhaps the secrets of thinking are simpler than anyone expected—the kind of thing that a high schooler, or even a machine, could understand. ♦&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=45802029</guid><pubDate>Mon, 03 Nov 2025 17:55:10 +0000</pubDate></item><item><title>Gallery of wonderful drawings our little thermal printer received</title><link>https://guestbook.goodenough.us</link><description>&lt;doc fingerprint="59d03e8ff57de69d"&gt;
  &lt;main&gt;
    &lt;p&gt;Back to GoodEnough.us This is a gallery of all the wonderful drawings our little printer received. Draw us something! Rene The Robot (Self Portrait) December 10, 2024 172.70.115.89 imthatwhodrawthis December 1, 2024 162.158.79.18 Dan C. November 27, 2024 108.162.216.235 Florian November 26, 2024 162.158.78.234 Kabir Kumar November 20, 2024 172.69.194.121 Charmaine ツ November 20, 2024 172.69.6.8 Rafael Enes November 20, 2024 172.68.102.237 (.❛ ᴗ ❛.) November 19, 2024 172.70.135.108 Lu November 19, 2024 162.158.78.231 werty November 18, 2024 108.162.216.131 Daniel November 18, 2024 108.162.216.130 dz November 16, 2024 162.158.79.62 MAx from Rennes (France) November 16, 2024 162.158.79.28 Jake November 16, 2024 162.158.78.249 Time + Pressure = Diamonds November 10, 2024 162.158.146.55 Sofia October 27, 2024 162.158.78.184 Ka Wai October 24, 2024 108.162.216.150 Francis October 24, 2024 162.158.79.146 ZEEP ZORP October 23, 2024 162.158.78.135 Jesse Cooke October 23, 2024 108.162.216.236 Alberto Gallwgo October 23, 2024 172.71.222.163 Loading more choice prints...&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=45802459</guid><pubDate>Mon, 03 Nov 2025 18:27:32 +0000</pubDate></item><item><title>The Mack Super Pumper was a locomotive engined fire fighter (2018)</title><link>https://bangshift.com/bangshiftxl/mack-super-pumper-system-locomotive-engine-powered-pumper-extinguish-hell-often/</link><description>&lt;doc fingerprint="3a1ad86c4fc08ebb"&gt;
  &lt;main&gt;
    &lt;p&gt;(Lead image: Philip Goldstein) – In the early 1960s the New York City Fire Department was facing a host of problems. The world around them was growing ever taller, ever more compact, and ever more dangerous with respect to fire. There were times when the very infrastructure that was supposed to be supplying them the water to extinguish a blaze simply stopped flowing, there were other times that the equipment they had proved to be woefully insufficient to stop a fire that should have been controlled, resulting in massive blazes that ate up homes, businesses, lives, and millions upon millions of dollars. In April of 1963, a massive fire on Staten Island taxed the city’s fire service to the absolute breaking point while destroying millions and millions in property.&lt;/p&gt;
    &lt;p&gt;The day is still referred to as Black Saturday by the people who lived through it. Due to the lack of suitable water supplies, the fire was far larger than it should have been. There was a drought that year and many of the sources that the firemen were used to pulling water from had literally run dry. This began a series of events that led to the construction of the most powerful land based fire fighting truck ever created, the Mack Super Pumper System. It was actually five trucks that worked as a brigade to battle the worst flaming disasters that the city could throw at it.&lt;/p&gt;
    &lt;p&gt;From 1965 through the early 1980s, the Mack Super Pumper System responded to more than 2,200 calls with more than 900 firefighters serving to operate it in some capacity. The five trucks that made up the super pumper system were a massive, locomotive-engined central pumping truck, a tender truck full of hoses, manifolds, and other gear, and three satellite trucks that looked like standard fire engines but were not equipped with their own pumps. It cost the city of New York $875,000 when it was new and we’ll wager to say that it was probably the best money ever spent to keep Gotham safe. There’s never been anything else like it.&lt;/p&gt;
    &lt;p&gt;The pumping unit –&lt;/p&gt;
    &lt;p&gt;The keystone of the whole operation was the massive central pumping unit that could draw water from eight hydrants at once, drop lines into bodies of water, supply a mind-boggling number of lines with water simultaneously, and flow over 10,000 gallons per minute at low pressures if the situation called for it. When the pressure was ramped up to to 350psi, it could move 8,800 GPM. This was enough to supply the other satellite trucks as well as feed a massive water cannon on the tender truck that could heave water over 600ft. That’s right, nearly and eight of a mile in whatever direction you wanted it to go. How was this possible? It was possible because of innovations in diesel engine technology during WWII. The grunt for the Super Pumper system came from a Napier-Deltic diesel engine. This was an engine designed by the British during WWII as a lightweight, high speed means to propel their ships. Making 2,400 horsepower and even more prodigious torque numbers, the engine was “light” enough to be mounted in a trailer behind a tractor and carted around. The Napier-Deltic was used to power locomotives and other massive land craft as well for a while. The engine’s design is interesting in the fact that it had three crankshafts and was an opposed piston style engine meaning that the pistons travel at each other. With turbochargers and a two stroke design, it was as mighty a compact piston powered engine the world had ever known to that point. It was thirsty and noisy as well. When working at full song, the engine would consume 137 gallons of diesel fuel per hour and the noise was so deafening that firemen near the truck had to wear strong ear protection to prevent hearing damage.&lt;/p&gt;
    &lt;p&gt;Mack was awarded the contract to build the truck in 1964 and by the end of the year, the unit was nearly ready to hit the streets of NYC. The tractor employed to drag the pumping unit around was a F715FSTP cab over that used a 255hp Mack END864 engine. The top speed of the whole rig was 42mph but since it was intended for responding to calls in the city, high mph was not as much a concern as maneuverability, and the ability to zip around at lower speeds happily. There were custom built PTOs to power the priming pump for the water pump and to to run an air compressor that needed 450psi to light off the pump engine.&lt;/p&gt;
    &lt;p&gt;The custom built trailer housed the engine and all of the stuff needed to keep it alive like the cooling system, fuel tanks, etc. At the rear of the trailer was the enormous six stage pump which was built by a company called DeLaval and that’s where the real magic happened. When the big Deltic was put to work turning that bad boy, fire, at least any on the first 60 stories of a building, didn’t stand a chance. The whole rig weighed in at 68,000lbs and for as much reading and research as we have done, there are no accounts of it ever faltering, failing, or leaving firefighters without the resources they needed to battle a fire. Often times we read about awesome machines like this and discover that they were unreliable or prone to fail but not this big guy.&lt;/p&gt;
    &lt;p&gt;Some pretty stunning facts about the truck and the pumper:&lt;/p&gt;
    &lt;p&gt;At 8,800 GPM it was throwing nearly 70,000lbs of water on a fire per minute.&lt;/p&gt;
    &lt;p&gt;During a fire in the Bronx, firemen laid 7,000ft of hose to get to a suitable water supply and the truck pumped as though it was dipping its feet into the ocean.&lt;/p&gt;
    &lt;p&gt;In 1967 the Super Pumper responded to a fire at a postal annex in NYC and managed to supply water to the massive gun on the tender truck, its three satellite units, two tower ladder trucks, and a portable manifold with multiple hand lines all by itself.&lt;/p&gt;
    &lt;p&gt;The hoses on the truck were pressure tested to 1,000psi of pressure but typically operated anywhere in the 350-800psi range depending on the situation. This is way higher (by several times!) what modern trucks use by our understanding. The hoses were a derivative of hoses developed by the Navy in WWII for high pressure applications and while incredibly heavy when compared to modern hoses, they were cutting edge at the time.&lt;/p&gt;
    &lt;p&gt;The truck still exists, living at a museum in Michigan and standing as a great reminder that human beings are amazingly inventive and creative beings when forced to find solutions to problems that endanger lots of lives or lots of valuable property!&lt;/p&gt;
    &lt;p&gt;SCROLL DOWN FOR MORE INFORMATION AND PHOTOS ON THIS MIGHTY TRUCK THAT SERVED NYC DUTIFULLY FOR MANY YEARS –&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=45804122</guid><pubDate>Mon, 03 Nov 2025 20:37:34 +0000</pubDate></item><item><title>AI's Dial-Up Era</title><link>https://www.wreflection.com/p/ai-dial-up-era</link><description>&lt;doc fingerprint="898080510eed85e8"&gt;
  &lt;main&gt;
    &lt;p&gt;It is 1995.&lt;/p&gt;
    &lt;p&gt;Your computer modem screeches as it tries to connect to something called the internet. Maybe it works. Maybe you try again.&lt;/p&gt;
    &lt;p&gt;For the first time in history, you can exchange letters with someone across the world in seconds. Only 2000-something websites exist1, so you could theoretically visit them all over a weekend. Most websites are just text on gray backgrounds with the occasional pixelated image2. Loading times are brutal. A single image takes a minute, a 1-minute video could take hours. Most people do not trust putting their credit cards online. The advice everyone gives: don’t trust strangers on the internet.&lt;/p&gt;
    &lt;p&gt;People split into two camps very soon.&lt;/p&gt;
    &lt;p&gt;Optimists predict grand transformations. Some believe digital commerce will overtake physical retail within years. Others insist we’ll wander around in virtual reality worlds.&lt;/p&gt;
    &lt;quote&gt;
      &lt;p&gt;“I expect that within the next five years more than one in ten people will wear head-mounted computer displays while traveling in buses, trains, and planes.” - Nicholas Negroponte, MIT Professor, 1993&lt;/p&gt;
    &lt;/quote&gt;
    &lt;p&gt;Pessimists call the internet a fad and a bubble.&lt;/p&gt;
    &lt;p&gt;If you told the average person in 1995 that within 25 years, we’d consume news from strangers on social media over newspapers, watch shows on-demand in place of cable TV, find romantic partners through apps more than through friends, and flip “don’t trust strangers on the internet” so completely that we’d let internet strangers pick us up in their personal vehicles and sleep in their spare bedrooms, most people would find that hard to believe.&lt;/p&gt;
    &lt;p&gt;We’re in 1995 again. This time with Artificial Intelligence.&lt;/p&gt;
    &lt;p&gt;And both sides of today’s debate are making similar mistakes.&lt;/p&gt;
    &lt;p&gt;One side warns that AI will eliminate entire professions and cause mass unemployment within a couple of years. The other claims that AI will create more jobs than it destroys. One camp dismisses AI as overhyped vaporware destined for a bubble burst, while the other predicts it will automate every knowledge task and reshape civilization within the decade.&lt;/p&gt;
    &lt;p&gt;Both are part right and part wrong.&lt;/p&gt;
    &lt;head rend="h3"&gt;The Employment Paradox: Why Automation’s Impact Depends On The Industry&lt;/head&gt;
    &lt;p&gt;Geoffrey Hinton, who some call the Father of AI, warned in 2016 that AI would trigger mass unemployment. “People should stop training radiologists now,” he declared, certain that AI would replace them within years.&lt;/p&gt;
    &lt;p&gt;Yet as Deena Mousa, a researcher, shows in “The Algorithm Will See You Now,” AI hasn’t replaced radiologists, despite predictions. It is thriving.&lt;/p&gt;
    &lt;quote&gt;
      &lt;p&gt;In 2025, American diagnostic radiology residency programs offered a record 1,208 positions across all radiology specialties, a four percent increase from 2024, and the field’s vacancy rates are at all-time highs. In 2025, radiology was the second-highest-paid medical specialty in the country, with an average income of $520,000, over 48 percent higher than the average salary in 2015.&lt;/p&gt;
    &lt;/quote&gt;
    &lt;p&gt;Mousa identifies a few factors for why the prediction failed - real-world complexity, the job involves more than image recognition, and regulatory/insurance hurdles. Most critical she points is Jevons Paradox, which is the economic principle that a technological improvement in resource efficiency leads to an increase in the total consumption of that resource, rather than a decrease. Her argument is that as AI makes radiologists more productive, better diagnostics and faster turnaround at lower costs mean more people get scans. So employment doesn’t decrease. It increases.&lt;/p&gt;
    &lt;p&gt;This is also the Tech world’s consensus. Microsoft CEO Satya Nadella agrees, as does Box CEO Aaron Levie, who suggests:&lt;/p&gt;
    &lt;quote&gt;
      &lt;p&gt;“The least understood yet most important concept in the world is Jevons Paradox. When we make a technology more efficient, demand goes well beyond the original level. AI is the perfect example of this—almost anything that AI is applied to will see more demand, not less.”&lt;/p&gt;
    &lt;/quote&gt;
    &lt;p&gt;They’re only half right.&lt;/p&gt;
    &lt;p&gt;First, as Andrej Karpathy, the computer scientist who coined the term vibe coding, points out, radiology is not the right job to look for initial job displacements.&lt;/p&gt;
    &lt;quote&gt;
      &lt;p&gt;“Radiology is too multi-faceted, too high risk, too regulated. When looking for jobs that will change a lot due to AI on shorter time scales, I’d look in other places - jobs that look like repetition of one rote task, each task being relatively independent, closed (not requiring too much context), short (in time), forgiving (the cost of mistake is low), and of course automatable giving current (and digital) capability. Even then, I’d expect to see AI adopted as a tool at first, where jobs change and refactor (e.g. more monitoring or supervising than manual doing, etc).”&lt;/p&gt;
    &lt;/quote&gt;
    &lt;p&gt;Second, the tech consensus that we will see increased employment actually depends on the industry. Specifically, how much unfulfilled demand can be unlocked in that industry, and whether this unfulfilled demand growth outpaces continued automation and productivity improvement.&lt;/p&gt;
    &lt;p&gt;To understand this better, look at what actually happened in three industries over a 200-year period from 1800 to 2000. In the paper Automation and jobs: when technology boosts employment, James Bessen, an economist, shows the employment, productivity, and demand data for textile, iron &amp;amp; steel, and motor vehicle industries.&lt;/p&gt;
    &lt;p&gt;After automation, both textile and iron/steel workers saw employment increase for nearly a century before experiencing a steep decline. Vehicle manufacturing, by contrast, holds steady and hasn’t seen the same steep decline yet.&lt;/p&gt;
    &lt;p&gt;To answer why those two industries saw sharp declines but motor vehicle manufacturing did not, first look at the productivity of workers in all three industries:&lt;/p&gt;
    &lt;p&gt;Then look at the demand across those three industries:&lt;/p&gt;
    &lt;p&gt;What the graphs show is a consistent pattern (note: the productivity and demand graphs are logarithmic, meaning productivity and demand grew exponentially). Early on, a service or product is expensive because many workers are needed to produce it. Most people can’t afford it or use them sparingly. For example, in the early 1800s, most people could only afford a pair of pants or shirt. Then automation makes workers dramatically more productive. A textile worker in 1900 could produce fifty times more than one in 1800. This productivity explosion crashes prices, which creates massive new demand. Suddenly everyone can afford multiple outfits instead of just one or two. Employment and productivity both surge (note: employment growth masks internal segment displacement and wage changes. See footnote3)&lt;/p&gt;
    &lt;p&gt;Once demand saturates, employment doesn’t further increase but holds steady at peak demand. But as automation continues and workers keep getting more productive, employment starts to decline. In textiles, mechanization enabled massive output growth but ultimately displaced workers once consumption plateaued while automation and productivity continued climbing. We probably don’t need infinite clothing. Similarly, patients will likely never need a million radiology reports, no matter how cheap they become and so radiologists will eventually hit a ceiling. We don’t need infinite food, clothing, tax returns, and so on.&lt;/p&gt;
    &lt;p&gt;Motor vehicles, in Bessen’s graphs, tell a different story because demand remains far from saturated. Most people globally still don’t own cars. Automation hasn’t completely conquered manufacturing either (Tesla’s retreat from full manufacturing automation proves the current technical limits). When both demand and automation potential remain high, employment can sustain or even grow despite productivity gains.&lt;/p&gt;
    &lt;p&gt;Software presents an even more interesting question. How many apps do you need? What about software that generates applications on demand, that creates entire software ecosystems autonomously? Until now, handcrafted software was the constraint. Expensive software engineers and their labor costs limited what companies could afford to build. Automation changes this equation by making those engineers far more productive. Both consumer and enterprise software markets suggest significant unmet demand because businesses have consistently left projects unbuilt4. They couldn’t justify the development costs or had to allocate limited resources to their top priority projects. I saw this firsthand at Amazon. Thousands of ideas went unfunded not because they lacked business value, but because of the lack of engineering resources to build them. If AI can produce software at a fraction of the cost, that unleashes enormous latent demand. The key question then is if and when that demand will saturate.&lt;/p&gt;
    &lt;p&gt;So to generalize, for each industry, employment hinges on a race between two forces:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;
        &lt;p&gt;The magnitude and growth of unmet market demand, and&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Whether that demand growth outpaces productivity improvements from automation.&lt;/p&gt;
      &lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Different industries will experience different outcomes depending on who’s winning that demand and productivity race.&lt;/p&gt;
    &lt;head rend="h3"&gt;The Bubble: Irrational Exuberance Builds the Future&lt;/head&gt;
    &lt;p&gt;The second debate centers on whether this AI boom is a bubble waiting to burst.&lt;/p&gt;
    &lt;p&gt;The dotcom boom of the 1990s saw a wave of companies adding “.com” to their name to ride the mania and watch their valuations soar. Infra companies poured billions into fiber optics and undersea cables - expensive projects only possible because people believed the hype5. All of this eventually burst in spectacular fashion in the dotcom crash in 2000-2001. Infrastructure companies like Cisco briefly became the most valuable in the world only to come tumbling down6. Pets.com served as the poster child of this exuberance raising $82.5 million in its IPO, spending millions on a Super Bowl ad only to collapse nine months later7.&lt;/p&gt;
    &lt;p&gt;But the dotcom bubble also got several things right. More importantly, it eventually bought us the physical infrastructure that made YouTube, Netflix, and Facebook possible. Sure, companies like Worldcom, NorthPoint, and Global Crossing making these investments went bankrupt, but they also laid the foundation for the future. Although the crash proved the skeptics right in the short term, it proved the optimists were directionally correct in the long term.&lt;/p&gt;
    &lt;p&gt;Today’s AI boom shows similar exuberance. Consider the AI startup founded by former OpenAI executive Mira Murati, which raised $2 billion at a $10 billion valuation, the largest seed round in history8. This despite having no product and declining to reveal what it’s building or how it will generate returns. Several AI wrappers have raised millions in seed funding with little to no moat.&lt;/p&gt;
    &lt;p&gt;Yet some investments will outlast the hype and will likely help future AI companies even if this is a bubble. For example, the annual capital expenditures of Hyperscalers9 that have more than doubled since ChatGPT’s release - Microsoft, Google, Meta, and Amazon are collectively spending almost half a trillion dollars on data centers, chips, and compute infrastructure. Regardless of which specific companies survive, this infrastructure being built now will create the foundation for our AI future - from inference capacity to the power generation needed to support it.&lt;/p&gt;
    &lt;p&gt;The infrastructure investments may have long-term value, but are we already in bubble territory? Azeem Azhar, a tech analyst and investor, provides an excellent practical framework to answer the AI bubble question. He benchmarks today’s AI boom using five gauges: economic strain (investment as a share of GDP), industry strain (capex to revenue ratios), revenue growth trajectories (doubling time), valuation heat (price-to-earnings multiples), and funding quality (the resilience of capital sources). His analysis shows that AI remains in a demand-led boom rather than a bubble, but if two of the five gauges head into red, we will be in bubble territory.&lt;/p&gt;
    &lt;p&gt;The demand is real. After all OpenAI is one of the fastest-growing companies in history10. But that alone doesn’t prevent bubbles. OpenAI will likely be fine given its product-market fit, but many other AI companies face the same unit economics questions that plagued dotcom companies in the 1990s. Pets.com had millions of users too (a then large portion of internet users), but as the tech axiom goes, you can acquire infinite customers and generate infinite revenue if you sell dollars for 85 cents11. So despite the demand, the pattern may rhyme with the 1990s. Expect overbuilding. Expect some spectacular failures. But also expect the infrastructure to outlast the hype cycle and enable things we can’t yet imagine.&lt;/p&gt;
    &lt;head rend="h3"&gt;The Predictably Unpredictable Future&lt;/head&gt;
    &lt;p&gt;So where does this leave us?&lt;/p&gt;
    &lt;p&gt;We’re early in the AI revolution. We’re at that metaphorical screeching modem phase of the internet era. Just as infrastructure companies poured billions into fiber optics, hyperscalers now pour billions into compute. Startups add “.ai” to their names like companies once added “.com” as they seek higher valuations. The hype will cycle through both euphoria and despair. Some predictions will look laughably wrong. Some that seem crazy will prove conservative.&lt;/p&gt;
    &lt;p&gt;Different industries will experience different outcomes. Unlike what the Jevons optimists suggest, demand for many things plateaus once human needs are met. Employment outcomes in any industry depend on the magnitude and growth of unmet market demand and whether that demand growth outpaces productivity improvements from automation.&lt;/p&gt;
    &lt;p&gt;Cost reduction will unlock market segments. Aswath Damodaran, a finance professor, (in)famously undervalued Uber assuming it would only capture a portion of the existing taxi market12. He missed that making rides dramatically cheaper would expand the market itself as people took Ubers to destinations they’d never have paid taxi prices to reach. AI will similarly enable products and services currently too expensive to build with human intelligence. A restaurant owner might use AI to create custom supply chain software that say at $100,000 with human developers would never have been built. A non-profit might deploy AI to contest a legal battle that was previously unaffordable.&lt;/p&gt;
    &lt;p&gt;We can predict change, but we can’t predict the details. No one in 1995 predicted we’d date strangers from the internet, ride in their ubers, or sleep in their airbnbs. Or that a job called influencers would become the most sought-after career among young people. Human creativity generates outcomes we can’t forecast with our current mental models. Expect new domains and industries to emerge. AI has already helped us decode more animal communication in the last five years than in the last fifty. Can we predict what jobs a technology that allows us to have full-blown conversations with them will unlock? A job that doesn’t exist today will likely be the most sought-after job in 2050. We can’t name it because it hasn’t been invented yet.&lt;/p&gt;
    &lt;p&gt;Job categories will transform. Even as the internet made some jobs obsolete, it also transformed others and created new categories. Expect the same with AI. Karpathy ends with a question:&lt;/p&gt;
    &lt;quote&gt;
      &lt;p&gt;About 6 months ago, I was also asked to vote if we will have less or more software engineers in 5 years. Exercise left for the reader.&lt;/p&gt;
    &lt;/quote&gt;
    &lt;p&gt;To answer this question, go back to 1995 and ask the same question but with journalists. You might have predicted more journalists because the internet would create more demand by enabling you to reach the whole world. You’d be right for 10 or so years as employment in journalism grew until the early 2000s. But 30 years later, the number of newspapers and the number of journalists both have declined, even though more “journalism” happens than ever. Just not by people we call journalists. Bloggers, influencers, YouTubers, and newsletter writers do the work that traditional journalists used to do13.&lt;/p&gt;
    &lt;p&gt;The same pattern will play out with software engineers. We’ll see more people doing software engineering work and in a decade or so, what “software engineer” means will have transformed. Consider the restaurant owner from earlier who uses AI to create custom inventory software that is useful only for them. They won’t call themselves a software engineer.&lt;/p&gt;
    &lt;p&gt;So just like in 1995, if the AI optimists today say that within 25 years, we’d prefer news from AI over social media influencers, watch AI-generated characters in place of human actors, find romantic partners through AI matchmakers more than through dating apps (or perhaps use AI romantic partners itself), and flip “don’t trust AI” so completely that we’d rely on AI for life-or-death decisions and trust it to raise our children, most people would find that hard to believe. Even with all the intelligence, both natural and artificial, no one can predict with certainty what our AI future will look like. Not the tech CEOs, not the AI researchers, and certainly not some random guy pontificating on the internet. But whether we get the details right or not, our AI future is loading.&lt;/p&gt;
    &lt;p&gt;Approximately 2,879 websites were established before 1995, expanding to 23,500 by June 1995. See https://en.wikipedia.org/wiki/List_of_websites_founded_before_1995&lt;/p&gt;
    &lt;p&gt;Historical data from the Industrial Revolution shows that even as aggregate textile employment grew, workers shifted between job types within the industry as some roles became redundant. And correspondingly, some jobs saw wages collapse while others saw increases. For example, domestic hand-loom weavers were displaced by power looms and saw their wages collapse, while self-acting mule spinners (a newly created role) and factory workers saw stable employment and steady compensation growth. Additionally, Britain’s deflationary period (1815-1850) saw food prices fall by half, meaning real purchasing power often rose even when nominal wages declined. Despite all this, the psychological reality was harsh. Even with falling prices, watching your paycheck shrink while neighbors lost jobs and debts grew harder to pay (lower wages but fixed obligations) created real instability regardless of aggregate statistics improvements. Also see Acemoglu &amp;amp; Johnson, 2024.&lt;/p&gt;
    &lt;p&gt;Ask any tech product leader about their roadmap planning, and they’ll all universally report far more worthwhile projects than resources to build them, forcing ruthless prioritization to decide what gets built.&lt;/p&gt;
    &lt;p&gt;Hyperscalers are large cloud computing companies like Microsoft, Google, Meta, and Amazon that operate massive data centers and provide the computing infrastructure necessary to train and run AI models at scale.&lt;/p&gt;
    &lt;p&gt;Damodaran valued Uber at $6B, assuming a 10% market share of the then $100B taxi market. Uber’s market cap as of October 2025 is $190B.&lt;/p&gt;
    &lt;p&gt;Job transformation doesn’t guarantee comparable compensation. Much of this new “journalism” or content creation happens for free or at rates far below what traditional news organizations paid, separating the work from stable employment.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=45804377</guid><pubDate>Mon, 03 Nov 2025 21:01:09 +0000</pubDate></item><item><title>Guideline has been acquired by Gusto</title><link>https://help.guideline.com/en/articles/12694322-guideline-has-joined-gusto-faqs-about-our-recent-acquisition</link><description>&lt;doc fingerprint="2ec558179725a185"&gt;
  &lt;main&gt;
    &lt;p&gt;We have exciting news to share: Guideline has been acquired by Gusto, a leading provider of payroll, benefits, and HR solutions tailored to small businesses.&lt;/p&gt;
    &lt;p&gt;By joining forces, we can deliver payroll and 401(k) services that are more seamlessly integrated all in one place. This is the start of a new chapter that will make saving for retirement simpler and more accessible than ever.&lt;/p&gt;
    &lt;p&gt;The service you've come to know and expect from Guideline hasn’t changed. Everything works the same as it did previously, and we're committed to making sure your experience stays smooth and reliable.&lt;/p&gt;
    &lt;p&gt;We know you might have questions about the acquisition, so here are some answers on what to expect.&lt;/p&gt;
    &lt;head rend="h1"&gt;Frequently asked questions&lt;/head&gt;
    &lt;head rend="h2"&gt;General information and day-to-day operations&lt;/head&gt;
    &lt;p&gt;Do I need to take any action right now?&lt;/p&gt;
    &lt;p&gt;No. Your current 401(k) setup stays exactly the same. Participants do not need to take any action and all current 401(k) contributions will continue according to the selections within your account.&lt;/p&gt;
    &lt;p&gt;Plan sponsors who received notice about transitioning to a self-service plan can find additional details on administrative and fiduciary responsibilities here.&lt;/p&gt;
    &lt;p&gt;Why does this benefit me?&lt;/p&gt;
    &lt;p&gt;By Guideline joining Gusto, we're making payroll and 401(k) management more seamless than ever. For instance, you can now access your 401(k) account using your Gusto credentials via Single Sign-On (SSO).&lt;/p&gt;
    &lt;p&gt;Over time, we’ll bring new tools to make setting up and managing your 401(k) even easier.&lt;/p&gt;
    &lt;p&gt;Will I lose access to anything I use today (mobile app, statements, educational resources)?&lt;/p&gt;
    &lt;p&gt;Not at all. You can continue to use the mobile app, access statements, and visit our Help Center for educational resources just as you normally would. We’ll keep you informed about future enhancements and a more unified experience.&lt;/p&gt;
    &lt;p&gt;Will I still have access to historical documents?&lt;/p&gt;
    &lt;p&gt;Yes, you will continue to have access to all documentation within your dashboard.&lt;/p&gt;
    &lt;p&gt;Will anything change for my company?&lt;/p&gt;
    &lt;p&gt;The core features and day-to-day operations of your plan are expected to continue seamlessly. We are focused on a smooth transition with minimal disruption. If your company uses Gusto payroll, you will experience the benefits of deeper integration.&lt;/p&gt;
    &lt;p&gt;Plan sponsors who received notice about being transitioned to a self-service plan can find additional details on administrative and fiduciary responsibilities here.&lt;/p&gt;
    &lt;p&gt;Will my fees change?&lt;/p&gt;
    &lt;p&gt;No pricing changes are planned at this time.&lt;/p&gt;
    &lt;head rend="h2"&gt;Security and transactions&lt;/head&gt;
    &lt;p&gt;Is my retirement account still secure during this transition?&lt;/p&gt;
    &lt;p&gt;We take the security of your account and personal information extremely seriously. Protecting your assets and data is a responsibility to which we are fully committed, both during this transition and beyond. All of our rigorous security measures will continue to operate without interruption.&lt;/p&gt;
    &lt;p&gt;Will there be any changes to my investments or allocations?&lt;/p&gt;
    &lt;p&gt;No, there will be no changes to your investments at this time. Your holdings and asset allocation are unaffected by this transition, and your money remains invested according to your chosen strategy.&lt;/p&gt;
    &lt;p&gt;Will this delay my contributions, distributions, or rollovers?&lt;/p&gt;
    &lt;p&gt;Not at all. We are committed to processing all of your financial transactions in a timely manner, just as we always have. You can expect your transactions to be handled promptly without any new delay.&lt;/p&gt;
    &lt;head rend="h2"&gt;Support&lt;/head&gt;
    &lt;p&gt;Who do I reach out to if I have questions?&lt;/p&gt;
    &lt;p&gt;Guideline's support teams are not changing. For 401(k) plan questions, sponsors and administrators can continue directing questions to clients@guideline.com. Participants can reach out to support@guideline.com. For questions related to payroll, please contact your existing payroll support team.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=45805458</guid><pubDate>Mon, 03 Nov 2025 22:54:20 +0000</pubDate></item><item><title>A friendly tour of process memory on Linux</title><link>https://www.0xkato.xyz/linux-process-memory/</link><description>&lt;doc fingerprint="8628597b90e6bdc5"&gt;
  &lt;main&gt;&lt;head rend="h1"&gt;A Friendly Tour of Process Memory on Linux&lt;/head&gt;- 24 mins&lt;head rend="h1"&gt;A Friendly Tour of Process Memory on Linux&lt;/head&gt;&lt;p&gt;You run a program. It reads and writes addresses as if a giant, continuous slab of memory had been waiting there all along. It didn’t. Linux builds that illusion on the fly, one page at a time. This is a walk through what your process actually owns, what happens on the first touch of a byte, how protections and huge pages fit in, how to see the truth from &lt;code&gt;/proc&lt;/code&gt;, and why modern kernels do a little extra dance to defend against Meltdown.&lt;/p&gt;&lt;p&gt;Note: This tour targets Linux on x86‑64, other architectures differ in details (page sizes, cache rules), but the ideas carry over.&lt;/p&gt;&lt;head rend="h2"&gt;Intro&lt;/head&gt;&lt;p&gt;The picture below is a quick introduction. It is a simple map you can keep in mind as you read.&lt;/p&gt;&lt;p&gt;Physical RAM is the real memory. It is a bunch of frames scattered around. The virtual view is the clean line your program sees. It does not match the real layout. The page table is a list. It tells which spot on the virtual line points to which frame in RAM. Disk is extra space the system can use when RAM is full.&lt;/p&gt;&lt;p&gt;Here is how it plays out. When you read or write, the CPU looks in the page table. If there is an entry it goes to that frame. If there is no entry you get a page fault. The system then fills a frame and adds the entry, or it stops you with an error. We will explain faults later.&lt;/p&gt;&lt;p&gt;When RAM is tight the system makes room. It moves pages you have not used in a while to disk, or drops file pages it can load again. If you touch one of those later it brings it back.&lt;/p&gt;&lt;p&gt;Tiny explainers appear throughout so anyone can follow along, regardless of background.&lt;/p&gt;&lt;quote&gt;&lt;p&gt;Tiny explainer:&lt;/p&gt;&lt;code&gt;/proc&lt;/code&gt;&lt;code&gt;/proc&lt;/code&gt;is a virtual filesystem the kernel builds in memory. It exposes process and kernel state as files. You can read them with normal tools like&lt;code&gt;cat&lt;/code&gt;.&lt;/quote&gt;&lt;head rend="h2"&gt;The floor plan you never see&lt;/head&gt;&lt;p&gt;Inside the kernel, your process owns one object that represents its whole address space. Think of it as a floor plan. Each room on that plan is a virtual memory area (VMA) a contiguous range with the same permissions (read, write, execute) and the same kind of backing (anonymous memory or a file).&lt;/p&gt;&lt;quote&gt;&lt;p&gt;Tiny explainer: VMA&lt;/p&gt;&lt;lb/&gt;A VMA is a continuous virtual address range with one set of rights and one kind of backing.&lt;/quote&gt;&lt;p&gt;Under the plan sit the page tables that the hardware reads to translate your virtual addresses to real page frames.&lt;/p&gt;&lt;quote&gt;&lt;p&gt;Tiny explainer: page tables and PTE&lt;/p&gt;&lt;lb/&gt;Page tables are lookup structures the CPU walks to translate addresses. A page table entry (PTE) maps one virtual page to one physical page and holds bits like present and writable.&lt;/quote&gt;&lt;p&gt;All threads in the process share the same plan. When the scheduler runs you, the CPU is pointed at your page tables, so pointer dereferences don’t need a syscall once a mapping exists, the hardware does the translation on its own.&lt;/p&gt;&lt;p&gt;You change the plan in three ways: &lt;code&gt;mmap&lt;/code&gt; draws a room, &lt;code&gt;mprotect&lt;/code&gt; changes the sign on its door (R/W/X), and &lt;code&gt;munmap&lt;/code&gt; tears it down.&lt;/p&gt;&lt;quote&gt;&lt;p&gt;Tiny explainer:&lt;/p&gt;&lt;code&gt;mmap&lt;/code&gt;&lt;code&gt;mmap&lt;/code&gt;reserves a virtual range with given permissions and a backing source.&lt;lb/&gt;Tiny explainer:&lt;code&gt;mprotect&lt;/code&gt;&lt;code&gt;mprotect&lt;/code&gt;changes the permissions on an existing range.&lt;lb/&gt;Tiny explainer:&lt;code&gt;munmap&lt;/code&gt;&lt;code&gt;munmap&lt;/code&gt;removes a mapping from the address space.&lt;/quote&gt;&lt;p&gt;Everything else (creating pages, reading file data, swapping) happens lazily when you touch memory.&lt;/p&gt;&lt;quote&gt;&lt;p&gt;Tiny explainer: page&lt;/p&gt;&lt;lb/&gt;Hardware manages memory in fixed chunks called pages. On many x86‑64 machines a base page is 4 KiB. Bigger pages exist at 2 MiB and 1 GiB.&lt;/quote&gt;&lt;head rend="h2"&gt;A quick glance at your own house&lt;/head&gt;&lt;p&gt;Run:&lt;code&gt;cat /proc/self/maps | sed -n '1,80p'&lt;/code&gt;&lt;/p&gt;&lt;p&gt;You’ll see your main binary’s segments (code, data, bss), the heap, anonymous mappings (allocators use these for big chunks), shared libraries, and thread stacks near the top.&lt;/p&gt;&lt;p&gt;You’ll typically also see two small regions:&lt;/p&gt;&lt;list rend="ul"&gt;&lt;item&gt;&lt;code&gt;[vdso]&lt;/code&gt;: a tiny shared object the kernel maps in so a few calls like&lt;code&gt;gettimeofday&lt;/code&gt;can run without a kernel trap.&lt;/item&gt;&lt;item&gt;&lt;code&gt;[vvar]&lt;/code&gt;: read‑only data those helpers use.&lt;/item&gt;&lt;/list&gt;&lt;quote&gt;&lt;p&gt;Tiny explainer:&lt;/p&gt;&lt;code&gt;vdso&lt;/code&gt;and&lt;code&gt;vvar&lt;/code&gt;&lt;code&gt;vdso&lt;/code&gt;is code the kernel maps into your process to make some syscalls fast.&lt;code&gt;vvar&lt;/code&gt;holds data that code reads.&lt;/quote&gt;&lt;p&gt;They’re why asking the time is fast.&lt;/p&gt;&lt;head rend="h2"&gt;&lt;code&gt;mmap&lt;/code&gt;, without the fog&lt;/head&gt;&lt;p&gt;When you call &lt;code&gt;mmap&lt;/code&gt;, you’re not “allocating memory” so much as drawing a promise on the floor plan. You say give me a range of addresses with these rights and back it by this file plus offset or by anonymous memory. Linux picks an address, makes sure it doesn’t collide, adjusts VMAs so each remains uniform, and records the promise.&lt;/p&gt;&lt;quote&gt;&lt;p&gt;Tiny explainer: ASLR&lt;/p&gt;&lt;lb/&gt;Address Space Layout Randomization places mappings at randomized locations to make exploits harder.&lt;lb/&gt;Tiny explainer: anonymous vs file mapping&lt;lb/&gt;Anonymous memory is not tied to a file and starts as zeros. File mappings mirror file contents.&lt;/quote&gt;&lt;p&gt;It does not allocate pages yet. That comes later at first touch.&lt;/p&gt;&lt;p&gt;Two gotchas come up over and over:&lt;/p&gt;&lt;list rend="ul"&gt;&lt;item&gt;File mappings: &lt;code&gt;offset&lt;/code&gt;must be page aligned or&lt;code&gt;mmap&lt;/code&gt;returns&lt;code&gt;EINVAL&lt;/code&gt;.&lt;/item&gt;&lt;item&gt;Mapping past end of file is allowed, but touching beyond the true end raises &lt;code&gt;SIGBUS&lt;/code&gt;. The VMA exists, the data does not.&lt;/item&gt;&lt;/list&gt;&lt;quote&gt;&lt;p&gt;Tiny explainer:&lt;/p&gt;&lt;code&gt;MAP_PRIVATE&lt;/code&gt;and&lt;code&gt;MAP_SHARED&lt;/code&gt;&lt;code&gt;MAP_SHARED&lt;/code&gt;means writes go back to the file and are visible to others that share it.&lt;code&gt;MAP_PRIVATE&lt;/code&gt;means you see the file but writes go to private copy‑on‑write pages.&lt;/quote&gt;&lt;p&gt;Anonymous mappings start life as zeroes. File mappings mirror the file. If the file ends mid page the tail of that last page reads as zeros but still belongs to the file.&lt;/p&gt;&lt;p&gt;&lt;code&gt;MAP_FIXED&lt;/code&gt; means exactly here and it overwrites anything already mapped at that address. Prefer &lt;code&gt;MAP_FIXED_NOREPLACE&lt;/code&gt; to fail instead of clobbering. Without either flag your &lt;code&gt;addr&lt;/code&gt; is just a hint.&lt;/p&gt;&lt;quote&gt;&lt;p&gt;Tiny explainer:&lt;/p&gt;&lt;code&gt;MAP_FIXED_NOREPLACE&lt;/code&gt;&lt;lb/&gt;Ask for an exact address and fail if something is already there. Safer than overwriting.&lt;/quote&gt;&lt;head rend="h2"&gt;The first touch&lt;/head&gt;&lt;p&gt;Imagine &lt;code&gt;*p = 42;&lt;/code&gt; to a fresh mapping. The CPU tries to translate the address. It finds no entry so it raises a page fault that includes the address and an error code.&lt;/p&gt;&lt;quote&gt;&lt;p&gt;Tiny explainer: page fault&lt;/p&gt;&lt;lb/&gt;A page fault is the CPU asking the kernel to handle a missing or illegal translation for an address.&lt;/quote&gt;&lt;p&gt;The kernel’s handler runs on your behalf and asks three questions in this order:&lt;/p&gt;&lt;list rend="ol"&gt;&lt;item&gt;Is the address inside any VMA&lt;lb/&gt;If not you are poking a hole in the plan →&lt;code&gt;SIGSEGV&lt;/code&gt;.&lt;/item&gt;&lt;item&gt;Do the rights allow this access&lt;lb/&gt;Write to a read only page or execute from non exec →&lt;code&gt;SIGSEGV&lt;/code&gt;.&lt;/item&gt;&lt;item&gt;If it is valid but missing make it real&lt;lb/&gt;For an anonymous mapping the kernel allocates a zero filled physical page, wires a page table entry with your requested permissions, and returns to your instruction. For a file mapping it first checks the page cache. If the data is not in RAM it reads from storage, then installs the translation and retries your instruction. Your store lands. You keep going.&lt;/item&gt;&lt;/list&gt;&lt;quote&gt;&lt;p&gt;Tiny explainer: page cache&lt;/p&gt;&lt;lb/&gt;The page cache is the kernel’s cache of file data in RAM. File mappings read and write through it.&lt;lb/&gt;Tiny explainer: zero page&lt;lb/&gt;Some reads from fresh anonymous memory can be satisfied by a shared read only page of zeros. A private page is created on the first write.&lt;/quote&gt;&lt;p&gt;People count these faults:&lt;/p&gt;&lt;list rend="ul"&gt;&lt;item&gt;A minor fault means the data was already in RAM and only the translation was missing.&lt;/item&gt;&lt;item&gt;A major fault means the kernel had to wait for I/O which is expensive.&lt;/item&gt;&lt;/list&gt;&lt;quote&gt;&lt;p&gt;Tiny explainer: stack guard&lt;/p&gt;&lt;lb/&gt;User stacks have a guard page. Touching just below the current stack can grow it. Touching far below looks like a bug and gets a&lt;code&gt;SIGSEGV&lt;/code&gt;.&lt;/quote&gt;&lt;p&gt;This same lazy first touch explains how memory is shared after &lt;code&gt;fork()&lt;/code&gt; and how &lt;code&gt;MAP_PRIVATE&lt;/code&gt; works. The next section shows that path.&lt;/p&gt;&lt;head rend="h2"&gt;Copy on write with &lt;code&gt;fork()&lt;/code&gt; and &lt;code&gt;MAP_PRIVATE&lt;/code&gt;&lt;/head&gt;&lt;p&gt;Why this is here. We just talked about first touch. The same rule explains why pages do not copy on &lt;code&gt;fork&lt;/code&gt; and why &lt;code&gt;MAP_PRIVATE&lt;/code&gt; does not change the file.&lt;/p&gt;&lt;p&gt;&lt;code&gt;fork&lt;/code&gt; does not duplicate pages. The child points at the same physical pages as the parent. The kernel flips those pages to read only for both. The first write hits a copy on write fault. The kernel allocates a new page, copies the bytes, updates the writer’s page table entry to the new page with write permission, and returns. Reads still share the original page. That is why RSS stays flat after &lt;code&gt;fork&lt;/code&gt; until you write.&lt;/p&gt;&lt;quote&gt;&lt;p&gt;Tiny explainer: RSS&lt;/p&gt;&lt;lb/&gt;Resident Set Size is how many pages of this process are currently in RAM. Tiny explainer: copy on write&lt;lb/&gt;Share the same page for reads. Make a private copy only when a write happens.&lt;/quote&gt;&lt;p&gt;&lt;code&gt;MAP_PRIVATE&lt;/code&gt; uses the same idea. You read file data through the page cache. When you write, the kernel gives you a private page. The file stays unchanged.&lt;/p&gt;&lt;p&gt;Things you will also run into:&lt;/p&gt;&lt;list rend="ul"&gt;&lt;item&gt;&lt;code&gt;fork&lt;/code&gt;then&lt;code&gt;execve&lt;/code&gt;. The child replaces its whole address space soon after. That avoids most CoW work.&lt;/item&gt;&lt;item&gt;&lt;code&gt;vfork&lt;/code&gt;. The child runs in the parent’s address space until it calls&lt;code&gt;exec&lt;/code&gt;or&lt;code&gt;_exit&lt;/code&gt;. The parent waits. Do not touch memory in the child.&lt;/item&gt;&lt;item&gt;&lt;code&gt;clone&lt;/code&gt;with&lt;code&gt;CLONE_VM&lt;/code&gt;. This makes a thread. One address space. No copy.&lt;/item&gt;&lt;item&gt;&lt;code&gt;MAP_SHARED&lt;/code&gt;. Writes go to the shared page and to the file or shmem. No CoW.&lt;/item&gt;&lt;item&gt;&lt;code&gt;MADV_DONTFORK&lt;/code&gt;. Leave this mapping out of the child.&lt;/item&gt;&lt;item&gt;&lt;code&gt;MADV_WIPEONFORK&lt;/code&gt;. The child sees zeros for this mapping.&lt;/item&gt;&lt;item&gt;Transparent huge pages. Breaking CoW on a huge page may split it first. Small extra cost.&lt;/item&gt;&lt;/list&gt;&lt;head rend="h2"&gt;Changing rights, and the little pause you feel&lt;/head&gt;&lt;p&gt;Why you care. JITs and loaders flip a region from writable to executable after codegen which is W^X. That flip is not free.&lt;/p&gt;&lt;quote&gt;&lt;p&gt;Tiny explainer: W^X&lt;/p&gt;&lt;lb/&gt;Write xor Execute is a policy. A page is never writable and executable at the same time.&lt;/quote&gt;&lt;p&gt;&lt;code&gt;mprotect(addr, len, prot)&lt;/code&gt; changes permissions. Internally the kernel may split VMAs so each remains uniform, edits the page table entries for the range, and then does one more necessary thing. It invalidates old translations from the CPU’s small cache of address translations which is the TLB. That invalidation is the small pause you sometimes feel when a JIT flips RW to RX or back.&lt;/p&gt;&lt;quote&gt;&lt;p&gt;Tiny explainer: TLB&lt;/p&gt;&lt;lb/&gt;The Translation Lookaside Buffer caches recent translations so the CPU does not walk page tables every time.&lt;/quote&gt;&lt;p&gt;Most systems enforce W^X. A page should not be writable and executable at the same time. JITs keep to that by flipping after codegen or by keeping two virtual mappings of the same memory so no single mapping is both.&lt;/p&gt;&lt;p&gt;Remember there are two layers of permission checks:&lt;/p&gt;&lt;list rend="ol"&gt;&lt;item&gt;Filesystem or mount policy like &lt;code&gt;noexec&lt;/code&gt;&lt;/item&gt;&lt;item&gt;Page permissions like &lt;code&gt;PROT_EXEC&lt;/code&gt;&lt;/item&gt;&lt;/list&gt;&lt;p&gt;Either layer can block execution.&lt;/p&gt;&lt;head rend="h2"&gt;Seeing what’s really mapped&lt;/head&gt;&lt;p&gt;For everyday questions the friendly view is enough.&lt;/p&gt;&lt;list rend="ul"&gt;&lt;item&gt;&lt;code&gt;/proc/&amp;lt;pid&amp;gt;/maps&lt;/code&gt;shapes: addresses, rights, file names&lt;/item&gt;&lt;item&gt;&lt;code&gt;/proc/&amp;lt;pid&amp;gt;/smaps&lt;/code&gt;and&lt;code&gt;smaps_rollup&lt;/code&gt;add per region accounting like how much is resident which is RSS, private vs shared, and whether huge pages were used like&lt;code&gt;AnonHugePages&lt;/code&gt;and&lt;code&gt;FilePmdMapped&lt;/code&gt;&lt;/item&gt;&lt;/list&gt;&lt;p&gt;When you need truth at the per page level Linux exposes sharper tools.&lt;/p&gt;&lt;p&gt;&lt;code&gt;/proc/&amp;lt;pid&amp;gt;/pagemap&lt;/code&gt; has one 64 bit entry per virtual page. It tells you whether a page is present, swapped, soft dirty, exclusively mapped with caveats for huge pages, whether it is write protected via userfaultfd, or part of a guard region. It can also reveal the page frame number which is PFN but modern kernels hide PFNs from unprivileged users. You need the right capability or root.&lt;/p&gt;&lt;quote&gt;&lt;p&gt;Tiny explainer: PFN&lt;/p&gt;&lt;lb/&gt;Page Frame Number is the physical page index used inside the kernel. Tiny explainer: userfaultfd&lt;lb/&gt;A file descriptor that lets a userspace thread handle faults and write protect events for a range.&lt;/quote&gt;&lt;p&gt;&lt;code&gt;/proc/kpagecount&lt;/code&gt; is indexed by PFN and tells you how many mappings point at a given physical page.&lt;/p&gt;&lt;p&gt;&lt;code&gt;/proc/kpageflags&lt;/code&gt; is also indexed by PFN and tells you what kind of page it is and what is happening to it like anonymous or file backed, part of a transparent huge page, in the LRU, dirty, under writeback, a page table page, or the shared zero page.&lt;/p&gt;&lt;head rend="h3"&gt;Common wrinkles&lt;/head&gt;&lt;list rend="ul"&gt;&lt;item&gt;Sparse files. To tell hole vs data, combine &lt;code&gt;mincore()&lt;/code&gt;which says resident or not with&lt;code&gt;lseek(..., SEEK_DATA/SEEK_HOLE)&lt;/code&gt;on the backing file.&lt;/item&gt;&lt;item&gt;Shared memory and swap. Shared and shmem pages may be non present at the PTE level while still logically allocated. Expect swap entries and non present PTEs.&lt;/item&gt;&lt;item&gt;Privileges. Modern kernels restrict PFN and some flag visibility to privileged users for security.&lt;/item&gt;&lt;/list&gt;&lt;quote&gt;&lt;p&gt;Tiny explainer:&lt;/p&gt;&lt;code&gt;mincore&lt;/code&gt;&lt;code&gt;mincore&lt;/code&gt;tells you which pages of a mapping are in RAM.&lt;lb/&gt;Tiny explainer:&lt;code&gt;SEEK_DATA&lt;/code&gt;and&lt;code&gt;SEEK_HOLE&lt;/code&gt;&lt;lb/&gt;File offsets that let you skip to the next data chunk or the next hole in a sparse file.&lt;/quote&gt;&lt;quote&gt;&lt;p&gt;Tiny explainer: soft dirty vs written&lt;/p&gt;&lt;lb/&gt;Soft dirty marks pages dirtied by userland but it can get lost across swaps or VMA merges. Newer kernels offer an ioctl named&lt;code&gt;PAGEMAP_SCAN&lt;/code&gt;that scans a range for pages written since last write protect and can in the same step write protect them again. It pairs with userfaultfd write protect to give fast and race free userspace dirty tracking for snapshotting and live migration.&lt;/quote&gt;&lt;head rend="h2"&gt;When your page suddenly gets bigger&lt;/head&gt;&lt;p&gt;Your CPU would rather cover more ground with fewer entries in its TLB. Linux can help by backing hot memory with bigger pages.&lt;/p&gt;&lt;quote&gt;&lt;p&gt;Tiny explainer: THP&lt;/p&gt;&lt;lb/&gt;Transparent Huge Pages automatically try to use larger pages for performance when safe.&lt;/quote&gt;&lt;p&gt;Transparent Huge Pages do this automatically for anonymous memory and shmem or tmpfs. A fault can be satisfied with a 2 MiB page instead of 512 small ones. A background thread named khugepaged can also collapse adjacent base pages into a huge page when it is safe.&lt;/p&gt;&lt;quote&gt;&lt;p&gt;Tiny explainer:&lt;/p&gt;&lt;code&gt;khugepaged&lt;/code&gt;&lt;lb/&gt;A kernel thread that scans and merges adjacent small pages into huge pages when conditions are right.&lt;/quote&gt;&lt;p&gt;Modern kernels add multi size THP which is mTHP on some architectures. Groups of base pages like 16 KiB or 64 KiB reduce fault count and TLB pressure without always jumping to 2 MiB. They are still PTE mapped but behave as larger folios inside the VM.&lt;/p&gt;&lt;quote&gt;&lt;p&gt;Tiny explainer: mTHP&lt;/p&gt;&lt;lb/&gt;Multi size THP allows variable order large folios so you get some of the benefit without a full 2 MiB page.&lt;/quote&gt;&lt;p&gt;You can ask for THP in a region with &lt;code&gt;madvise(..., MADV_HUGEPAGE)&lt;/code&gt; or opt out with &lt;code&gt;MADV_NOHUGEPAGE&lt;/code&gt;. System wide behavior lives under &lt;code&gt;/sys/kernel/mm/transparent_hugepage/&lt;/code&gt; with per size controls. &lt;code&gt;enabled&lt;/code&gt; can be &lt;code&gt;always&lt;/code&gt;, &lt;code&gt;madvise&lt;/code&gt;, &lt;code&gt;never&lt;/code&gt;, or &lt;code&gt;inherit&lt;/code&gt;. Shmem or tmpfs have their own knobs like a &lt;code&gt;huge=&lt;/code&gt; mount option with &lt;code&gt;always&lt;/code&gt;, &lt;code&gt;advise&lt;/code&gt;, &lt;code&gt;within_size&lt;/code&gt;, &lt;code&gt;never&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;How to tell if it worked. In &lt;code&gt;/proc/self/smaps&lt;/code&gt; the lines for a region include &lt;code&gt;AnonHugePages&lt;/code&gt; for anonymous THP and &lt;code&gt;FilePmdMapped&lt;/code&gt; for file or shmem huge mappings. System wide &lt;code&gt;/proc/meminfo&lt;/code&gt; has &lt;code&gt;AnonHugePages&lt;/code&gt;, &lt;code&gt;ShmemPmdMapped&lt;/code&gt;, and &lt;code&gt;ShmemHugePages&lt;/code&gt;. &lt;code&gt;/proc/vmstat&lt;/code&gt; keeps a diary of THP events allocated on fault, fell back, split, swapped as a whole, and so on.&lt;/p&gt;&lt;p&gt;Controls plain map:&lt;/p&gt;&lt;list rend="ul"&gt;&lt;item&gt;Top level: &lt;code&gt;/sys/kernel/mm/transparent_hugepage/enabled&lt;/code&gt;which is&lt;code&gt;always&lt;/code&gt;or&lt;code&gt;madvise&lt;/code&gt;or&lt;code&gt;never&lt;/code&gt;&lt;/item&gt;&lt;item&gt;Defrag effort: &lt;code&gt;/sys/kernel/mm/transparent_hugepage/defrag&lt;/code&gt;tunes how hard the kernel tries on the fault path vs deferring to khugepaged&lt;/item&gt;&lt;item&gt;Shmem or tmpfs: &lt;code&gt;huge=always|within_size|advise|never&lt;/code&gt;plus shmem specific knobs&lt;/item&gt;&lt;/list&gt;&lt;p&gt;Modern kernels may also create variable order large folios that are bigger than 4 KiB but PTE mapped not full 2 MiB PMD. This reduces fault count and TLB pressure without always jumping to 2 MiB. Behavior differs by kernel and architecture.&lt;/p&gt;&lt;p&gt;One trade off. Assembling a huge page may require compaction which moves other pages to free a contiguous chunk and this can add a small pause. If first touch latency matters more than steady state speed the defrag knob lets you temper how hard the kernel tries which pushes work to khugepaged instead of doing it inline.&lt;/p&gt;&lt;quote&gt;&lt;p&gt;Tiny explainer: THP vs hugetlbfs&lt;/p&gt;&lt;lb/&gt;THP is automatic and pageable. Explicit huge pages from&lt;code&gt;MAP_HUGETLB&lt;/code&gt;or hugetlbfs are quota managed and non swap.&lt;/quote&gt;&lt;head rend="h2"&gt;Dirty‑tracking in userspace, without racing the kernel&lt;/head&gt;&lt;p&gt;Imagine you want to copy only the pages an application modified since your last snapshot.&lt;/p&gt;&lt;list rend="ol"&gt;&lt;item&gt;Give yourself the ability to catch write protect faults with userfaultfd in write protect mode.&lt;/item&gt;&lt;item&gt;Use &lt;code&gt;PAGEMAP_SCAN&lt;/code&gt;over your range with the category written since last write protect. Ask the kernel to write protect matching pages and to return compact ranges of what it found.&lt;/item&gt;&lt;item&gt;Copy those ranges. When the app later writes to one of them userfaultfd wakes your thread. Log the dirtied page, clear write protect, and let it proceed.&lt;/item&gt;&lt;/list&gt;&lt;p&gt;This avoids walking every PTE and avoids the classic race where a page is dirtied while you were looking. It is also fast because scan plus write protect happens as one atomic operation inside the kernel.&lt;/p&gt;&lt;quote&gt;&lt;p&gt;Tiny explainer:&lt;/p&gt;&lt;code&gt;PAGEMAP_SCAN&lt;/code&gt;&lt;lb/&gt;An ioctl that scans a virtual range for pages with properties like written since last protect and can also apply write protect in the same step.&lt;/quote&gt;&lt;head rend="h2"&gt;The TLB, and why &lt;code&gt;mprotect&lt;/code&gt; costs a little&lt;/head&gt;&lt;p&gt;The Translation Lookaside Buffer remembers recent translations so the CPU does not walk page tables on every access. If Linux changes a mapping or its permissions it must make sure stale entries are not used.&lt;/p&gt;&lt;p&gt;On x86 there are two broad ways to do it.&lt;/p&gt;&lt;list rend="ul"&gt;&lt;item&gt;Precise invalidation. Invalidate one page at a time with &lt;code&gt;INVLPG&lt;/code&gt;. Good for small changes. A single invalidation on a huge page mapping drops the whole 2 MiB entry.&lt;/item&gt;&lt;item&gt;Broader flushes. Drop many or all entries for example by reloading the page table root register. Fewer instructions now and more misses later while refilling.&lt;/item&gt;&lt;/list&gt;&lt;p&gt;Which is better depends on how big a change you made, whether you are changing small or huge pages, and the microarchitecture.&lt;/p&gt;&lt;quote&gt;&lt;p&gt;Tiny explainer: PCID&lt;/p&gt;&lt;lb/&gt;Process Context Identifiers tag TLB entries so switching page tables does not flush everything.&lt;lb/&gt;Tiny explainer: INVPCID&lt;lb/&gt;Allows targeted invalidation of TLB entries for a given tag without switching to it.&lt;/quote&gt;&lt;p&gt;There is also a debug knob on some x86 builds named &lt;code&gt;tlb_single_page_flush_ceiling&lt;/code&gt; that nudges when the kernel switches from per page invalidations to a broad flush.&lt;/p&gt;&lt;quote&gt;&lt;p&gt;Tiny explainer:&lt;/p&gt;&lt;code&gt;INVLPG&lt;/code&gt;&lt;lb/&gt;A privileged instruction that invalidates TLB entries for the page containing a given address in the current address space tag.&lt;/quote&gt;&lt;head rend="h2"&gt;Meltdown, and why the kernel sometimes switches maps on entry&lt;/head&gt;&lt;p&gt;Early 2018 brought Meltdown. Speculative execution plus a cache side channel could leak data across the user and kernel boundary. Even if a user mode load from a kernel address would fault, the CPU might speculatively execute it and touch data that leaves a measurable cache trace.&lt;/p&gt;&lt;p&gt;Linux’s defense on x86‑64 is Page Table Isolation which is PTI. Keep two views and switch between them on entry and exit.&lt;/p&gt;&lt;quote&gt;&lt;p&gt;Tiny explainer: CR3&lt;/p&gt;&lt;lb/&gt;CR3 holds the current page table root and on x86 switching it changes the active address space.&lt;lb/&gt;Tiny explainer: PTI&lt;lb/&gt;PTI keeps a reduced userspace view without normal kernel data mapped and a full kernel view used while in the kernel.&lt;/quote&gt;&lt;p&gt;Cost. More page table switches, different TLB sharing behavior, and a small memory bump for extra top level tables and the per CPU entry area. With PCID Linux keeps separate TLB tags for the two views to reduce flushes. Some systems allow opting out with &lt;code&gt;nopti&lt;/code&gt; when acceptable. Default is on.&lt;/p&gt;&lt;quote&gt;&lt;p&gt;Tiny explainer: what Meltdown reads&lt;/p&gt;&lt;lb/&gt;Permissions never turn off. The architectural access still faults. The leak is in transient speculation which leaves a timing trace.&lt;/quote&gt;&lt;head rend="h2"&gt;How the kernel changes mappings safely&lt;/head&gt;&lt;p&gt;When Linux edits page tables the order is deliberate.&lt;/p&gt;&lt;list rend="ol"&gt;&lt;item&gt;Handle cache rules first on architectures that need it.&lt;/item&gt;&lt;item&gt;Modify page tables by adding, removing, or changing PTEs.&lt;/item&gt;&lt;item&gt;Invalidate the TLB so the CPU forgets stale translations.&lt;/item&gt;&lt;/list&gt;&lt;p&gt;Under the hood are functions that match the granularity of the change like flush an address space, flush a range, or flush a single page.&lt;/p&gt;&lt;p&gt;There is a parallel story for kernel only mappings made with &lt;code&gt;vmap&lt;/code&gt; and &lt;code&gt;vmalloc&lt;/code&gt;. Before I/O the kernel flushes the vmap range so the physical page sees the latest bytes. After I/O it invalidates the vmap range so speculative reads do not go stale.&lt;/p&gt;&lt;quote&gt;&lt;p&gt;Tiny explainer:&lt;/p&gt;&lt;code&gt;vmap&lt;/code&gt;and&lt;code&gt;vmalloc&lt;/code&gt;&lt;lb/&gt;APIs that create kernel virtual mappings to non contiguous physical pages for use inside the kernel.&lt;/quote&gt;&lt;p&gt;On x86 you rarely think about the instruction cache because it is coherent with data stores. On others, copying code into executable memory requires an explicit instruction cache flush before running it. The VM has hooks like &lt;code&gt;copy_to_user_page&lt;/code&gt; and &lt;code&gt;flush_icache_range&lt;/code&gt; where architectures do this housekeeping.&lt;/p&gt;&lt;quote&gt;&lt;p&gt;Tiny explainer: icache flush&lt;/p&gt;&lt;lb/&gt;Some CPUs need an instruction cache sync after writing new code so execution sees the new bytes.&lt;/quote&gt;&lt;head rend="h2"&gt;A tiny x86 aside: stacks and calls, without the haze&lt;/head&gt;&lt;p&gt;In 64 bit mode registers wear an R. &lt;code&gt;RIP&lt;/code&gt; is the instruction pointer, &lt;code&gt;RSP&lt;/code&gt; is the stack, &lt;code&gt;RBP&lt;/code&gt; is the frame. The stack grows down. &lt;code&gt;push&lt;/code&gt; decrements &lt;code&gt;RSP&lt;/code&gt; and stores. &lt;code&gt;pop&lt;/code&gt; loads then increments. &lt;code&gt;CALL&lt;/code&gt; pushes the return address and jumps. &lt;code&gt;RET&lt;/code&gt; pops it into &lt;code&gt;RIP&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;On Linux the System V AMD64 ABI passes the first arguments in registers which are &lt;code&gt;RDI&lt;/code&gt;, &lt;code&gt;RSI&lt;/code&gt;, &lt;code&gt;RDX&lt;/code&gt;, &lt;code&gt;RCX&lt;/code&gt;, &lt;code&gt;R8&lt;/code&gt;, &lt;code&gt;R9&lt;/code&gt; and returns values in &lt;code&gt;RAX&lt;/code&gt;. Large objects go by pointer. Your stack must be readable and writable.&lt;/p&gt;&lt;quote&gt;&lt;p&gt;Tiny explainer: System V AMD64 ABI&lt;/p&gt;&lt;lb/&gt;The calling convention for 64 bit Unix like systems on x86‑64 that defines where arguments and return values go.&lt;/quote&gt;&lt;p&gt;User code runs in ring 3. The kernel runs in ring 0. Crossings like syscalls, interrupts, and exceptions go through CPU defined gates. In 64 bit mode Linux uses a flat segmentation model and relies on paging for isolation.&lt;/p&gt;&lt;quote&gt;&lt;p&gt;Tiny explainer: rings&lt;/p&gt;&lt;lb/&gt;Rings are CPU privilege levels. Ring 3 is user mode. Ring 0 is kernel mode.&lt;/quote&gt;&lt;quote&gt;&lt;p&gt;Tiny note for ARM64 readers&lt;/p&gt;&lt;lb/&gt;The ideas like stack growth and user vs kernel separation are similar. Register names, calling conventions, and syscall entry differ.&lt;/quote&gt;&lt;head rend="h2"&gt;When things go sideways (and what that usually means)&lt;/head&gt;&lt;list rend="ul"&gt;&lt;item&gt;&lt;code&gt;mmap&lt;/code&gt;→&lt;code&gt;EINVAL&lt;/code&gt;often a misaligned file&lt;code&gt;offset&lt;/code&gt;which must be page aligned or an impossible flag combo&lt;/item&gt;&lt;item&gt;&lt;code&gt;mmap&lt;/code&gt;→&lt;code&gt;ENOMEM&lt;/code&gt;you may be out of virtual space or VMA count or you hit strict overcommit&lt;/item&gt;&lt;item&gt;Store to a file mapping → &lt;code&gt;SIGBUS&lt;/code&gt;you walked past EOF. The VMA existed, the data did not&lt;/item&gt;&lt;item&gt;&lt;code&gt;mprotect(PROT_EXEC)&lt;/code&gt;→&lt;code&gt;EACCES&lt;/code&gt;could be a&lt;code&gt;noexec&lt;/code&gt;mount or a W^X policy&lt;/item&gt;&lt;item&gt;Big &lt;code&gt;malloc&lt;/code&gt;creates a new line in&lt;code&gt;maps&lt;/code&gt;your allocator used&lt;code&gt;mmap&lt;/code&gt;for that size&lt;/item&gt;&lt;item&gt;RSS balloons after &lt;code&gt;fork()&lt;/code&gt;copy on write did its job and you wrote to lots of shared pages&lt;/item&gt;&lt;item&gt;Accidentally clobbered a mapping you probably used &lt;code&gt;MAP_FIXED&lt;/code&gt;. Prefer&lt;code&gt;MAP_FIXED_NOREPLACE&lt;/code&gt;to fail instead of overwrite&lt;/item&gt;&lt;/list&gt;&lt;p&gt;When it is mysterious, look. Start friendly with &lt;code&gt;smaps_rollup&lt;/code&gt; for the big picture and &lt;code&gt;maps&lt;/code&gt; for shapes. Drop to &lt;code&gt;pagemap&lt;/code&gt; and the &lt;code&gt;kpage*&lt;/code&gt; files only when you truly need per page truth and expect to need privileges.&lt;/p&gt;&lt;head rend="h2"&gt;A small checklist to keep nearby&lt;/head&gt;&lt;list rend="ul"&gt;&lt;item&gt;Need memory now. &lt;code&gt;mmap&lt;/code&gt;anonymous with&lt;code&gt;PROT_READ|PROT_WRITE&lt;/code&gt;and&lt;code&gt;MAP_PRIVATE|MAP_ANONYMOUS&lt;/code&gt;&lt;/item&gt;&lt;item&gt;Generating code. Keep W^X. Write bytes then &lt;code&gt;mprotect(PROT_READ|PROT_EXEC)&lt;/code&gt;&lt;/item&gt;&lt;item&gt;Mapping a file. &lt;code&gt;offset&lt;/code&gt;must be page aligned. Touching beyond real EOF is&lt;code&gt;SIGBUS&lt;/code&gt;&lt;/item&gt;&lt;item&gt;Lots of major faults. Nudge the kernel with &lt;code&gt;MADV_WILLNEED&lt;/code&gt;or touch earlier. Watch page cache and storage&lt;/item&gt;&lt;item&gt;Where did memory go. Start with &lt;code&gt;/proc/&amp;lt;pid&amp;gt;/smaps_rollup&lt;/code&gt;then&lt;code&gt;/proc/&amp;lt;pid&amp;gt;/maps&lt;/code&gt;&lt;/item&gt;&lt;item&gt;Forking big processes. Expect CoW. RSS grows as you write. Consider &lt;code&gt;exec&lt;/code&gt;in the child for heavy work&lt;/item&gt;&lt;item&gt;Latency sensitive. Consider THP or mTHP where it helps. &lt;code&gt;mlock&lt;/code&gt;hot sets. Watch your TLB behavior&lt;/item&gt;&lt;/list&gt;&lt;p&gt;Feedback is extremely welcomed! You can reach out to me on X @0xkato&lt;/p&gt;&lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=45805539</guid><pubDate>Mon, 03 Nov 2025 23:04:22 +0000</pubDate></item><item><title>Things you can do with diodes</title><link>https://lcamtuf.substack.com/p/things-you-can-do-with-diodes</link><description></description><guid isPermaLink="false">https://news.ycombinator.com/item?id=45805900</guid><pubDate>Mon, 03 Nov 2025 23:49:03 +0000</pubDate></item><item><title>You can't cURL a Border</title><link>https://drobinin.com/posts/you-cant-curl-a-border/</link><description>&lt;doc fingerprint="7f44c81abfa3ce57"&gt;
  &lt;main&gt;
    &lt;head rend="h1"&gt;You can't cURL a Border&lt;/head&gt;
    &lt;p&gt;An error fare to Iceland pops up. It's cheap enough to feel like a typo and most likely will be gone in minutes. I'm moderately obsessed with ways to travel on budget, so I keep an eye on these.&lt;lb/&gt; Before I click Buy, I need to know (fast!) if it actually works for me: would I need a visa, are there any odd passport requirements, can I quickly sort out the driving permit, would it affect my Schengen 90/180 window, break UK presence tests or accidentally prevent a tax residency I am chasing.&lt;/p&gt;
    &lt;p&gt;It isn’t one check, it’s a stack of small unfriendly ones, and takes around 20 minutes to process. Some bits are fun, like hunting for a seat upgrade, but mostly it’s counting midnights and expiry dates so a cheap weekend doesn’t become an expensive lesson.&lt;/p&gt;
    &lt;p&gt;I've been doing this dance for a decade now. In 2015 I made a spreadsheet for a US visa application that wanted ten years of travel history, down to the day. The spreadsheet grew: UK work visa, Indefinite Leave to Remain and citizenship applications, Canadian work permits. Any government form that asked "where have you been?" got its answer from the same battered CSV. It worked well enough, in the sense that I was never detained.&lt;/p&gt;
    &lt;p&gt;It also made me think that this was a solvable problem I was solving badly. I built a ledger to answer “where was I on 15 March 2023?” Instead, I ran simulations to check, “if I book this, what breaks later?”&lt;/p&gt;
    &lt;p&gt;The only question is whether the computer can answer all of faster than I do, and leave December, the next border control, and the end of the tax year blissfully uneventful.&lt;/p&gt;
    &lt;head rend="h2"&gt;Does this trip compile? ¶&lt;/head&gt;
    &lt;p&gt;That twenty-minute panic before buying a flight comes from one basic problem: none of the systems that judge you will tell you your state.&lt;/p&gt;
    &lt;p&gt;Schengen is running one check. The UK is running another. Tax residency is running a third. Your passport is running its own quiet clock in the background. None of them explain themselves, and none of them agree on what “a day” even is.&lt;/p&gt;
    &lt;p&gt;Schengen cares about presence across rolling windows. The UK counts how many midnights you were physically in the country in a tax year that, for historical reasons [1], starts on 6 April out of all options. Some countries track how many days you’ve spent in certain places and change the medical paperwork they expect from you once you cross a threshold. Meanwhile your passport might fail you with its expiry date, validity rules that may apply on arrival or departure depending on routing, and a finite number of blank facing pages that some countries require.&lt;/p&gt;
    &lt;p&gt;None of that is easily exposed. The officer at the desk can see it but you can’t. That's parsing the State—both kinds. The government's view of you, and the state machine that tracks it.&lt;/p&gt;
    &lt;head rend="h3"&gt;The bureaucratic edge cases ¶&lt;/head&gt;
    &lt;p&gt;The rules aren't just complex—they're occasionally specific in ways that make you regret leaving the house in the first place.&lt;/p&gt;
    &lt;p&gt;To apply for British citizenship, you need to prove you were physically in the UK on your application date but five years ago. Not approximately five years, not that week—that exact day when you press "submit" on the form minus five years. Miss it by 24 hours and your application is reject after months of waiting, and you have to pay a hefty fee to re-apply.&lt;/p&gt;
    &lt;p&gt;Transiting through a UK airport? Leaving the terminal doesn't count as presence unless you do something "unrelated to your travel"—buy a sausage roll at Greggs, see a play in West End, meet a friend. The guidance doesn't even specify a minimum spend.&lt;/p&gt;
    &lt;p&gt;Morocco runs on UTC+1 most of the year but switches to UTC during Ramadan to shorten the fasting day. Which means "days spent in Morocco" depends on your timezone database version and whether you remembered to update it.&lt;/p&gt;
    &lt;p&gt;It would be alright with a single source of truth, but all these facts are scattered across (semi)official websites and PDFs, and you're supposed to figure it out yourself.&lt;/p&gt;
    &lt;p&gt;So the job isn't "log trips" (I already did that for ten years in a spreadsheet). The job is: given what I've already done and what I'm about to do, does this plan quietly break anything, and if so, where, and by how much.&lt;/p&gt;
    &lt;p&gt;"You're at 56 days because Amsterdam contributed 12, Prague 3, Barcelona 10, Iceland would add a month, and February doesn't count anymore" is something I can trust, argue with, or fix. "You're fine" isn't.&lt;/p&gt;
    &lt;p&gt;That's where this stops being a spreadsheet and starts being a linter. Apparently I want the compiler warning before I press Buy.&lt;/p&gt;
    &lt;head rend="h2"&gt;Counting the right midnight ¶&lt;/head&gt;
    &lt;p&gt;If I want a compiler warning I trust, the compiler has to agree with the officer about what a day is.&lt;/p&gt;
    &lt;p&gt;For the past five years I've been working on an app for people with epilepsy, managing timezones, medication reminders, and edge cases. We juggled multiple sources of truth and multiple storage styles (some records in UTC, some in local time with timezones stored separately—historical reasons, obviously).&lt;/p&gt;
    &lt;p&gt;This time, I tried to learn from that: facts are stored as instants, reasoning happens in local days of the jurisdiction that cares.&lt;/p&gt;
    &lt;p&gt;Take this routing: depart Dublin morning of November the 17th, brief Newark layover, a longer one in Mexico City, 23-hour Heathrow stop, then Tenerife. Ask five immigration systems "how many tax residency days?" and you get five answers:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Ireland: zero (under 30 days/year threshold).&lt;/item&gt;
      &lt;item&gt;US: zero (foreign-to-foreign transit under 24 hours).&lt;/item&gt;
      &lt;item&gt;Mexico: two (you cross midnight twice).&lt;/item&gt;
      &lt;item&gt;UK: zero (even though you cross midnight once), unless you went landside for non-travel reasons, then one.&lt;/item&gt;
      &lt;item&gt;Schengen: one (entry day counts, exit day will count too, even if both are only for 15 minutes).&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Each stop has same or similar conditions, but different state machines are asking different questions. I pin the timezone database version that produced each result, and when rules or clocks shift, I recompute so I could show both answers if needed. Yesterday should stay reproducible even when tomorrow disagrees.[2]&lt;/p&gt;
    &lt;head rend="h2"&gt;Parsing the State ¶&lt;/head&gt;
    &lt;p&gt;In other words, the linter is meant to answer the same question in various disguises: "what happens if I do this?"&lt;/p&gt;
    &lt;p&gt;Can I book Christmas in the Alps with three summer weekends planned in Europe? Does it matter if I leave UK before the tax year ends? What passport should I travel on? Does anything expire between booking and boarding?&lt;/p&gt;
    &lt;p&gt;Every question has the same shape: simulate forward, find what breaks, decide if you care. The goal isn't to convince border officers—it's to not make mistakes they'd catch. Trips get assembled from whatever I can verify later: geotagged photos, background location, manual entries. A resolver turns that into "present on this local day" and keeps track of why.&lt;/p&gt;
    &lt;p&gt;I don't hardcode rules, I ship interpretations instead: each jurisdiction has a small versioned blob that says what counts, how the window is measured, where that reading came from.&lt;/p&gt;
    &lt;p&gt;The paperwork gets the same treatment because documents are state machines too. A passport isn’t just means of identity; it has constraints and timers. Some requirements, like six months validity are legacy and usually exist to keep deportations possible without issuing emergency documents, but still need to be checked. [3]&lt;/p&gt;
    &lt;p&gt;Before I buy anything the linter should tell me that I don't have the correct flavour of IDP (and man, getting those in Scotland since they delegated it from Post Offices to corner shops is tough), that a Dubai connection flips a “valid on arrival” buffer into “invalid on departure”. Quiet warnings, early enough to change dates or renew the right booklet, and clear enough that I won't have to improvise at a counter.&lt;/p&gt;
    &lt;p&gt;If the world changes—new examples, revised guidance, a delayed system finally launches—I don’t rewrite history. I version the assumption, keep both answers recorded, and move on.&lt;/p&gt;
    &lt;p&gt;Keeping all those rules up-to-date is hard, so rather than maintaining rules for every country, I parse a few databases, then let users configure their own tracking goals. A user emailed about Cyprus's fast-tracked tax residency scheme; another pointed out I'd missed a few countries entirely. The app gets better as people use it, which feels more honest than pretending to be a global authority on 195 countries' immigration rules.&lt;/p&gt;
    &lt;head rend="h2"&gt;Making things public ¶&lt;/head&gt;
    &lt;p&gt;The app is local by default. Calculations happen on-device, and if you're in airplane mode, it still works. Network is always the bottleneck, and I'm the person who spent a weekend reverse-engineering gym entry to save 44 seconds. I'm not adding server round-trips when you're standing at a gate.&lt;/p&gt;
    &lt;p&gt;Being local also means no liability. Personal immigration history is exactly the kind of data governments might want. Keeping it off my servers means nobody can demand I hand it over. Some friends asked about cloud sync: I keep saying no. Not because sync is hard—it is, though surely Claude Code can do that for me [4]—but because the moment you add a server you add retention policies, jurisdiction questions, and a magnet for legal demands. If you want it on another device, export a file and move it yourself like the ancestors did it.&lt;/p&gt;
    &lt;p&gt;The first version just counted Schengen days, then I added the UK's midnight arithmetic because I needed it for my own calculations. Then documents with their expiry rules because I was tired of manually looking them up. Then the what-if layer because adding and deleting trips to see impact felt like manually diffing state. Then visa requirements and IDP rules: none of this was planned, it accumulated from use, the same way my fermentation tracker grew from "can I eat this?" to HACCP compliance documents.&lt;/p&gt;
    &lt;p&gt;I shipped it because keeping it private felt unfinished, and because I'd like fewer people spending twenty minutes researching whether a £62 return flight will cause problems six months later.&lt;/p&gt;
    &lt;p&gt;That Iceland error fare? I bought it. The app told me I wouldn't need an IDP, that the trip wouldn't push me over any Schengen threshold, that I'd leave with 34 days of margin in my 90/180 window, and—importantly—that booking it would mean I'd stop being a UK tax resident given my upcoming Canada move. Useful things to know before clicking purchase. The officer at Keflavík looked at his screen, agreed with his systems, and waved me through.&lt;/p&gt;
    &lt;p&gt;I called the app Residency and you can get it here. No subscriptions, costs less than an airport martini, and you'll likely regret it less a few hours later.[5]&lt;/p&gt;
    &lt;p&gt;You can't &lt;code&gt;cURL&lt;/code&gt; a border. But you can track your own state carefully enough that when the governments know the answer, so do you.&lt;/p&gt;
    &lt;p&gt;Working on problems where rules are complex and official documentation is &lt;del&gt;garbage&lt;/del&gt; contradictory? I build systems that handle state when the state won't tell you your state. work@drobinin.com&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;
        &lt;p&gt;Until 1752, England’s New Year began on 25 March, aka Lady Day. The calendar reform shaved 11 days off, nudging the tax year to 5 April, and skipping a leap day in 1800 pushed it to 6 April. Two centuries later it stays there probably because changing it would be expensive and annoying. ↩︎&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Apparently time zones shift all the time for a variety of reasons, from political to religious. ↩︎&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;I couldn't find any legit reasons for keeping the "six-month rule" around but it seems like it's still occasionally checked, sometimes even during boarding. ↩︎&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;These stunts are performed by trained professionals, don't try this at home. ↩︎&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;I have nothing against airport bars, but hear me out: vermouth should be kept in the fridge at all times, and glasses need to be chilled. ↩︎&lt;/p&gt;
      &lt;/item&gt;
    &lt;/list&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=45806263</guid><pubDate>Tue, 04 Nov 2025 00:37:14 +0000</pubDate></item><item><title>When stick figures fought</title><link>https://animationobsessive.substack.com/p/when-stick-figures-fought</link><description></description><guid isPermaLink="false">https://news.ycombinator.com/item?id=45806348</guid><pubDate>Tue, 04 Nov 2025 00:48:56 +0000</pubDate></item><item><title>My Truck Desk</title><link>https://www.theparisreview.org/blog/2025/10/29/truck-desk/</link><description>&lt;doc fingerprint="6f48b816f30396dc"&gt;
  &lt;main&gt;
    &lt;p&gt;Photograph courtesy of Bud Smith.&lt;/p&gt;
    &lt;p&gt;After eight glorious weeks of freedom, I got rehired.&lt;/p&gt;
    &lt;p&gt;First thing I did was walk over to the machine shop to look for my F-150. The oil stain was there but the truck wasn’t. It wasn’t in the rock lot where the bulldozers parked either.&lt;/p&gt;
    &lt;p&gt;Who would have stooped so low as to co-opt that piece of shit? It had no heat and no air-conditioning. The radio bubbled static. Door handles were missing. Floorboards, fenders, and frame all rusted and rotted. It certainly hadn’t been what could be called roadworthy. And, my God, the smell.&lt;/p&gt;
    &lt;p&gt;I went into the machine shop. One of the welders lifted his hood and told me the bad news—they’d had to move the truck for a rebar delivery and the engine on that old thing finally blew, so the truck got dragged to the scrapyard.&lt;/p&gt;
    &lt;p&gt;In a dusty corner, I saw a pile of salvaged tools from the truck. I took some wrenches and my tape measure but didn’t see what I was really looking for—my Truck Desk®. Oh well.&lt;/p&gt;
    &lt;p&gt;I caught a ride out to the unit with the foreman and the rest of the crew. Our goal for the day was to unbolt components from a heat exchanger and fly them off with a crane. Once the exchanger was apart and inspected, we’d begin our real repairs.&lt;/p&gt;
    &lt;p&gt;The morning went well. The mornings always go well. Everybody knows what they’re doing. We’re professionals, equals. Same pay. Same benefits. All working together toward retirement. We look out for each other. Whoever has the hardest task in this crew today could be the foreman tomorrow, and vice versa. Nobody wants to be the boss, so our bosses are the best kind.&lt;/p&gt;
    &lt;p&gt;At first break we packed into our truck and drove shoulder-to-shoulder back to the trailer compound for coffee. During the five-minute drive, I couldn’t help but think how good I’d had it when I had the luxury of using that piece of shit F-150.&lt;/p&gt;
    &lt;p&gt;See, the truck nobody else wanted had been my office. I’d built a portable desk inside it. My truck desk, I called it. A couple of planks screwed together, our union sticker slapped on, the whole deal sealed with shellac. I’d built the desk so it slid into the bottom of the steering wheel and sat across the armrests. I used to hang back at the job and sneak in some creative work while the rest of the crew went to break. My desk—which I’d taken far too long to build and perfect through many prototypes—had been stowed behind the driver’s seat when the truck was hauled off by the wrecker.&lt;/p&gt;
    &lt;p&gt;Back at the break trailer, I took my old seat and joined in on the jokes, insults, tall tales. That trailer was, to me, the best place for storytelling in the world—but, as always, it was too loud, too raucous, too fun to do any writing or reading, which is all I ever want to do on break. At lunch, I retreated into the relative quiet of the machine shop. I sat down by the drill press and took out my cell phone and started writing. Just like I used to do.&lt;/p&gt;
    &lt;p&gt;For nearly two decades I’ve worked off and on at this petrochemical plant as a mechanic and welder. The union dispatched me here: When it gets slow, I get laid off; when work picks up, I boomerang back. And the whole time, I’ve written stories and parts of my novels during breaks—fifteen minutes for coffee and then half an hour for lunch. I’ve also made use of the heaven-sent delays brought on by lightning, severe rainstorms, evacuations, permitting problems, equipment issues, and so on. I’m thankful for each and every delay that happens on this construction site, and, believe me, there are many.&lt;/p&gt;
    &lt;p&gt;Most artists I know are like this. Finding time to make art while working another job, or taking care of loved ones. They improvise. They get better. They get worse. They get better again.&lt;/p&gt;
    &lt;p&gt;Really it mostly comes down to that first thing: finding time. When I talk to people who want to find more time, I repeat something an old-timer said to me early on: “You’ve gotta make your own conditions.”&lt;/p&gt;
    &lt;p&gt;What does that mean? Well. Is it raining? You can either stand out in the rain and get wet, or you can find a coil of tie-wire and hang up tarps for a hooch.&lt;/p&gt;
    &lt;p&gt;There’s another expression I like, which goes: “Let your wallet be your guide.” I try to remember that every time I feel the urge to quit my job and never return.&lt;/p&gt;
    &lt;p&gt;So ever since cell phones got smart, I’ve sat somewhere quiet, semi-on-the-clock, texting myself poems, paragraphs that became stories and novels, and things about my life, or I should say just life, like this thing you’re reading right now.&lt;/p&gt;
    &lt;p&gt;Writing on my cell phone, pecking away, was good enough for many years, but then after a rightfully humbling decade of manual labor, I started having irrational fantasies about convenience and comfort.&lt;/p&gt;
    &lt;p&gt;Of course I have a desk in my apartment, but I couldn’t help myself. Somehow I’d gotten seduced by the prospect of attaining my very own cubicle amid this massive junkyard full of toxic waste.&lt;/p&gt;
    &lt;p&gt;One day I walked into the payroll trailer where the secretaries and site manager sat. There wasn’t an explicit sign that said NO CONTRACTORS ALLOWED, but it was an unspoken rule. The trailer had a few unused old cubicles tucked to the side. I sat down in one and happily pecked away with my thumbs. Every break for a week I went in and worked on my writing. After a few days I started to feel like I should hang pictures of my mom and dad and my wife inside it. But I didn’t dare.&lt;/p&gt;
    &lt;p&gt;Then things really heated up. I brought in a Bluetooth keyboard and wrote a whole story that day on my breaks. There was no going back. My heart soared. I thought I should adopt a brown dog with a bandanna around his neck just so I could thumbtack his picture to the cubicle wall. I hadn’t interacted with any of the office staff, but they’d seen me. They’d followed my oily bootprints down the hallway and begun to leer. Who is this diesel-stinking contractor? He’s probably the one who’s been eating Janelle’s Oreos. He raided the mango-kiwi yogurt from the fridge. He glommed all the sporks. I knew my cubicle dreams were over the morning I found the site manager waiting in “my” cubicle.&lt;/p&gt;
    &lt;p&gt;“What are you doing here?” he asked.&lt;/p&gt;
    &lt;p&gt;In all my years working at that place, I’d never seen the site manager out on the site. I’m not sure he knew what it was or where it was. You went to him to order tools; he was the one who said no. I’d only ever seen him at a urinal or buying bacon and eggs off the lunch truck. But if I had ever seen him out on the site, it would have never occurred to me to ask him what he was doing there. He was wearing a blue polo shirt and khakis, and I was in his world—and he was asking.&lt;/p&gt;
    &lt;p&gt;“Office work,” I said.&lt;/p&gt;
    &lt;p&gt;“What kind, exactly?”&lt;/p&gt;
    &lt;p&gt;How can you explain literary fiction to a site manager?&lt;/p&gt;
    &lt;p&gt;“Little bit of everything,” I said.&lt;/p&gt;
    &lt;p&gt;I started writing in the machine shop again. It wasn’t the same. Once I’d been infected by the cubicle virus, there was no going back. Out of scrap lumber I gathered from various dumpsters, I built a proper desk for myself in the northeast corner of the shop. That desk was a huge leap forward in possibility and productivity. In the evenings, if I wrote something by hand or on my typewriter at home, I could now use my time at work to retype it at my shop desk.&lt;/p&gt;
    &lt;p&gt;The shop desk was not ideal. Some days I arrived to find someone had disassembled a small motor on top of it, gaskets and hardware spread out on newspaper. Other times I found pneumatic guns taken apart, or electrical devices with wiring splayed in a colorful tangle, or—fair enough—important blueprints laid out the entire length of the desk.&lt;/p&gt;
    &lt;p&gt;Right around this time I first saw the F-150. One of the workers had abandoned it by the shop. I put a battery in. That lasted one shift. Then I took an alternator out of another junk truck and, lo and behold, I had my own four wheels. The fan belt screamed. The engine smoked. The brakes worked when they wanted to. It was mine that whole dangerous year.&lt;/p&gt;
    &lt;p&gt;Then, one day, my luck changed.&lt;/p&gt;
    &lt;p&gt;A crate full of chain falls got delivered. It was a glorious crate, made of sanded spruce. I unscrewed some of the planking and built my first Truck Desk prototype.&lt;/p&gt;
    &lt;p&gt;It was made of three boards cut at twenty-four inches. Light and compact. Sealed with shellac. It slid into the bottom of the steering wheel, one side supported by a curved rebar I welded into a nut that fit exactly in a recess on the driver’s door. The center console supported the other side of the desk. I kept it stored behind the seat. Whenever break time came and the crew drove back to the trailer compound, I stayed parked on the unit and got at least ten extra minutes to write.&lt;/p&gt;
    &lt;p&gt;Now that I had my Truck Desk, that vehicle was my very own rolling cubicle.&lt;/p&gt;
    &lt;p&gt;Having that truck reminded me of when I lived on 173rd Street in New York City. Back then I used to drive around endlessly looking for street parking. I would see men and women sitting in their cars. They weren’t leaving, though; they were reading a book or a magazine, smoking cigarettes, playing Sudoku, scribbling love letters. They were the wisest men and women in the entire city, using their vehicles as a kind of office down on the street, a sanctuary where they could do their real work.&lt;/p&gt;
    &lt;p&gt;After the F-150 was scrapped, I never got a replacement truck. I never found that first Truck Desk either, even when I called the scrapyard.&lt;/p&gt;
    &lt;p&gt;What I did do, though, was go over to the carpenter’s side of the shop and cut a scaffold plank at twenty-nine inches. This simple plank fits across the armrests of whatever Chevy or Ford pickup the crew has that day. This dramatic redesign of Truck Desk into Truck Plank® took all of ten seconds. I didn’t bother with the sticker or shellac.&lt;/p&gt;
    &lt;p&gt;The years on the job have rolled on. Now editors send me Word documents with comments and questions and tracked changes. I bring my backpack to work with my laptop inside.&lt;/p&gt;
    &lt;p&gt;Every morning, when I find out what crew I’m in, I bring that plank with me. I stick it on the dashboard and climb into the driver’s seat. I drive us all out to the job and at break time I take them to the trailer. I clean my hands with pumice wipes and sit alone in whoever’s truck it is that day, pulling the plank off the dashboard and setting it across the armrests. Within a minute or so, I’ve got the laptop out and I’m working. If somebody from the crew is still in the back seat, bandanna over their eyes, snoozing, I do my best to keep extra quiet. And if they begin to snore, I don’t let that bother me at all.&lt;/p&gt;
    &lt;p&gt;Bud Smith is the author of the novel Teenager and the story collection Double Bird, among other books. Mighty, a novel, is forthcoming from Knopf in spring 2027. His story “Skyhawks” appears in the new Fall issue of The Paris Review.&lt;/p&gt;
    &lt;p&gt;Last / Next Article&lt;/p&gt;
    &lt;p&gt;Share&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=45806903</guid><pubDate>Tue, 04 Nov 2025 02:37:01 +0000</pubDate></item><item><title>Show HN: MyTimers.app offline-first PWA with no build step and zero dependencies</title><link>https://mytimers.app/</link><description>&lt;doc fingerprint="d367ecaf867e1ccc"&gt;
  &lt;main&gt;
    &lt;p&gt;MyTimers Light Mode Add Timer&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=45807502</guid><pubDate>Tue, 04 Nov 2025 04:46:47 +0000</pubDate></item><item><title>Pain Points of OCaml</title><link>https://quamserena.com/2025-11-03/pain-points-of-ocaml</link><description>&lt;doc fingerprint="e521109f4f6181dc"&gt;
  &lt;main&gt;
    &lt;p&gt;I am currently looking for a job! If you're hiring a new grad in 2026 for for Rust, TypeScript, or React, feel free to shoot me an email at serena (at) quamserena.com.&lt;/p&gt;
    &lt;head rend="h1"&gt;Pain points of OCaml&lt;/head&gt;
    &lt;p&gt;I've been writing a compiler in OCaml for the language described by the dragon book for a class, and now that I'm about halfway through it I've found myself missing Rust in a few spots. In no particular order, the pain points I've hit while using OCaml:&lt;/p&gt;
    &lt;head rend="h2"&gt;Syntax&lt;/head&gt;
    &lt;p&gt;The OCaml syntax is... not great, its only redeeming quality being that it has no significant whitespace. There are some alternative syntax frontends for OCaml like ReasonML that fix these problems, but I didn't know about them before starting the project. &lt;code&gt;let...in&lt;/code&gt; syntax is weird, but I can chalk that up to an aesthetic choice; the real devil is in the fact that match statements have no terminator, leading to mysterious errors sometimes if you try to nest them. In general, OCaml has very little punctuation (which isn't necessarily a bad thing) but it can mean that in some situations it's difficult to tell where this start and stop. For me, C-style brackets help make the syntax heirarchy in code more clear.&lt;/p&gt;
    &lt;p&gt;Another annoyance is automatic currying and partial function application. Usually partial function application is a bug, and typically there is a helpful lint where it happens, but if you're not explicitly annotating types the errors can be inscrutable. My preferred method for debugging syntax-related issues is to start randomly adding parenthesis where I think things are supposed to start and end, and usually that makes it clear where the error is.&lt;/p&gt;
    &lt;head rend="h2"&gt;Typechecking is way too clever&lt;/head&gt;
    &lt;p&gt;The type checker in OCaml is extremely clever and is usually able to determine the correct type of a variable without having to annotate anything. When it can't, though, (usually because of an error you made somewhere else) the error message is typically inscrutable. While this is cool because it allows OCaml to be both statically typed and have no type annotations, it is extremely bad from a software robustness perspective — usage of a variable in one area can influence its type in another opaquely, and it's just annoying to debug why the type inference is failing. Good luck debugging this when one of your dependencies updates and changes a function's signature. I've taken to annotating every function parameter and return type manually just for clarity's sake and so that the error messages make more sense. I think that Rust was definitely correct for making type annotations for function parameters and return values explicit despite also being based on Hindley-Milner type inference. Rust still allows you to be clever with type inference in some places if you want to though, such as with return type polymorphism.&lt;/p&gt;
    &lt;head rend="h2"&gt;Types&lt;/head&gt;
    &lt;p&gt;Annoyingly you cannot use types before they're declared — there is no type hoisting as you would see in other languages. You can get around this pretty easily by creating a parameterized type and then at the bottom of the file setting an alias for the type with the correct parameter bound, but it adds noise to the code. Enumerated types also dump all of their variants into the module scope (not namespaced to any type) and will silently shadow variants from other types, which is an odd choice to say the least. I think that it is reminiscent of global &lt;code&gt;#define&lt;/code&gt;'s not being namespaced in C, but I am not sure.&lt;/p&gt;
    &lt;head rend="h2"&gt;Tooling and ecosystem&lt;/head&gt;
    &lt;p&gt;OCaml tooling has improved a lot recently. It has a build system, Dune, that is comparable to the build systems of other languages like Cargo or NPM, and generally works quite well in my experience. The OCaml ecosystem is a bit strange, being dominated by Jane Street who maintains their own separate standard library Core (since the OCaml stdlib leaves a lot to be desired).&lt;/p&gt;
    &lt;p&gt;In terms of writing compilers, there's ocamllex and Menhir, which is what I'm using. (Menhir is (mostly) a drop-in replacement for ocamlyacc that fixes some problems). My gripe with these is that they are two DSLs that opaquely compile to OCaml source files and have their own (separate) semantics and grammar. Despite OCaml having match statements and everything, these tools instead more similarly follow their C counterparts, choosing to define their own match-statement-like-construct for lexing and parsing. They also emit errors where the entire diagnostic is just "Syntax Error", which is difficult to debug considering that these are DSLs with OCaml embedded within them. Usually the only way to debug this is to open up the Menhir manual and look at the examples.&lt;/p&gt;
    &lt;head rend="h2"&gt;Printing&lt;/head&gt;
    &lt;p&gt;Printing strings to stdout is oddly annoying in OCaml. There isn't really a way that you can just take an object and print it; instead you have to use &lt;code&gt;printf&lt;/code&gt; for primitives and define your own print function for your own objects — there is no equivalent to Java's &lt;code&gt;toString&lt;/code&gt; or Rust's &lt;code&gt;#[derive(Debug)]&lt;/code&gt;. The inability to express this is a weakness of the OCaml type system in my opinion.&lt;/p&gt;
    &lt;head rend="h2"&gt;Would I do it again?&lt;/head&gt;
    &lt;p&gt;When comparing Rust to OCaml, there is a general theme of robustness vs. elegance. Many of the design choices of OCaml (partial function application, inferred types) are motivated from the perspective of elegant functional programming (the things a PhD student cares about), meanwhile Rust is always about long-term stability and maintainability (the things a software engineer cares about). The usual mantra applies here: that neither of these are better in the general case but rather the best choice depends on the problem domain.&lt;/p&gt;
    &lt;p&gt;If I was to write another compiler, I would highly consider OCaml again, despite all of its pain points and missing quality-of-life features. I enjoy being able to use pattern matching and the elegance of a functional approach without having to worry about lifetimes and memory management, at least for a first draft/MVP version of the compiler. I would probably take a closer look at ReasonML though.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=45807735</guid><pubDate>Tue, 04 Nov 2025 05:41:51 +0000</pubDate></item><item><title>Lessons from interviews on deploying AI Agents in production</title><link>https://mmc.vc/research/state-of-agentic-ai-founders-edition/</link><description>&lt;doc fingerprint="bf43921aad23a4ce"&gt;
  &lt;main&gt;
    &lt;p&gt;“Customers look at Microsoft’s Copilot and think, ‘Oh great, Clippy 2.0!’” – Marc Benioff, CEO of Salesforce&lt;/p&gt;
    &lt;p&gt;“Copilot? Think of it as Clippy after a decade at the gym.” – Satya Nadella, CEO of Microsoft&lt;/p&gt;
    &lt;p&gt;If you don’t know what Clippy is (or better yet, never encountered it), consider yourself lucky. Introduced in Microsoft Office in 1996, Clippy was the infamously annoying digital paperclip that offered unsolicited advice to users, and instantly became the world’s most hated virtual assistant. And why are we referencing an oft-reviled 1996 virtual assistant that was eventually turned off in 2007? Because history never repeats itself, but it does often rhyme.&lt;/p&gt;
    &lt;p&gt;With all the buzz around agentic AI (and Gartner’s prediction that over 40% of agent-based AI initiatives will be abandoned by 2027), we asked ourselves: What does it take for AI agents to be deployed in production environments at large enterprises? What does it take for agentic products and copilots to actually be loved and used by employees (unlike the much-maligned Clippy)?&lt;/p&gt;
    &lt;p&gt;To this end, we surveyed over 30 of the top agentic AI startup founders in Europe and interviewed 40+ practitioners to not only build a view around the State of Agentic AI, but also create a playbook based on the common practices we’ve seen successful agentic startups deploy. We also include raw, unfiltered commentary from the survey. To give you a flavour of some of the things we’ve learned:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;The biggest challenges founders encounter when they are deploying AI Agents in production environments are actually not of the technical variety, instead they are: &lt;list rend="ul"&gt;&lt;item&gt;Workflow integration and the human-agent interface (60% of startups)&lt;/item&gt;&lt;item&gt;Employee resistance and other non-technical factors (50%)&lt;/item&gt;&lt;item&gt;Data privacy and security (50%) &lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;As a result, the most successful deployment strategies involve a “Think Small” approach, starting with low-risk yet medium-impact, easy-to-verify tasks that quickly demonstrate clear ROI. Even better if it’s automating a task the human user hates, and it’s pitched as a co-pilot that augments (rather than replaces) humans.&lt;/item&gt;
      &lt;item&gt;A significant 62% of agentic AI startups are already tapping into Line of Business or core spend budgets, proving the technology is moving beyond the experimental phase.&lt;/item&gt;
      &lt;item&gt;Although pricing strategies are continuously evolving, Hybrid and Per Task are most commonly used (23% each), while the “Holy Grail” of Outcome-based pricing is currently used by only 3% because different customers value different outcomes, it’s hard to attribute, measure and monitor these outcomes, and that makes pricing unpredictable.&lt;/item&gt;
      &lt;item&gt;As the ecosystem is in such nascent stages, most (52%) startups are building their agentic infrastructure fully or predominantly in-house.&lt;/item&gt;
      &lt;item&gt;Startups are focusing on reliability, as over 90% report at least 70% accuracy in their solutions. While healthcare startups reported the highest levels of accuracy (unsurprising), medium levels of accuracy is acceptable for simpler, low-risk use cases with easily verifiable output, when the high volume of automation offsets the lower accuracy, or when the AI enables an entirely new, previously impossible capability.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Based on our findings and interviews with enterprise practitioners, we’ve outlined observations on successful agentic deployment drivers, covering everything from strategic roll-out of use cases to (what we call) the 3Es framework (Education, Entertainment and Expectation management). Are you an agentic AI startup looking to overcome the various challenges around enterprise deployments? Jump straight to our observations here.&lt;/p&gt;
    &lt;p&gt;If you’re a founder building in this space, please reach out to Advika, Sevi or Mina – we’d love to chat.&lt;/p&gt;
    &lt;head rend="h2"&gt;What’s an AI agent, and why do we need them?&lt;/head&gt;
    &lt;p&gt;“What’s in a name? That which we call an AI Agent&lt;lb/&gt; By any other name would be just as hypey”&lt;/p&gt;
    &lt;p&gt;– Not said by William Shakespeare&lt;/p&gt;
    &lt;p&gt;A variety of definitions of AI agents are thrown about, but for the purposes of our discussion, we describe their key attributes:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Goal orientation: AI agents are assigned specific tasks or objectives, and their actions are aligned with achieving those goals.&lt;/item&gt;
      &lt;item&gt;Reasoning: Agents create plans to achieve the aforementioned goals and incorporate the ever-changing real-world context in their planning; they break down their main goal or complex problems into smaller, manageable tasks and think about the next best steps.&lt;/item&gt;
      &lt;item&gt;Autonomy: AI agents act independently without needing constant inputs/instructions from humans; they make decisions and take actions (via tool calling) based on the changing world around them. Given the nascence of GenAI-powered agents and assorted reliability issues around them (and enterprise practitioners’ caution around deploying fully autonomous systems), our definition of agents does not require full autonomy. As a result, co-pilots are included in our definition (so long as they meet the the other criteria we’ve listed out, such as goal orientation, reasoning, and actions via tool use).&lt;/item&gt;
      &lt;item&gt;Persistence: Agents have memory, or are able to remember their prior experiences and maintain focus on a long-term goals across sessions. This is also known as state management.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;AI agents are different from basic LLM chatbots because state management and tool calling are a harder engineering challenge, making their deployments much trickier. An evolution of this is multi-agent systems (MAS) is where agents can have shared memory, overarching goals, coordination amongst themselves. These MAS involve individual agents with specialised capabilities (or distinct sub-components of a broader goal) working together to solve complex problems, even across organisational boundaries.&lt;/p&gt;
    &lt;p&gt;Given MAS distribute cognitive load across multiple agents (each optimised for specific sub-tasks), they have demonstrated superior performance in handling complex, open ended problems vs single-agent approaches. They improve efficiency, reduce costs, and offer better fault tolerance and flexibility – which means they outperform single-agent systems in overall performance.&lt;/p&gt;
    &lt;p&gt;But why use AI agents at all? Why not RPA (Robotic Process Automation) or other traditional forms of automation? That’s because AI agents are better for complex, dynamic, and unstructured tasks that require cognitive ability, reasoning, and adaptability. Unlike RPA which follows rigid, pre-defined rules, AI agents can reason toward a goal, make dynamic decisions on the fly, and learn or improve over time – this allows them to handle edge cases and changes in the environment without breaking.&lt;/p&gt;
    &lt;head rend="h2"&gt;What does enterprise adoption of Agentic AI look like?&lt;/head&gt;
    &lt;p&gt;Certain surveys, such as KPMG’s AI 3Q 2025 quarterly pulse, note that AI agent deployment has nearly quadrupled, with 42% of organisations now having deployed “at least some agents,” up from 11% two quarters ago. While this may sound promising, we think “at least some agents deployed” is a poor measure of the true picture of adoption. Our conversations with practitioners suggest that, yes, most large enterprises are deploying AI agents in production environments, but these deployments are typically fairly small. They’re also mostly concentrated in (relatively) more mature areas as such as Customer Support, Sales and Marketing, Cybersecurity and Tech (e.g. AI coding agents).&lt;/p&gt;
    &lt;p&gt;We think it would be more useful to think of adoption through the following lenses:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;How many teams and employees are actually using Agentic AI in their day-to-day work: A May 2025 PwC survey noted that for most respondents (68%), half or fewer of their employees interact with agents in their everyday work. That said, our conversations with practitioners suggests that employees are using personal accounts where enterprises are not adopting the tech, triggering a “Shadow AI” problem where compliance issues run rampant.&lt;/item&gt;
      &lt;item&gt;The extent to which employees are using AI agents for their “potentially automatable” workflows (for very few of their workflows, some, or most): We stress on the “potentially automatable” point because it may not be desirable for EVERY workflow to be automated, and agentic AI may not necessarily be the best automation technique for that specific task. &lt;lb/&gt;While collecting data for actual workflows automated vs potentially automatable workflows is challenging, KPMG’s observation (from the same survey) on “How have AI agents been received by employees?” is a relatively useful proxy: only 10% of respondents indicated “significant adoption” where employees are enthusiastically adopted AI agents and are fully integrating them into workflows, while 45% pointed to “slight adoption” where employees are beginning to accept and integrate AI agents into their work (the remainder are getting mixed responses).&lt;/item&gt;
      &lt;item&gt;The degree of autonomy given to the AI agent for each workflow (whether it can execute only some tasks within a given workflow, or it can drive the entire workflow end-to-end): Our conversations with enterprise practitioners suggest that they are taking a conservative approach. Even if agentic AI solutions can theoretically be run reliably at 80% levels of autonomy, most practitioners will veer towards greater levels of human-in-the-loop and run the solution at 50% levels of autonomy.&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h2"&gt;Survey Findings&lt;/head&gt;
    &lt;p&gt;We surveyed 30 European agentic AI startup founders, and interviewed 40+ enterprise practitioners and founders to ascertain:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Levels of accuracy and autonomy that their Agentic AI solutions are operating at&lt;/item&gt;
      &lt;item&gt;Pricing strategies most commonly used by founders&lt;/item&gt;
      &lt;item&gt;Budgets that agentic startups are able to tap into (just innovation budgets, or the core Line of Business budgets)&lt;/item&gt;
      &lt;item&gt;Challenges startup founders typically encounter when deploying agentic AI solutions at large enterprises&lt;/item&gt;
      &lt;item&gt;Agentic infrastructure that founders have built internally, and third party tools they have used&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h3"&gt;Autonomy and Accuracy&lt;/head&gt;
    &lt;p&gt;Autonomy and Accuracy are linked dimensions – after all, you only automate to the extent to which you can get reliable and accurate outputs from AI agents. In an ideal agentic world, we would have extremely high levels of both accuracy and autonomy. By accuracy, we mean the % of agent-executed tasks result in a successful or accepted outcome (i.e. 0 being completely overridden by a human, 10 being fully accepted without changes).&lt;/p&gt;
    &lt;p&gt;While we’re not there yet, we’ve found that currently &amp;gt;90% of Agentic AI startups have at least 70% accuracy, though only 66% of Agentic AI startups operate at least 70% autonomy. Unsurprisingly, the acceptable levels of accuracy vary by industry and use case – e.g. 80% average accuracy for financial services, 90% accuracy for healthcare and so on. The more interesting question is: under what circumstances is a medium level of accuracy acceptable?&lt;/p&gt;
    &lt;p&gt;Given the interplay between accuracy and autonomy, we’ve identified three configurations that startups mainly sit in:&lt;/p&gt;
    &lt;p&gt;Medium Accuracy, High Autonomy: A medium level of accuracy (60-70%) is acceptable if the use case is:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;low risk and results in an output that is easy for a human to verify and modify; and&lt;/item&gt;
      &lt;item&gt;such that the lower level of accuracy is more than offset by a very high level of automation, so if it’s a time-consuming task with overwhelming volumes you would take the higher level of automation so you can move through massive volumes and only focus on the edge cases which the agent can’t handle; or&lt;/item&gt;
      &lt;item&gt;an entirely new capability, which was previously impossible, so the trade-off is that you would rather be able to perform a certain activity at 70% accuracy than not be able to do it at all.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;High Accuracy, Low Autonomy: This category predominantly comprised of agentic healthcare startups, where the typical levels of accuracy and autonomy were 90% and 40% respectively – and these were for much more high-stakes use cases (e.g. research for clinical trials, mental health care) where accuracy is of paramount importance. As one founder noted (regarding their agentic AI solution’s &amp;gt;85% accuracy):&lt;/p&gt;
    &lt;p&gt;“This accuracy level is not sufficient to remove human oversight and achieve full autonomy, especially in the sensitive context of clinical trials where regulatory standards are stringent.”&lt;/p&gt;
    &lt;p&gt;High Accuracy, High Autonomy: Majority of the startups in this category operate at 80-90% accuracy and autonomy levels, and are typically focused on the financial services use cases (e.g. compliance) as well as relatively more mature areas of AI deployment, such as customer support, cybersecurity, and research. In these cases, we’ve observed that founders are increasingly marrying probabilistic LLMs with more deterministic AI methods to enhance accuracy and consequently further autonomy.&lt;/p&gt;
    &lt;p&gt;Here’s a visual summary of the three Accuracy/Autonomy configurations that agentic startups mainly sit in:&lt;/p&gt;
    &lt;p&gt;&lt;lb/&gt;As we increasingly deploy agents on multi-step problems or introduce multi-agent systems, the bar for accuracy is only going to increase – like what happens when you chain a 90% accurate agent with another 90% accurate agent, and so on with the errors compounding at each step? It triggers something called cascade failure, a phenomenon we explore in our upcoming research reports (along with how knowledge graphs and neurosymbolic AI are the way forward) – so stay tuned!&lt;/p&gt;
    &lt;head rend="h3"&gt;Pricing&lt;/head&gt;
    &lt;p&gt;Given the agentic AI ecosystem is in early stages, most founders we spoke to see their pricing strategies as something to be evolved over time, a position we believe makes sense. For instance, a “per user” pricing makes sense at lower levels of autonomy (because a co-pilot needs a human user alongside) but at higher levels of autonomy, where an agent could perform most of an employee’s tasks (plus unlock new capabilities), a “per agent” pricing with an outcomes bonus may make more sense.&lt;/p&gt;
    &lt;p&gt;As SaaS license and API usage-based pricing are well understood, we’re focusing here on other pricing strategies and their implications:&lt;/p&gt;
    &lt;head rend="h4"&gt;Outcome based&lt;/head&gt;
    &lt;p&gt;Outcome-based pricing is often touted as the Holy Grail of AI Monetisation, because it lets customers pay only when a specific, pre-defined business result is achieved. A great example of this is Intercom, which charges customers $0.99 for every successful conversation resolution achieved autonomously by its Fin AI Agent, ensuring they only pay when the agent delivers. This way price is aligned with the business value delivered, the customers’ risk is lower and because it’s connected with a tangible output, it’s relatively easier for customers to understand than a token-based calculation (which doesn’t feel intuitive).&lt;/p&gt;
    &lt;p&gt;However, in practice, outcome based pricing is difficult to achieve for a wide variety of reasons. Firstly you’ll need to agree on what outcomes the customer values (and different customers may value different outcomes, so you could potentially end up in a situation where you have loads of customised contracts). Secondly, you’ll need to figure out attribution – for instance, with a Sales Co-pilot, it would be hard to attribute how much of a new customer win is driven by the AI agent vs the human sales rep. Linked with that is the problem of how to measure the outcome – and all of this makes the calculation more complex. Finally, it can be unpredictable because it is challenging to forecast certain outcomes (e.g. % of cost savings) in advance – as in, not only are you uncertain of the magnitude of outcome but also the timing of the outcome (it could be deferred). Here’s what a founder had to say:&lt;/p&gt;
    &lt;p&gt;“But the problem is ultimately it’s very difficult to agree on what those outcomes are. It’s very difficult to agree on tracking that, and it’s very hard to do at scale. You can’t really do that self serve because it’s so gamified – people are incentivised not to report outcomes to you.”&lt;/p&gt;
    &lt;p&gt;It’s much easier to work with outcome based pricing when:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;the desired outcomes are well-defined and similar across your customers;&lt;/item&gt;
      &lt;item&gt;the agent operates the entire workflow or task end-to-end, so it’s easier to attribute; and&lt;/item&gt;
      &lt;item&gt;when the outcomes are simple to measure and monitor in real time (like Intercom’s outcomes are binary – either the agent resolves it or doesn’t, and that feedback is received quickly).&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Consequently, we expect to see more hybrid models than pure outcome-based, where a per-agent pricing model is augmented with outcome bonuses rather than charging only for outcomes.&lt;/p&gt;
    &lt;head rend="h4"&gt;Per user&lt;/head&gt;
    &lt;p&gt;From a budget allocation perspective, this is easier for customers to understand, and it also makes sense for co-pilots where a human user is necessarily required alongside your product. The disadvantage of this pricing model is that it doesn’t distinguish between power users and casual users of your agentic AI solution, leading to the casual users subsidising the lower or negative margin power users. However, if the price point of your co-pilot product is high enough to cover even the costs of supporting power users, it’s a good starting point. As one founder noted:&lt;/p&gt;
    &lt;p&gt;“We’re fortunate to be in an industry [financial services] where price anchoring is quite high; if you have premium product you can charge a better price. While usage is very high, usage would need to be rather absurd to sufficiently eat into the margins.”&lt;/p&gt;
    &lt;p&gt;Also, if your agentic solution is highly successful in automating away a great many tasks, it would end up reducing the number of seats to be had in the first place – so it is unsuitable for highly automated solutions. That said, most founders we spoke to intend to evolve their pricing to a hybrid model, particularly as they enable greater autonomy.&lt;/p&gt;
    &lt;head rend="h4"&gt;Per agent&lt;/head&gt;
    &lt;p&gt;This is an intuitive pricing model when you’re automating the vast majority of tasks a particular employee carries out; that way you’re replacing a human and it comes out of the headcount budget. It’s also predictable and easy for customers to understand. However, an interesting dimension we observed around how founders (running this pricing model) are positioning it – rather than pitching their product as a replacement for a human employee (or focusing on the tasks that an employee currently performs), they are focusing on the net new capabilities the AI agent unlocks that a human employee couldn’t, which allows them to charge more premium prices.&lt;/p&gt;
    &lt;head rend="h4"&gt;Per task&lt;/head&gt;
    &lt;p&gt;This is intuitively easy to understand, because it directly connects usage with the cost (so customers pay only for what they use). This is especially helpful in cases where it’s challenging to predict the frequency and volumes of the tasks to be performed. Because it’s linked with tasks performed, it also helps startups tap into the services budget.&lt;/p&gt;
    &lt;head rend="h4"&gt;Hybrid&lt;/head&gt;
    &lt;p&gt;We increasingly see founders opting for a hybrid strategy, which typically involves some sort of base fee, and variable pricing on top, with tiers and overages. Or it could be charging per agent plus an outcome based bonus. Or it could be charging per agent plus metered dedicated tools (so it’s a bit like a human employee asking for SaaS tools to perform their work). As you can see, there are a variety of ways to implement a hybrid pricing model.&lt;/p&gt;
    &lt;p&gt;It’s good because it’s much more flexible, and protects margins by capping usage (so startups can control costs and reduce the risk of unprofitable customers). However, it can quickly get complex, and helping customers predict consumption is key – whether it’s by having a pre-installation analysis for existing volumes of work that could be automated, setting usage reminders and hard usage limits, or credit rollovers, depending on the implementation of the hybrid model.&lt;/p&gt;
    &lt;head rend="h3"&gt;Agentic AI increasingly a part of line of business budgets&lt;/head&gt;
    &lt;p&gt;We asked founders: “Which enterprise budgets are you currently tapping into?” and we were heartened to see that agentic AI startups are predominantly selling into Line of Business or core spend budgets. It goes to show that we are moving past a pure experimental stage (which is where innovation budgets come in) and that AI agents are making a difference to real business use cases or core activities. It’s an excellent way of tracking the mainstreaming of AI agents- even though deployments currently are “broad” rather than “deep” it’s undeniably positive.&lt;/p&gt;
    &lt;p&gt;Our findings were corroborated by other enterprise-oriented surveys as well:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;On average, CFOs report dedicating 25% of their current, total AI budget on AI agents. (Salesforce, August 2025 survey of 261 global CFOs)&lt;/item&gt;
      &lt;item&gt;88% of executives say their companies plan to up their AI-related budgets this year due to agentic AI. Over a quarter of them plan increases of 26% or more. (PwC, May 2025 survey of 300 senior executives)&lt;/item&gt;
      &lt;item&gt;Organisations are redirecting their AI investments toward core functions, which now command 64% of AI budgets compared to 36% for noncore activities. This reallocation suggests a growing sophistication: a recognition that AI delivers its most compelling value when applied to central business operations rather than peripheral processes. (IBM, June 2025 survey of 2,900 executives globally)&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h3"&gt;The challenges with agentic deployments&lt;/head&gt;
    &lt;p&gt;We asked founders in our survey: “What are the biggest issues you have encountered when deploying AI Agents for your customers? Please rank them in order of magnitude (e.g. Rank 1 assigned to the biggest issue)”&lt;/p&gt;
    &lt;p&gt;The results of the Top 3 issues were illuminating: we’ve frequently heard that integrating with legacy tech stacks and dealing with data quality issues are painful. These issues haven’t gone away; they’ve merely been eclipsed by other major problems. Namely:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Difficulties in integrating AI agents into existing customer/company workflows, and the human-agent interface (60% of respondents)&lt;/item&gt;
      &lt;item&gt;Employee resistance and non-technical factors (50% of respondents)&lt;/item&gt;
      &lt;item&gt;Data privacy and security (50% of respondents)&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h4"&gt;Workflow integration and the human-agent interface&lt;/head&gt;
    &lt;p&gt;By this we are referring to both the conceptual aspects (e.g. How should my processes, workflows or even role evolve to accommodate AI? Where and how can AI agents help me?) and practical aspects (e.g. what does the UI look like?).&lt;/p&gt;
    &lt;p&gt;Conceptually, it takes end-users some time to adapt to his new paradigm. First it’s about accepting and realising that processes need to change, second it’s about figuring out how they need to change. And it’s not just for the end-users to work that out, but also for the team that makes the buying decisions for agentic AI solutions.&lt;/p&gt;
    &lt;p&gt;Practically, startups are focused on making sure their agents are deployed within the context the user needs and also show up in other UIs (e.g. ServiceNow, Slack) in workflows across systems. Basically, meeting users wherever they are, to make the process of adopting agents as frictionless as possible. It’s also about making sure that the workflows and outputs are customised to the human user. As one founder observed:&lt;/p&gt;
    &lt;p&gt;“A lot of companies will want very specific workflows – which makes sense – but supporting multiple unique instances is still quite difficult as some users will want it in very specific formats e.g. specific excel output – supporting that ‘last mile’ UI is probably the biggest headache.”&lt;/p&gt;
    &lt;head rend="h4"&gt;Employee resistance and non-technical factors&lt;/head&gt;
    &lt;p&gt;We observed an interesting pattern in the survey results, where startups whose agents operate at higher levels of autonomy (9/10 or higher) were more likely to report employee resistance as a bigger issue. Those operating in heavily regulated industries and domains (healthcare, compliance) and therefore require high accuracy also noted that customers were sceptical of agentic solutions. Our findings around autonomy, accuracy and their effect on employee resistance are simply expressions of a single problem: Trust issues.&lt;/p&gt;
    &lt;p&gt;These trust issues invariably have other manifestations. Our conversations with enterprise practitioners suggested that human-AI collaborations weren’t always working well; either humans overrelied on the AI which gave faulty responses or they underrelied and double-checked everything the AI did, reducing efficiency. This phenomenon was also observed in an MIT study which suggests that human-AI collaboration often underperforms compared to AI or humans working alone. Reasons for this include the presence of communication barriers, trust issues, ethical concerns, and lack of effective coordination between humans and AI systems. As one founder noted:&lt;/p&gt;
    &lt;p&gt;“They [human users] often think AI is ‘magic’, and don’t fully grasp its advantages and downsides. Failing to understand how AI works can sometimes lead to frustration and confusion. There is also a certain reluctance to drop old processes and taking the plunge fully with AI.”&lt;/p&gt;
    &lt;p&gt;Another major non-technical factor that founders pointed to was that customers often lacked a coherent AI and data strategy, leading to a plethora or use cases and test pilots but no cohesive plan for AI adoption at scale. In fairness to the customers, another founder highlighted:&lt;/p&gt;
    &lt;p&gt;“AI proliferation creates selling friction. Every incumbent provider promises AI enabled point solutions now, which are often initially attractive to customers as its covered by committed budget. But this results in a fragmented AI strategy and very often fails to bring the latest innovation; not all AI is equal.”&lt;/p&gt;
    &lt;head rend="h4"&gt;Integration with legacy tech stacks&lt;/head&gt;
    &lt;p&gt;This isn’t a new problem; we’ve always had these issues with enterprise software. But here’s a fun fact for you – 42% of enterprises need access to eight or more data sources to deploy AI agents successfully. It’s not as much fun when you’re working through it all: legacy tech stacks don’t always have an API, documentation is lacking, customers rely on a variety of super-walled archaic applications that keep the company knowledge blocked, so data is siloed and distributed… and the list goes on. We aren’t sharing any quotes from founders here because they’ve mostly said similar things, which speaks to the universality of a painful experience that doesn’t need any further elucidation.&lt;/p&gt;
    &lt;head rend="h4"&gt;Observability, monitoring and evaluation&lt;/head&gt;
    &lt;p&gt;In our previous research on Responsible AI, we covered why it’s so hard to ensure that AI systems function as intended, and interpreting what the AI model did and why. It was hard enough to interpret the behaviour of a single LLM-powered agent, but this complexity is compounded when multiple agents interact asynchronously and dynamically with each other. Each agent may have its own memory, task objective and reasoning path, so tracing the chain of events leading to a final decision or failure is difficult. Also, you can have cascading errors in a multi-agent system, where they end up reinforcing each others’ bad decisions. And all of these would be difficult to detect unless you have ongoing monitoring and robust eval mechanisms. By ensuring that the AI agents are working as intended, observability, monitoring and evals give customers the confidence to launch them with their end users. It’s also about traceability. As a founder highlighted:&lt;/p&gt;
    &lt;p&gt;“The challenge is to find a rationale for the AI agent’s output that is understood and verifiable by humans, so as to increase trust and actually free up time.”&lt;/p&gt;
    &lt;p&gt;Here’s an interesting aside: As part of our survey, we ask founders “What would you like to learn through our research into Agentic AI? What would be most helpful or useful to you?” and a surprising number of questions were around observability and evals. Stay tuned, we’re covering it in our upcoming research.&lt;/p&gt;
    &lt;head rend="h4"&gt;Data privacy and security&lt;/head&gt;
    &lt;p&gt;There are the actual issues, and then there are the perceived issues. In terms of actual issues, founders talked about everything from doing considerable engineering (with several complete restarts) to work around large financial services requirements for the data they can or can’t send to LLMs, to getting ISO 27001 certifications to overcome issues with MedTech clients. Yet even if the data is protected, there are perceived issues leading to resistance or slower rollout of agentic solutions. To illustrate with some founder observations:&lt;/p&gt;
    &lt;p&gt;“Data and privacy are not so much as a blocker as a major source of slowing us down.”&lt;/p&gt;
    &lt;p&gt;“Data privacy is not a problem per se, but on occasion we have experienced resistance from senior leadership because of concerns around privacy and security.”&lt;/p&gt;
    &lt;head rend="h4"&gt;Data quality, data infrastructure issues&lt;/head&gt;
    &lt;p&gt;Much like with integration issues, data quality and data infrastructure issues are not new. Almost all the founders in our survey talked about having to do a lot of data clean-up to get to reliable agentic workflows. However, the problem is exacerbated because agentic AI aims to tackle actual tasks performed, and clients typically have poor or outdated documentation of processes. Not to mention that there is lots of embedded knowledge of processes that sits within users’ heads.&lt;/p&gt;
    &lt;head rend="h4"&gt;Infrastructure costs&lt;/head&gt;
    &lt;p&gt;Sam Altman noted in his blog that “The cost to use a given level of AI falls about 10x every 12 months, and lower prices lead to much more use.” Even as the price per token (for a given level of AI) has decreased, the newer cutting-edge reasoning models are more expensive, and the number of tokens consumed has skyrocketed. Epoch AI found that average output length for reasoning models has grown at 5x per year (vs 2.2x for non-reasoning models), and reasoning models exhibit longer response lengths overall – 8x more tokens on average compared to non-reasoning models. And even a simple query may use about 5,000 reasoning tokens internally to return only a 100 token response. The token bloat is a real problem, and the quest for quality (and consistent) model outputs exacerbates the issue, as a founder called out:&lt;/p&gt;
    &lt;p&gt;“Model consistency is a challenge and has implications for infrastructure costs. Infrastructure costs are a balancing act as it limits the tiers we can make agentic flows available. We have found we need a lot of context and multi pass/reasoning models for most real tasks to get at the required reliability in 2025 which could become significant enough to impact margin.”&lt;/p&gt;
    &lt;head rend="h3"&gt;Agentic infrastructure predominantly built in-house&lt;/head&gt;
    &lt;p&gt;We asked founders: “Which third-party AI agent infrastructure solutions do you work with when building, deploying, monitoring the agents? Eg. solutions for memory, tool calling, agentic frameworks, browser infrastructure, agentic payments etc.”&lt;/p&gt;
    &lt;p&gt;Based on their responses, we found that 52% of the founders surveyed built their agentic AI infrastructure in-house (either predominantly or fully). We attribute this primarily to the nascence of the agentic ecosystem.&lt;/p&gt;
    &lt;p&gt;Here are some of the excerpts from our founder survey (click on the carousel arrows to see more quotes):&lt;/p&gt;
    &lt;p&gt;In terms of the third-party tools most frequently cited, ChatGPT and Claude models were most often mentioned along with the Google Agent Development Kit, while LangChain (unsurprisingly) came up as the most popular framework. Other tools that received shout-outs include: frameworks and orchestration platforms (Pydantic, Temporal, Inngest, Pipecat); monitoring, observability and evaluations (Langfuse, Langtrace, Coval); agentic browsers (Browserbase, Browser Use, Strawberry) and vector databases (Qdrant).&lt;/p&gt;
    &lt;head rend="h2"&gt;Observations&lt;/head&gt;
    &lt;p&gt;Based on our 40+ interviews with enterprise practitioners and startup founders, we outline the common approaches taken by startups to successfully deploy AI agents in enterprises.&lt;/p&gt;
    &lt;head rend="h3"&gt;Strategic rollout of use cases&lt;/head&gt;
    &lt;p&gt;The most successful deployment strategies we’ve seen started with:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;simple and specific use cases with clear value drivers, that were low risk yet medium impact;&lt;/item&gt;
      &lt;item&gt;weren’t majorly disruptive to existing workflows;&lt;/item&gt;
      &lt;item&gt;preferably automating a task that the human user dislikes (or was outsourced);&lt;/item&gt;
      &lt;item&gt;the output of the workflow can be easily/quickly verified by the human for accuracy or suitability; and&lt;/item&gt;
      &lt;item&gt;demonstrated clear ROI quickly&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Given the current levels of technological development, AI Agents work best when narrowly applied to very specific tasks and operating under a specific context. For instance, we’ve seen this in healthcare with revenue cycle management processes (claim and denial management) that health systems were already outsourcing to third-party providers.&lt;/p&gt;
    &lt;p&gt;The land-and-expand strategy for AI agents is very different to traditional SaaS. Given enterprises are increasingly under pressure from the C-Suite to incorporate AI into their work, there are plenty of opportunities for startups to “land” but it’s much harder to “expand” – and not only that, it’s taking much longer to expand even when they want to expand, because it’s a use case by use case rollout. Much like the iconic Volkswagen ad, sometimes it’s better to “Think Small” and build trust first, rather than attempt too many use cases (and excessively complex use cases) right off the bat.&lt;/p&gt;
    &lt;head rend="h3"&gt;Hand-holding and more hand-holding&lt;/head&gt;
    &lt;p&gt;Successful enterprise deployments of agentic AI require significant levels of hand-holding and education. This is primarily because enterprises aren’t often fully clear on the best use cases to apply agentic AI to, the opportunities and limitations of the technology, how best to use the tools, how to redesign workflows… and more critically, how to evaluate and buy agentic AI products.&lt;/p&gt;
    &lt;p&gt;Workshops and consultative GTM: Pre-installation analysis and workshops at the very outset are critical for setting and managing expectations, on everything from identifying areas where agents can or can’t be helpful, to providing clarity upfront on expected usage and pricing. For instance, Health Force (AI Agents that automate daily administrative tasks at hospitals), does an AI Readiness Assessment for free, and helps hospitals identify the workflows where AI agents would be most beneficial. Or Runwhen (AI Agents for developer experience) performs a pre-installation analysis on existing alerts or chats and measures which could be automated via Runwhen. Using a consultative GTM approach also gives the enterprise comfort around the degree of customisability of third-party solutions (every organisation has some workflows unique to them, and incorporating their specific needs is key to driving adoption).&lt;/p&gt;
    &lt;p&gt;Forward Deployed Engineers (FDE) driving adoption forward: A Forward Deployed Engineer (FDE) is a software engineer who works directly with customers, often embedded within their teams, to solve complex, real-world problems – so it’s a hybrid role where an FDE is a software developer, a consultant and a product manager, all rolled into one.&lt;/p&gt;
    &lt;p&gt;Most of the agentic startups we spoke to have found Palantir-style forward deployment useful when selling to enterprises/mid-market clients who have complex data that is fragmented across different data sources. But there other forms of complexity as well, such as product complexity and process complexity, that necessitate a deeper partnership with customers at the very outset to ensure the agentic solutions are achieving the desired outcomes. The more complex the data integration, the product and the business processes, the greater is the need for an FDE to help drive the best outcomes for clients.&lt;/p&gt;
    &lt;p&gt;The human-agent interface and the three E’s (education, entertainment and expectation management): As we observed earlier, our survey suggests that 60% of agentic AI startups struggle with workflow integration and the human-agent interface. Startups such as Strawberry (AI agents on browsers) are focused on building out multiple dimensions of that, such as: (a) moving beyond merely a chatbot-style interface; (b) having the AI agents themselves educate the customers on what they can or can’t do, plus give suggestions on how to better use the product whilst managing expectations; and (c) make the AI Agents fun or engaging to work with. For our part, we were vastly amused by Strawberry’s agents such as LinkedIn Linus or Competition Camille or Data Extraction Denise (as you can see, we have an ardent appreciation for alliteration).&lt;/p&gt;
    &lt;p&gt;Besides educating the customers (in an engaging way) on how to best use agents and manage expectations, founders are also focused on enabling human users to educate the agents, so users can guide the agent’s behaviour to reflect changing priorities and workloads, as well as capture the users’ unique style of working. Users need to enjoy working with the agent enough to evangelise it (clearly, no Clippy!)&lt;/p&gt;
    &lt;head rend="h3"&gt;Positioning&lt;/head&gt;
    &lt;p&gt;A common question we’ve got from agentic AI founders is how to position their products when everyone’s marketing sounds the same. Also, many solutions claim to use Agentic AI; they over-promise and under-deliver, leading to buyer fatigue and scepticism – thus creating a challenging environment for truly high quality agentic AI solutions to cut through the noise. Taking a consultative, collaborative and problem-focused approach that demonstrates real value is critical (which we described above), but so are the various dimensions of positioning (which we discuss below). We fully acknowledge that the positioning is mostly a function of current perceptions and levels of technological development; as these systems see more mainstream acceptance and agents achieve higher levels of autonomy reliably, no doubt the positioning strategies will evolve as well.&lt;/p&gt;
    &lt;p&gt;To mention AI or not to mention AI, that is the question: We’ve observed an interesting dichotomy in positioning strategies. In verticals like Healthcare, founders are actively downplaying the use of agentic AI in their solutions. As two founders in Healthcare observed:&lt;/p&gt;
    &lt;p&gt;“You know what’s weird? If you use the words ‘agent’ or ‘AI’ it actually backlashes more than it benefits. The moment you put AI out to clients, it’s like, ‘oh, here goes a bunch of fluff again.’”&lt;/p&gt;
    &lt;p&gt;“We position more as a mental healthcare company than an agent company to our customers.”&lt;/p&gt;
    &lt;p&gt;However, in verticals such as Financial Services, founders are prominently featuring their “agentic AI” proposition, given the AI-forward positioning resonates with users and buyers. The good news is that in most verticals (outside of healthcare), the “agentic AI” positioning resonates well (provided it meets all the criteria we outlined in the section on “strategic rollout of use cases”).&lt;/p&gt;
    &lt;p&gt;Levels of autonomy: Most founders we spoke to have opted for a co-pilot approach to selling, even if their solutions were capable of higher levels of autonomy. This was mainly done to build trust with the customer. For instance, Juna AI (whose agents optimise complex manufacturing processes in heavy industries) started with a co-pilot approach where the agents give recommendations to the customer on how to optimally run the systems, and the customer still has the option to choose whether or not they implement it. While the idea is to eventually get to higher levels of autonomy (the solution is certainly capable of it), it’s baby steps for now.&lt;/p&gt;
    &lt;p&gt;Most practitioners we spoke to feel like they’re on a learning journey, and would much prefer the co-pilot approach than a fully autonomous one (though again, this depends on 3 factors: the criticality/impact of the task being automated, how easy it is to audit the mistakes the AI may potentially make and catch them before it does any harm, and whether it unlocks an entirely new capability e.g. being able to perform a task a human was never able to do before). However, being able to easily review the AI agent’s outputs were critical.&lt;/p&gt;
    &lt;p&gt;Augmentation, not replacement: Tied to the previous point on lower levels of autonomy, startups that have positioned themselves as “augmenting” rather than replacing existing employees or legacy tech stacks have found it easier to gain a foothold in large enterprises. It’s even better if they’re pitching a net new capability that wasn’t previously possible. From a tech standpoint, rip-and-replace is difficult for customers who have complex downstream workflows built on top of their existing ERPs like SAP and startups (such as askLio in the procurement space) are focused on working with existing technologies to get to faster deployments. From an employee standpoint, we’re not yet at a level where most AI agents are sufficiently reliable or capable of so many automated end-to-end workflows that enterprises could contemplate a true FTE replacement. Or even if both those things were true (tying back to our earlier point around levels of automation) enterprise practitioners are more cautious with highly autonomous deployments.&lt;/p&gt;
    &lt;p&gt;Articulation of value proposition and ROI: We can analyse the issue in two ways: (1) where the value proposition is well understood so it is relatively easier to articulate the ROI; or (2) where AI agents have unlocked entirely new capabilities (so it’s hard to compare to existing solutions) and therefore harder to characterise ROI.&lt;/p&gt;
    &lt;p&gt;Let’s take the first case, where it is easier to understand the use case and articulate the ROI because it’s an established workflow. Here, it’s usually about pitching time and cost savings and/or revenue uplift. For instance, Covecta (AI agents for financial services) talks about 70% time saving on tasks such as drafting detailed credit applications, while Biorce (clinical AI platform that speeds up drug development) talks about ROI both in terms of labour cost savings as well as faster time-to-market (Biorce’s calculation being that one hour spent on its platform saves 720 human hours), with the faster time-to-market itself creating revenue acceleration opportunities. Credit applications and drug discovery are still well understood; but what of entirely new developments such as Generative UI?&lt;/p&gt;
    &lt;p&gt;That brings us to the second case. Startups such as Architect provide AI agents to build, personalise, and optimise your web pages for every visitor – something we would call “Generative UI” because the visual presentation, content and visitor experience of the website changes on the fly depending on who the viewer is. Given the novelty of the solution, it may be challenging to pitch the product, but Architect overcomes this by positioning the product as complementary to ads systems/platforms (like Google AdWords) and measures success through improvement in conversion (emphasising the utility, not just the novelty).&lt;/p&gt;
    &lt;p&gt;Given we backed Synthesia (AI video platform that generates photorealistic performances of avatars) back in 2019, we’ve seen firsthand how startups with highly novel technologies get widespread adoption through emphasising utility over novelty. We don’t expect the agentic AI wave (for net new use cases) to be any different.&lt;/p&gt;
    &lt;head rend="h2"&gt;Getting to the desirable end state&lt;/head&gt;
    &lt;p&gt;Today’s AI agents are still (for the most part) reactive, because they are triggered in response to human prompts or explicit user instruction to act. However, in the future we expect to see more ambient agents and proactive agents that initiate tasks by themselves, and can reason more effectively around edge cases so that task execution is robust even under uncertainty. This means that agents need to be adaptable without becoming unreliable, and they need to learn continuously as well as retain those memories over long periods of time (much like how a human colleague learns about your organisation). Today, they operate in more constrained and controlled environments with organisations, but we see agents eventually interacting with “open” environments – engaging with and negotiating with other agents across different organisations, hiring other agents and interacting with the wider world much like a human colleague would.&lt;/p&gt;
    &lt;p&gt;The question is: how do we get there? And we explore that in the next 3 parts of our series on Agentic AI, where we focus on the technologies and startups that are: (a) enabling AI agents to access accurate, relevant and up-to-date information, as well as manage context and memory; (b) enabling agents to perform actions reliably, whether through secure tool execution or agentic browsers to help agents navigate a visual world much like a human would; and (c) ensuring that agents are trustworthy, reliable, and robust to adversarial attacks or unintended failure modes.&lt;/p&gt;
    &lt;p&gt;If you’re a founder building something that gets us closer to the desirable end state, please reach out to Advika, Sevi or Mina – we’d love to chat.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=45808308</guid><pubDate>Tue, 04 Nov 2025 07:26:45 +0000</pubDate></item><item><title>Some software bloat is OK</title><link>https://waspdev.com/articles/2025-11-04/some-software-bloat-is-ok</link><description>&lt;doc fingerprint="b34add5ae62d211c"&gt;
  &lt;main&gt;
    &lt;head rend="h1"&gt;Some software bloat is OK&lt;/head&gt;
    &lt;p&gt;Published on&lt;/p&gt;
    &lt;p&gt;In the era of fast CPUs, gigabytes of RAM, and terabytes of storage software efficiency has become an overlooked thing. Many believe there are less reasons to optimize software today, as processors are fast and memory is cheap. They claim that we should focus on other things, such as developers' efficiency, maintainability, fast prototyping etc. They often recall Donald Knuth's famous quote:&lt;/p&gt;
    &lt;quote&gt;Premature optimization is the root of all evil.&lt;/quote&gt;
    &lt;head rend="h2"&gt;How bad is software bloat nowadays?&lt;/head&gt;
    &lt;p&gt;Historically computers had much less computing power and memory. CPUs and memory were expensive. Programmers were much more constrained by the CPU speed and available memory. A lot of work had to be done in order to fit the program into these limited resources. It's no surprise that for 1970-80s era programs it was a normal thing to be written in very low-level languages, such as machine code or assembly as they give the programmers ultimate control over every byte and processor instruction used.&lt;/p&gt;
    &lt;p&gt;Over time, memory and CPUs became cheaper (all the hardware overall). This reduced the constraints and allowed to use higher level languages and eventually led to the rise of languages with garbage collection (Java, C#, PHP, Python, JavaScript, etc).&lt;/p&gt;
    &lt;p&gt;Sometimes when you compare the system requirements of older and newer generation software, you become shocked. Just compare the system requirements of, let's say Windows 11 Calculator alone (let alone the full OS), and the whole Windows 95 OS! Windows 11 Calculator alone consumes over 30MiB of RAM (even this might be an underestimation because shared memory is not included), while Windows 95 could work even with 4MiB of RAM.&lt;/p&gt;
    &lt;p&gt;Here is another more dramatic example. Super Mario Bros. game was just 31KiB (or 40KiB, still doesn't change much anything) and used only 2KiB of RAM. But this high quality (preserved pixels from original, lossless) WebP image below is almost 54KiB. Larger than the game itself!&lt;/p&gt;
    &lt;head rend="h2"&gt;A significant part of this bloat is actually a tradeoff&lt;/head&gt;
    &lt;p&gt;From the first glance this seems insane, the developers probably don't care about efficiency, right? Well, it's more complicated, and actually a significant part of this isn't caused by the developers' incompetence or laziness.&lt;/p&gt;
    &lt;p&gt;Today's software solves some problems that were less of a concern in 1990s and before. Here are some examples:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Layers &amp;amp; frameworks. Modern software tends to be more complicated. Most of the time people don't write software from scratch, they usually use some library or framework. For example, the mentioned Windows 11 Calculator is a UWP / WinUI / XAML app with C++ / WinRT. You're loading a UI framework, layout engine, localization, input, vector icons, theming, high-DPI, etc. Those shared DLLs live somewhere in RAM even if Task Manager only shows part of them in the app's "Working Set".&lt;/item&gt;
      &lt;item&gt;Security &amp;amp; isolation. Nowadays security is very important. Sandboxes, code integrity, ASLR, CFG, data execution prevention, etc. add processes, mappings, and metadata. This didn't exist much in older era software.&lt;/item&gt;
      &lt;item&gt;Robustness &amp;amp; error handling / reporting. Related to the previous one. Since modern software is usually complicated and has tons of edge cases (and sometimes integrated with other third parties), this requires to handle and log all the possible errors / failures. All these safety measures also add extra code.&lt;/item&gt;
      &lt;item&gt;Globalization &amp;amp; accessibility. Full Unicode, RTL, complex script support, screen readers, keyboard navigation, high-contrast / animations bring code and resources.&lt;/item&gt;
      &lt;item&gt;Containers &amp;amp; virtualization. Bundle the app with its exact runtime/deps into an image, run it as a container on any host with Docker. Same container in dev, CI, staging, prod means fewer environment drift bugs. VMs are great when in addition to this something should be run on an OS that is not compatible with the host OS.&lt;/item&gt;
      &lt;item&gt;Engineering trade-offs. We accept a larger baseline to ship faster, safer code across many devices. Hardware grew ~three orders of magnitude. Developer time is often more valuable than RAM or CPU cycles. Also modern software is usually developed by many people (sometimes even organizations) which adds a need of a code structure that makes it easier to maintain and collaborate, such as modularity, extensibility / flexibility, code / architectural patterns, etc. I mean just try to add some feature to an ancient ultra-optimized game written entirely in assembly by some hobbyist. Without the help of the author it will probably be a very challenging task: the code will be much harder to understand (more like reverse engineer), the changes might break some "clever but fragile" code, etc. We certainly don't want that.&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h2"&gt;But yeah, a significant part of the bloat is also bad&lt;/head&gt;
    &lt;p&gt;That being said, a lot of this bloat is also not a result of a tradeoff, but incompetence or laziness. For example, using libraries or frameworks for trivial things or not understanding algorithmic complexity. Many websites are notoriously bloated by having dozens (sometimes hundreds) of questionable dependencies, they don't only degrade performance, they can cause security issues and maintenance problems. And nowadays AI is a multiplier of such problems.&lt;/p&gt;
    &lt;p&gt;Another source of bloat is over-engineering:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Microservices for a tiny app.&lt;/item&gt;
      &lt;item&gt;Generic plugin systems.&lt;/item&gt;
      &lt;item&gt;DI forests.&lt;/item&gt;
      &lt;item&gt;"Just in case" interfaces that are used once.&lt;/item&gt;
      &lt;item&gt;SPA + global state for static content (heavy hydration for simple pages).&lt;/item&gt;
      &lt;item&gt;Multiple build steps/tools for marginal gains.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Finally, this obsession with containers is also concerning. Containers often cause increased startup time (quite long even on SSDs), RAM and CPU usage (looking at you, Ubuntu Snap). Sadly, containers are very appealing as an easy crutch for mitigating compatibility and security issues for ordinary desktop apps.&lt;/p&gt;
    &lt;head rend="h2"&gt;"Bottlenecks" still exist and are still optimized&lt;/head&gt;
    &lt;p&gt;Many programs still have some small but critical areas of code that need some level of optimization. This might be some database query or a long running function.&lt;/p&gt;
    &lt;p&gt;There are still highly demanded optimized programs or parts of such programs which won't disappear any time soon. Here is a small fraction of such software:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Codecs: dav1d (AV1), x264 / x265 (H.264 / 265), libjpeg-turbo.&lt;/item&gt;
      &lt;item&gt;Archivers / compressors: zstd, xz / LZMA, brotli, libarchive.&lt;/item&gt;
      &lt;item&gt;VMs / JITs: HotSpot (JIT tiers + GC tuning), V8 / JavaScriptCore (inline caches, TurboFan), LuaJIT (trace JIT).&lt;/item&gt;
      &lt;item&gt;Std libs: glibc, musl (small, predictable), modern C++ STL (small-buffer opt, node vs flat containers), Rust std (zero-cost iterators).&lt;/item&gt;
      &lt;item&gt;Crypto: OpenSSL / BoringSSL / LibreSSL (constant-time, vectorized primitives).&lt;/item&gt;
      &lt;item&gt;GPU drivers.&lt;/item&gt;
      &lt;item&gt;Game engines.&lt;/item&gt;
      &lt;item&gt;OS kernels.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Such software will always exist, it just moved to some niche or became a lower level "backbone" of other higher level software.&lt;/p&gt;
    &lt;head rend="h2"&gt;Too late optimization is also a source of evil&lt;/head&gt;
    &lt;p&gt; While premature optimization by sacrificing design and correctness for hypothetical gains is harmful, delaying it is also bad. You still need to choose the right algorithms and architecture early on since wrong decisions might bite you later. The choice between &lt;code&gt;O(N)&lt;/code&gt; and &lt;code&gt;O(N2)&lt;/code&gt;
		algorithms
		is usually still important in the early
		stages.
	&lt;/p&gt;
    &lt;head rend="h2"&gt;Conclusion&lt;/head&gt;
    &lt;p&gt;Some bloat is actually OK and it has benefits. Without some bloat we would not have so much innovation. Sure, we could make many things ultra-optimized, we could reduce many apps' sizes by a factor of 10 - 100. But most of the time it will be just an unworthy exchange of the developers' time for a Pyrrhic victory. On the other hand, like most other things, the bloat becomes harmful when it's not in moderation which we also see. Thus, too late optimization can be a problem as well.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=45808690</guid><pubDate>Tue, 04 Nov 2025 08:27:23 +0000</pubDate></item><item><title>Show HN: Yourshoesmells.com – Find the most smelly boulder gym</title><link>https://yourshoesmells.com</link><description>&lt;doc fingerprint="7b37ec77fee53b6e"&gt;
  &lt;main&gt;
    &lt;p&gt;💨 Stinky ✨ Login 💨 TOP 5 Stink 💨 Top 5 Stinky Gyms 💨 Top 5 Stinky Gyms 💡 Request a feature Feedback ☕ Buy me a coffee Support 🔒 Register / Login ✕ Username Letters, numbers, underscores, or hyphens only; 3-20 characters Password at least 6 characters Register 🌍 Farthest Gym Calculating... 💨 Stinkiest Gym Calculating... 🏋️ Gyms Visited Loading... 📍 Gyms by Region Loading chart... 🔒 Setup / Reset Password ✕ ✏️ Cast Your Vote ✕&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=45808918</guid><pubDate>Tue, 04 Nov 2025 09:11:27 +0000</pubDate></item><item><title>Bloom filters are good for search that does not scale</title><link>https://notpeerreviewed.com/blog/bloom-filters/</link><description>&lt;doc fingerprint="7b8d83e54decc003"&gt;
  &lt;main&gt;
    &lt;p&gt;A great blog post from 2013 describes using bloom filters to build a space-efficient full text search index for small numbers of documents. The algorithm is simple: Per document, create a bloom filter of all its words. To query, simply check each document's bloom filter for the query terms.&lt;/p&gt;
    &lt;p&gt;With a query time complexity of O(number-of-documents), we can forget about using this on big corpuses, right? In this blog post I propose a way of scaling the technique to large document corpuses (e.g. the web) and discuss why that is a bad idea.&lt;/p&gt;
    &lt;p&gt;Fun fact: There is a nice implementation of this exact algorithm that is still used in the wild. But let's get into it.&lt;/p&gt;
    &lt;head rend="h2"&gt;Why even try this?&lt;/head&gt;
    &lt;p&gt;The bloom filter index's big selling point is its small size. It allows static websites with dozens of pages to ship a full text search index to the client that is as small as a small image. An equivalent inverted index, which is the traditional textbook approach for keyword-based full text search, would be multiple times bigger.&lt;/p&gt;
    &lt;p&gt;But index size is not only relevant on small blog websites. If we could scale this technique to larger document corpuses and achive similar space savings, that would be huge!&lt;/p&gt;
    &lt;p&gt;The main thing that seems to stand in our way is query performance. Instead of always checking every document's bloom filter, we will try to construct an index that only checks a small subset of filters, but still finds all matching documents.&lt;/p&gt;
    &lt;head rend="h2"&gt;Some Ideas that don't work at all&lt;/head&gt;
    &lt;p&gt;Look, I brainstormed a bunch of ideas for how to improve the bloom filter based index. I will quickly go over two of them, because identifying and discarding ideas that will not work is an important part of science and engineering.&lt;/p&gt;
    &lt;head rend="h3"&gt;Sort the filters&lt;/head&gt;
    &lt;p&gt;If we sort the filters by some metric, for example by the most to least significant bits, then we can use a binary search algorithm or something like that, right? - Wrong.&lt;/p&gt;
    &lt;p&gt;We can construct a simple counter example to show that this does not work. Here the query is matched by the first and the last filter in a sorted list of filters.&lt;/p&gt;
    &lt;head rend="h3"&gt;Tree of filters&lt;/head&gt;
    &lt;p&gt;Plain sorting does not work, but what if we structure our big set of filters into a tree? Imagine it sort of like this, but much bigger.&lt;/p&gt;
    &lt;p&gt;At each branch node, we construct an aggregate filter that encodes all documents that are reachable from the branch. Aggregate filters are constructed by a simple bitwise or of the other filters like this.&lt;/p&gt;
    &lt;p&gt;When we get a query, we first check it against the top level branch filters. If a filter does not match e.g. the filter for document 6-10, we can discard that entire branch of the tree for this query.&lt;/p&gt;
    &lt;p&gt;Ideally we would like to search as few branches of the tree as possible to improve performance. How many branches we do need to search, depends heavily on the partitioning of the documents. Intuitively, we can think of it like this: branch A should contain all documents that contain the words "dog", "cat", "bird". Branch B should contain documents with "car", "bus", "plane". The fewer branches each word is contained in the better.&lt;/p&gt;
    &lt;p&gt;Here comes the problem: What if there is a document that says "I took my cat on the bus today"?&lt;lb/&gt; This breaks our assumtion above, and suddenly for the query "bus" we need to search both branches. You can imagine this happening for almost every word in the dicionary across all branches, because language is complex and lets us say so many different things in many different contexts.&lt;/p&gt;
    &lt;p&gt;Or in other words: Text documents are high-dimensional.&lt;lb/&gt; I recommend reading about the curse of dimensionality for an intuition of what issues this implies. Here it means that it is basically impossible to cluster text documents into disjunct subsets without significant overlap. For our seach index that means that even when using this tree, we would still need to search almost every document for every query.&lt;/p&gt;
    &lt;head rend="h2"&gt;Inverted Index of Bloom Filters&lt;/head&gt;
    &lt;p&gt;The problem with our previous tree-based idea is that there is so much overlap between text documents. But I know one book that only contains every work exactly once: The dictionary. We can construct a search tree of the entire dictionary, again based on bloom filters. Each leaf represents a set of words. At each leaf we keep a list of pointers to every document's filter that contains one of those words.&lt;/p&gt;
    &lt;p&gt;Maybe not so incidentally, this looks a lot like an inverted index. And it works! For any query term we can walk the tree to the leaf that contains the query term and then we match only against the filters at that leaf. Instead of a hash table, as in the inverted index, our index uses a tree for the dictionary, but fundamentally it does a similar thing.&lt;/p&gt;
    &lt;p&gt;The big difference is that the tree can be smaller than the hash table. Remember, size is the main reason to attempt this at all. Not only is there no empty space in a tree, but we also encode all the words in our bloom filters instead of storing them outright. Modern bloom filters (actually called Xor filters) require about ten bits per element [1], much less than the 8 bits per character required to store a full word.&lt;/p&gt;
    &lt;p&gt;As an aside, bloom filters are indeed already used in full text search for large-ish datasets, but in the form of skip-indexes. In a skip index, a bloom filter is used to quickly check if a large chunk of data contains a value (e.g. a word) at all. That way, a database can avoid reading chunks of data that do not contain any records for a given query. Until very recently this technique was used by the Clickhouse OLAP system for full text search [2]. It has been superseeded by a proper inverted index in 2025.&lt;/p&gt;
    &lt;head rend="h2"&gt;Why all of this is still a bad idea&lt;/head&gt;
    &lt;p&gt;We did it! We have a working idea for a bloom filter based search index that works for large document corpuses. The query time complexity is not as good as for an inverted index, but it is logarithmic with the number of documents. That is good enough if you ask me. So why do I write that it is still a bad idea?&lt;/p&gt;
    &lt;p&gt;Let's think about what allows the bloom filter based index to be small again. Instead of storing the entire dictionary in our index, we use bloom filters that require about ten bits per word. Ten bits per word. Ten bits per every word. Not unique word. Every word in our document corpus (except duplicates in the same document). To make our math exceedingly simple, let's say the english dictionary has about 500 Thousand unique words and every document contains 1000 distinct words. At ten bits per entry for a bloom filter, that makes each document's filter about 1.25kb. Assume that words are on average ten characters long, then the dictionary will require 5mb for the text alone. We can assume another 4mb for the inverted index's hash table to get a lower bound of 9mb for the inverted index. Both indexes require similar amounts of space for document ids and pointers, so relative to the inverted index, our bloom filter index grows by 1.25kb per document. Divide 9mb by 1.25kb and you find out that at only 7200 documents the inverted index becomes more space efficient than the bloom filter index. Of course the real numbers will be different and we are ignoring some things here, but the trend will stay the same.&lt;/p&gt;
    &lt;p&gt;What is going on here is that while an inverted index must store every word in the dictionary exactly once, sharing the space when a word is reused, bloom filters do not share space amongst each other. Every document's bloom filter must encode all words in the document from scratch. If a word is contained in thousands of documents, that requires much more space than simply storing the word in plain text.&lt;/p&gt;
    &lt;head rend="h2"&gt;Conclusions&lt;/head&gt;
    &lt;p&gt;When you have a small number of documents relative to the size of your dictionary, bloom filters can indeed achieve a much smaller full text search index than is possible traditionally.&lt;/p&gt;
    &lt;p&gt;Bloom filters are space efficient when compressing a large dictionary into a small number of filters. As more filters share the same dictionary, this efficiency decreases. Intuitively this is because bloom filters cannot share information amongst each other. Each filter must encode its entire dictionary from scratch. An inverted index does not do this. It only stores the dictionary once and shares it for all documents, so it gets more space efficient with the number of documents.&lt;/p&gt;
    &lt;p&gt;More generally, there is no synergy between bloom filters. Each filter on its own is efficient, but as a whole system, a different approach might be more efficient. We can transfer this insight to other problem domains as well. For example, imagine a content moderation system on a social media platform that allows blocking individual accounts. If we have one global blocklist on our platform, a bloom filter can be an efficient (though maybe not ideal) implementation of this. But allow every user to create their own blocklist and a different design will be more scaleable.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=45808998</guid><pubDate>Tue, 04 Nov 2025 09:25:31 +0000</pubDate></item></channel></rss>