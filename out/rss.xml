<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>Hacker News: Front Page</title><link>https://raw.githubusercontent.com/Prabesh01/hnrss-content-extract/refs/heads/main/out/rss.xml</link><description>Hacker News RSS</description><atom:link href="https://raw.githubusercontent.com/Prabesh01/hnrss-content-extract/refs/heads/main/out/rss.xml" rel="self"/><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><language>en</language><lastBuildDate>Fri, 23 Jan 2026 05:25:44 +0000</lastBuildDate><item><title>Show HN: Text-to-video model from scratch (2 brothers, 2 years, 2B params)</title><link>https://huggingface.co/collections/Linum-AI/linum-v2-2b-text-to-video</link><description>&lt;doc fingerprint="745d5508e730e637"&gt;
  &lt;main&gt;
    &lt;p&gt;Hugging Face Models Datasets Spaces Community Docs Enterprise Pricing Log In Sign Up Linum-AI 's Collections Linum v2 (2B, text-to-video) Linum v2 (2B, text-to-video) updated about 12 hours ago 360p or 720p, 2-5 seconds, Apache 2.0 Upvote 3 Linum-AI/linum-v2-360p Text-to-Video • Updated 2 days ago • 4 Linum-AI/linum-v2-720p Text-to-Video • Updated 3 days ago • 13 Upvote 3 Share collection View history Collection guide Browse collections&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=46721488</guid><pubDate>Thu, 22 Jan 2026 16:31:47 +0000</pubDate></item><item><title>Show HN: isometric.nyc – giant isometric pixel art map of NYC</title><link>https://cannoneyed.com/isometric-nyc/</link><guid isPermaLink="false">https://news.ycombinator.com/item?id=46721802</guid><pubDate>Thu, 22 Jan 2026 16:52:35 +0000</pubDate></item><item><title>AnswerThis (YC F25) Is Hiring</title><link>https://www.ycombinator.com/companies/answerthis/jobs/r5VHmSC-ai-agent-orchestration</link><description>&lt;doc fingerprint="3d09585cf826800c"&gt;
  &lt;main&gt;
    &lt;p&gt;End-to-end workspace to accelerate scientific discovery&lt;/p&gt;
    &lt;p&gt;We crossed $1M ARR in 8 months. 200,000+ researchers at Stanford, MIT, and Amazon use us to do literature reviews 10x faster.&lt;lb/&gt; Now we're building something bigger: the system of record for scientists where they can find papers, analyze experiments, and write their drafts while collaborating with other scientists as well as our AI agents. &lt;lb/&gt; You should apply if you:&lt;lb/&gt; → Ship fast and learn faster &lt;lb/&gt; → Know the agentic AI stack cold (vector DBs, graph RAG, agent memory) &lt;lb/&gt; → Have built full-stack products that scaled past 1M users &lt;lb/&gt; → Actually care about accelerating scientific discovery&lt;lb/&gt; Bonus: You've published research yourself. &lt;lb/&gt; Don't apply if you:&lt;lb/&gt; → Can't be in SF, in person &lt;lb/&gt; → Haven't used the product yet &lt;lb/&gt; → Don't want to talk to customers &lt;lb/&gt; $120K-$200K + equity. We're a small team backed by YC. &lt;lb/&gt; Reach out on careers [at] answerthis.io&lt;lb/&gt; Tell us what you hate about AnswerThis, what you love, and one project you're proud of alongside your resume.&lt;lb/&gt; Science moves too slowly. Help us fix that.&lt;/p&gt;
    &lt;p&gt;We move fast. The whole process can be done in 2-3 weeks.&lt;/p&gt;
    &lt;p&gt;AnswerThis is building the system of record for scientists—where researchers can find papers, analyze experiments, and write drafts while collaborating with other scientists and AI agents.&lt;/p&gt;
    &lt;p&gt;We crossed $1M ARR in 8 months. 200,000+ researchers at Stanford, MIT, Amazon, and top institutions worldwide use us daily. We're backed by Y Combinator (F25) and cash-flow positive.&lt;/p&gt;
    &lt;p&gt;Science moves too slowly. Grant applications take months. Literature reviews take weeks. Researchers spend more time on paperwork than on discovery. We're fixing that.&lt;/p&gt;
    &lt;p&gt;You'll be joining a small, fast team in SF that ships constantly and talks to customers every day.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=46721897</guid><pubDate>Thu, 22 Jan 2026 17:00:40 +0000</pubDate></item><item><title>Launch HN: Constellation Space (YC W26) – AI for satellite mission assurance</title><link>https://news.ycombinator.com/item?id=46721933</link><description>&lt;doc fingerprint="22906374e6a95fca"&gt;
  &lt;main&gt;
    &lt;div&gt;&lt;p&gt;Hi HN! We're Kamran, Raaid, Laith, and Omeed from Constellation Space (&lt;/p&gt;https://constellation-io.com/&lt;p&gt;). We built an AI system that predicts satellite link failures before they happen. Here's a video walkthrough: &lt;/p&gt;https://www.youtube.com/watch?v=069V9fADAtM&lt;p&gt;.&lt;/p&gt;&lt;p&gt;Between us, we've spent years working on satellite operations at SpaceX, Blue Origin, and NASA. At SpaceX, we managed constellation health for Starlink. At Blue, we worked on next-gen test infra for New Glenn. At NASA, we dealt with deep space communications. The same problem kept coming up: by the time you notice a link is degrading, you've often already lost data.&lt;/p&gt;&lt;p&gt;The core issue is that satellite RF links are affected by dozens of interacting variables. A satellite passes overhead, and you need to predict whether the link will hold for the next few minutes. That depends on: the orbital geometry (elevation angle changes constantly), tropospheric attenuation (humidity affects signal loss via ITU-R P.676), rain fade (calculated via ITU-R P.618 - rain rates in mm/hr translate directly to dB of loss at Ka-band and above), ionospheric scintillation (we track the KP index from magnetometer networks), and network congestion on top of all that.&lt;/p&gt;&lt;p&gt;The traditional approach is reactive. Operators watch dashboards, and when SNR drops below a threshold, they manually reroute traffic or switch to a backup link. With 10,000 satellites in orbit today and 70,000+ projected by 2030, this doesn't scale. Our system ingests telemetry at around 100,000 messages per second from satellites, ground stations, weather radar, IoT humidity sensors, and space weather monitors. We run physics-based models in real-time - the full link budget equations, ITU atmospheric standards, orbital propagation - to compute what should be happening. Then we layer ML models on top, trained on billions of data points from actual multi-orbit operations.&lt;/p&gt;&lt;p&gt;The ML piece is where it gets interesting. We use federated learning because constellation operators (understandably) don't want to share raw telemetry. Each constellation trains local models on their own data, and we aggregate only the high-level patterns. This gives us transfer learning across different orbit types and frequency bands - learnings from LEO Ka-band links help optimize MEO or GEO operations. We can predict most link failures 3-5 minutes out with &amp;gt;90% accuracy, which gives enough time to reroute traffic before data loss. The system is fully containerized (Docker/Kubernetes) and deploys on-premise for air-gapped environments, on GovCloud (AWS GovCloud, Azure Government), or standard commercial clouds.&lt;/p&gt;&lt;p&gt;Right now we're testing with defense and commercial partners. The dashboard shows real-time link health, forecasts at 60/180/300 seconds out, and root cause analysis (is this rain fade? satellite setting below horizon? congestion?). We expose everything via API - telemetry ingestion, predictions, topology snapshots, even an LLM chat endpoint for natural language troubleshooting.&lt;/p&gt;&lt;p&gt;The hard parts we're still working on: prediction accuracy degrades for longer time horizons (beyond 5 minutes gets dicey), we need more labeled failure data for rare edge cases, and the federated learning setup requires careful orchestration across different operators' security boundaries. We'd love feedback from anyone who's worked on satellite ops, RF link modeling, or time-series prediction at scale. What are we missing? What would make this actually useful in a production NOC environment?&lt;/p&gt;&lt;p&gt;Happy to answer any technical questions!&lt;/p&gt;&lt;/div&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=46721933</guid><pubDate>Thu, 22 Jan 2026 17:03:21 +0000</pubDate></item><item><title>Composing APIs and CLIs in the LLM era</title><link>https://walters.app/blog/composing-apis-clis</link><description>&lt;doc fingerprint="b7e1c59035133bd8"&gt;
  &lt;main&gt;
    &lt;p&gt;Itâs early 2026. Industry practice is divided on how to structure tool descriptions within the context window of an LLM. One strategy is to provide top-level tools that perform fine grained actions (e.g. list pull requests in a GitHub repo). Another increasingly popular strategy is to eschew new tools per se and to simply inform the model of useful shell commands it may invoke. In both cases reusable skills can be defined that give the model tips on how to perform useful work with the tools; the main difference is whether the model emits a direct tool call or instead an &lt;code&gt;exec_bash&lt;/code&gt; call containing a reference to CLIs.&lt;/p&gt;
    &lt;p&gt;To me it is clear that the latter represents an innovation on the former. The best feature of the unix shell is command composition. Enabling the model to form pipelines of tool calls without re-prompting the model after each stage should present huge savings in token cost. The resulting pipelines can also be saved to scripts or be customized and interactively executed by human operators.&lt;/p&gt;
    &lt;p&gt;The command line is an interface compatible with humans and machines. If the model is adept at using it (itâs already text), why fall back to a machine-native protocol?&lt;/p&gt;
    &lt;p&gt;One good response is that MCP is an easy way to expose SaaS functionality to agents. In lieu of MCP, how can we achieve that? Iâll answer this question by providing two quite different examples from my recent work: giving an agent access to Google Docs and to Google Groups.&lt;/p&gt;
    &lt;head rend="h2"&gt;HTTP APIs&lt;/head&gt;
    &lt;p&gt;I wanted my agent to be able to list my cloud-based Google Docs, to read them as markdown, and to read and understand any attached comment threads.&lt;/p&gt;
    &lt;p&gt;Google provides a very nice API to fulfill all of this functionality (well, comments are harder). I did the obvious thing and spun up a Google Cloud project, pasted the API documentation into an LLM, and the result was a &lt;code&gt;gdrive&lt;/code&gt; CLI with subcommands to list files and to export a particular one.&lt;/p&gt;
    &lt;p&gt;That worked. But as in the title of this post, the best code is no code. This script seemed entirely like boilerplate which shouldnât have to exist. This would be true even if the script were to use an SDK rather than make HTTP calls directly. In reality, Googleâand many SaaS vendorsâalready define a program which can be used to call all of their APIs. Itâs their OpenAPI spec! The program just needs a sufficient interpreter.&lt;/p&gt;
    &lt;p&gt;I Googled around and was thrilled to discover Restish, a tool which nearly perfectly matches my philosophy. If OpenAPI specs are programs, Restish is their interpreter. Sample usage (cribbed from their docs):&lt;/p&gt;
    &lt;quote&gt;# Register a new API called `cool-api` $ restish api configure cool-api https://api.rest.sh/openapi.yaml # This will show you all available commands from the API description. $ restish cool-api --help # Call an API operation (`list-images`) $ restish -r cool-api -H 'Accept: application/json' list-images | jq '.[0].name' "Dragonfly macro"&lt;/quote&gt;
    &lt;p&gt;Restish even generates shell completions for the API endpoints (subcomands) and parameters (options/args)!&lt;/p&gt;
    &lt;p&gt;I have only two complaints:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Restish wants to handle API authorization for me (persisting e.g. OAuth tokens). I want it to just be an âinterpreter for OpenAPI programsâ. Iâll manage my own auth flows and inject my own tokens.&lt;/item&gt;
      &lt;item&gt;Executing commands against an api spec requires registering the spec with Restish ahead of time. See aboveâI want just an interpreter.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Both points imply that Iâll want a wrapper script around restish. The wrapper script will manage the second issue (it will create a temporary spec directory to satisfy Restish). The script will also perform my desired authorization flow and inject tokens into Restish ephemerally.&lt;/p&gt;
    &lt;head rend="h2"&gt;API Authorization&lt;/head&gt;
    &lt;p&gt;Looking back at the omnibus script that I generated initially, it contained an OAuth 2.0 client to hit Googleâs authorization flow, get tokens, and refresh them upon expiry. OAuth 2.0 is a standard. A particular set of parameters (Googleâs OAuth URL, client id, client secret, grant type, scopes) could be thought of as a valid program in the OAuth 2.0 client language.&lt;/p&gt;
    &lt;p&gt;I, again, just needed an interpreter. I, again, found one.&lt;/p&gt;
    &lt;p&gt;oauth2c is a command-line client for OAuth 2.0-compliant authorization servers. You input the aforementioned program (i.e. URL, grant type, ...) and it begins the ensuing flow (usually by opening your browser) then prints the resulting tokens to stdout.&lt;/p&gt;
    &lt;p&gt;With this missing piece, what was previously a couple-hundred lines of dense Python is now an order-of-magnitude smaller shell script which performs the logical equivalent of &lt;code&gt;oauth2c "https://accounts.google.com/..." | restish google drive-files-list&lt;/code&gt;.&lt;/p&gt;
    &lt;p&gt;Iâve published the resulting script to bmwalters/gdrive-client. The repo also contains a cool method for propagating shell completions.&lt;/p&gt;
    &lt;head rend="h3"&gt;Detour: secure token storage for macOS CLI scripts&lt;/head&gt;
    &lt;p&gt;While Iâm dispensing pro-tips, I should highlight this pretty cool and under-documented way to securely store data (like a long-lived refresh token) from a macOS shell script.&lt;/p&gt;
    &lt;p&gt;Let me introduce the problem. The results of Googleâs OAuth flow are a short-lived access token (to hit APIs; valid for about an hour) and a long-lived refresh token (to mint new access tokens; valid for 6 months). I wasnât comfortable with leaving that refresh token exposed on my machine. Services like the AWS CLI do indeed store plaintext credentials in &lt;code&gt;~&lt;/code&gt;, but those tend to expire much more frequently than 6 months.&lt;/p&gt;
    &lt;p&gt;I knew I wanted to reach for the macOS Keychain, and in particular some security level that would require biometrics / passcode when reading the refresh token.&lt;/p&gt;
    &lt;p&gt;macOS ships a handy keychain CLI named &lt;code&gt;security&lt;/code&gt;. You can store secrets in Keychain with invocations like &lt;code&gt;security add-generic-password -s google-api -a my-account -w $REFRESH_TOKEN&lt;/code&gt;. But biometrics are not trivially supported, and web search advised me to create a small Swift wrapper. After doing so, I learned that any &lt;code&gt;kSecAttrAccessControl&lt;/code&gt; attribute that would lead to biometrics or device passcode would result in the binary requiring real signed entitlements through the Apple Developer Program. I was a bit stuck looking for a solution to what seemed to be a simple requirement.&lt;/p&gt;
    &lt;p&gt;I ran the &lt;code&gt;security&lt;/code&gt; man page through Claude Opus 4.5 and the model made a very interesting discovery.&lt;/p&gt;
    &lt;quote&gt;-T appPath Specify an application which may access this item (multiple -T options are allowed)&lt;/quote&gt;
    &lt;p&gt;It turns out that the keychain remembers which application stored the passwordâby default this is probably &lt;code&gt;security&lt;/code&gt; itself or perhaps my shell; I havenât checkedâand that application is permitted to read back the password without user-interactive authorization. Providing the &lt;code&gt;-T&lt;/code&gt; flag to &lt;code&gt;security&lt;/code&gt; when creating the password allows overriding said program entry, and crucially the empty string may be used to remove the default application entry.&lt;/p&gt;
    &lt;p&gt;In other words this code:&lt;/p&gt;
    &lt;quote&gt;security add-generic-password -T"" ...&lt;/quote&gt;
    &lt;p&gt;will prevent &lt;code&gt;security find-generic-password&lt;/code&gt; from simply returning the secret, even when invoked immediately after secret creation. In practice, attempts to read the secret will prompt me for my device passcode, which is definitely good enough for my use case.&lt;/p&gt;
    &lt;p&gt;Putting it all together, I had a CLI that, when invoked, would try to use the stored access token with Restish (no passcode prompt needed). If the access token was invalid, it would invoke &lt;code&gt;oauth2c&lt;/code&gt; to refresh the token and retry. This would prompt me for my devcie passcode. If that also failed, it would invoke the Authorization Code flow using &lt;code&gt;oauth2c&lt;/code&gt; which would seamlessly open my browser and retry the command on success.&lt;/p&gt;
    &lt;p&gt;All with only shell pipelines, no bespoke code. Vastly reduced surface area for future maintenance and for bugs to hide in.&lt;/p&gt;
    &lt;head rend="h2"&gt;Adversarial interoperability&lt;/head&gt;
    &lt;p&gt;Thatâs all-well-and-good for services which provide machine-readable API specs, but what about those which are less charitable?&lt;/p&gt;
    &lt;p&gt;Google Groups is one such case. I wanted to export the discussion history from pollenpub to serve as a Q&amp;amp;A knowledge base while developing this blog site. However my research turned up no such API from Google.&lt;/p&gt;
    &lt;p&gt;I love using LLMs to solve this class of problem. My workflow is as follows:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Open a fresh private browser (to capture any authorization flow, if needed).&lt;/item&gt;
      &lt;item&gt;Open Devtools &amp;gt; Network and filter to HTML, XHR, WS, Other.&lt;/item&gt;
      &lt;item&gt;Perform the actions that I would like to automate, i.e. load the Google Group site, navigate to the next page, and read a particular conversation.&lt;/item&gt;
      &lt;item&gt;Firefox Devtools &amp;gt; Network &amp;gt; right click &amp;gt; âSave All As HARâ.&lt;/item&gt;
      &lt;item&gt;Run the file through cloudflare/har-sanitizer&lt;/item&gt;
      &lt;item&gt;Prompt an LLM with: âin this directory there is a large HAR file captured while I did actions xyz; please create a Python client for this APIâ.&lt;/item&gt;
      &lt;item&gt;Edit the generated file to add a meaningful &lt;code&gt;User-Agent&lt;/code&gt;string with a backlink.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Iâve repeated this workflow about three times and I have near-term plans for a couple more.&lt;/p&gt;
    &lt;p&gt;Note that I havenât tried combining the above two workflows yet: I havenât asked the model to produce an OpenAPI spec + reverse-engineered OAuth parameters, but thatâs a logical next step.&lt;/p&gt;
    &lt;head rend="h2"&gt;Conclusion&lt;/head&gt;
    &lt;p&gt;Thereâs a lot of power in composing CLIs. You get human interaction and current-generation-LLM interaction for the price of one. And with some creativity, itâs often possible for one individual to maintain CLIs in place of an MCP server that has been developed for a given service, or even to do so before the comparable MCP server has been written.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=46722074</guid><pubDate>Thu, 22 Jan 2026 17:14:04 +0000</pubDate></item><item><title>CSS Optical Illusions</title><link>https://alvaromontoro.com/blog/68091/css-optical-illusions</link><description>&lt;doc fingerprint="860c29efdbe599e5"&gt;
  &lt;main&gt;
    &lt;p&gt;You can find a collection with all the optical illusions in this article (and more!) on CodePen. You can move your mouse over many of the demos below to reveal the effect or stop the animations.&lt;/p&gt;
    &lt;head rend="h2"&gt;1 - Poggendorff Illusions&lt;/head&gt;
    &lt;p&gt;The Poggendorff illusion is an optical illusion in which a diagonal line interrupted by a vertical bar appears misaligned, even when both segments are actually continuous.&lt;/p&gt;
    &lt;p&gt;A simple version of this effect can be seen in the following demo. I used the &lt;code&gt;::before&lt;/code&gt; and &lt;code&gt;::after&lt;/code&gt; pseudo-elements to create the diagonal line and the vertical bar, respectively.&lt;/p&gt;
    &lt;p&gt;The effect can also be seen in a more elaborate version with multiple diagonal lines and vertical bars:&lt;/p&gt;
    &lt;p&gt;This drawing can easily be achieved using two CSS gradients: one tilted at 70 degrees and another consisting of a series of vertical columns. I applied it to the &lt;code&gt;body&lt;/code&gt;, although I could have used &lt;code&gt;:root&lt;/code&gt; instead.&lt;/p&gt;
    &lt;p&gt;Another variation of this illusion is the Münsterberg Poggendorff Arch, in which the two sides of an arch appear misaligned and seem as though they will not meet at the top - but they do (mouse over to see it).&lt;/p&gt;
    &lt;head rend="h2"&gt;2 - Induced Gradients&lt;/head&gt;
    &lt;p&gt;The following illusions combine gradients and flat colors. Surprisingly, some of the gradients do not actually exist. They are simple gray bars that, when placed over a gradient, appear to have gradients themselves.&lt;/p&gt;
    &lt;p&gt;Take the following demo: all three bars (two vertical ones on the sides and one horizontal bar in the center) are the same shade of gray. The only real gradient is behind them, which tricks our brain into believing that the bars are different colors and even contain gradients.&lt;/p&gt;
    &lt;p&gt;Here is another variation of this effect. It looks like the central line has a repeating gradient of dark and light grays, but in reality it is a flat color. If you mouse over the demo, the bar will expand, making it clear that there is no gradient at all.&lt;/p&gt;
    &lt;head rend="h2"&gt;3 - Cornsweet Illusion&lt;/head&gt;
    &lt;p&gt;The next few optical illusions share a common idea: some colors are identical, but they do not look the same. This typically happens when regions of the same color or brightness are surrounded by areas with different contrast.&lt;/p&gt;
    &lt;p&gt;For example, in the following demo, the left and right ends are the same shade of gray. However, one looks lighter because it is closer to white, while the other looks darker because it is closer to black. Mouse over to reveal that they are, in fact, the same color.&lt;/p&gt;
    &lt;head rend="h2"&gt;4 - White's Illusion&lt;/head&gt;
    &lt;p&gt;Run the following demo. You will see two gray columns in a black-and-white grid. Both columns are the same shade of gray, but the one surrounded by black appears darker than the one surrounded by white.&lt;/p&gt;
    &lt;p&gt;I coded this demo using &lt;code&gt;mix-blend-mode&lt;/code&gt; so I could try something a bit different. That worked well, but it also made it harder to showcase the effect on hover. In hindsight, I should have planned that better.&lt;/p&gt;
    &lt;p&gt;This optical illusion also works with colors. For example, these two squares appear to be different shades of blue, but they are the same color. This time, you can mouse over to reveal the effect:&lt;/p&gt;
    &lt;head rend="h2"&gt;5 - Wertheimer-Koffka Ring&lt;/head&gt;
    &lt;p&gt;The ring in the following illustration has the same color all the way around. However, one side is placed over white and the other over black, which makes them look different. If you mouse over the demo, the red bar will disappear, making it more obvious that the ring is a single, uniform color.&lt;/p&gt;
    &lt;head rend="h2"&gt;6 - Adelson's Illusion&lt;/head&gt;
    &lt;p&gt;You have probably seen the illusion involving a checkerboard and an object casting a shadow, where two tiles - one seemingly light and one seemingly dark - turn out to be the same color.&lt;/p&gt;
    &lt;p&gt;This demo follows the same principle. You will see two tiles labeled A and B. Both have the same shade of gray, but most people cannot tell at first glance (or second, or even third).&lt;/p&gt;
    &lt;head rend="h2"&gt;7 - Asahi illusion of Brightness&lt;/head&gt;
    &lt;p&gt;The circle at the center of this flower-shaped element is the same white as the rest of the page, but it gives the impression of being brighter, as if it were emitting light.&lt;/p&gt;
    &lt;head rend="h2"&gt;8 - Color Spheres&lt;/head&gt;
    &lt;p&gt;This is one of my favorite illusions in the collection. The circles (or spheres) look red, blue, or green, but in reality they are all the same grayish color. Our brain "colorizes" them based on the lines that overlap the shapes. Don't believe it? Mouse over the illustration.&lt;/p&gt;
    &lt;head rend="h2"&gt;9 - Colors from Contour&lt;/head&gt;
    &lt;p&gt;In the following illustration, the lines inside the yellow section appear blue, while the lines inside the blue section appear red... but they are all black (or very dark gray). The white contour creates the illusion of color. Mouse over to remove the contour and the lines will clearly appear black.&lt;/p&gt;
    &lt;head rend="h2"&gt;10 - Curvature Blindness&lt;/head&gt;
    &lt;p&gt;One set of lines looks straighter (top) while the other looks more curved (bottom). In reality, both sets are equally wavy. The only difference is how they are colored: changing the color at the peaks makes the lines look straighter. Changing it at the inflection points makes them look more curved.&lt;/p&gt;
    &lt;p&gt;The CSS code for the wavy lines is adapted from a Temani Afif snippet on CSS-Tricks and his wavy shape generator.&lt;/p&gt;
    &lt;head rend="h2"&gt;11 - Cafe Wall&lt;/head&gt;
    &lt;p&gt;This is a classic optical illusion and an easy one to code in CSS. Three gradients are all that is needed to generate the effect in which the horizontal lines appear slanted, even though they are perfectly parallel.&lt;/p&gt;
    &lt;head rend="h2"&gt;12 - Penrose Triangle&lt;/head&gt;
    &lt;p&gt;This optical illusion depicts an impossible shape. Parts that should be in front appear in the back, top becomes right, and everything feels contradictory. I coded this one some time ago for the 2024 Divtober event.&lt;/p&gt;
    &lt;head rend="h2"&gt;13 - Ebbinghaus Illusion&lt;/head&gt;
    &lt;p&gt;Which orange circle is larger: the one on the right or the one on the left? It is a trick question: both are the same size. However, having smaller surrounding elements gives the impression that one is larger.&lt;/p&gt;
    &lt;p&gt;I also created an animated version of this illusion (see below), as well as another version using a square shape instead of a flower shape:&lt;/p&gt;
    &lt;head rend="h2"&gt;14 - Kanizsa Square&lt;/head&gt;
    &lt;p&gt;When people look at this illustration, they usually say they see a white square over black circles. However, the square is not actually there. The "Pac-Man" shapes create the illusion of a square and a sense of depth. Our brain fills in the missing information.&lt;/p&gt;
    &lt;head rend="h2"&gt;15 - Ehrenstein's Illusion&lt;/head&gt;
    &lt;p&gt;There are no circles or discs in this illustration, only vertical and horizontal lines forming crosses. Our visual system completes the shape and makes us perceive a disc that does not exist.&lt;/p&gt;
    &lt;head rend="h2"&gt;16 - Neon-Color-Spreading Illusion&lt;/head&gt;
    &lt;p&gt;This illustration shows concentric circles, some of which have a green-and-black pattern. Our brain perceives a central patterned circle and four concentric circles around it, beneath the green circle.&lt;/p&gt;
    &lt;p&gt;I cheated a little when creating this in CSS, as I actually used a green circle blended with the other backgrounds.&lt;/p&gt;
    &lt;head rend="h2"&gt;17 - Hering and Wundt Illusions&lt;/head&gt;
    &lt;p&gt;Perspective-based illusions are fascinating. Even when we know we are looking at a flat image, our brain insists on interpreting depth.&lt;/p&gt;
    &lt;p&gt;In the Hering illusion, the red lines appear to curve outward, even though they are straight.&lt;/p&gt;
    &lt;p&gt;The opposite effect is the Wundt illusion. When the lines expand from the sides toward the center, the red lines appear to curve inward (this effect is more subtle).&lt;/p&gt;
    &lt;head rend="h2"&gt;18 - Ponzo Illusion&lt;/head&gt;
    &lt;p&gt;Both yellow lines are the same length, but the top one looks longer due to perceived depth and perspective. I tried a different approach when coding this one by applying a three-dimensional rotation in CSS... so the perspective is technically real.&lt;/p&gt;
    &lt;head rend="h2"&gt;19 - T Illusion&lt;/head&gt;
    &lt;p&gt;This illusion is easy to code in CSS and easy to fall for. Both the vertical and horizontal lines are the same length, but the vertical line appears longer.&lt;/p&gt;
    &lt;head rend="h2"&gt;20 - Müller-Lyer Illusion&lt;/head&gt;
    &lt;p&gt;A classic illusion: the horizontal lines are the same length, but inward- or outward-pointing edges dramatically change how we perceive them. I could swear the top one is longer. But it is not.&lt;/p&gt;
    &lt;p&gt; From a coding perspective, each shape is a pseudo-element. I ensured the horizontal lines were identical by using the same gradients and only repositioning the edges in the &lt;code&gt;::before&lt;/code&gt; and &lt;code&gt;::after&lt;/code&gt;.&lt;/p&gt;
    &lt;head rend="h2"&gt;21 - Tilted Table Illusion&lt;/head&gt;
    &lt;p&gt;It looks like the top rectangle is leaning to the left, but it is actually parallel to the one at the bottom. The trick lies in the direction of the diagonal lines used to "color" each rectangle.&lt;/p&gt;
    &lt;p&gt;This illusion works better on larger screens. The effect is diminished when you can see the whole picture.&lt;/p&gt;
    &lt;head rend="h2"&gt;22 - Parallel Lines&lt;/head&gt;
    &lt;p&gt;This is a simple effect: the black lines are parallel, but they appear not to be because of the direction of the bars crossing them.&lt;/p&gt;
    &lt;p&gt;I slightly overcomplicated this one while coding it. I initially built the black-and-red version below and tried to reuse more code than I probably should have.&lt;/p&gt;
    &lt;p&gt;Here is the original version I created. The effect is also visible there:&lt;/p&gt;
    &lt;p&gt;Good news! There are more optical illusions below - but first, a warning.&lt;/p&gt;
    &lt;p&gt;ATTENTION: The following optical illusions are static, but they give the impression of movement. Proceed accordingly.&lt;/p&gt;
    &lt;p&gt;(Leaving some blank space in case you do not want to continue.)&lt;/p&gt;
    &lt;p&gt;.&lt;/p&gt;
    &lt;p&gt;.&lt;/p&gt;
    &lt;p&gt;.&lt;/p&gt;
    &lt;p&gt;.&lt;/p&gt;
    &lt;p&gt;.&lt;/p&gt;
    &lt;p&gt;.&lt;/p&gt;
    &lt;p&gt;.&lt;/p&gt;
    &lt;p&gt;.&lt;/p&gt;
    &lt;p&gt;.&lt;/p&gt;
    &lt;p&gt;.&lt;/p&gt;
    &lt;p&gt;.&lt;/p&gt;
    &lt;head rend="h2"&gt;23 - Expanding Hole&lt;/head&gt;
    &lt;p&gt;This is a trippy optical illusion. It is completely static, yet it looks like the black hole at the center is expanding - especially when you are not looking at it directly, creating the sensation of falling into a pit.&lt;/p&gt;
    &lt;p&gt;From a coding perspective, this one was very simple: a background pattern made with two radial gradients, plus a blurred pseudo-element for the "expanding" hole.&lt;/p&gt;
    &lt;head rend="h2"&gt;24 - Rotating Snakes&lt;/head&gt;
    &lt;p&gt;This is one of only two optical illusions in this collection where I used HTML elements instead of relying exclusively on CSS. It is a classic effect: when you look at the illustration, the peripheral discs appear to rotate, even though nothing is actually moving.&lt;/p&gt;
    &lt;head rend="h2"&gt;25 - Appearing Dots&lt;/head&gt;
    &lt;p&gt;Another classic illusion. Focus on the white dots and the adjacent dots will appear to turn black. There is no animation, no transition, and nothing dynamic. Just intersecting lines and small white circles, yet it looks like motion.&lt;/p&gt;
    &lt;head rend="h2"&gt;26 - Disappearing Dots&lt;/head&gt;
    &lt;p&gt;This pattern consists of repeating black and white dots across the page. If you focus on one dot, the others will begin to disappear. At first it may happen by row or column, but after a short while, most of them vanish.&lt;/p&gt;
    &lt;p&gt;If you do not immediately see the effect, try focusing on one black dot. Mouse over it, wait a few seconds while keeping your focus, and then mouse out.&lt;/p&gt;
    &lt;head rend="h2"&gt;27 - Ouchi Illusion&lt;/head&gt;
    &lt;p&gt;This is a static image, but it gives the impression that the pattern inside the circle is moving sideways. This happens because our eyes are constantly making small movements, even when we are not aware of it.&lt;/p&gt;
    &lt;p&gt;If you cannot see the illusion, try slightly moving the screen (or your head) while looking just outside the circle.&lt;/p&gt;
    &lt;head rend="h2"&gt;28 - Orthogonal Dotted Lines Sway&lt;/head&gt;
    &lt;p&gt;When you look around this pattern, the central area appears to slide and sway, even though it is completely static. This illusion makes me dizzy... but that may also be because I had to stare at it for a long time while coding it.&lt;/p&gt;
    &lt;head rend="h2"&gt;29 - Enigma&lt;/head&gt;
    &lt;p&gt;This illusion is particularly interesting. There is a pink circle surrounded by concentric pink and purple rings. If you focus on the pink circle, the rings appear to spin or scintillate, as if there were some activity in them. Of course, nothing is actually moving.&lt;/p&gt;
    &lt;head rend="h2"&gt;30 - Waves&lt;/head&gt;
    &lt;p&gt;This demo was challenging to code and takes a long time to load. Mainly because it uses a large number of conic gradients behind the scenes, which browsers struggle to render efficiently. There is probably a better way to implement it, but I have not explored that yet.&lt;/p&gt;
    &lt;p&gt;If you look closely at the illustration, you may notice wave-like motion. As with the previous illusions in this section, the image is entirely static.&lt;/p&gt;
    &lt;p&gt;Good news! There are more optical illusions below - but first, another warning.&lt;/p&gt;
    &lt;p&gt;ATTENTION: The following optical illusions actually move, and the illusion is created by motion itself. Some of them can be dizzying, so proceed accordingly.&lt;/p&gt;
    &lt;p&gt;(Leaving some blank space in case you do not want to continue.)&lt;/p&gt;
    &lt;p&gt;.&lt;/p&gt;
    &lt;p&gt;.&lt;/p&gt;
    &lt;p&gt;.&lt;/p&gt;
    &lt;p&gt;.&lt;/p&gt;
    &lt;p&gt;.&lt;/p&gt;
    &lt;p&gt;.&lt;/p&gt;
    &lt;p&gt;.&lt;/p&gt;
    &lt;p&gt;.&lt;/p&gt;
    &lt;p&gt;.&lt;/p&gt;
    &lt;p&gt;.&lt;/p&gt;
    &lt;head rend="h2"&gt;31 - Animated Ebbinghaus Illusion&lt;/head&gt;
    &lt;p&gt;Earlier, we saw two static versions of the Ebbinghaus illusion. This one is animated. The elements move side to side, and the surrounding shapes grow and shrink, giving the impression that the orange circle is changing size - when it definitely is not.&lt;/p&gt;
    &lt;head rend="h2"&gt;32 - Psychokinematic Tower&lt;/head&gt;
    &lt;p&gt;This looks like a three-dimensional tower spinning in space, as seen from above. In reality, it is a flat, two-dimensional image rotating.&lt;/p&gt;
    &lt;p&gt;Mouse over the demo to stop the rotation and the illusion of depth disappears entirely.&lt;/p&gt;
    &lt;head rend="h2"&gt;33 - Color Fan&lt;/head&gt;
    &lt;p&gt;This optical illusion requires only two gradients: a conic gradient for the fan-shaped arms and a radial gradient for the circles and discs.&lt;/p&gt;
    &lt;p&gt;If you focus on the black dot, the illustration may appear to develop a darker greenish or brownish border. However, the colors never change.&lt;/p&gt;
    &lt;head rend="h2"&gt;34 - Reverse Spoke Illusion&lt;/head&gt;
    &lt;p&gt;This illusion is delightful and disorienting. While the background colors of the wheel are spinning, the spokes remain fixed. However, they appear to rotate in the opposite direction. In reality, only the background is moving.&lt;/p&gt;
    &lt;head rend="h2"&gt;35 - Motion Binding&lt;/head&gt;
    &lt;p&gt;What do you see in this animation? Most people report two sets of lines operating independently: one moving horizontally and another moving vertically. And that is exactly how it looks.&lt;/p&gt;
    &lt;p&gt;In reality, it is a single shape moving uniformly. Run the demo, mouse over the lines, and the true motion will be revealed.&lt;/p&gt;
    &lt;head rend="h2"&gt;36 - Mainz-Linez Illusion&lt;/head&gt;
    &lt;p&gt;Focus on one of the red dots. You will notice it moves straight up and down along a vertical path. Now shift your focus to one of the black crosses in the center. Suddenly, the red dots appear to zigzag instead of moving straight.&lt;/p&gt;
    &lt;p&gt;The CSS code for the wavy lines is adapted from a Temani Afif snippet on CSS-Tricks and his wavy shape generator.&lt;/p&gt;
    &lt;head rend="h2"&gt;37 - Waddling Colors&lt;/head&gt;
    &lt;p&gt;It may look like the boxes are moving at different speeds or like a set of walking feet. In reality, all elements move at the same pace and in parallel. Mouse over the demo to reveal the effect.&lt;/p&gt;
    &lt;p&gt;The illusion also works when the "feet" move in circles, as shown in this alternative version:&lt;/p&gt;
    &lt;head rend="h2"&gt;38 - Dotted-Line Motion&lt;/head&gt;
    &lt;p&gt;Follow the red dot as it moves sideways. From the corner of your vision, it may appear that the dashed black-and-white lines are moving closer together (when the dot moves left) or farther apart (when it moves right). In reality, the lines are completely static.&lt;/p&gt;
    &lt;head rend="h2"&gt;39 - Contrast Asynchrony&lt;/head&gt;
    &lt;p&gt;These dots always have the same color. However, when placed against alternating backgrounds, they appear to jump or move out of sync because of how they blend with their surroundings.&lt;/p&gt;
    &lt;p&gt;Mouse over the demo to remove the background and the illusion disappears.&lt;/p&gt;
    &lt;head rend="h2"&gt;40 - Breathing Square&lt;/head&gt;
    &lt;p&gt;This illusion gives the impression that a blue square is growing and shrinking rhythmically, almost as if it were breathing or beating like a heart.&lt;/p&gt;
    &lt;p&gt;Although the image is rotating, its size never changes. Mouse over the illustration to remove the green boxes and reveal the rotating blue square.&lt;/p&gt;
    &lt;head rend="h2"&gt;41 - Troxler Fading&lt;/head&gt;
    &lt;p&gt;This illustration shows a circle made of pink dots, with one dot missing. Focus on the cross at the center and the missing dot will appear as a yellow or green dot, giving the impression that it is "eating" the pink dots. Just like Pac-Man.&lt;/p&gt;
    &lt;p&gt;I could have used CSS trigonometric functions to calculate the exact positions of the dots, but since they never change, I chose to hardcode the values instead.&lt;/p&gt;
    &lt;p&gt;Here is a related effect. Follow the light gray circle as it spins, and the darker circles will appear to change from gray to greenish. Focus on the cross at the center, and after a short time, the darker circles may begin to fade entirely.&lt;/p&gt;
    &lt;head rend="h2"&gt;42 - Pinna-Brelstaff Illusion&lt;/head&gt;
    &lt;p&gt;This illusion is particularly dizzying. Follow the bluish dot as it moves from right to left and back again. It will appear as though parts of the tiled background are shifting, even though they are static. The only moving element is the dot.&lt;/p&gt;
    &lt;p&gt; From a CSS perspective, I coded the pattern using conic gradients, and applied it to the &lt;code&gt;::before&lt;/code&gt; and &lt;code&gt;::after&lt;/code&gt; pseudo-elements. I then flipped one upside down and clipped it.&lt;/p&gt;
    &lt;head rend="h2"&gt;43 - Palisade&lt;/head&gt;
    &lt;p&gt;The radii of a wheel, when viewed through a palisade, appear to curve. In reality, they are perfectly straight. Mouse over the demo to remove the palisade and you will see that the radii never bend.&lt;/p&gt;
    &lt;head rend="h2"&gt;44 - Alternative Motion&lt;/head&gt;
    &lt;p&gt;This animation demonstrates how our minds infer motion that may not actually be there. Consider the two blue dots. Different people perceive different movements: side to side, top to bottom, or even circular motion.&lt;/p&gt;
    &lt;p&gt;Cover the right side of the animation so that you see only one dot at a time. The motion now appears vertical. Cover the bottom part instead, and the motion appears horizontal. This is our brain trying to complete the movement.&lt;/p&gt;
    &lt;head rend="h2"&gt;45 - Motion Inversion&lt;/head&gt;
    &lt;p&gt;These two illustrations are identical - same shapes, same animation. The only difference is the CSS timing function.&lt;/p&gt;
    &lt;p&gt;The top animation moves smoothly from right to left. The bottom one appears to move choppily in the same direction, but if you focus on it, it may suddenly seem to reverse direction and move faster.&lt;/p&gt;
    &lt;p&gt;Most of the inspiration for these optical illusions came from two excellent resources:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;"35 optical illusions and why they trick your brain" by Patrick Pester.&lt;/item&gt;
      &lt;item&gt;"154 Visual Phenomena &amp;amp; Optical Illusions" with explanations by Michael Bach&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;You can also find this article on:&lt;/p&gt;
    &lt;p&gt;(You can leave comments on those platforms and I will reply there).&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=46722570</guid><pubDate>Thu, 22 Jan 2026 17:41:22 +0000</pubDate></item><item><title>Recent discoveries on the acquisition of the highest levels of human performance</title><link>https://www.science.org/doi/abs/10.1126/science.adt7790</link><description></description><guid isPermaLink="false">https://news.ycombinator.com/item?id=46722853</guid><pubDate>Thu, 22 Jan 2026 18:01:02 +0000</pubDate></item><item><title>I was banned from Claude for scaffolding a Claude.md file?</title><link>https://hugodaniel.com/posts/claude-code-banned-me/</link><description>&lt;doc fingerprint="7a2301352c29c929"&gt;
  &lt;main&gt;
    &lt;p&gt;Excessive sitting isn't good for a person's physical or mental health, but there's a type of sedentary activity that may not shrink our brains or cost our cognition to the same extent.&lt;/p&gt;
    &lt;p&gt;A systematic review of 85 studies has now found good reason to differentiate between 'active' sitting, like playing cards or reading, and 'passive' sitting, like watching TV.&lt;/p&gt;
    &lt;p&gt;The former may actually boost brain health.&lt;/p&gt;
    &lt;p&gt;That's probably because active sitting engages the brain, whereas passive sitting lets a person take a back seat both physically and cognitively.&lt;/p&gt;
    &lt;p&gt;Related: Scientists Revealed How Much Exercise You Need to 'Offset' Sitting All Day&lt;/p&gt;
    &lt;p&gt;"Total sitting time has been shown to be related to brain health; however, sitting is often treated as a single entity, without considering the specific type of activity," explains public health researcher Paul Gardiner from the University of Queensland in Australia.&lt;/p&gt;
    &lt;p&gt;"Most people spend many hours sitting each day, so the type of sitting really matters … These findings show that small everyday choices – like reading instead of watching television – may help keep your brain healthier as you age."&lt;/p&gt;
    &lt;p&gt;Obviously, exercise remains incredibly important for cognitive health, but giving your brain a workout is also important, and that doesn't necessarily mean you have to be on your feet.&lt;/p&gt;
    &lt;p&gt;Across numerous studies, Gardiner and colleagues found that active sitting activities, like reading, playing card games, and using a computer, showed "overwhelmingly positive associations with cognitive health, enhancing cognitive functions such as executive function, situational memory, and working memory."&lt;/p&gt;
    &lt;p&gt;Meanwhile, passive sitting was most consistently associated with negative cognitive outcomes, including increased risk of dementia.&lt;/p&gt;
    &lt;p&gt;The effect sizes were small but significant. The study authors hope their results will help inform future health research and more nuanced health guidance.&lt;/p&gt;
    &lt;p&gt;For example, the researchers suggest guidelines should recognize the difference between passively watching TV and actively using a computer, and encourage people to take short breaks to stimulate their brains and move.&lt;/p&gt;
    &lt;p&gt;Their review focused on studies of typical sedentary activities in natural settings, rather than structured programs designed to boost brain function, making it relevant to people's everyday lives.&lt;/p&gt;
    &lt;p&gt;"Health advice could shift from simply saying 'sit less' to encouraging more mentally engaging activities while sitting," argues Gardiner.&lt;/p&gt;
    &lt;p&gt;"This could help people make easy, realistic changes that support long‑term brain health and potentially reduce dementia risk."&lt;/p&gt;
    &lt;p&gt;The study was published in the Journal of Alzheimer's Disease.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=46723384</guid><pubDate>Thu, 22 Jan 2026 18:38:27 +0000</pubDate></item><item><title>'Active' sitting is better for brain health: review of studies</title><link>https://www.sciencealert.com/not-all-sitting-is-equal-one-type-was-just-linked-to-better-brain-health</link><description>&lt;doc fingerprint="7a2301352c29c929"&gt;
  &lt;main&gt;
    &lt;p&gt;Excessive sitting isn't good for a person's physical or mental health, but there's a type of sedentary activity that may not shrink our brains or cost our cognition to the same extent.&lt;/p&gt;
    &lt;p&gt;A systematic review of 85 studies has now found good reason to differentiate between 'active' sitting, like playing cards or reading, and 'passive' sitting, like watching TV.&lt;/p&gt;
    &lt;p&gt;The former may actually boost brain health.&lt;/p&gt;
    &lt;p&gt;That's probably because active sitting engages the brain, whereas passive sitting lets a person take a back seat both physically and cognitively.&lt;/p&gt;
    &lt;p&gt;Related: Scientists Revealed How Much Exercise You Need to 'Offset' Sitting All Day&lt;/p&gt;
    &lt;p&gt;"Total sitting time has been shown to be related to brain health; however, sitting is often treated as a single entity, without considering the specific type of activity," explains public health researcher Paul Gardiner from the University of Queensland in Australia.&lt;/p&gt;
    &lt;p&gt;"Most people spend many hours sitting each day, so the type of sitting really matters … These findings show that small everyday choices – like reading instead of watching television – may help keep your brain healthier as you age."&lt;/p&gt;
    &lt;p&gt;Obviously, exercise remains incredibly important for cognitive health, but giving your brain a workout is also important, and that doesn't necessarily mean you have to be on your feet.&lt;/p&gt;
    &lt;p&gt;Across numerous studies, Gardiner and colleagues found that active sitting activities, like reading, playing card games, and using a computer, showed "overwhelmingly positive associations with cognitive health, enhancing cognitive functions such as executive function, situational memory, and working memory."&lt;/p&gt;
    &lt;p&gt;Meanwhile, passive sitting was most consistently associated with negative cognitive outcomes, including increased risk of dementia.&lt;/p&gt;
    &lt;p&gt;The effect sizes were small but significant. The study authors hope their results will help inform future health research and more nuanced health guidance.&lt;/p&gt;
    &lt;p&gt;For example, the researchers suggest guidelines should recognize the difference between passively watching TV and actively using a computer, and encourage people to take short breaks to stimulate their brains and move.&lt;/p&gt;
    &lt;p&gt;Their review focused on studies of typical sedentary activities in natural settings, rather than structured programs designed to boost brain function, making it relevant to people's everyday lives.&lt;/p&gt;
    &lt;p&gt;"Health advice could shift from simply saying 'sit less' to encouraging more mentally engaging activities while sitting," argues Gardiner.&lt;/p&gt;
    &lt;p&gt;"This could help people make easy, realistic changes that support long‑term brain health and potentially reduce dementia risk."&lt;/p&gt;
    &lt;p&gt;The study was published in the Journal of Alzheimer's Disease.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=46723694</guid><pubDate>Thu, 22 Jan 2026 19:03:56 +0000</pubDate></item><item><title>Why does SSH send 100 packets per keystroke?</title><link>https://eieio.games/blog/ssh-sends-100-packets-per-keystroke/</link><description>&lt;doc fingerprint="c61ded10eca0acfa"&gt;
  &lt;main&gt;
    &lt;head rend="h2"&gt;Why does SSH send 100 packets per keystroke?&lt;/head&gt;
    &lt;p&gt;And why do I care?&lt;/p&gt;
    &lt;p&gt;Jan 22, 2026&lt;/p&gt;
    &lt;p&gt;Here are a few lines of summarized &lt;code&gt;tcpdump&lt;/code&gt; output for an ssh session where I send a single keystroke:&lt;/p&gt;
    &lt;code&gt;$ ./first_lines_of_pcap.sh single-key.pcap
  1   0.000s  CLIENT-&amp;gt;SERVER   36 bytes
  2   0.007s  SERVER-&amp;gt;CLIENT  564 bytes
  3   0.015s  CLIENT-&amp;gt;SERVER    0 bytes
  4   0.015s  CLIENT-&amp;gt;SERVER   36 bytes
  5   0.015s  SERVER-&amp;gt;CLIENT   36 bytes
  6   0.026s  CLIENT-&amp;gt;SERVER    0 bytes
  7   0.036s  CLIENT-&amp;gt;SERVER   36 bytes
  8   0.036s  SERVER-&amp;gt;CLIENT   36 bytes
  9   0.046s  CLIENT-&amp;gt;SERVER    0 bytes
 10   0.059s  CLIENT-&amp;gt;SERVER   36 bytes
&lt;/code&gt;
    &lt;p&gt;I said a “few” because there are a lot of these lines.&lt;/p&gt;
    &lt;code&gt;$ ./summarize_pcap.sh single-key.pcap
Total packets: 270

  36-byte msgs:   179 packets ( 66.3%)   6444 bytes
  Other data:       1 packet  (  0.4%)    564 bytes
  TCP ACKs:        90 packets ( 33.3%)

  Data sent:      6444 bytes in 36-byte messages,  564 bytes in other data
  Ratio:          11.4x more data in 36-byte messages than other data

  Data packet rate: ~90 packets/second (avg 11.1 ms between data packets)
&lt;/code&gt;
    &lt;p&gt;That is a lot of packets for one keypress. What’s going on here? Why do I care?&lt;/p&gt;
    &lt;head class="sc-4d1d4ca-1 bowwWe"&gt;here's those scripts if you're curious&lt;/head&gt;
    &lt;code&gt;# first_lines_of_pcap.sh
tshark -r "$1" \
  -T fields -e frame.number -e frame.time_relative -e ip.src -e ip.dst -e tcp.len | \
  awk 'NR&amp;lt;=10 {dir = ($3 ~ /71\.190/ ? "CLIENT-&amp;gt;SERVER" : "SERVER-&amp;gt;CLIENT");
       printf "%3d  %6.3fs  %-4s  %3s bytes\n", $1, $2, dir, $5}'
&lt;/code&gt;
    &lt;code&gt;# summarize_pcap.sh
tshark -r "$1" -Y "frame.time_relative &amp;lt;= 2.0" -T fields -e frame.time_relative -e tcp.len | awk '
  {
      count++
      payload = $2

      if (payload == 0) {
          acks++
      } else if (payload == 36) {
          mystery++
          if (NR &amp;gt; 1 &amp;amp;&amp;amp; prev_data_time &amp;gt; 0) {
              delta = $1 - prev_data_time
              sum_data_deltas += delta
              data_intervals++
          }
          prev_data_time = $1
      } else {
          game_data++
          game_bytes = payload
          if (NR &amp;gt; 1 &amp;amp;&amp;amp; prev_data_time &amp;gt; 0) {
              delta = $1 - prev_data_time
              sum_data_deltas += delta
              data_intervals++
          }
          prev_data_time = $1
      }
  }
  END {
      print "Total packets:", count
      print ""
      printf "  36-byte msgs:   %3d packets (%5.1f%%)  %5d bytes\n", mystery, 100*mystery/count, mystery*36
      printf "  Other data:     %3d packet  (%5.1f%%)  %5d bytes\n", game_data, 100*game_data/count, game_bytes
      printf "  TCP ACKs:       %3d packets (%5.1f%%)\n", acks, 100*acks/count
      print ""
      printf "  Data sent:      %d bytes in 36-byte messages,  %d bytes in other data\n", mystery*36, game_bytes
      printf "  Ratio:          %.1fx more data in 36-byte messages than other data\n", (mystery*36)/game_bytes
      print ""
      avg_ms = (sum_data_deltas / data_intervals) * 1000
      printf "  Data packet rate: ~%d packets/second (avg %.1f ms between data packets)\n", int(1000/avg_ms + 0.5), avg_ms
  }'
&lt;/code&gt;
    &lt;head rend="h2"&gt;Discovery&lt;/head&gt;
    &lt;p&gt;I am working on a high-performance game that runs over ssh. The TUI for the game is created in bubbletea 1 and sent over ssh via wish.&lt;/p&gt;
    &lt;p&gt;I have also forked bubbletea to make it faster. Stay tuned!&lt;/p&gt;
    &lt;p&gt;The game is played in an 80x60 window that I update 10 times a second. I’m targeting at least 2,000 concurrent players, which means updating ~100 million cells a second. I care about performance.&lt;/p&gt;
    &lt;p&gt;So I have a script that connects a few hundred bots over ssh and has them make a move a second. Then I use go’s outstanding profiling tools to look at what’s going on.&lt;/p&gt;
    &lt;p&gt;Yesterday I inadvertently broke my test harness. Instead of regularly sending game data, my server sent the bots a single message that said “your screen is too small.” This cut my game’s CPU and bandwidth usage in half.&lt;/p&gt;
    &lt;p&gt;At first I was disappointed. I (briefly) thought I had a free massive speedup on my hands, but it was actually a testing error.&lt;/p&gt;
    &lt;p&gt;But wait.&lt;/p&gt;
    &lt;p&gt;If I wasn’t sending game data back to my bots, why did CPU usage drop by 50% instead of 100%?&lt;/p&gt;
    &lt;head rend="h2"&gt;Investigation&lt;/head&gt;
    &lt;p&gt;As part of debugging the test harness issue, I used &lt;code&gt;tcpdump&lt;/code&gt; to log game traffic with and without the breaking change. Something like:&lt;/p&gt;
    &lt;code&gt;# The game runs on port 22
timeout 30s tcpdump -i eth0 'port 22' -w with-breaking-change.pcap
# Revert change
timeout 30s tcpdump -i eth0 'port 22' -w without-breaking-change.pcap
&lt;/code&gt;
    &lt;p&gt;Our breaking change stopped us from rendering our game over ssh. So &lt;code&gt;with-breaking-change.pcap&lt;/code&gt; contains packets that represent the overhead of each connection without actually rendering the game.&lt;/p&gt;
    &lt;p&gt;I was debugging this with Claude Code, so I asked it to summarize what it saw in the pcap.&lt;/p&gt;
    &lt;code&gt;Wanna take a look yourself? I put with-breaking-change.pcap in this directory

--

Wow! Here's what I found:

Packet Size Distribution (413,703 total packets):
274,907 packets (66%): Exactly 36 bytes
138,778 packets (34%): 0 bytes (TCP ACKs)
18 packets (&amp;lt;0.1%): 72 bytes
&lt;/code&gt;
    &lt;p&gt;Further analysis on a smaller pcap pointed to these mysterious packets arriving ~20ms apart.&lt;/p&gt;
    &lt;p&gt;This was baffling to me (and to Claude Code). We kicked around several ideas like:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;SSH flow control messages&lt;/item&gt;
      &lt;item&gt;PTY size polling or other status checks&lt;/item&gt;
      &lt;item&gt;Some quirk of bubbletea or wish&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;One thing stood out - these exchanges were initiated by my ssh client (stock ssh installed on MacOS) - not by my server.&lt;/p&gt;
    &lt;p&gt;On a hunch, I took a &lt;code&gt;tcpdump&lt;/code&gt; of a regular ssh session.&lt;/p&gt;
    &lt;code&gt;# on my mac, in one tab
sudo tcpdump -ien0 'port 22'

# on my mac, in another tab
ssh $some_vm_of_mine
&lt;/code&gt;
    &lt;p&gt;I waited for the initial connection chatter to die down, sent one keystroke to my remote vm, and looked at the &lt;code&gt;tcpdump&lt;/code&gt; output.&lt;/p&gt;
    &lt;p&gt;I saw the exact same pattern! What in the world?&lt;/p&gt;
    &lt;head rend="h2"&gt;Root cause&lt;/head&gt;
    &lt;p&gt;Once I realized that this was a property of stock ssh and not my game, debugging got a lot easier.&lt;/p&gt;
    &lt;p&gt;Running &lt;code&gt;ssh -vvv&lt;/code&gt; gave me a pretty good sense of what was going on:&lt;/p&gt;
    &lt;code&gt;debug3: obfuscate_keystroke_timing: starting: interval ~20ms
debug3: obfuscate_keystroke_timing: stopping: chaff time expired (49 chaff packets sent) 
debug3: obfuscate_keystroke_timing: starting: interval ~20ms
debug3: obfuscate_keystroke_timing: stopping: chaff time expired (101 chaff packets sent)
&lt;/code&gt;
    &lt;p&gt;That &lt;code&gt;20ms&lt;/code&gt; is a smoking gun - it lines up perfectly with the mysterious pattern we saw earlier! And the rest of the message is pretty helpful too - we sent 49 “chaff” packets for the first keystroke and 101 “chaff” for around the second one.&lt;/p&gt;
    &lt;p&gt;In 2023, ssh added keystroke timing obfuscation. The idea is that the speed at which you type different letters betrays some information about which letters you’re typing. So ssh sends lots of “chaff” packets along with your keystrokes to make it hard for an attacker to determine when you’re actually entering keys.&lt;/p&gt;
    &lt;p&gt;That makes a lot of sense for regular ssh sessions, where privacy is critical. But it’s a lot of overhead for an open-to-the-whole-internet game where latency is critical.&lt;/p&gt;
    &lt;head rend="h2"&gt;Remediation&lt;/head&gt;
    &lt;p&gt;Keystroke obfuscation can be disabled client-side. After reverting my original breaking change, I tried updating my test harness to pass &lt;code&gt;ObscureKeystrokeTiming=no&lt;/code&gt; when starting up ssh sessions.&lt;/p&gt;
    &lt;p&gt;This worked great. CPU usage dropped dramatically and bots still received valid data.&lt;/p&gt;
    &lt;p&gt;But this is hardly a solution in the real world. I want &lt;code&gt;ssh mygame&lt;/code&gt; to Just Work without asking users to pass options that they might not understand.&lt;/p&gt;
    &lt;p&gt;Claude Code originally didn’t have much faith that we could disable this functionality server-side.&lt;/p&gt;
    &lt;p&gt;generated with simon wilson's excellent claude-code-transcripts tool&lt;/p&gt;
    &lt;p&gt;Fortunately, the description I found of SSH keystroke obfuscation made it easy to look up the relevant code in go’s ssh library (which I was transitively depending on).&lt;/p&gt;
    &lt;code&gt;Log message:
Introduce a transport-level ping facility

This adds a pair of SSH transport protocol messages SSH2_MSG_PING/PONG
to implement a ping capability. These messages use numbers in the "local
extensions" number space and are advertised using a "[email protected]"
ext-info message with a string version number of "0".
&lt;/code&gt;
    &lt;p&gt;The “chaff” messages that ssh uses to obscure keystrokes are SSH2_MSG_PING messages. And they’re sent to servers that advertise the availability of the &lt;code&gt;[email protected]&lt;/code&gt; extension. What if we just…don’t advertise &lt;code&gt;[email protected]&lt;/code&gt;?&lt;/p&gt;
    &lt;p&gt;I searched go’s ssh library for &lt;code&gt;[email protected]&lt;/code&gt; and found the commit where support was added. The commit was tiny and seemed very easy to revert.&lt;/p&gt;
    &lt;p&gt;I cloned the go crypto repo and told Claude to revert this change and update our dependencies to use our clone (go’s replace directive makes forking a library very easy).&lt;/p&gt;
    &lt;p&gt;Then I re-ran my test harness. The results were…very good:&lt;/p&gt;
    &lt;code&gt;Total CPU  29.90%          -&amp;gt; 11.64%
Syscalls   3.10s           -&amp;gt; 0.66s
Crypto     1.6s            -&amp;gt; 0.11s
Bandwidth  ~6.5 Mbit/sec   -&amp;gt; ~3 Mbit/sec
&lt;/code&gt;
    &lt;p&gt;Claude was also pretty pumped:&lt;/p&gt;
    &lt;p&gt;yes it's 1:30 am what of it&lt;/p&gt;
    &lt;p&gt;Obviously forking go’s crypto library is a little scary, and I’m gonna have to do some thinking about how to maintain my little patch in a safe way.&lt;/p&gt;
    &lt;p&gt;But this is a huge improvement. I’ve spent much of the last week squeezing out small single-digit performance wins. A &amp;gt;50% drop was unimaginable to me.&lt;/p&gt;
    &lt;head rend="h2"&gt;Debugging with LLMs was fun&lt;/head&gt;
    &lt;p&gt;I’ve been thinking about whether LLMs remove parts of the problem-solving process that I enjoy. But I’ve gotta say, debugging this problem using Claude Code was super fun.&lt;/p&gt;
    &lt;p&gt;I am familiar enough with &lt;code&gt;tcpdump&lt;/code&gt;, &lt;code&gt;tshark&lt;/code&gt;, and friends to know what they can do. But I don’t use them regularly enough to be fast with them. Being able to tell an agent “here’s a weird pcap - tell me what’s going on” was really lovely. And by watching commands as the agent ran them I was able to keep my mental model of the problem up to date.&lt;/p&gt;
    &lt;p&gt;There were still edge cases. At some point in my confusion I switched to ChatGPT and it very confidently told me that my tcpdump output was normal ssh behavior:&lt;/p&gt;
    &lt;p&gt;do all chatgpt messages have this tone and formatting now?&lt;/p&gt;
    &lt;p&gt;And then doubled down when I pushed back:&lt;/p&gt;
    &lt;p&gt;no!!!&lt;/p&gt;
    &lt;p&gt;Similarly, I had to push Claude Code to consider forking go’s ssh library. And I had to make the original leap of “wait…if our test harness was broken, why was usage not 0%?”&lt;/p&gt;
    &lt;p&gt;When you say “LLMs did not fully solve this problem” some people tend to respond with “you’re holding it wrong!”&lt;/p&gt;
    &lt;p&gt;I think they’re sometimes right! Interacting with LLMs is a new skill, and it feels pretty weird if you’re used to writing software like it’s 2020. A more talented user of LLMs may have trivially solved this problem.&lt;/p&gt;
    &lt;p&gt;But the best way to develop a skill is by practicing it. And for me, that means figuring out how to transfer my problem-solving intuitions to the tools that I’m using.&lt;/p&gt;
    &lt;p&gt;Besides. Being in the loop is fun. How else would I write this post?&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=46723990</guid><pubDate>Thu, 22 Jan 2026 19:27:32 +0000</pubDate></item><item><title>Capital One to acquire Brex for $5.15B</title><link>https://www.reuters.com/legal/transactional/capital-one-buy-fintech-firm-brex-515-billion-deal-2026-01-22/</link><description>&lt;doc fingerprint="e1d8a53d0af29fa9"&gt;
  &lt;main&gt;
    &lt;p&gt;Jan 22 (Reuters) - Capital One Financial (COF.N) said on Thursday it will acquire fintech firm Brex in a cash and stock deal valued at $5.15 billion and reported a rise in quarterly profit on the back of higher interest income from its credit card debt.&lt;/p&gt;
    &lt;p&gt;Shares of the consumer lender fell more than 5% following the announcement of the deal, but robust results helped them pare losses to trade 1.5% lower.&lt;/p&gt;
    &lt;p&gt;Sign up here.&lt;/p&gt;
    &lt;p&gt;The move comes as dealmakers prepare for another strong year in 2026, with a record slate of transactions expected as executives pursue scale to navigate rising economic and geopolitical uncertainties.&lt;/p&gt;
    &lt;p&gt;The deal, which is expected to close in mid‑2026, will be carried out on an approximate 50-50 cash-stock basis, Capital One said.&lt;/p&gt;
    &lt;p&gt;Brex operates in corporate cards and expense management software used by firms such as DoorDash (DASH.O) and Robinhood (HOOD.O), which could give Capital One greater exposure and reduce its reliance on consumer credit, cushioning it against the impact of economic downturns.&lt;/p&gt;
    &lt;p&gt;Brex operates in more than 120 countries according to its website.&lt;/p&gt;
    &lt;p&gt;Capital One said the fintech firm's chief executive and founder, Pedro Franceschi, will remain at the helm following the transaction.&lt;/p&gt;
    &lt;head rend="h2"&gt;FOURTH-QUARTER EARNINGS&lt;/head&gt;
    &lt;p&gt;U.S. consumer spending rose at a solid pace in November and October, suggesting the economy was on track for a third consecutive quarter of strong growth.&lt;/p&gt;
    &lt;p&gt;Economic momentum has been underpinned largely by resilient household demand as well as a narrowing trade deficit, with imports declining in response to President Donald Trump's broad tariff increases.&lt;/p&gt;
    &lt;p&gt;However, the tariffs have pushed up the prices of many goods, weighing unevenly across income groups.&lt;/p&gt;
    &lt;p&gt;Economists say spending strength is increasingly concentrated among higher-income households, while lower- and middle-income consumers have limited scope to switch to cheaper alternatives.&lt;/p&gt;
    &lt;p&gt;Capital One's net interest income — the difference between what it makes on loans and pays out on deposits — rose 54% to $12.47 billion in the fourth quarter from a year ago.&lt;/p&gt;
    &lt;p&gt;The McLean, Virginia-based company's net income available to common stockholders came in at $2.06 billion, or $3.26 per share, for the quarter, compared with $1.02 billion, or $2.67 per share, a year earlier.&lt;/p&gt;
    &lt;head rend="h2"&gt;CREDIT CARD CAP CONUNDRUM&lt;/head&gt;
    &lt;p&gt;Trump said last week he was calling for a one‑year cap on credit card interest rates at 10% starting January 20, but offered few details on how the proposal would be implemented or how companies would be compelled to comply.&lt;/p&gt;
    &lt;p&gt;Banking industry groups have pushed back against the proposal, warning it would restrict the availability of credit for everyday consumers.&lt;/p&gt;
    &lt;p&gt;JPMorgan Chase (JPM.N) CEO Jamie Dimon said on Wednesday a proposal to cap credit card interest rates would amount to economic disaster.&lt;/p&gt;
    &lt;p&gt;However, Bank of America (BAC.N) is considering options to offer new credit cards with an interest rate of 10% to satisfy Trump's demands, a source familiar with the matter said on Thursday.&lt;/p&gt;
    &lt;p&gt;The introduction of an interest rate cap would deal a significant blow to Capital One Financial, which has one of the most credit-card‑dependent business models among major U.S. lenders.&lt;/p&gt;
    &lt;p&gt;"We feel strongly that a cap on interest rates would catalyze a number of unintended consequences," CEO Richard Fairbank said in a call with analysts.&lt;/p&gt;
    &lt;p&gt;He added that lack of credit would result in reduced consumer spending and likely bring on a recession.&lt;/p&gt;
    &lt;p&gt;Reporting by Pritam Biswas in Bengaluru; Editing by Shreya Biswas&lt;/p&gt;
    &lt;p&gt;Our Standards: The Thomson Reuters Trust Principles.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=46725288</guid><pubDate>Thu, 22 Jan 2026 21:23:12 +0000</pubDate></item><item><title>Scaling PostgreSQL to power 800M ChatGPT users</title><link>https://openai.com/index/scaling-postgresql/</link><description>&lt;doc fingerprint="9558893f469078c2"&gt;
  &lt;main&gt;&lt;head rend="h1"&gt;Scaling PostgreSQL to power 800 million ChatGPT users&lt;/head&gt;&lt;p&gt;By Bohan Zhang, Member of the Technical Staff&lt;/p&gt;&lt;p&gt;For years, PostgreSQL has been one of the most critical, under-the-hood data systems powering core products like ChatGPT and OpenAI’s API. As our user base grows rapidly, the demands on our databases have increased exponentially, too. Over the past year, our PostgreSQL load has grown by more than 10x, and it continues to rise quickly.&lt;/p&gt;&lt;p&gt;Our efforts to advance our production infrastructure to sustain this growth revealed a new insight: PostgreSQL can be scaled to reliably support much larger read-heavy workloads than many previously thought possible. The system (initially created by a team of scientists at University of California, Berkeley) has enabled us to support massive global traffic with a single primary Azure PostgreSQL flexible server instance(opens in a new window) and nearly 50 read replicas spread over multiple regions globally. This is the story of how we’ve scaled PostgreSQL at OpenAI to support millions of queries per second for 800 million users through rigorous optimizations and solid engineering; we’ll also cover key takeaways we learned along the way.&lt;/p&gt;&lt;p&gt;After the launch of ChatGPT, traffic grew at an unprecedented rate. To support it, we rapidly implemented extensive optimizations at both the application and PostgreSQL database layers, scaled up by increasing the instance size, and scaled out by adding more read replicas. This architecture has served us well for a long time. With ongoing improvements, it continues to provide ample runway for future growth.&lt;/p&gt;&lt;p&gt;It may sound surprising that a single-primary architecture can meet the demands of OpenAI’s scale; however, making this work in practice isn’t simple. We’ve seen several SEVs caused by Postgres overload, and they often follow the same pattern: an upstream issue causes a sudden spike in database load, such as widespread cache misses from a caching-layer failure, a surge of expensive multi-way joins saturating CPU, or a write storm from a new feature launch. As resource utilization climbs, query latency rises and requests begin to time out. Retries then further amplify the load, triggering a vicious cycle with the potential to degrade the entire ChatGPT and API services.&lt;/p&gt;&lt;p&gt;Although PostgreSQL scales well for our read-heavy workloads, we still encounter challenges during periods of high write traffic. This is largely due to PostgreSQL’s multiversion concurrency control (MVCC) implementation, which makes it less efficient for write-heavy workloads. For example, when a query updates a tuple or even a single field, the entire row is copied to create a new version. Under heavy write loads, this results in significant write amplification. It also increases read amplification, since queries must scan through multiple tuple versions (dead tuples) to retrieve the latest one. MVCC introduces additional challenges such as table and index bloat, increased index maintenance overhead, and complex autovacuum tuning. (You can find a deep-dive on these issues in a blog I wrote with Prof. Andy Pavlo at Carnegie Mellon University called The Part of PostgreSQL We Hate the Most(opens in a new window), cited(opens in a new window) in the PostgreSQL Wikipedia page.)&lt;/p&gt;&lt;p&gt;To mitigate these limitations and reduce write pressure, we’ve migrated, and continue to migrate, shardable (i.e. workloads that can be horizontally partitioned), write-heavy workloads to sharded systems such as Azure Cosmos DB, optimizing application logic to minimize unnecessary writes. We also no longer allow adding new tables to the current PostgreSQL deployment. New workloads default to the sharded systems.&lt;/p&gt;&lt;p&gt;Even as our infrastructure has evolved, PostgreSQL has remained unsharded, with a single primary instance serving all writes. The primary rationale is that sharding existing application workloads would be highly complex and time-consuming, requiring changes to hundreds of application endpoints and potentially taking months or even years. Since our workloads are primarily read-heavy, and we’ve implemented extensive optimizations, the current architecture still provides ample headroom to support continued traffic growth. While we’re not ruling out sharding PostgreSQL in the future, it’s not a near-term priority given the sufficient runway we have for current and future growth.&lt;/p&gt;&lt;p&gt;In the following sections, we’ll dive into the challenges we faced and the extensive optimizations we implemented to address them and prevent future outages, pushing PostgreSQL to its limits and scaling it to millions of queries per second (QPS).&lt;/p&gt;&lt;p&gt;Challenge: With only one writer, a single-primary setup can’t scale writes. Heavy write spikes can quickly overload the primary and impact services like ChatGPT and our API.&lt;/p&gt;&lt;p&gt;Solution: We minimize load on the primary as much as possible—both reads and writes—to ensure it has sufficient capacity to handle write spikes. Read traffic is offloaded to replicas wherever possible. However, some read queries must remain on the primary because they’re part of write transactions. For those, we focus on ensuring they’re efficient and avoid slow queries. For write traffic, we’ve migrated shardable, write-heavy workloads to sharded systems such as Azure CosmosDB. Workloads that are harder to shard but still generate high write volume take longer to migrate, and that process is still ongoing. We also aggressively optimized our applications to reduce write load; for example, we’ve fixed application bugs that caused redundant writes and introduced lazy writes, where appropriate, to smooth traffic spikes. In addition, when backfilling table fields, we enforce strict rate limits to prevent excessive write pressure.&lt;/p&gt;&lt;p&gt;Challenge: We identified several expensive queries in PostgreSQL. In the past, sudden volume spikes in these queries would consume large amounts of CPU, slowing both ChatGPT and API requests.&lt;/p&gt;&lt;p&gt;Solution: A few expensive queries, such as those joining many tables together, can significantly degrade or even bring down the entire service. We need to continuously optimize PostgreSQL queries to ensure they’re efficient and avoid common Online Transaction Processing (OLTP) anti-patterns. For example, we once identified an extremely costly query that joined 12 tables, where spikes in this query were responsible for past high-severity SEVs. We should avoid complex multi-table joins whenever possible. If joins are necessary, we learned to consider breaking down the query and move complex join logic to the application layer instead. Many of these problematic queries are generated by Object-Relational Mapping frameworks (ORMs), so it’s important to carefully review the SQL they produce and ensure it behaves as expected. It’s also common to find long-running idle queries in PostgreSQL. Configuring timeouts like idle_in_transaction_session_timeout is essential to prevent them from blocking autovacuum.&lt;/p&gt;&lt;p&gt;Challenge: If a read replica goes down, traffic can still be routed to other replicas. However, relying on a single writer means having a single point of failure—if it goes down, the entire service is affected.&lt;/p&gt;&lt;p&gt;Solution: Most critical requests only involve read queries. To mitigate the single point of failure in the primary, we offloaded those reads from the writer to replicas, ensuring those requests can continue serving even if the primary goes down. While write operations would still fail, the impact is reduced; it’s no longer a SEV0 since reads remain available.&lt;/p&gt;&lt;p&gt;To mitigate primary failures, we run the primary in High-Availability (HA) mode with a hot standby, a continuously synchronized replica that is always ready to take over serving traffic. If the primary goes down or needs to be taken offline for maintenance, we can quickly promote the standby to minimize downtime. The Azure PostgreSQL team has done significant work to ensure these failovers remain safe and reliable even under very high load. To handle read replica failures, we deploy multiple replicas in each region with sufficient capacity headroom, ensuring that a single replica failure doesn’t lead to a regional outage.&lt;/p&gt;&lt;p&gt;Challenge: We often encounter situations where certain requests consume a disproportionate amount of resources on PostgreSQL instances. This can lead to degraded performance for other workloads running on the same instances. For example, a new feature launch can introduce inefficient queries that heavily consume PostgreSQL CPU, slowing down requests for other critical features.&lt;/p&gt;&lt;p&gt;Solution: To mitigate the “noisy neighbor” problem, we isolate workloads onto dedicated instances to ensure that sudden spikes in resource-intensive requests don’t impact other traffic. Specifically, we split requests into low-priority and high-priority tiers and route them to separate instances. This way, even if a low-priority workload becomes resource-intensive, it won’t degrade the performance of high-priority requests. We apply the same strategy across different products and services as well, so that activity from one product does not affect the performance or reliability of another.&lt;/p&gt;&lt;p&gt;Challenge: Each instance has a maximum connection limit (5,000 in Azure PostgreSQL). It’s easy to run out of connections or accumulate too many idle ones. We’ve previously had incidents caused by connection storms that exhausted all available connections.&lt;/p&gt;&lt;p&gt;Solution: We deployed PgBouncer as a proxy layer to pool database connections. Running it in statement or transaction pooling mode allows us to efficiently reuse connections, greatly reducing the number of active client connections. This also cuts connection setup latency: in our benchmarks, the average connection time dropped from 50 milliseconds (ms) to 5 ms. Inter-region connections and requests can be expensive, so we co-locate the proxy, clients, and replicas in the same region to minimize network overhead and connection use time. Moreover, PgBouncer must be configured carefully. Settings like idle timeouts are critical to prevent connection exhaustion.&lt;/p&gt;&lt;p&gt;Challenge: A sudden spike in cache misses can trigger a surge of reads on the PostgreSQL database, saturating CPU and slowing user requests.&lt;/p&gt;&lt;p&gt;Solution: To reduce read pressure on PostgreSQL, we use a caching layer to serve most of the read traffic. However, when cache hit rates drop unexpectedly, the burst of cache misses can push a large volume of requests directly to PostgreSQL. This sudden increase in database reads consumes significant resources, slowing down the service. To prevent overload during cache-miss storms, we implement a cache locking (and leasing) mechanism so that only a single reader that misses on a particular key fetches the data from PostgreSQL. When multiple requests miss on the same cache key, only one request acquires the lock and proceeds to retrieve the data and repopulate the cache. All other requests wait for the cache to be updated rather than all hitting PostgreSQL at once. This significantly reduces redundant database reads and protects the system from cascading load spikes.&lt;/p&gt;&lt;p&gt;Challenge: The primary streams Write Ahead Log (WAL) data to every read replica. As the number of replicas increases, the primary must ship WAL to more instances, increasing pressure on both network bandwidth and CPU. This causes higher and more unstable replica lag, which makes the system harder to scale reliably.&lt;/p&gt;&lt;p&gt;Solution: We operate nearly 50 read replicas across multiple geographic regions to minimize latency. However, with the current architecture, the primary must stream WAL to every replica. Although it currently scales well with very large instance types and high-network bandwidth, we can’t keep adding replicas indefinitely without eventually overloading the primary. To address this, we’re collaborating with the Azure PostgreSQL team on cascading replication(opens in a new window), where intermediate replicas relay WAL to downstream replicas. This approach allows us to scale to potentially over a hundred replicas without overwhelming the primary. However, it also introduces additional operational complexity, particularly around failover management. The feature is still in testing; we’ll ensure it’s robust and can fail over safely before rolling it out to production.&lt;/p&gt;&lt;p&gt;Challenge: A sudden traffic spike on specific endpoints, a surge of expensive queries, or a retry storm can quickly exhaust critical resources such as CPU, I/O, and connections, which causes widespread service degradation.&lt;/p&gt;&lt;p&gt;Solution: We implemented rate-limiting across multiple layers—application, connection pooler, proxy, and query—to prevent sudden traffic spikes from overwhelming database instances and triggering cascading failures. It’s also crucial to avoid overly short retry intervals, which can trigger retry storms. We also enhanced the ORM layer to support rate limiting and when necessary, fully block specific query digests. This targeted form of load shedding enables rapid recovery from sudden surges of expensive queries.&lt;/p&gt;&lt;p&gt;Challenge: Even a small schema change, such as altering a column type, can trigger a full table rewrite(opens in a new window). We therefore apply schema changes cautiously—limiting them to lightweight operations and avoiding any that rewrite entire tables.&lt;/p&gt;&lt;p&gt;Solution: Only lightweight schema changes are permitted, such as adding or removing certain columns that do not trigger a full table rewrite. We enforce a strict 5-second timeout on schema changes. Creating and dropping indexes concurrently is allowed. Schema changes are restricted to existing tables. If a new feature requires additional tables, they must be in alternative sharded systems such as Azure CosmosDB rather than PostgreSQL. When backfilling a table field, we apply strict rate limits to prevent write spikes. Although this process can sometimes take over a week, it ensures stability and avoids any production impact.&lt;/p&gt;&lt;p&gt;This effort demonstrates that with the right design and optimizations, Azure PostgreSQL can be scaled to handle the largest production workloads. PostgreSQL handles millions of QPS for read-heavy workloads, powering OpenAI’s most critical products like ChatGPT and the API platform. We added nearly 50 read replicas, while keeping replication lag near zero, maintained low-latency reads across geo-distributed regions, and built sufficient capacity headroom to support future growth.&lt;/p&gt;&lt;p&gt;This scaling works while still minimizing latency and improving reliability. We consistently deliver low double-digit millisecond p99 client-side latency and five-nines availability in production. And over the past 12 months, we’ve had only one SEV-0 PostgreSQL incident (it occurred during the viral launch(opens in a new window) of ChatGPT ImageGen, when write traffic suddenly surged by more than 10x as over 100 million new users signed up within a week.)&lt;/p&gt;&lt;p&gt;While we’re happy with how far PostgreSQL has taken us, we continue to push its limits to ensure we have sufficient runway for future growth. We’ve already migrated the shardable write-heavy workloads to our sharded systems like CosmosDB. The remaining write-heavy workloads are more challenging to shard—we’re actively migrating those as well to further offload writes from the PostgreSQL primary. We’re also working with Azure to enable cascading replication so we can safely scale to significantly more read replicas.&lt;/p&gt;&lt;p&gt;Looking ahead, we’ll continue to explore additional approaches to further scale, including sharded PostgreSQL or alternative distributed systems, as our infrastructure demands continue to grow.&lt;/p&gt;&lt;head rend="h2"&gt;Author&lt;/head&gt;Bohan Zhang&lt;head rend="h2"&gt;Acknowledgements&lt;/head&gt;&lt;p&gt;Special thanks to Jon Lee, Sicheng Liu, Chaomin Yu, and Chenglong Hao, who contributed to this post, and to the entire team that helped scale PostgreSQL. We’d also like to thank the Azure PostgreSQL team for their strong partnership.&lt;/p&gt;&lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=46725300</guid><pubDate>Thu, 22 Jan 2026 21:24:23 +0000</pubDate></item><item><title>Anthropic Economic Index economic primitives</title><link>https://www.anthropic.com/research/anthropic-economic-index-january-2026-report</link><description>&lt;doc fingerprint="3e0084fd2d338e6f"&gt;
  &lt;main&gt;
    &lt;head rend="h2"&gt;Introduction&lt;/head&gt;
    &lt;head rend="h3"&gt;How is AI reshaping the economy?&lt;/head&gt;
    &lt;p&gt;This report introduces new metrics of AI usage to provide a rich portrait of interactions with Claude in November 2025, just prior to the release of Opus 4.5. These “primitives”—simple, foundational measures of how Claude is used, which we generate by asking Claude specific questions about anonymized Claude.ai and first-party (1P) API transcripts—cover five dimensions relevant to AI’s economic impact: user and AI skills, how complex tasks are, the degree of autonomy afforded to Claude, how successful Claude is, and whether Claude is used for personal, educational, or work purposes.&lt;/p&gt;
    &lt;p&gt;The results reveal striking geographic variation, real-world estimates of AI task horizons, and a basis for revised assessments of Claude's macroeconomic impact.&lt;/p&gt;
    &lt;p&gt;The data we release alongside this report are the most comprehensive to date, covering five new dimensions of AI use, consumer and firm use, and country and region breakdowns for Claude.ai.&lt;/p&gt;
    &lt;head rend="h3"&gt;What has changed since our last report&lt;/head&gt;
    &lt;p&gt;In the first chapter, we revisit findings from our previous Economic Index report published in September 2025. We find:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Claude usage remains concentrated among certain tasks, most of them related to coding &lt;lb/&gt;While we see over 3,000 unique work tasks in Claude.ai, the top 10 most common tasks account for 24% of our sampled conversations, a slight increase since our last report. Augmentation patterns (conversations where the user learns, iterates on a task, or gets feedback from Claude) edged to just over half of conversations on Claude.ai. In contrast, automated use remains dominant in 1P API traffic, reflecting its programmatic nature.&lt;/item&gt;
      &lt;item&gt;Global usage remains persistently uneven while US states converge&lt;lb/&gt;The US, India, Japan, the UK, and South Korea lead in overall Claude.ai use. Worldwide, uneven adoption remains well-explained by GDP per capita. Within the US, workforce composition plays a key role in shaping uneven adoption as states with more computer and mathematical professionals show systematically more Claude usage.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;While substantial concentration remains, since our last report Claude usage has become noticeably more evenly distributed across US states. If sustained, usage per capita would be equalized across the country in 2-5 years.&lt;/p&gt;
    &lt;head rend="h3"&gt;Introducing and analyzing our new economic primitives&lt;/head&gt;
    &lt;p&gt;In the second chapter we discuss the motivation for and introduce our new economic primitives, including how they were selected and operationalized, and their limitations. We additionally present evidence that our primitives capture directionally accurate aspects of underlying usage patterns as compared to external benchmarks. In chapters three and four we use these primitives to further investigate implications for adoption and productivity. We find:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Claude use diversifies with higher adoption and income&lt;lb/&gt;While the most common use of Claude is for work, coursework use is highest in countries with the lowest GDP per capita, while rich countries show the highest rates of personal use. This aligns with a simple adoption curve story: early adopters in less developed countries tend to be technical users with specific, high-value applications or use Claude for education, whereas mature markets see usage diversify toward casual and personal purposes.&lt;/item&gt;
      &lt;item&gt;Claude succeeds on most tasks, but less so on the most complex ones&lt;lb/&gt;We find that Claude generally succeeds at the tasks it is given, and that the education level of its responses tends to match the user's input. Claude struggles on more complex tasks: As the time it would take a human to do the task increases, Claude’s success rate falls, much like prominent evals measuring the longest tasks that AIs can reliably perform.&lt;/item&gt;
      &lt;item&gt;Job exposure to AI looks different when success rates are factored in&lt;lb/&gt;We also use the success rate primitive to better understand job exposure to AI, calculating the share of each occupation that Claude can perform by weighting task coverage by both success rates and the importance of each task within the job. For some occupations, like data entry keyers and database architects, Claude shows proficiency in large swaths of the job.&lt;/item&gt;
      &lt;item&gt;Claude is used for higher-skill tasks than those in the broader economy&lt;lb/&gt;The tasks we observe in Claude usage tend to require more education than those in the broader economy. If we assume that AI-assisted tasks diminish as a share of worker responsibilities, removing them would leave behind less-skilled work. But this simple task displacement would not affect white-collar workers uniformly—for some occupations it removes the most skill-intensive tasks, for others the least.&lt;lb/&gt;Without the tasks that we observe Claude performing, travel agents would experience deskilling as complex planning work gives way to routine ticket purchasing and payment collection. Property managers, by contrast, would experience upskilling as bookkeeping tasks give way to contract negotiations and stakeholder management.&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h3"&gt;A new window for understanding AI’s impact on the economy&lt;/head&gt;
    &lt;p&gt;These results provide a new window into how AI is currently impacting the economy. Knowing the success rate of tasks gives a more accurate picture of which tasks might be automated, how impacted certain jobs might be, and how labor productivity will change. Measuring differential performance by user education sheds light on inequality effects.&lt;/p&gt;
    &lt;p&gt;Indeed, the close relationship between education levels in inputs and outputs signals that countries with higher educational attainment may be better positioned to benefit from AI, independent of adoption rates alone.&lt;/p&gt;
    &lt;p&gt;This data release aims to enable researchers and the public to better understand the economic implications of AI and investigate the ways in which this transformative technology is already having an effect.&lt;/p&gt;
    &lt;head rend="h2"&gt;Chapter 1: What has changed since our last report&lt;/head&gt;
    &lt;head rend="h3"&gt;Overview&lt;/head&gt;
    &lt;p&gt;Because frontier AI model capabilities are improving rapidly and adoption has been swift, it is important to regularly take stock of changes in how people and businesses are using such systems—and what this usage implies for the broader economy.1&lt;/p&gt;
    &lt;p&gt;In this chapter we analyze how Claude usage and diffusion patterns changed from August 2025 to November 2025 just prior to the release of Opus 4.5. We make four observations:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Usage remains highly concentrated across tasks:&lt;lb/&gt;The ten most common tasks represent 24% of observed usage on Claude.ai, up from 23% in our last report. For first-party (1P) API enterprise customers, concentration among tasks increased more notably: the top ten tasks now represent 32% of traffic, up from 28% in the last report.&lt;/item&gt;
      &lt;item&gt;Augmentation is once again more common than automation on Claude.ai:&lt;lb/&gt;In our previous report we noted that automated use had risen to exceed augmented use on Claude.ai, perhaps capturing both improving capabilities and greater familiarity among users with LLMs. Data from November 2025 points to a broad-based shift back toward augmented use on Claude.ai: The share of conversations classified as augmented jumped 5pp to 52% and the share deemed automated fell 4pp to 45%.2 Product changes during this period—including file creation capabilities, persistent memory, and Skills for workflow customization—may have shifted usage patterns toward more collaborative, human-in-the-loop interactions.&lt;/item&gt;
      &lt;item&gt;Within the US, lower usage states have relatively faster gains in adoption&lt;lb/&gt;Within the US, usage per capita remains largely shaped by how well-matched the workforce is to broader Claude usage: For example, states with a larger share of workers in computer and mathematical occupations tend to have higher usage. Indeed, the top five US states account for nearly half (50%) of all usage despite representing only 38% of the working-age population.&lt;lb/&gt;Nevertheless, there are early signs of rapid regional convergence in adoption: usage has increased relatively faster for states that had lower usage in our last report. If sustained, usage per capita would be equalized across the country in 2-5 years, a pace of diffusion roughly 10x faster than the spread of previous economically consequential technologies in the 20th century.3&lt;lb/&gt;While this is consistent with rapid AI adoption and diffusion, this estimate comes with uncertainty given that it is based on a change observed over a three month period. Diffusion may ultimately proceed more slowly in the months and years to come.&lt;/item&gt;
      &lt;item&gt;Global usage shows little sign of increasing or decreasing regional convergence&lt;lb/&gt;Globally, Claude usage per capita—as captured by the Anthropic AI Usage Index (AUI)—remains highly uneven and strongly correlated with GDP. These gaps are stable: we see no evidence that low-use countries are catching up or that high-use countries are pulling away.&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h3"&gt;Shifting patterns of usage across tasks and associated occupations&lt;/head&gt;
    &lt;p&gt;Even though frontier LLMs have an impressive range of capabilities relevant to every facet of the modern economy, Claude usage remains very concentrated among a small number of tasks. As compared to nearly one year ago, consumer usage on Claude.ai is modestly more concentrated: The share of conversations assigned to the ten most prevalent O*NET tasks was 24% in November 2025, 1pp higher than in August and up from 21% in January 2025. The most prevalent task in November 2025—modifying software to correct errors—alone represented 6% of usage.&lt;/p&gt;
    &lt;p&gt;In our last Anthropic Economic Index Report we began tracking business adoption patterns by studying Claude usage among 1P API customers. The ten most common tasks grew from 28% of API records in August to 32% in November. Rising concentration among a small set of tasks suggests the highest-value applications continue to generate outsized economic value even as models have become more capable at a wider range of tasks. As with Claude.ai the most common task among API customers was modifying software to correct errors, which accounted for one in ten records.&lt;/p&gt;
    &lt;p&gt;Indeed, computer and mathematical tasks—like modifying software to correct errors—continue to dominate Claude usage overall, representing a third of conversations on Claude.ai and nearly half of 1P API traffic. Such dominance has subsided on Claude.ai: the share of conversations on Claude.ai assigned to such (mostly) coding-related tasks is down from a peak of 40% in March 2025 to 34% in November 2025. At the same time, the share of transcripts assigned to computer and mathematical tasks among 1P API traffic edged higher from 44% in August to 46% in November 2025 (Figure 1.2).&lt;/p&gt;
    &lt;p&gt;The second largest share of Claude.ai usage in November 2025 was in the Educational Instruction and Library category. This corresponds mostly to help with coursework and review, and the development of instructional materials. Such usage has risen steadily since our first report, up from 9% of conversations on Claude.ai in January 2025 to 15% in November.&lt;/p&gt;
    &lt;p&gt;&lt;lb/&gt;The share of usage on Claude.ai for Arts, Design, Entertainment, Sports, and Media tasks increased between August and November 2025 as Claude was used in a growing share of conversations for writing tasks, primarily copyediting and the writing and refinement of fictional pieces. This jump in the prevalence of design- and writing-related tasks reversed a steady decline across earlier reports. For both Claude.ai and API customers, there was a drop in the share of conversations/transcripts where Claude was used for Life, Physical, and Social Science-related tasks.&lt;/p&gt;
    &lt;p&gt;Perhaps the most notable development for API customers was the increase in the share of transcripts associated with Office and Administrative Support related tasks, which rose 3pp in August to 13% in November 2025. Because API use is automation-dominant, this suggests that businesses are increasingly using Claude to automate routine back-office workflows such as email management, document processing, customer relationship management, and scheduling.4&lt;/p&gt;
    &lt;head rend="h3"&gt;Augmentation is again dominant on Claude.ai&lt;/head&gt;
    &lt;p&gt;How AI will affect the economy depends not just on the tasks Claude is used for but the way that users access and engage underlying model capabilities. Since our first report, we have classified conversations into one of five interaction types, which we group into two broader categories: automation and augmentation.5&lt;/p&gt;
    &lt;p&gt;Figure 1.3 plots how automated versus augmented use has evolved over time since we first started collecting this data one year ago. In January 2025, augmented use of Claude was dominant: 56% of conversations were classified as augmentation compared to 41% automated.6 In August 2025, more conversations were classified as automated as compared to augmented.&lt;/p&gt;
    &lt;p&gt;This was a notable development since it suggested that rapid improvements in model capabilities and platform functionality coincided with users increasingly delegating tasks entirely to Claude. This was evident in the “directive” collaboration mode, which is further grouped as automation. Directive conversations are those in which users give Claude a task and it completes it with minimal back-and-forth. From January 2025 to August 2025 the share of such directive conversations rose from 27% to 39%.7&lt;/p&gt;
    &lt;p&gt;Three months later, the share of directive conversations had fallen 7pp to 32% in November 2025 as augmentation once again became more prevalent on Claude.ai than automation. Nevertheless, the automation share was still elevated as compared to nearly one year ago when we first began tracking this measure, suggesting that the underlying trend is still toward greater automation even as the August spike overstated how quickly it was materializing.&lt;/p&gt;
    &lt;p&gt;While we see some evidence of a shift toward soft skill usage on Claude.ai with design, management, and education now higher, the shift back toward augmented use was broad-based in November (Figure 1.4). The rise in augmented use was driven mainly by users iterating with Claude to complete tasks (“task iteration”) rather than asking Claude to explain concepts (“learning”). See Figure 1.5 for common words associated with the three most common interaction modes across O*NET tasks and bottom-up descriptions of requests made of Claude.&lt;/p&gt;
    &lt;head rend="h3"&gt;Persistent regional concentration&lt;/head&gt;
    &lt;p&gt;In our previous report, we introduced the Anthropic AI Usage Index (AUI), a measure of whether Claude is over- or underrepresented in a given geography relative to the size of its working-age population. The AUI is defined as&lt;/p&gt;
    &lt;p&gt;An AUI above 1 indicates that a country uses Claude more intensively than its population alone would predict, while an AUI below 1 indicates lower-than-expected usage. For example, Denmark has an AUI of 2.1, meaning its residents use Claude at roughly twice the rate its share of the global working-age population would suggest.&lt;/p&gt;
    &lt;p&gt;A key fact about Claude usage globally is that it is geographically concentrated: a small number of countries comprise an outsized share of use. From a global perspective, little changed in this respect between August and November 2025. Indeed, the left panel of Figure 1.6 shows that the AUI concentration across countries was essentially unchanged between our last report and this report.&lt;/p&gt;
    &lt;p&gt;By contrast, usage became more evenly distributed across US states from August to November 2025: the Gini coefficient, a standard measure of equality, fell from 0.37 to 0.32. While it is important to exercise caution in interpreting short-run changes, this is a relatively large change toward perfect equality in which the AUI is equal to 1 for all states with a Gini coefficient of 0. If the Gini coefficient for the US again falls by 0.05 every three months, then parity of usage would be reached in roughly two years.&lt;/p&gt;
    &lt;p&gt;What shapes patterns of usage within the US and around the world? In our previous report we emphasized the key role played by income differences globally: Variation in Claude usage across countries is largely accounted for by variation in GDP per capita. In Chapter 3 we revisit the importance of income in shaping not just usage intensity but also patterns of usage around the world.&lt;/p&gt;
    &lt;p&gt;Within the US, income is less clearly a predictor of usage. Instead, what appears to matter most is the composition of each state’s workforce and how well-matched the workforce is to Claude capabilities as reflected in task-level usage. States that have a higher share of workers in computer and mathematical occupations—like Washington D.C., Virginia, and Washington—tend to have higher usage per capita. Quantitatively, each 1% increase in the share of such tech workers in a state is associated with 0.36% higher usage per capita (Figure 1.7). This alone accounts for nearly two-thirds of the cross-state variation in AUI.&lt;/p&gt;
    &lt;p&gt;While we would intuitively expect Claude usage to be higher in states with more tech workers, this pattern holds more generally: Usage per capita is higher in states with more workers in occupations where Claude usage is overrepresented as compared to the US workforce (e.g., Arts, Design, Entertainment, Sports and Media) or with relatively fewer workers in occupations where Claude usage is low as compared to the national economy (e.g., Transportation and Material Moving). This can be seen by calculating the Kullback–Leibler (KL) divergence between the composition of each state’s workforce and the global composition of Claude usage. States with a lower KL divergence—and thus with a workforce that looks more similar to Claude usage patterns—tend to have higher usage per capita.&lt;/p&gt;
    &lt;head rend="h3"&gt;Signs of faster Claude diffusion in the US among low usage states&lt;/head&gt;
    &lt;p&gt;While differences in workforce composition appear to play a role in shaping regional adoption within the US, early evidence suggests Claude is diffusing considerably faster than historical precedent would predict. Economically consequential technologies have historically taken around half a century to achieve full diffusion across the US (Kalanyi et al., 2025). By contrast, comparing Claude adoption rates in November 2025 to three months prior, we estimate that parity in adoption per capita across US states—as measured by the AUI—could be reached within 2–5 years. This estimate comes with a high degree of uncertainty as the precision of our estimates cannot rule out much slower rates of diffusion.&lt;/p&gt;
    &lt;p&gt;We generate this estimate through the lens of a simple model of diffusion, which we briefly describe here. We model diffusion as proportional convergence toward a common steady state of equalized usage per capita in which each state s has an AUI equal to 1:&lt;/p&gt;
    &lt;p&gt;Under this model, the log deviation of AUI from steady state (AUI = 1) shrinks by a factor of β every three months, implying a half-life of ln(.5)/ln(β) quarters. For example, with quarterly data a value of β = 0.99 implies a half-life of about 17 years. To illustrate, starting from an initial AUI of 2, this means AUI would decline to around 1.4 after 17 years and to around 1.1 after 50 years. We take β = 0.99 as a sensible benchmark because it implies a pace of diffusion similar to economically consequential technologies in the 20th century.&lt;/p&gt;
    &lt;p&gt;This model of convergence motivates the following regression specification8:&lt;/p&gt;
    &lt;p&gt;Naively estimating this equation by ordinary least squares (OLS) yields an estimate of β̂ ≈ 0.77. Weighted least squares (WLS) where we weight by each state’s workforce yields an estimate of β̂ ≈ 0.76 (Figure 1.8). Both are statistically distinguishable from 1 at conventional levels. Taken at face value, these estimates imply that it would take little more than two years for each state's AUI to close most of the gap to 1.&lt;/p&gt;
    &lt;p&gt;A concern with estimating convergence this way is that our AUI estimates are subject to sampling noise and other variation unrelated to diffusion. This can produce classical attenuation bias: even if AUI is not actually changing, our estimate of β could end up meaningfully below one.&lt;/p&gt;
    &lt;p&gt;To address this, we estimate the model by two-stage least squares (2SLS), instrumenting the log of AUI in August 2025 with the composition of each state's workforce, measured by its proximity to overall Claude usage patterns. The logic behind this instrument is that workforce composition is a strong predictor of Claude usage (relevance) but being measured independently, is expected to be uncorrelated with sampling noise in our AUI estimates (validity). As noted above, states with more workers in high-Claude-usage roles do tend to have systematically higher usage per capita.&lt;/p&gt;
    &lt;p&gt;The 2SLS estimates imply modestly slower convergence: β̂ ≈ 0.89 unweighted and β̂ ≈ 0.86 when weighting by each state’s working-age population. However, these estimates are less precise, and only the former is statistically distinguishable from 1 at the 10% level. Despite implying a slower convergence than OLS, the 2SLS estimates still imply rapid diffusion: just four to five years for the log deviation of each state's AUI to shrink by 90%.&lt;/p&gt;
    &lt;p&gt;&lt;lb/&gt;That said, our estimates are based on just three months of data. And while the 2SLS specification may help address sampling noise, considerable uncertainty remains. We will revisit this question of the pace of diffusion in future reports.&lt;/p&gt;
    &lt;p&gt;1 As with previous reports, all our analysis is based on privacy-preserving analysis. Throughout the report we analyze a random sample of 1M conversations from Claude.ai Free, Pro and Max conversations (we also refer to this as “consumer data” since it mostly represents consumer use) and 1M transcripts from our first-party (1P) API traffic (we also refer to this as “enterprise data” since it mostly represents enterprise use). Both samples come from November 13, 2025 to November 20, 2025. We continue to manage data according to our privacy and retention policies, and our analysis is consistent with our terms, policies, and contractual agreements. For 1P API data, each record is a prompt-response pair from our sample period which in some instances is mid-session for multi-turn interactions.&lt;/p&gt;
    &lt;p&gt;2 The share of conversations on Claude.ai that were classified into neither automation nor augmentation categories fell from 3.9% to 3.0%.&lt;/p&gt;
    &lt;p&gt;3 See, for example, Kalanyi et al (2025): “Second, as the technologies mature and the number of related jobs grows, hiring spreads geographically. This process is very slow, taking around 50 years to disperse fully.”&lt;/p&gt;
    &lt;p&gt;4 With our bottom-up analysis of 1P API traffic we see Claude used to "Generate personalized B2B cold sales emails" (0.47%), "Analyze emails and draft replies for business correspondence" (0.28%), "Build and maintain invoice processing systems" (0.24%), "Classify and categorize emails into predefined labels" (0.23%), and "Manage calendar scheduling, meeting coordination, and appointment booking" (0.16%).&lt;/p&gt;
    &lt;p&gt;5 At a high level, we distinguish between automation and augmentation modes of using Claude. Automation encompasses interaction patterns focused on task completion: Directive: Users give Claude a task and it completes it with minimal back-and-forth; Feedback Loops: Users automate tasks and provide feedback to Claude as needed; Augmentation focuses on collaborative interaction patterns: Learning: Users ask Claude for information or explanations about various topics; Task Iteration: Users iterate on tasks collaboratively with Claude; Validation: Users ask Claude for feedback on their work.&lt;/p&gt;
    &lt;p&gt;6 These interaction modes are not mutually exhaustive. In some instances, Claude determines that a sampled conversation does not match any of the five interaction modes.&lt;/p&gt;
    &lt;p&gt;7 In this report we use Sonnet 4.5 for classification whereas in our previous Economic Index report we used Sonnet 4. We previously found that different models can generate different classification outcomes, though these effects tend to be modest.&lt;/p&gt;
    &lt;p&gt;8 We include a constant term in the regression since it should be equal to zero under the null hypothesis. Across all our specifications, the constant term is estimated to be close to and statistically indistinguishable from zero.&lt;/p&gt;
    &lt;head rend="h2"&gt;Chapter 2: Introducing economic primitives&lt;/head&gt;
    &lt;p&gt;The strength of the Anthropic Economic Index lies in showing not only how much AI is used, but how it is used. In prior reports, we showed which tasks Claude is used for, and how people collaborate with Claude. These data have enabled external researchers to analyze labor market shifts (e.g., Brynjolfsson, Chandar &amp;amp; Chen, 2025).&lt;/p&gt;
    &lt;p&gt;In this edition of the Anthropic Economic Index, we expand the breadth of data available to external researchers by providing insights on five economic “primitives”, by which we mean simple, foundational measures of the ways that Claude is used, which we generate by asking Claude to answer specific questions about the anonymized transcripts in our sample. Some of our primitives encompass several such questions, and others use a single indicator.&lt;/p&gt;
    &lt;p&gt;Because AI capabilities are advancing so rapidly and the economic effects will be unevenly experienced, we need a breadth of signals to uncover not just how Claude is used but also to inform what impact this technology will have.&lt;/p&gt;
    &lt;head rend="h3"&gt;Dimensions of AI use that matter for economic impacts&lt;/head&gt;
    &lt;p&gt;This report introduces five new economic primitives beyond the one we already measure, collaboration patterns (whether users automate or augment their tasks with Claude). These primitives capture five dimensions of a human-AI conversation: 1) task complexity, 2) human and AI skills, 3) work, coursework or personal use case, 4) the AI’s level of autonomy, and 5) task success (see Table 2.1). AI autonomy captures something different from our existing automation/augmentation distinction. For example, “Translate this paragraph into French” is high automation (directive, minimal back-and-forth) but low AI autonomy (the task requires little decision-making from Claude).&lt;/p&gt;
    &lt;p&gt;Task complexity captures that tasks can vary in their complexity, including how long they take to complete and how difficult they are. A "debugging" task in O*NET could refer to Claude fixing a small error in a function or comprehensively refactoring a codebase—with very different implications for labor demand. We measure complexity through estimated human time to complete tasks without AI, time spent completing tasks with AI, and whether users handle multiple tasks within a single conversation.&lt;/p&gt;
    &lt;p&gt;Human and AI skills address how automation interacts with skill levels. If AI disproportionately substitutes for tasks requiring less expertise while complementing higher-skilled work, it could be another form of skill-biased technical change—increasing demand for highly skilled workers while displacing lower skilled workers. We measure whether users could have completed tasks without Claude, and the years of education needed to understand both user prompts and Claude's responses.&lt;/p&gt;
    &lt;p&gt;Use case distinguishes professional, educational, and personal use. Labor market effects most directly follow from workplace use, while educational use may signal where the future workforce is building AI-complementary skills.&lt;/p&gt;
    &lt;p&gt;AI autonomy measures the degree to which users delegate decision-making to Claude. Our latest report documented rising "directive" use where users delegate tasks entirely. Tracking autonomy levels—from active collaboration to full delegation—helps forecast the pace of automation.&lt;/p&gt;
    &lt;p&gt;Task success measures Claude’s assessment of whether Claude completes tasks successfully. Task success helps assess whether tasks can be automated effectively (can a task be automated at all?) and efficiently (how many attempts would it take to automate a task?). That is, task success matters for both the feasibility and the cost of automation labor tasks.&lt;/p&gt;
    &lt;head rend="h3"&gt;Selecting and validating the new measures&lt;/head&gt;
    &lt;p&gt;The new dimensions of AI use captured in our data were informed by our recent work on the productivity effects of Claude, feedback we received from external researchers, recent literature on AI’s economic impact through the lens of human capital and expertise (Vendraminell et al., 2025), and deliberation within our economic research team. Our main selection criteria were expected economic relevance, complementarity of dimensions, and whether Claude could classify conversations along that dimension with directional accuracy.&lt;/p&gt;
    &lt;p&gt;We propose that multiple simple primitives, even if somewhat noisy and not perfectly accurate by themselves, can together provide important signals on how AI is being used. We therefore mainly tested for directional accuracy.&lt;/p&gt;
    &lt;p&gt;For classifying task duration with and without AI, we used minimally modified versions of our prior productivity work. For net new classifiers1, implemented via our privacy-preserving tooling, our validation process was as follows. We designed multiple potential measures to capture concepts such as task complexity. For Claude.ai, we evaluated the classifier performance compared to a human researcher on a small set of transcripts in which users gave feedback to Claude.ai and for which we thus have permission to look at underlying transcripts. For first-party API (1P API) data, we validate the classifiers using a mix of internal and synthetic data. Neither data sources are fully representative of Claude.ai or 1P API traffic, but they allow us to check that the classifiers are working on data that resembles real usage data, while ensuring privacy.&lt;/p&gt;
    &lt;p&gt;Based on initial performance, we revised the classifiers that needed tweaking or discarded classifiers that did not perform well. Interestingly, we find that in some instances (e.g., to measure task success), a simple classifier performed better than a nuanced, complex classifier when compared to human ratings. We then compared performance of classifier versions with vs. without chain of thought prompting, and decided to keep chain of thought prompting only for three facets (human time estimate, human with AI time estimate, and AI autonomy) where we found that it substantially improved performance. We selected a final set of nine new classifiers for the five primitives, all of which are directionally accurate even if they may deviate somewhat from human ratings.&lt;/p&gt;
    &lt;head rend="h3"&gt;The primitives' value is in what they can predict&lt;/head&gt;
    &lt;p&gt;Our goal was to create classifiers that are straightforward to implement and in combination provide potentially important economic signals. While we are very confident in the directional accuracy of the new measures (e.g., tasks with higher average years of education needed to understand the human prompt are likely more complex), none of the measures should be taken as exact or definitive (e.g., Claude.ai may somewhat underestimate the human education years needed for many tasks).&lt;/p&gt;
    &lt;p&gt;Even so, the primitives enrich our understanding of how people use AI. Systematic relationships emerge across primitives, regions, and tasks—patterns we explore in depth in Chapters 3 and 4. That these relationships are intuitive and consistent suggests the primitives capture relevant aspects of how people and businesses use Claude.&lt;/p&gt;
    &lt;p&gt;External benchmarks reinforce this. In our productivity work, Claude’s time estimates correlate with actual time spent on software engineering tasks. Figure 2.1 shows that our human education measure correlates with actual worker education levels across occupations. These validations suggest individual primitives are directionally correct—and combining them may provide additional analytical value, such as enriching productivity estimates with task success rates or constructing new measures of occupational exposure.&lt;/p&gt;
    &lt;p&gt;Ultimately, the strongest validation will come from the primitives’ ability to capture meaningful variation in labor market outcomes. The data we release enable external researchers to analyze economic shifts in new ways. Early work has been encouraging—the automation/augmentation distinction from prior reports has already been used by external researchers to analyze labor market shifts (Brynjolfsson, Chandar &amp;amp; Chen, 2025).&lt;/p&gt;
    &lt;head rend="h3"&gt;Primitives highlight how use cases differ&lt;/head&gt;
    &lt;p&gt;To illustrate how the primitives distinguish between different types of AI use, we examine two contrasting request clusters: software development ("Help debug, develop, and optimize software across multiple programming domains") and personal life management ("Assist with personal life management and everyday tasks"). Figure 2.2 shows the primitive profile for each cluster alongside global averages.&lt;/p&gt;
    &lt;p&gt;Task complexity. Claude estimates that software development requests would take a competent professional approximately 3.3 hours to complete without AI—close to the global average of 3.1 hours. Personal life management tasks are estimated to be simpler, averaging 1.8 hours. Estimated human-AI collaboration time is similar across both (~15 minutes), showing this primitive varies less than other primitives for these two tasks.&lt;/p&gt;
    &lt;p&gt;Human and AI skills. Software development requests draw on more specialized knowledge: both human prompts and AI responses are estimated to require approximately 13.8 years of education to understand, compared to 9.1–9.4 years for personal life management requests. Claude estimates that users would be able to complete personal life management requests by themselves 96% of the time, versus 82% for software development requests—indicating that Claude provides more essential support for technical work.&lt;/p&gt;
    &lt;p&gt;Use case. Claude classifies 64% of software development requests as work-related, compared to just 17% for personal life management. This illustrates that Claude can be used for very different purposes. Overall, Claude.ai use is 46% work, 19% coursework, and 35% personal.&lt;/p&gt;
    &lt;p&gt;AI autonomy. Both clusters show similar estimated autonomy levels (~3.5 on a 1 to 5 scale), near the global average. This means that both software development and personal life management tasks, on average, afford Claude a similar autonomy to make decisions on how to complete the task.&lt;/p&gt;
    &lt;p&gt;Task success. Claude assesses personal tasks as successfully completed 78% of the time, versus 61% for software development. Harder tasks—those requiring more specialized knowledge and where users could not easily complete them alone—show lower estimated success rates.&lt;/p&gt;
    &lt;head rend="h3"&gt;Tasks and primitives differ between Claude.ai and API users&lt;/head&gt;
    &lt;p&gt;As in our previous report, we find major differences in the tasks and primitives in Claude.ai conversations compared to the 1P API data. Part of this reflects the nature of the interaction: Claude.ai transcripts can include multi-turn conversations, while the API data we analyze is limited to single input-output pairs. This is because API requests arrive independently, with no metadata linking them to prior exchanges. This means we can only analyze them as isolated user-assistant pairs rather than full conversation trajectories.&lt;/p&gt;
    &lt;p&gt;Overall, API usage is overwhelmingly work-related (74% vs. 46%) and directive (64% vs. 32%), with three-quarters of interactions classified as automation compared to less than half on Claude.ai (see Figure 1.3).&lt;/p&gt;
    &lt;p&gt;Claude.ai users, by contrast, engage in more back-and-forth: task iteration and learning modes are far more common, and tasks tend to be more lengthy—both in terms of human time with AI (15 minutes vs. 5 minutes) and the estimated time a human would need to complete the task alone (3.1 hours vs. 1.7 hours). Claude.ai also shows higher task success rates (67% vs. 49%), which may reflect the benefits of multi-turn conversation, where users can clarify, correct course, and iterate toward a solution. Claude.ai users also give the AI more autonomy on average, and are more likely to bring tasks they couldn't complete alone.&lt;/p&gt;
    &lt;p&gt;These differences are also reflected in the occupational distribution of tasks. API usage is heavily concentrated in Computer &amp;amp; Mathematical tasks (52% vs. 36%), consistent with its use for programmatic, automation-friendly workflows like code generation and data processing. Office &amp;amp; Administrative tasks are also more prevalent in the API (15% vs. 8%), reflecting routine business operations suited to delegation. Claude.ai, by contrast, sees substantially more Educational Instruction tasks (16% vs. 4%)—coursework help, tutoring, and instructional material development—as well as more Arts, Design, and Entertainment tasks (11% vs. 6%). Claude.ai also has a longer tail of human-facing categories like Community &amp;amp; Social Service and Healthcare Practitioners, where users seek advice, counseling, or information on personal matters.&lt;/p&gt;
    &lt;p&gt;These patterns suggest that 1P API deployments concentrate on tasks amenable to systematic automation, while Claude.ai serves a broader range of use cases including learning, creative work, and personal assistance.&lt;/p&gt;
    &lt;p&gt;Chapter 4 explores task-level variation in greater depth.&lt;/p&gt;
    &lt;p&gt;1 A classifier is a model that assigns a given input (e.g. a user conversation) a specific output (e.g. the use case “work”). In this report, we use Claude as a classifier, meaning that we prompt Claude to select a specific output and then use Claude’s response as the output (see Table 2.1 for the prompts).&lt;/p&gt;
    &lt;p&gt;2 Throughout this report, we use binned scatterplots to show bivariate relationships. We divide observations into 20 equally-sized bins based on the x variable, then plot the average x and y values for each bin. The leftmost dot, for example, represents the averages for observations in the lowest 5% of the x distribution.&lt;/p&gt;
    &lt;head rend="h2"&gt;Chapter 3: How Claude is used varies by geography&lt;/head&gt;
    &lt;head rend="h3"&gt;Overview&lt;/head&gt;
    &lt;p&gt;In this chapter, we analyze geographic variation in Claude usage patterns using a privacy-preserving¹ analysis of 1 million Claude.ai conversations². We make five observations:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Claude is mostly used for work, but use cases diversify with adoption: Work and personal use cases are more common in higher-income countries, while coursework use cases are more common in lower-income countries. This echoes findings from our prior report and aligns with recent work by Microsoft.&lt;/item&gt;
      &lt;item&gt;GDP and human education predict adoption globally and within the US: A 1% increase in GDP per capita is associated with a 0.7% increase in Claude usage per capita at the country level. Human education—Claude's estimate of years of formal education needed to understand the human prompt—correlates positively with the Anthropic AI Usage Index at both levels.&lt;/item&gt;
      &lt;item&gt;Other primitives predict adoption differently at global vs. US levels: At the country level, higher usage correlates with shorter tasks and less AI autonomy. At the US state level, these relationships are not statistically significant, though work use correlates positively with adoption.&lt;/item&gt;
      &lt;item&gt;Relationships between primitives depend on context: Task success is negatively associated with human education across countries, but positively within US states. However, when controlling for other primitives, the US relationship becomes insignificant.&lt;/item&gt;
      &lt;item&gt;How humans prompt is how Claude responds: The education levels of human prompts and AI responses are nearly perfectly correlated (r &amp;gt; 0.92 at both levels). Higher per capita usage countries also show more augmentation—using Claude as a collaborator rather than delegating decisions entirely.&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h3"&gt;Claude is mostly used for work, but use cases diversify with adoption&lt;/head&gt;
    &lt;p&gt;Our data, relying on a privacy-preserving1 analysis of 1 million Claude.ai conversations2, reveals striking geographic differences in how Claude is adopted. Claude is predominantly used for work, across the globe and across the United States. However, there is geographic variation in use cases. At the global level, the Balkans and Brazil have the highest relative share of work use (see Figure 3.1), and Indonesia stands out with the highest share of coursework. At the US state level, New York stands out as the state using Claude relatively the most for work.&lt;/p&gt;
    &lt;p&gt;Use case differences are related to a country’s per capita income, which, in turn, is related to per capita AI adoption. We observe that work use cases and personal use cases of Claude are more common in higher income countries, while coursework use cases are more common in lower income countries (see Figure 3.2). Interestingly, these findings converge with recent work by Microsoft showing that AI use for school is associated with lower per capita income, whereas AI use for leisure is associated with higher per capita income.&lt;/p&gt;
    &lt;p&gt;Multiple factors could contribute to these patterns:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Personal use cases may be more common as AI adoption increases and more diverse users use AI, or existing users explore wider applications of AI. In contrast, countries with lower per capita adoption (which is correlated with lower per capita income) may be focused on specific use cases such as coding or as coursework.&lt;/item&gt;
      &lt;item&gt;Countries differ in their ability to pay for Claude, and coursework use cases may be better suited to free Claude usage than complex use cases in work areas such as software engineering.&lt;/item&gt;
      &lt;item&gt;Users in higher-income countries may have other resources, such as free time and continuous Internet access, that enable non-essential personal use cases.&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h3"&gt;International and US adoption differ across economic primitives&lt;/head&gt;
    &lt;p&gt;The economic primitives introduced in this report allow us to analyze some of the factors that may drive differential adoption. When analyzing the relationship between the Anthropic AI Usage Index (AUI) and core economic primitives as well as GDP, we observe that certain patterns hold for both countries and US states. For example, we replicate the finding from our prior report that GDP is strongly correlated with the AUI (see Figures 3.3 and 3.4). At the country level, a 1% increase in GDP per capita is associated with a 0.7% increase in Claude usage per capita. Human education (how many years of education it takes to understand the human written prompts in a conversation) correlates positively and significantly with the Anthropic AI Usage Index both at the country and at the US state level.&lt;/p&gt;
    &lt;p&gt;However, the relationship between AUI and the primitives often differs between country and US state level. For example, at the country level, the AUI correlates negatively with the time it would take a human to complete a task without AI, and with how much decision-making autonomy AI is given. At the US state level, these relationships are not statistically significant–likely also due to the smaller sample size for US states. Additionally, we observe a positive correlation between the AUI and Claude.ai use for work at the US state, but not at the country level.&lt;/p&gt;
    &lt;p&gt;Importantly, the primitives themselves are not necessarily causal factors—we don't know if income or education are truly driving adoption, or if they're proxies for other underlying conditions. Many of these factors are highly correlated with one another. For example, at the US state level, human education years show a strong association with the Anthropic AI Usage Index in isolation, but this relationship disappears once we control for GDP and other primitives—suggesting education may be capturing variation that's better explained by economic development and other factors.&lt;/p&gt;
    &lt;head rend="h3"&gt;Institutional factors shape the relationship between task success and education years&lt;/head&gt;
    &lt;p&gt;Economic and institutional context—such as how education levels vary within a geography—are related to how AI is being used. Interestingly, we observe that task success is negatively associated with human education at the country level, but positively related at the US state level. However, the positive relationship at the state level becomes insignificant when controlling for other primitives (see Figure 3.5). This means the relationship pattern at one level of observation (country) contradicts the relationship pattern at another level (US state). Cross-country, educated populations may attempt harder tasks and therefore see lower success rates. Within homogeneous contexts, education may not improve task success.&lt;/p&gt;
    &lt;head rend="h3"&gt;How humans prompt is how Claude responds&lt;/head&gt;
    &lt;p&gt;We find a very high correlation between human and AI education, i.e. the number of years of education required to understand a human prompt or the AI’s response (countries: r = 0.925, p &amp;lt; 0.001, N = 117; US states: r = 0.928, p &amp;lt; 0.001, N = 50). This highlights the importance of skills and suggests that how humans prompt the AI determines how effective it can be. This also highlights the importance of model design and training. While Claude is able to respond in a highly sophisticated manner, it tends to do so only when users input sophisticated prompts.&lt;/p&gt;
    &lt;p&gt;How models are trained, fine-tuned and instructed affects how they respond to users. For example, one AI model could have a system prompt that instructs it to always use simple language that a middle school student could understand, whereas another AI model may only respond in complex language that would require a PhD education to understand. For Claude, we observe a more dynamic pattern where how the user prompts Claude relates to how Claude responds.&lt;/p&gt;
    &lt;head rend="h3"&gt;Higher income and higher usage are related to more augmentation&lt;/head&gt;
    &lt;p&gt;Higher per capita usage countries, which tend to be higher per capita income countries, show lower automation, and less decision-making autonomy delegated to Claude. That is, higher income countries use AI more as an assistant and collaborator rather than letting it work independently. This relationship is not significant at the US state level, perhaps because income variation and use case diversity are more limited within the United States than globally. This mirrors a finding from our 3rd Economic Index report where countries with higher Anthropic AI Usage Index tend to use Claude in a more collaborative manner (augmentation), rather than letting it operate independently (automation).&lt;/p&gt;
    &lt;head rend="h3"&gt;Conclusion&lt;/head&gt;
    &lt;p&gt;The striking geographic variation in our data shows that Claude is used in different ways around the world. GDP predicts the Anthropic AI Usage Index at both the country and US state level, and human education—the sophistication of user prompts—correlates with adoption at both levels as well.&lt;/p&gt;
    &lt;p&gt;Other relationships depend on context. At the country level, higher usage correlates with shorter tasks and less AI autonomy; within the US, these patterns do not hold. Task success and human education show opposite relationships globally versus within the US.&lt;/p&gt;
    &lt;p&gt;The near-perfect correlation between human and AI education years underscores that how users prompt Claude shapes how it responds. Combined with the finding that higher-usage countries engage Claude more collaboratively, this suggests that the skills required to use AI well may themselves be unevenly distributed.&lt;/p&gt;
    &lt;p&gt;By measuring the characteristics of conversations with Claude, we find important relationships with broader economic factors such as human capital. These relationships may help predict labor market outcomes and inform a smooth transition to an AI-enabled economy that will require different skillsets.&lt;/p&gt;
    &lt;p&gt;&lt;lb/&gt;1 For privacy reasons, our automated analysis system filters out any cells—e.g., countries, and (country, task) intersections—with fewer than 15 conversations and 5 unique user accounts. For bottom-up request clusters, we have an even higher privacy filter of at least 500 conversations and 250 unique accounts.&lt;/p&gt;
    &lt;p&gt;2 Data in this section covers 1 million Claude.ai Free, Pro and Max conversations from November 13 to 20, 2025, randomly sampled from all conversations in that period. We then excluded content that was flagged as potential trust and safety violations. The unit of observation is a conversation with Claude on Claude.ai, not a user, so it is possible that multiple conversations from the same user are included, though our past work suggests that sampling conversations at random versus stratified by user does not yield substantively different results. Aggregate geographic statistics at the country and US state level were assessed and tabulated from the IP address of each conversation. For geolocation, we use ISO-3166 codes since our provider for IP geolocation uses this standard. International locations use ISO-3166-1 country codes, US state level data use ISO-3166-2 region codes, which include all 50 US states and Washington DC. We exclude conversations originating from VPN, anycast, or hosting services, as determined by our IP geolocation provider.&lt;/p&gt;
    &lt;p&gt;3 The world map is based on Natural Earth’s world map with the ISO standard point of view for disputed territories, which means that the map may not contain some disputed territories. We note that in addition to the countries shown in gray (“Claude not available”), we do not operate in the Ukrainian regions Crimea, Donetsk, Kherson, Luhansk, and Zaporizhzhia. In accordance with international sanctions and our commitment to supporting Ukraine’s territorial integrity, our services are not available in areas under Russian occupation.&lt;/p&gt;
    &lt;p&gt;4 “No data” applies to countries with partially missing data. Some territories (e.g., Western Sahara, French Guiana) have their own ISO-3611 code. Some of these have some usage, others have none. Since the Anthropic AI Usage Index is calculated per working-age capita based on working age population data from the World Bank, and population data is not readily available for all of these territories, we cannot calculate the AUI for these territories.&lt;/p&gt;
    &lt;p&gt;5 We exclude the Seychelles from all geographic analyses because a large fraction of usage we saw during the sampling dates was abusive traffic.&lt;/p&gt;
    &lt;p&gt;6 We exclude Wyoming from all US state analyses because a large fraction of usage we saw during the sampling dates was abusive traffic.&lt;/p&gt;
    &lt;head rend="h2"&gt;Chapter 4: Tasks and productivity&lt;/head&gt;
    &lt;p&gt;In this chapter, we examine how time savings, success rates, and autonomy vary across task types, and what this entails for potential impacts on jobs and productivity.&lt;/p&gt;
    &lt;p&gt;The patterns reveal that more complex tasks yield greater time savings, but that this trades off against reliability. In a simple task removal exercise inspired by Autor and Thompson (2025), Claude's tendency to cover higher-education tasks produces a net deskilling effect across most occupations, as the tasks AI handles are often the more skilled components of a job.&lt;/p&gt;
    &lt;p&gt;Claude usage spans a meaningful fraction of tasks across a growing share of occupations. We incorporate success rates into a richer model of job coverage; some occupations with modest coverage see large effects because AI succeeds on their most time-intensive work. Adjusting productivity estimates for task reliability roughly halves the implied gains, from 1.8 to about 1.0 percentage points of annual labor productivity growth over the next decade. However, these estimates reflect current model capabilities, and all signs suggest that reliability over increasingly long-running tasks will improve.&lt;/p&gt;
    &lt;head rend="h3"&gt;Tradeoffs in task acceleration&lt;/head&gt;
    &lt;p&gt;Our estimates suggest that, in general, the more complex tasks in our data yield a greater time savings (or “speedup”) from AI. We derive this by having Claude estimate both how long a task would take a human working alone and the duration when human and AI work together, which we validated in previous work. Speedup is then the human-alone time divided by the human-with-AI time. So reducing a 1 hour task to 10 minutes would give a 6x speedup.&lt;/p&gt;
    &lt;p&gt;The left panel of Figure 4.1 below gives the average speedup against our core measure of task complexity, the human years of schooling required to understand the inputs, all at the O*NET task level1. It shows that in Claude.ai conversations, for example, prompts requiring 12 years of schooling (a high school education) enjoy a speedup of 9x, while those requiring 16 years of schooling (a college degree) attain a 12x speedup. This implies that productivity gains are more pronounced for use cases requiring higher human capital, consistent with evidence that white collar workers are far more likely to adopt AI (e.g., Bick et al 2025).&lt;/p&gt;
    &lt;p&gt;Throughout the range of task complexity, the speedup is higher for API users. This could reflect the nature of the API data, which is restricted to single-turn interactions, and that API tasks have been specifically selected for automation.&lt;/p&gt;
    &lt;p&gt;The results also capture a tradeoff, however. More complex tasks have a lower task success rate, as shown in the panel on the right. On Claude.ai, for example, tasks requiring less than a high school education (e.g., answering basic questions about products) attain a 70% success rate, but this drops to 66% for college-level conversations like developing analysis plans. Still, accounting for the difference in success rates—by either excluding low-success tasks or discounting speedups by success probability—does not eliminate the education gradient: complex tasks still show greater net productivity gains.&lt;/p&gt;
    &lt;p&gt;One way to examine the implications of the education gradient is to look at the share of automation across the education levels required to understand the inputs. If high-education tasks show relatively more automation, it could signal more exposure for white collar workers. Here, though, the message is unclear: the automation share is essentially unrelated to the human levels of education required to write the prompt (Appendix Figure A.1)2. On both Claude.ai and 1P API, tasks across education levels show automation patterns in roughly equal shares.&lt;/p&gt;
    &lt;p&gt;In what contexts do users defer more to Claude? Claude.ai users give the AI slightly more autonomy when working on more complex tasks. In contrast, API usage shows uniformly lower autonomy at all levels of complexity.&lt;/p&gt;
    &lt;p&gt;Note though that these distributions do not span the same set of tasks. API usage covers a more narrow swath of tasks in the economy, as seen in the concentration plot in Chapter 1. The high education tasks that experience heavy usage in the API data include security analysis, testing and quality assurance, and code review, whereas Claude.ai users are more likely to have iterative, instructive sessions.&lt;/p&gt;
    &lt;head rend="h3"&gt;Task Horizons in Real-World Usage&lt;/head&gt;
    &lt;p&gt;Recent work on AI “task horizons” (Kwa et al., 2025) finds that AI success rates decline with task duration: longer tasks are harder for models to complete. With each successive model generation, however, this decline has become shallower as models succeed on increasingly long tasks. METR operationalizes task horizon primarily as the maximum duration at which a model achieves at least 50% success, and growth in this metric has become a key indicator of AI progress.&lt;/p&gt;
    &lt;p&gt;Figure 4.3 shows a similar measure using our primitives. The plot shows task-level success rates against the human time required, all at the O*NET task level. In the API data, success rates drop from around 60% for sub-hour tasks to roughly 45% for tasks estimated to take humans 5+ hours. The fitted line crosses the horizontal 50% success line at 3.5 hours, suggesting that API calls attain a 50% success rate for tasks that are 3.5 hours. The analogous time estimate in METR’s software engineering benchmark is 2 hours for Sonnet 4.5 and about 5 hours for Opus 4.5. (The data in this report predates the release of Opus 4.5.)&lt;/p&gt;
    &lt;p&gt;Claude.ai data tells a different story. Success rates decline far slower as a function of task length. Extrapolating using the linear fit, Claude.ai would hit a 50% success rate at about 19 hours. This may reflect how multi-turn conversation effectively breaks complex tasks into smaller steps, with each turn providing a feedback loop that allows users to correct course.&lt;/p&gt;
    &lt;p&gt;It’s worth noting that a fundamental difference from the METR setting is selection. METR constructs a benchmark where a fixed set of tasks is assigned to models. In our data, users choose which tasks to bring to Claude. This means observed success rates reflect not just model capability but also user judgment about what will work, the cost of setting up the problem for Claude, and the expected time savings if the task succeeds.&lt;/p&gt;
    &lt;p&gt;If users avoid tasks they expect to fail, for example, observed success rates will overstate true capability on the full distribution of potential tasks. This selection likely operates on both platforms, but in different ways: API customers select for tasks amenable to automation, while Claude.ai users select for tasks that could benefit from iteration. Also due to this selection effect, there’s no guarantee that more performant models would show improvement in this plot, because users may respond to new models by providing more challenging presentations of otherwise similar O*NET tasks.&lt;/p&gt;
    &lt;p&gt;Controlled benchmarks like METR’s measure the frontier of autonomous capability. Our real-world data can measure the effective task horizon, reflecting a mix of model capabilities and user behavior, and expanding beyond coding tasks. Both approaches find that AI can be effective for tasks requiring hours of human work.&lt;/p&gt;
    &lt;head rend="h3"&gt;Revisiting occupation penetration with effective AI coverage&lt;/head&gt;
    &lt;p&gt;&lt;lb/&gt;Our earlier work found that 36% of jobs had AI usage for at least a quarter of their tasks, with about 4% reaching 75% task coverage. This measure was based only on the appearance of a task in our data, however. The primitives introduced in this report can help better characterize how AI is changing the work content of occupations.3&lt;/p&gt;
    &lt;p&gt;First, we find that task coverage is increasing. Combining across reports, 49% of jobs have seen AI usage for at least a quarter of their tasks. But incorporating that task’s share of the job, and Claude’s average success rate, suggests a different set of affected occupations.&lt;/p&gt;
    &lt;p&gt;We define effective AI coverage as the percent of a worker’s day that can be performed successfully by Claude. It’s calculated as the weighted sum of task success rates, where each task's weight is its share of the worker's time adjusted by how frequently the task occurs. The success rate comes from our primitives, the hours estimate from our previous work on productivity effects, and the frequency estimate from O*NET data, where surveyed workers indicate how often they perform the task.&lt;/p&gt;
    &lt;p&gt;The plot below shows how the effective AI coverage (y-axis) differs from task coverage alone (x-axis). The two are highly correlated, but with key differences. On the right side of the plot, occupations with high coverage—where almost all tasks appear with some frequency in Claude data—generally fall below the 45-degree line. This suggests that even 90% task coverage does not necessarily indicate large job impacts, since Claude may fail on key covered tasks or miss the most time-intensive ones.&lt;/p&gt;
    &lt;p&gt;Zooming in, several occupations show large differences in effective AI coverage compared to task coverage. For example, data entry workers have one of the highest effective AI coverage. This is because although only two of their nine tasks are covered, their largest task—reading and entering data from source documents—has high success rates with Claude. AI excels at what they spend most of their time doing.&lt;/p&gt;
    &lt;p&gt;Medical transcriptionists and radiologists also move up because their covered tasks happen to be their most time-intensive and highest-frequency work. For radiologists, their top two tasks— interpreting diagnostic images and preparing interpretive reports—have high success rates. These occupations have low task coverage because AI can't do the hands-on or administrative work in their job profiles, but it succeeds on the core knowledge work that dominates their workday.&lt;/p&gt;
    &lt;p&gt;Microbiologists fall below the 45-degree line, suggesting lower effective AI coverage than would be predicted by task coverage alone. Claude covers half of their tasks, but not their most time-intensive: hands-on research using specialized lab equipment.&lt;/p&gt;
    &lt;p&gt;This measure arguably gives a more realistic picture of job-level AI penetration. However, its implications depend on how often these Claude conversations actually displace or augment work that would otherwise be done by humans. For data entry clerks, AI likely does substitute for tasks previously performed manually. But when a Claude conversation maps to a teacher performing a lecture, it is less clear how this translates to reduced lecture time on the job. In future work, we could leverage our 1P API data to understand which of these tasks are being integrated into production workflows.&lt;/p&gt;
    &lt;head rend="h3"&gt;&lt;lb/&gt;AI’s impact on the task content of jobs&lt;/head&gt;
    &lt;p&gt;&lt;lb/&gt;Beyond how much of a worker's day AI can successfully perform, a separate question is which tasks get covered, and whether those tend to be the high-skill or low-skill components of the job. Recent research has studied changes in the task mix within jobs to understand AI's impact on wages and employment (Autor and Thompson 2025; Hampole et al 2025). A key insight is that automation's effects depend not just on how many tasks are covered, but on which tasks.&lt;/p&gt;
    &lt;p&gt;To see how jobs change when we remove the tasks AI can perform, we first construct a measure of the level of skill required for each task. O*NET doesn't provide task-level education requirements, so we train a model that predicts years of schooling from task embeddings, using the BLS's occupation-level education as the target4. This way, a low-education occupation may still have a high-skill task if it looks like those that tend to exist in high-education occupations. For example, Legal Secretaries is a 12-year education occupation, but the task “Review legal publications and perform database searches to identify laws and court decisions relevant to pending cases” is predicted to require 17.7 years because it resembles tasks typically performed by lawyers and paralegals.&lt;/p&gt;
    &lt;p&gt;The data shows that Claude tends to cover tasks that require higher levels of education. The mean predicted education for tasks in the economy is 13.2 years. For tasks that we see in our data, the mean prediction is about a year higher, 14.4 years (corresponding to an Associate’s degree). This aligns with the occupation-level results from earlier reports, showing more Claude usage among white collar occupations.&lt;/p&gt;
    &lt;p&gt;We next calculate how removing AI-covered tasks shifts the average education level of what remains. Overall, the net first-order impact is to deskill jobs, since AI removes tasks that require relatively higher levels of education. One job that experiences such deskilling is technical writers, which loses tasks like "Analyze developments in specific field to determine need for revisions" (18.7 years) and "Review published materials and recommend revisions or changes in scope, format" (16.4 years), leaving tasks like "Draw sketches to illustrate specified materials" (13.6 years) and "Observe production, developmental, and experimental activities" (13.5 years). Travel agents also experience deskilling because AI covers tasks like "Plan, describe, arrange, and sell itinerary tour packages" (13.5 years) and "Compute cost of travel and accommodations" (13.4 years), while tasks like "Print or request transportation carrier tickets" (12.0 years) and "Collect payment for transportation and accommodations" (11.5 years) remain. Several teaching professions experience deskilling because AI addresses tasks like grading, advising students, writing grants, and conducting research without being able to do the hands-on work of delivering lectures in person and managing a classroom.&lt;/p&gt;
    &lt;p&gt;Some jobs see average education levels increase. Real estate managers experience upskilling because AI covers routine administrative tasks—maintaining sales records (12.8 years), reviewing rents against market rates (12.6 years)—while tasks requiring higher-level professional judgment and in-person interaction remain, like securing loans, negotiating with architecture firms, and meeting with boards.&lt;/p&gt;
    &lt;p&gt;These patterns illustrate how jobs may evolve over the coming years as their task content adjusts in response to AI. If the education level can be interpreted like expertise in Autor and Thompson's analysis, their framework might predict that wages will fall and employment will increase for technical writers and travel agents; conversely, real estate managers will specialize in complex negotiations and stakeholder management, shrinking employment while increasing wages.5&lt;/p&gt;
    &lt;p&gt;However, our education-based measure differs from Autor and Thompson's expertise concept: their framework would label some tasks as high expertise where ours specifies low education—for example, the Electrician task "Connect wires to circuit breakers, transformers, or other components." And these predictions are based on current Claude usage patterns, which will shift as models are trained on new capabilities and users discover new applications—potentially changing which tasks are covered and whether the net effect is deskilling or upskilling.&lt;/p&gt;
    &lt;head rend="h3"&gt;Revisiting the aggregate productivity implications of Claude usage&lt;/head&gt;
    &lt;p&gt;In earlier work, we estimated that widespread adoption of AI could increase US labor productivity growth by 1.8 percentage points annually over the next decade. Here we revisit that analysis, incorporating the task success primitive introduced in this report and a richer treatment of task complementarity.&lt;/p&gt;
    &lt;p&gt;Based on the speedups associated with tasks with at least 200 observations in our sample of 1M Claude.ai conversations,6 we replicate our previous finding that current-generation AI models and current usage patterns imply a productivity effect of 1.8 percentage points per year over the next decade.7&lt;/p&gt;
    &lt;p&gt;With the inclusion of 1P API data, we can assess whether implied labor productivity effects differ based on enterprise Claude deployment patterns. Two countervailing forces are at play: API usage is more concentrated in a narrower set of tasks and occupations (particularly coding-related work), which would tend to reduce implied effects; but task-level speedups are higher on average among API tasks, as implied by Figure 4.1. These forces largely offset: the API sample likewise implies a 1.8 percentage point increase in labor productivity over the next decade.&lt;/p&gt;
    &lt;p&gt;A salient critique of this analysis is that it fails to account for model reliability. If workers must validate AI output, the productivity benefits will be smaller than raw speedups suggest. To assess how quantitatively important this channel might be, we incorporate the task success primitive introduced in this report, multiplying task-level time savings by task-specific success rates before aggregating.8&lt;/p&gt;
    &lt;p&gt;This adjustment has a meaningful effect: implied productivity growth falls from 1.8 to 1.2 percentage points per year for the next decade based on Claude.ai usage, and to 1.0 percentage points for API traffic. Yet, even after accounting for reliability, the implied impact remains economically significant—a sustained increase of 1.0 percentage point per year for the next ten years would return US productivity growth to rates that prevailed in the late 1990s and early 2000s.A second critique concerns task complementarity. If some tasks are essential and cannot easily be substituted, then overall productivity effects will be constrained regardless of speedups on other tasks. Teachers may prepare lesson plans more efficiently with AI while having no impact on time spent with students in the classroom.&lt;/p&gt;
    &lt;p&gt;To operationalize this idea, we impose some structure on how we aggregate task-level time savings within occupations but otherwise add up occupational efficiency gains as in the main analysis. Specifically, we suppose that within each occupation tasks are combined according to a Constant Elasticity of Substitution (CES) aggregator, where each task is weighted by the estimated time spent on each task as calculated in our earlier analysis of the productivity effects implied by Claude usage.9&lt;/p&gt;
    &lt;p&gt;The key parameter is the elasticity of substitution across tasks, σ. When the elasticity of substitution is less than one, tasks are complements and those tasks that are not sped up by AI become bottlenecks for broader productivity gains. Alternatively, when the elasticity of substitution is greater than one, then workers can allocate toward the more productive tasks—thereby amplifying the overall time savings at the occupational level. An elasticity of substitution equal to one is a special case that replicates the main analysis above.&lt;/p&gt;
    &lt;p&gt;Figure 4.6 reports the results of this exercise for different values of task substitutability. As expected, when the elasticity of substitution is equal to one the implied productivity effect is the same as in our baseline analysis: An increase in labor productivity growth of ~1.8 percentage points per year over the next decade implied by both Claude.ai and API samples.&lt;/p&gt;
    &lt;p&gt;When tasks are complements, however, the implied aggregate labor productivity impact declines sharply as the economic effects are bottlenecked by tasks that AI speeds up the least. For example, at =0.5 the implied overall labor productivity effect is 0.7-0.9 percentage points per year—around half the size as implied by our baseline estimates. Additionally adjusting for task success further reduces the implied productivity effects to 0.8pp for Claude.ai and 0.6pp for API.&lt;/p&gt;
    &lt;p&gt;On the other hand, when the elasticity of substitution is greater than one, the implied labor productivity based on pre-Opus 4.5 usage patterns is materially higher. For example, at =1.5 the implied labor productivity effect rises to 2.2-2.6 percentage points per year, consistent with greater specialization in tasks where AI provides the largest speedups.&lt;/p&gt;
    &lt;p&gt;In both cases the implied productivity impact based on API traffic is more responsive to the degree of task substitutability. This is consistent with the fact that there is a larger share of API traffic concentrated in fewer tasks and associated occupations as compared to Claude.ai: When tasks are complements, this concentration amplifies the bottleneck problem; when they are substitutes, it amplifies productivity gains from task specialization.&lt;/p&gt;
    &lt;p&gt;What this analysis shows is that the productivity effects of automation may ultimately be constrained by bottleneck tasks that elude AI automation for the time being. And the labor market implications of increasingly capable AI could be similarly affected by such forces. For example, Gans and Goldfarb (2026) argue that the presence of bottleneck tasks within jobs means that partial AI automation can lead to an increase in labor income as such tasks increase in economic value (at least until a job is entirely automated).&lt;/p&gt;
    &lt;head rend="h3"&gt;Conclusion&lt;/head&gt;
    &lt;p&gt;The upshot of this chapter is that the impact of AI on the economy is unlikely to be uniform. As our effective AI coverage framework illustrates, the labor market implications for different workers will hinge on how reliable frontier AI tools are for their most central tasks.&lt;/p&gt;
    &lt;p&gt;But the labor market effects may also depend on the skill requirements of tasks that AI can proficiently handle relative to the rest of the economy. Indeed, we find that removing tasks Claude can already handle from the economy would produce a net deskilling effect: the tasks remaining for humans have lower educational requirements than those handled by AI.&lt;/p&gt;
    &lt;p&gt;While highly suggestive, this may miss an important detail: the most complex tasks where Claude is used tend also to be those where it struggles most. Rather than displacing highly skilled professionals, this could instead reinforce the value of their complementary expertise in understanding AI's work and assessing its quality.&lt;/p&gt;
    &lt;p&gt;The counterpart to these transformative labor market effects is the broader impact on growth and productivity. On the one hand, incorporating task reliability into our analysis diminishes the implied effect on labor productivity growth as informed by current Claude usage patterns. If bottleneck tasks bind, the implied impact diminishes further. On the other hand, the continuing growth in model capabilities suggests that both task coverage and task success may increase, which, in turn, could increase productivity impacts.&lt;/p&gt;
    &lt;p&gt;1 When we study the correlation between primitives with the O*NET, we restrict to tasks appearing in at least 100 conversations to reduce measurement error. In the coverage analysis, we use all tasks above the privacy threshold of 15.&lt;/p&gt;
    &lt;p&gt;2 Our online appendix is available at https://huggingface.co/datasets/Anthropic/EconomicIndex.&lt;/p&gt;
    &lt;p&gt;3 See also Tomlinson et al (2025) for a related AI applicability score.&lt;/p&gt;
    &lt;p&gt;4 We generate embeddings for each task statement using a pretrained sentence transformer (all-mpnet-base-v2) and predict education with Ridge regression.&lt;/p&gt;
    &lt;p&gt;5 On the other hand, some historical evidence suggests that when technologies automating job tasks appear in patent data, employment and wages subsequently fall for exposed occupations (Webb 2020).&lt;/p&gt;
    &lt;p&gt;6 When we first assessed the aggregate productivity implications of Claude usage, we relied on a sample of 100k Claude.ai conversations from Fall 2025. Based on the set of tasks for which we observed speedups, we estimated that labor productivity could be 1.8 percentage points higher per year over the next decade. Expanding the sample to 1M observations means that we need to take a stand on how to handle very infrequently occurring tasks—which are very common given that usage follows a power law, as we documented in our past report. We choose a threshold of 0.02% because it replicates our previous results for our sample of Claude.ai conversations. For privacy-preserving reasons, we only ever analyze tasks with at least 15 observations, or an implied threshold of 0.015% for a 100k sample. And so our results are internally consistent across samples. If we do not impose a restriction on our 1M sample and assume that efficiency gains for any task in our sample, even those with just 15 observations out of one million, the implied aggregate labor productivity growth over the next decade would be roughly 5% percentage points per year—a mechanical increase based on a the much larger set of tasks included.&lt;/p&gt;
    &lt;p&gt;7 As before, this result is based on applying Hulten’s Theorem to task-level productivity shocks and assuming that the corresponding one-time increase in total factor productivity materializes over the course of a decade alongside capital deepening effects.&lt;lb/&gt;8 As a reminder, for aggregating to implied labor productivity we calculate task-level efficiency gains as the log difference between human time without AI and with AI. There are certainly other ways to adjust based on task reliability. If tasks in our sample are composed of sub-tasks with heterogeneous AI applicability, and workers optimally deploy AI only on sub-tasks where it is effective, then scaling the efficiency gain by the success rate captures the extensive margin of AI adoption within a task.&lt;/p&gt;
    &lt;p&gt;9 We use a CES (constant elasticity of substitution) production function to aggregate task-level time savings to economy-wide productivity impacts. The elasticity parameter σ governs how easily workers can substitute between tasks. When σ=1, we apply Hulten's theorem directly: the aggregate productivity gain equals the wage-share-weighted sum of log speedups across tasks. For σ≠1, we use a two-level aggregation: first, within each occupation, we compute an occupation-level speedup as a CES aggregate of task speedups weighted by time fractions, using ρ=(σ-1)/σ. Then we apply Hulten's theorem to these occupation-level speedups. When σ&amp;lt;1 (complements), productivity gains are bottlenecked by tasks with the smallest speedups. When σ&amp;gt;1 (substitutes), workers can specialize in tasks where AI provides the largest speedups, amplifying aggregate gains. For tasks without observed AI speedup data, we assume no productivity change. We thank Pascual Restrepo for suggesting this particular exercise.&lt;/p&gt;
    &lt;head rend="h2"&gt;Concluding Remarks&lt;/head&gt;
    &lt;p&gt;This fourth Anthropic Economic Index Report introduces economic primitives—foundational characteristics of AI use—that show how Claude is used by both consumers and firms. We use Claude to estimate the extent to which usage varies along these dimensions; these measures are directionally accurate and, taken together, provide important signals even if individual classifications are imperfect.&lt;/p&gt;
    &lt;p&gt;Our findings carry significant implications for how AI will reshape economies and labor markets. Notably, Claude tends to be used more, and appears to provide greater productivity boosts, on tasks that require higher education. If these tasks shrink for US workers, the net effect could be to deskill jobs. But these impacts depend crucially on complementarity across tasks, and whether increased productivity at a certain task may increase the demand for it.&lt;/p&gt;
    &lt;p&gt;At the global level, the strong relationship between per capita income and usage patterns—with higher-income nations using Claude collaboratively while lower-income countries focus on coursework and specific applications—suggests that AI's impact will be mediated by existing institutional structures rather than unfolding uniformly. Geographic diffusion patterns reinforce this picture. Within the US, per capita usage has converged slightly; globally, diffusion is slower. Combined with income-driven differences in how AI is used, this raises questions about whether AI will narrow or widen international economic gaps.&lt;/p&gt;
    &lt;p&gt;Equally important to the patterns documented here are potential changes across this and subsequent reports. As AI capabilities advance, Claude's success rate may increase, usage patterns may show greater autonomy, users may tackle new and more complex tasks, and tasks that prove automatable may graduate from interactive chat to API deployment. We will track these dynamics over time, providing a longitudinal view of AI's role in the economy.&lt;/p&gt;
    &lt;p&gt;Building on prior releases, this edition significantly expands both the scope and transparency of usage data we share, including task-level classifications along new dimensions and regional breakdowns globally for the first time. We publish this data to enable researchers, journalists, and the public to investigate novel questions about AI's economic impacts that can form the empirical foundation for policy responses.&lt;/p&gt;
    &lt;p&gt;How willing users are to experiment with AI, and whether policymakers create a regulatory context that advances both safety and innovation, will shape how AI transforms economies. For AI to benefit users globally, expanding access alone will not suffice—developing the human capital that enables effective use, particularly in lower-income economies, is essential.&lt;/p&gt;
    &lt;head rend="h2"&gt;Authors &amp;amp; Acknowledgements&lt;/head&gt;
    &lt;head rend="h4"&gt;First Author Block*:&lt;/head&gt;
    &lt;p&gt;Ruth Appel, Maxim Massenkoff, Peter McCrory&lt;/p&gt;
    &lt;p&gt;*Lead authors of the report&lt;/p&gt;
    &lt;head rend="h4"&gt;Second Author Block:&lt;/head&gt;
    &lt;p&gt;Miles McCain, Ryan Heller, Tyler Neylon, Alex Tamkin&lt;/p&gt;
    &lt;head rend="h4"&gt;Acknowledgements&lt;/head&gt;
    &lt;p&gt;Xabi Azagirre, Tim Belonax, Keir Bradwell, Andy Braden, Dexter Callender III, Sylvie Carr, Miriam Chaum, Ronan Davy, Evan Frondorf, Deep Ganguli, Kunal Handa, Andrew Ho, Rebecca Jacobs, Owen Kaye-Kauderer, Bianca Lindner, Kelly Loftus, James Ma, Jennifer Martinez, Jared Mueller, Kelsey Nanan, Kim O'Rourke, Dianne Penn, Sarah Pollack, Ankur Rathi, Zoe Richards, Alexandra Sanderford, David Saunders, Michael Sellitto, Thariq Shihipar, Michael Stern, Kim Withee, Mengyi Xu, Tony Zeng, Xiuruo Zhang, Shuyi Zheng, Emily Pastewka, Angeli Jain, Sarah Heck, Jared Kaplan, Jack Clark, Dario Amodei&lt;/p&gt;
    &lt;head rend="h4"&gt;&lt;lb/&gt;Citation &lt;/head&gt;
    &lt;code&gt;@online{anthropic2026aeiv4,
        author = {Ruth Appel and Maxim Massenkoff and Peter McCrory and Miles McCain and Ryan Heller and Tyler Neylon and Alex Tamkin},
        title = {Anthropic Economic Index report: economic primitives},
        date = {2026-01-15},
        year = {2026},
        url = {https://www.anthropic.com/research/anthropic-economic-index-january-2026-report},
}&lt;/code&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=46725632</guid><pubDate>Thu, 22 Jan 2026 21:54:02 +0000</pubDate></item><item><title>Improving the usability of C libraries in Swift</title><link>https://www.swift.org/blog/improving-usability-of-c-libraries-in-swift/</link><description>&lt;doc fingerprint="6e025913b407b699"&gt;
  &lt;main&gt;
    &lt;head rend="h1"&gt;Improving the usability of C libraries in Swift&lt;/head&gt;
    &lt;p&gt;There are many interesting, useful, and fun C libraries in the software ecosystem. While one could go and rewrite these libraries in Swift, usually there is no need, because Swift provides direct interoperability with C. With a little setup, you can directly use existing C libraries from your Swift code.&lt;/p&gt;
    &lt;p&gt;When you use a C library directly from Swift, it will look and feel similar to using it from C. That can be useful if you’re following sample code or a tutorial written in C, but it can also feel out of place. For example, here’s a small amount of code using a C API:&lt;/p&gt;
    &lt;code&gt;  var instanceDescriptor = WGPUInstanceDescriptor()
  let instance = wgpuCreateInstance(&amp;amp;instanceDescriptor)
  var surfaceDescriptor = WGPUSurfaceDescriptor()
  let surface = wgpuInstanceCreateSurface(instance, &amp;amp;surfaceDescriptor)
  if wgpuSurfacePresent(&amp;amp;surface) == WGPUStatus_Error {
      // report error
  }
  wgpuSurfaceRelease(surface)
  wgpuInstanceRelease(instance)
&lt;/code&gt;
    &lt;p&gt;The C library here that Swift is using comes from the webgpu-headers project, which vends a C header (&lt;code&gt;webgpu.h&lt;/code&gt;) that is used by several implementations of WebGPU. WebGPU  is a technology that enables web developers to use the system’s GPU (Graphics Processing Unit) from the browser. For the purposes of this post, you don’t really need to know anything about WebGPU: I’m using it as an example of a typical C library, and the techniques described in this blog post apply to lots of other well-designed C libraries.&lt;/p&gt;
    &lt;p&gt;The Swift code above has a very “C” feel to it. It has global function calls with prefixed names like &lt;code&gt;wgpuInstanceCreateSurface&lt;/code&gt; and global integer constants like &lt;code&gt;WGPUStatus_Error&lt;/code&gt;. It pervasively uses unsafe pointers, some of which are managed with explicit reference counting, where the user provides calls to &lt;code&gt;wpuXYZAddRef&lt;/code&gt; and &lt;code&gt;wgpuXYZRelease&lt;/code&gt; functions. It works, but it doesn’t feel like Swift, and inherits various safety problems of C.&lt;/p&gt;
    &lt;p&gt;Fortunately, we can improve this situation, providing a safer and more ergonomic interface to WebGPU from Swift that feels like it belongs in Swift. More importantly, we can do so without changing the WebGPU implementation: Swift provides a suite of annotations that you can apply to C headers to improve the way in which the C APIs are expressed in Swift. These annotations describe common conventions in C that match up with Swift constructs, projecting a more Swift-friendly interface on top of the C code.&lt;/p&gt;
    &lt;p&gt;In this post, I’m going to use these annotations to improve how Swift interacts with the WebGPU C code. By the end, we’ll be able to take advantage of Swift features like argument labels, methods, enums, and automatic reference counting, like this:&lt;/p&gt;
    &lt;code&gt;  var instanceDescriptor = WGPUInstanceDescriptor()
  let instance = WGPUInstance(descriptor: &amp;amp;instanceDescriptor)
  var surfaceDescriptor = WGPUSurfaceDescriptor()
  let surface = instance.createSurface(descriptor: &amp;amp;surfaceDescriptor)
  if surface.present() == .error {
      // report error
  }
  // Swift automatically deallocates the instance and surface when we're done
&lt;/code&gt;
    &lt;p&gt;These same annotations can be used for any C library to provide a safer, more ergonomic development experience in Swift without changing the C library at all.&lt;/p&gt;
    &lt;quote&gt;
      &lt;p&gt;Note: Some of what is covered in this post requires bug fixes that first became available in Swift 6.2.3.&lt;/p&gt;
    &lt;/quote&gt;
    &lt;head rend="h2"&gt;Setup: Writing a module map&lt;/head&gt;
    &lt;p&gt;A module map is a way of layering a Swift-friendly modular structure on top of C headers. You can create a module map for the WebGPU header by writing the following to a file &lt;code&gt;module.modulemap&lt;/code&gt;:&lt;/p&gt;
    &lt;code&gt;module WebGPU {
  header "webgpu.h"
  export *
}
&lt;/code&gt;
    &lt;p&gt;The easiest thing to do is to put &lt;code&gt;module.modulemap&lt;/code&gt; alongside the header itself. For my experiment here, I put it in the root directory of my &lt;code&gt;webgpu-headers&lt;/code&gt; checkout. If you’re in a Swift package, put it into its own target with this layout:&lt;/p&gt;
    &lt;code&gt;├── Package.swift
└── Sources
    └── WebGPU
        ├── include
        │   ├── webgpu.h
        │   └── module.modulemap
        └── WebGPU.c (empty file)
&lt;/code&gt;
    &lt;p&gt;If you reference this &lt;code&gt;WebGPU&lt;/code&gt; target from elsewhere in the package, you can &lt;code&gt;import WebGPU&lt;/code&gt; to get access to the C APIs.&lt;/p&gt;
    &lt;head rend="h2"&gt;Seeing the results&lt;/head&gt;
    &lt;p&gt;There are a few ways to see what the Swift interface for a C library looks like.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;The &lt;code&gt;swift-synthesize-interface&lt;/code&gt;tool in Swift 6.2+ prints the Swift interface to the terminal.&lt;/item&gt;
      &lt;item&gt;Xcode’s “Swift 5 interface” counterpart to the &lt;code&gt;webgpu.h&lt;/code&gt;header will show how the header has been mapped into Swift.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Let’s do it from the command line, using &lt;code&gt;swift-synthesize-interface&lt;/code&gt;. From the directory containing &lt;code&gt;webgpu.h&lt;/code&gt; and &lt;code&gt;module.modulemap&lt;/code&gt;, run:&lt;/p&gt;
    &lt;code&gt;xcrun swift-synthesize-interface -I . -module-name WebGPU -target arm64-apple-macos15 -sdk /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX26.0.sdk
&lt;/code&gt;
    &lt;p&gt;The leading &lt;code&gt;xcrun&lt;/code&gt; and the &lt;code&gt;-sdk&lt;/code&gt; argument with the path is only needed on macOS; on other platforms, make sure &lt;code&gt;swift-synthesize-interface&lt;/code&gt; is in your path. The &lt;code&gt;-target&lt;/code&gt; operation is the triple provided if you run &lt;code&gt;swiftc -print-target-info&lt;/code&gt;. It looks like this:&lt;/p&gt;
    &lt;code&gt;{
  "compilerVersion": "Apple Swift version 6.2 (swiftlang-6.2.2.15.4 clang-1700.3.15.2)",
  "target": {
    "triple": "arm64-apple-macosx15.0",
    "unversionedTriple": "arm64-apple-macosx",
    "moduleTriple": "arm64-apple-macos",
    "compatibilityLibraries": [ ],
    "librariesRequireRPath": false
  },
  "paths": { ... }
}
&lt;/code&gt;
    &lt;p&gt;The output of &lt;code&gt;swift-synthesize-interface&lt;/code&gt; is the Swift API for the WebGPU module, directly translated from C. For example, this code from the WebGPU header:&lt;/p&gt;
    &lt;code&gt;typedef enum WGPUAdapterType {
    WGPUAdapterType_DiscreteGPU = 0x00000001,
    WGPUAdapterType_IntegratedGPU = 0x00000002,
    WGPUAdapterType_CPU = 0x00000003,
    WGPUAdapterType_Unknown = 0x00000004,
    WGPUAdapterType_Force32 = 0x7FFFFFFF
} WGPUAdapterType WGPU_ENUM_ATTRIBUTE;
&lt;/code&gt;
    &lt;p&gt;is translated into:&lt;/p&gt;
    &lt;code&gt;public struct WGPUAdapterType : Hashable, Equatable, RawRepresentable {
    public init(_ rawValue: UInt32)
    public init(rawValue: UInt32)
    public var rawValue: UInt32
}

public var WGPUAdapterType_DiscreteGPU: WGPUAdapterType { get }
public var WGPUAdapterType_IntegratedGPU: WGPUAdapterType { get }
public var WGPUAdapterType_CPU: WGPUAdapterType { get }
public var WGPUAdapterType_Unknown: WGPUAdapterType { get }
public var WGPUAdapterType_Force32: WGPUAdapterType { get }
&lt;/code&gt;
    &lt;p&gt;and there are lots of global functions like this:&lt;/p&gt;
    &lt;code&gt;public func wgpuComputePipelineGetBindGroupLayout(_ computePipeline: WGPUComputePipeline!, _ groupIndex: UInt32) -&amp;gt; WGPUBindGroupLayout!
public func wgpuComputePipelineSetLabel(_ computePipeline: WGPUComputePipeline!, _ label: WGPUStringView)
public func wgpuComputePipelineAddRef(_ computePipeline: WGPUComputePipeline!)
public func wgpuComputePipelineRelease(_ computePipeline: WGPUComputePipeline!)
&lt;/code&gt;
    &lt;p&gt;It’s a starting point! You can absolutely write Swift programs using these WebGPU APIs, and they’ll feel a lot like writing them in C. Let’s see what we can do to make it better.&lt;/p&gt;
    &lt;head rend="h2"&gt;Cleaning up enumeration types&lt;/head&gt;
    &lt;p&gt;C enums can be used for several things. Sometimes they really represent a choice among a number of alternatives. Sometimes they represent flags in a set of options, from which you can choose several. Sometimes they’re just a convenient way to create a bunch of named constants. Swift conservatively imports enum types as wrappers over the underlying C type used to store values of the enum (e.g., &lt;code&gt;WGPUAdapterType&lt;/code&gt; wraps a &lt;code&gt;UInt32&lt;/code&gt;) and makes the enumerators into global constants. It covers all of the possible use cases, but it isn’t nice.&lt;/p&gt;
    &lt;p&gt;The &lt;code&gt;WGPUAdapterType&lt;/code&gt; enum really is a choice among one of several options, which would be best represented as an &lt;code&gt;enum&lt;/code&gt; in Swift. If we were willing to modify the header, we could apply the &lt;code&gt;enum_extensibility&lt;/code&gt; attribute to the enum, like this:&lt;/p&gt;
    &lt;code&gt;typedef enum __attribute__((enum_extensibility(closed))) WGPUAdapterType {
    WGPUAdapterType_DiscreteGPU = 0x00000001,
    WGPUAdapterType_IntegratedGPU = 0x00000002,
    WGPUAdapterType_CPU = 0x00000003,
    WGPUAdapterType_Unknown = 0x00000004,
    WGPUAdapterType_Force32 = 0x7FFFFFFF
} WGPUAdapterType WGPU_ENUM_ATTRIBUTE;
&lt;/code&gt;
    &lt;p&gt;This works, and results in a much nicer Swift API:&lt;/p&gt;
    &lt;code&gt;@frozen public enum WGPUAdapterType : UInt32, @unchecked Sendable {
    case discreteGPU = 1
    case integratedGPU = 2
    case CPU = 3
    case unknown = 4
    case force32 = 2147483647
}
&lt;/code&gt;
    &lt;p&gt;Now, we get an &lt;code&gt;enum&lt;/code&gt; that we can switch over, and nice short case names, e.g.,&lt;/p&gt;
    &lt;code&gt;switch adapterType {
  case .discreteGPU, .integratedGPU:
    print("definitely a GPU")
  default:
    print("not so sure")
}
&lt;/code&gt;
    &lt;p&gt;That’s great, but I already broke my rule: no header modifications unless I have to!&lt;/p&gt;
    &lt;head rend="h2"&gt;API notes&lt;/head&gt;
    &lt;p&gt;The problem of needing to layer information on top of existing C headers is not a new one. As noted earlier, Swift relies on a Clang feature called API notes to let us express this same information in a separate file, so we don’t have to edit the header. In this case, we create a file called &lt;code&gt;WebGPU.apinotes&lt;/code&gt; (the name &lt;code&gt;WebGPU&lt;/code&gt; matches the module name from &lt;code&gt;module.modulemap&lt;/code&gt;), which is a YAML file describing the extra information. We’ll start with one that turns &lt;code&gt;WGPUAdapterType&lt;/code&gt; into an &lt;code&gt;enum&lt;/code&gt;:&lt;/p&gt;
    &lt;code&gt;---
Name: WebGPU
Tags:
- Name: WGPUAdapterType
  EnumExtensibility: closed
&lt;/code&gt;
    &lt;p&gt;&lt;code&gt;Tags&lt;/code&gt; here is a term used in the C and C++ standard to refer to enum, struct, union, or class types. Any information about those types in the API notes file will go into that section.&lt;/p&gt;
    &lt;p&gt;Put &lt;code&gt;WebGPU.apinotes&lt;/code&gt; alongside the &lt;code&gt;module.modulemap&lt;/code&gt;, and now &lt;code&gt;WGPUAdapterType&lt;/code&gt; gets mapped into a &lt;code&gt;Swift&lt;/code&gt; enum. For a package, the structure will look like this:&lt;/p&gt;
    &lt;code&gt;├── Package.swift
└── Sources
    └── WebGPU
        ├── include
        │   ├── webgpu.h
        │   ├── WebGPU.apinotes
        │   └── module.modulemap
        └── WebGPU.c (empty file)
&lt;/code&gt;
    &lt;p&gt;We’ll be adding more to this API notes file as we keep digging through the interface.&lt;/p&gt;
    &lt;head rend="h2"&gt;Reference-counted object types&lt;/head&gt;
    &lt;p&gt;The WebGPU header has a number of “object” types that are defined like this:&lt;/p&gt;
    &lt;code&gt;typedef struct WGPUBindGroupImpl* WGPUBindGroup WGPU_OBJECT_ATTRIBUTE;
&lt;/code&gt;
    &lt;p&gt;This gets imported into Swift as an alias for an opaque pointer type, which is… not great:&lt;/p&gt;
    &lt;code&gt;public typealias WGPUBindGroup = OpaquePointer
&lt;/code&gt;
    &lt;p&gt;WebGPU object types are reference counted, and each object type has corresponding &lt;code&gt;AddRef&lt;/code&gt; and &lt;code&gt;Release&lt;/code&gt; functions to increment and decrement the reference count, like this:&lt;/p&gt;
    &lt;code&gt;WGPU_EXPORT void wgpuBindGroupAddRef(WGPUBindGroup bindGroup) WGPU_FUNCTION_ATTRIBUTE;
WGPU_EXPORT void wgpuBindGroupRelease(WGPUBindGroup bindGroup) WGPU_FUNCTION_ATTRIBUTE;
&lt;/code&gt;
    &lt;p&gt;Of course, you can use these functions in Swift exactly how you do in C, making sure to balance out calls to &lt;code&gt;AddRef&lt;/code&gt; and &lt;code&gt;Release&lt;/code&gt;, but then it would be every bit as unsafe as C.&lt;/p&gt;
    &lt;p&gt;We can do better with &lt;code&gt;SWIFT_SHARED_REFERENCE&lt;/code&gt;. It’s a macro (defined in the &lt;code&gt;&amp;lt;swift/bridging&amp;gt;&lt;/code&gt; header) that can turn a reference-counted C type like the above into an automatically reference-counted &lt;code&gt;class&lt;/code&gt; in Swift. Here’s how we would use it in the header:&lt;/p&gt;
    &lt;code&gt;typedef struct SWIFT_SHARED_REFERENCE(wgpuBindGroupAddRef, wgpuBindGroupRelease) WGPUBindGroupImpl* WGPUBindGroup WGPU_OBJECT_ATTRIBUTE;
&lt;/code&gt;
    &lt;p&gt;Now, &lt;code&gt;WGPUBindGroup&lt;/code&gt; gets imported like this:&lt;/p&gt;
    &lt;code&gt;public class WGPUBindGroupImpl { }
public typealias WGPUBindGroup = WGPUBindGroupImpl
&lt;/code&gt;
    &lt;p&gt;The extra typealias is a little unexpected, but overall this is a huge improvement: Swift is treating &lt;code&gt;WGPUBindGroup&lt;/code&gt; as a class, meaning that it automatically manages retains and releases for you! This is both an ergonomic win (less code to write) and a safety win, because it’s eliminated the possibility of mismanaging these instances.&lt;/p&gt;
    &lt;p&gt;There’s one more thing: when dealing with reference-counting APIs, you need to know whether a particular function that returns an object is expecting you to call “release” when you’re done. In the WebGPU header, this information is embedded in a comment:&lt;/p&gt;
    &lt;code&gt;/**
 * @returns
 * This value is @ref ReturnedWithOwnership.
 */
WGPU_EXPORT WGPUBindGroup wgpuDeviceCreateBindGroup(WGPUDevice device, WGPUBindGroupDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;
&lt;/code&gt;
    &lt;p&gt;“ReturnedWithOwnership” here means that the result of the call has already been retained one extra time, and the caller is responsible for calling “release” when they are done with it. The &lt;code&gt;&amp;lt;swift/bridging&amp;gt;&lt;/code&gt; header has a &lt;code&gt;SWIFT_RETURNS_RETAINED&lt;/code&gt; macro that expresses this notion. One can use it like this:&lt;/p&gt;
    &lt;code&gt;WGPU_EXPORT WGPUBindGroup wgpuDeviceCreateBindGroup(WGPUDevice device, WGPUBindGroupDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE SWIFT_RETURNS_RETAINED;
&lt;/code&gt;
    &lt;p&gt;Now, Swift will balance out the retain that &lt;code&gt;wgpuDeviceCreateBindGroup&lt;/code&gt; has promised to do by performing the extra release once you’re done using the object. Once these annotations are done, we’re all set with a more ergonomic and memory-safe API for this C library. There’s no need to ever call &lt;code&gt;wgpuBindGroupRelease&lt;/code&gt; or &lt;code&gt;wgpuBindGroupAddRef&lt;/code&gt; yourself.&lt;/p&gt;
    &lt;p&gt;We’ve hacked up our header again, so let’s undo that and move all of this out to API notes. To turn a type into a foreign reference type, we augment the &lt;code&gt;Tags&lt;/code&gt; section of our API notes with the same information, but in YAML form:&lt;/p&gt;
    &lt;code&gt;- Name: WGPUBindGroupImpl
  SwiftImportAs: reference
  SwiftReleaseOp: wgpuBindGroupRelease
  SwiftRetainOp: wgpuBindGroupAddRef
&lt;/code&gt;
    &lt;p&gt;That makes &lt;code&gt;WGPUBindGroupImpl&lt;/code&gt; import as a class type, with the given retain and release functions. We can express the “returns retained” behavior of the &lt;code&gt;wgpuDeviceCreateBindGroup&lt;/code&gt; function like this:&lt;/p&gt;
    &lt;code&gt;Functions:
- Name: wgpuDeviceCreateBindGroup
  SwiftReturnOwnership: retained
&lt;/code&gt;
    &lt;p&gt;That’s enums and classes, so now let’s tackle… functions.&lt;/p&gt;
    &lt;head rend="h2"&gt;Importing functions&lt;/head&gt;
    &lt;p&gt;A typical function from &lt;code&gt;webgpu.h&lt;/code&gt;, like this:&lt;/p&gt;
    &lt;code&gt;WGPU_EXPORT void wgpuQueueWriteBuffer(
    WGPUQueue queue, WGPUBuffer buffer, uint64_t bufferOffset, 
    void const * data, size_t size
) WGPU_FUNCTION_ATTRIBUTE;
&lt;/code&gt;
    &lt;p&gt;will come into Swift like this:&lt;/p&gt;
    &lt;code&gt;public func wgpuQueueWriteBuffer(_ queue: WGPUQueue!, _ buffer: WGPUBuffer!, _ bufferOffset: UInt64, _ data: UnsafeRawPointer!, _ size: Int)
&lt;/code&gt;
    &lt;p&gt;Note that &lt;code&gt;_&lt;/code&gt; on each parameter, which means that we won’t use argument labels for anything when we call it:&lt;/p&gt;
    &lt;code&gt;wgpuQueueWriteBuffer(myQueue, buffer, position, dataToWrite, bytesToWrite)
&lt;/code&gt;
    &lt;p&gt;That matches C, but it isn’t as clear as it could be in Swift. Let’s clean this up by providing a better name in Swift that includes argument labels. We can do so using &lt;code&gt;SWIFT_NAME&lt;/code&gt; (also in &lt;code&gt;&amp;lt;swift/bridging&amp;gt;&lt;/code&gt;), like this:&lt;/p&gt;
    &lt;code&gt;WGPU_EXPORT void wgpuQueueWriteBuffer(
      WGPUQueue queue, WGPUBuffer buffer, uint64_t bufferOffset,
      void const * data, size_t size
  ) WGPU_FUNCTION_ATTRIBUTE 
    SWIFT_NAME("wgpuQueueWriteBuffer(_:buffer:bufferOffset:data:size:)");
&lt;/code&gt;
    &lt;p&gt;Within the parentheses, we have each of the argument labels that we want (or &lt;code&gt;_&lt;/code&gt; meaning “no label”), each followed by a &lt;code&gt;:&lt;/code&gt;. This is how one describes a full function name in Swift. Once we’ve made this change to the Swift name, the C function comes into Swift with argument labels, like this:&lt;/p&gt;
    &lt;code&gt;public func wgpuQueueWriteBuffer(_ queue: WGPUQueue!, buffer: WGPUBuffer!, bufferOffset: UInt64, data: UnsafeRawPointer!, size: Int)
&lt;/code&gt;
    &lt;p&gt;That makes the call site more clear and self-documenting:&lt;/p&gt;
    &lt;code&gt;wgpuQueueWriteBuffer(myQueue, buffer: buffer, offset: position, data: dataToWrite, size: bytesToWrite)
&lt;/code&gt;
    &lt;head rend="h3"&gt;Importing functions as methods&lt;/head&gt;
    &lt;p&gt;There is more usable structure in this API. Note that the &lt;code&gt;wgpuQueueWriteBuffer&lt;/code&gt; function takes, as its first argument, an instance of &lt;code&gt;WGPUQueue&lt;/code&gt;. Most of the C functions in &lt;code&gt;WebGPU.h&lt;/code&gt; are like this, because these are effectively functions that operate on their first argument. In a language that has methods, they would be methods. Swift has methods, so let’s make them methods!&lt;/p&gt;
    &lt;code&gt;WGPU_EXPORT void wgpuQueueWriteBuffer(
      WGPUQueue queue, WGPUBuffer buffer, uint64_t bufferOffset, void const * data, size_t size) 
  WGPU_FUNCTION_ATTRIBUTE SWIFT_NAME("WGPUQueueImpl.writeBuffer(self:buffer:bufferOffset:data:size:)");
&lt;/code&gt;
    &lt;p&gt;There are three things to notice about this &lt;code&gt;SWIFT_NAME&lt;/code&gt; string:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;It starts with &lt;code&gt;WGPUQueueImpl.&lt;/code&gt;, which tells Swift to make this function a member inside&lt;code&gt;WGPUQueueImpl&lt;/code&gt;.&lt;/item&gt;
      &lt;item&gt;Let’s change the function name to &lt;code&gt;writeBuffer&lt;/code&gt;, because we no longer need the&lt;code&gt;wgpuQueue&lt;/code&gt;prefix to distinguish it from other “write buffer” operations on other types.&lt;/item&gt;
      &lt;item&gt;The name of the first argument in parentheses is &lt;code&gt;self&lt;/code&gt;, which indicates that the&lt;code&gt;self&lt;/code&gt;argument (in Swift) should be passed as that positional argument to the C function. The other arguments are passed in-order.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Note that this also requires &lt;code&gt;WGPUQueue(Impl)&lt;/code&gt; to be imported as a &lt;code&gt;class&lt;/code&gt;, as we did earlier for &lt;code&gt;WGPUBindGroupImpl&lt;/code&gt;. Once we’ve done so, we get a much-nicer Swift API:&lt;/p&gt;
    &lt;code&gt;extension WGPUQueueImpl {
  /**
   * Produces a @ref DeviceError both content-timeline (`size` alignment) and d
evice-timeline
   * errors defined by the WebGPU specification.
   */
  public func writeBuffer(buffer: WGPUBuffer!, bufferOffset: UInt64, data: UnsafeRawPointer!, size: Int)
}
&lt;/code&gt;
    &lt;p&gt;We’ve hacked up the header again, but didn’t have to. In &lt;code&gt;WebGPU.apinotes&lt;/code&gt;, you can put a &lt;code&gt;SwiftName&lt;/code&gt; attribute on any entity. For &lt;code&gt;wgpuQueueWriteBuffer&lt;/code&gt;, it would look like this (in the &lt;code&gt;Functions&lt;/code&gt; section):&lt;/p&gt;
    &lt;code&gt;- Name: wgpuQueueWriteBuffer
  SwiftName: WGPUQueueImpl.writeBuffer(self:buffer:bufferOffset:data:size:)
&lt;/code&gt;
    &lt;head rend="h3"&gt;Importing functions as properties&lt;/head&gt;
    &lt;p&gt;&lt;code&gt;WebGPU.h&lt;/code&gt; has a number of &lt;code&gt;Get&lt;/code&gt; functions that produce information about some aspect of a type. Here are two for the &lt;code&gt;WGPUQuerySet&lt;/code&gt; type:&lt;/p&gt;
    &lt;code&gt;WGPU_EXPORT uint32_t wgpuQuerySetGetCount(WGPUQuerySet querySet) WGPU_FUNCTION_ATTRIBUTE;
WGPU_EXPORT WGPUQueryType wgpuQuerySetGetType(WGPUQuerySet querySet) WGPU_FUNCTION_ATTRIBUTE;
&lt;/code&gt;
    &lt;p&gt;With the &lt;code&gt;SWIFT_NAME&lt;/code&gt; tricks above, we can turn these into “get” methods on &lt;code&gt;WGPUQuerySet&lt;/code&gt;, like this:&lt;/p&gt;
    &lt;code&gt;extension WGPUQuerySetImpl {
    public func getCount() -&amp;gt; UInt32
    public func getType() -&amp;gt; WGPUQueryType
}
&lt;/code&gt;
    &lt;p&gt;That’s okay, but it’s not what you’d do in Swift. Let’s go one step further and turn them into read-only computed properties. To do so, use the &lt;code&gt;getter:&lt;/code&gt; prefix on the Swift name we define. We’ll skip ahead to the YAML form that goes into API notes:&lt;/p&gt;
    &lt;code&gt;- Name: wgpuQuerySetGetCount
  SwiftName: getter:WGPUQuerySetImpl.count(self:)
- Name: wgpuQuerySetGetType
  SwiftName: getter:WGPUQuerySetImpl.type(self:)
&lt;/code&gt;
    &lt;p&gt;And now, we arrive at a nice Swift API:&lt;/p&gt;
    &lt;code&gt;extension WGPUQuerySetImpl {
    public var count: UInt32 { get }
    public var type: WGPUQueryType { get }
}
&lt;/code&gt;
    &lt;head rend="h3"&gt;Importing functions as initializers&lt;/head&gt;
    &lt;p&gt;&lt;code&gt;SWIFT_NAME&lt;/code&gt; can also be used to import a function that returns a new instance as a Swift initializer. For example, this function creates a new &lt;code&gt;WGPUInstance&lt;/code&gt; (which we assume is getting imported as a &lt;code&gt;class&lt;/code&gt; like we’ve been doing above):&lt;/p&gt;
    &lt;code&gt;/**
 * Create a WGPUInstance
 *
 * @returns
 * This value is @ref ReturnedWithOwnership.
 */
WGPU_EXPORT WGPUInstance wgpuCreateInstance(WGPU_NULLABLE WGPUInstanceDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;
&lt;/code&gt;
    &lt;p&gt;We can turn this into a Swift initializer, which is used to create a new object, using the same &lt;code&gt;SWIFT_NAME&lt;/code&gt; syntax but where the method name is &lt;code&gt;init&lt;/code&gt;. Here is the YAML form that goes into API notes:&lt;/p&gt;
    &lt;code&gt;- Name: wgpuCreateInstance
  SwiftReturnOwnership: retained
  SwiftName: WGPUInstanceImpl.init(descriptor:)
&lt;/code&gt;
    &lt;p&gt;and here is the resulting Swift initializer:&lt;/p&gt;
    &lt;code&gt;extension WGPUInstanceImpl {
    /**
     * Create a WGPUInstance
     *
     * @returns
     * This value is @ref ReturnedWithOwnership.
     */
    public /*not inherited*/ init!(descriptor: UnsafePointer&amp;lt;WGPUInstanceDescriptor&amp;gt;!)
}
&lt;/code&gt;
    &lt;p&gt;Now, one can create a new &lt;code&gt;WGPUInstance&lt;/code&gt; with the normal object-creation syntax, e.g.,&lt;/p&gt;
    &lt;code&gt;let instance = WGPUInstance(descriptor: myDescriptor)
&lt;/code&gt;
    &lt;head rend="h2"&gt;Another Boolean type?&lt;/head&gt;
    &lt;p&gt;The WebGPU header defines its own Boolean type. I wish everyone would use C99’s &lt;code&gt;_Bool&lt;/code&gt; and be done with it, but alas, here are the definitions for WebGPUs Boolean types:&lt;/p&gt;
    &lt;code&gt;#define WGPU_TRUE (UINT32_C(1))
#define WGPU_FALSE (UINT32_C(0))
typedef uint32_t WGPUBool;
&lt;/code&gt;
    &lt;p&gt;This means that &lt;code&gt;WGPUBool&lt;/code&gt; will come in to Swift as a &lt;code&gt;UInt32&lt;/code&gt;. The two macros aren’t available in Swift at all: they’re “too complicated” to be recognized as integral constants. Even if they were available in Swift, it still wouldn’t be great because we want to use &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; for Boolean values in Swift, not &lt;code&gt;WGPU_TRUE&lt;/code&gt; and &lt;code&gt;WGPU_FALSE&lt;/code&gt;.&lt;/p&gt;
    &lt;p&gt;To make &lt;code&gt;WGPUBool&lt;/code&gt; easier to use from Swift, we’re first going to map that typedef to its own &lt;code&gt;struct&lt;/code&gt; that stores the underlying &lt;code&gt;UInt32&lt;/code&gt;, giving it an identity separate from &lt;code&gt;UInt32&lt;/code&gt;. We can do this using a &lt;code&gt;SwiftWrapper&lt;/code&gt; API note within the &lt;code&gt;Typedefs&lt;/code&gt; section of the file, like this:&lt;/p&gt;
    &lt;code&gt;- Name: WGPUBool
  SwiftWrapper: struct
&lt;/code&gt;
    &lt;p&gt;Now, we get &lt;code&gt;WGPUBool&lt;/code&gt; imported like this:&lt;/p&gt;
    &lt;code&gt;public struct WGPUBool : Hashable, Equatable, RawRepresentable {
    public init(_ rawValue: UInt32)
    public init(rawValue: UInt32)
}
&lt;/code&gt;
    &lt;p&gt;To be able to use &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; literals with this new &lt;code&gt;WGPUBool&lt;/code&gt;, we can write a little bit of Swift code that makes this type conform to the &lt;code&gt;ExpressibleByBooleanLiteral&lt;/code&gt; protocol, like this:&lt;/p&gt;
    &lt;code&gt;extension WGPUBool: ExpressibleByBooleanLiteral {
  init(booleanLiteral value: Bool) {
    self.init(rawValue: value ? 1 : 0)
  }
}
&lt;/code&gt;
    &lt;p&gt;That’s it! Better type safety (you cannot confuse a &lt;code&gt;WGPUBool&lt;/code&gt; with any other integer value) and the convenience of Boolean literals in Swift.&lt;/p&gt;
    &lt;head rend="h2"&gt;Option sets&lt;/head&gt;
    &lt;p&gt;&lt;code&gt;webgpu.h&lt;/code&gt; describes a set of flags using a &lt;code&gt;typedef&lt;/code&gt; of the &lt;code&gt;WGPUFlags&lt;/code&gt; type (a 64-bit unsigned integer) along with a set of global constants for the different flag values. For example, here is the &lt;code&gt;WGPUBufferUsage&lt;/code&gt; flag type and some of its constants:&lt;/p&gt;
    &lt;code&gt;typedef WGPUFlags WGPUBufferUsage;
static const WGPUBufferUsage WGPUBufferUsage_MapRead = 0x0000000000000001;
static const WGPUBufferUsage WGPUBufferUsage_MapWrite = 0x0000000000000002;
static const WGPUBufferUsage WGPUBufferUsage_CopySrc = 0x0000000000000004;
static const WGPUBufferUsage WGPUBufferUsage_Index = 0x0000000000000010;
&lt;/code&gt;
    &lt;p&gt;Similar to what we saw with &lt;code&gt;WGPUBool&lt;/code&gt;, &lt;code&gt;WGPUBufferUsage&lt;/code&gt; is a &lt;code&gt;typedef&lt;/code&gt; of a &lt;code&gt;typedef&lt;/code&gt; of a &lt;code&gt;uint64_t&lt;/code&gt;. There’s no type safety in this C API, and one could easily mix up these flags with, say, those of &lt;code&gt;WGPUMapMode&lt;/code&gt;:&lt;/p&gt;
    &lt;code&gt;typedef WGPUFlags WGPUMapMode;
static const WGPUMapMode WGPUMapMode_Read = 0x0000000000000001;
static const WGPUMapMode WGPUMapMode_Write = 0x0000000000000002;
&lt;/code&gt;
    &lt;p&gt;We can do better, by layering more structure for the Swift version of this API using the same &lt;code&gt;SwiftWrapper&lt;/code&gt; approach from &lt;code&gt;WGPUBool&lt;/code&gt;. This goes into the &lt;code&gt;Typedefs&lt;/code&gt; section of API notes:&lt;/p&gt;
    &lt;code&gt;Typedefs:
- Name: WGPUBufferUsage
  SwiftWrapper: struct
&lt;/code&gt;
    &lt;p&gt;Now, &lt;code&gt;WGPUBufferUsage&lt;/code&gt; comes in as its own &lt;code&gt;struct&lt;/code&gt;:&lt;/p&gt;
    &lt;code&gt;public struct WGPUBufferUsage : Hashable, Equatable, RawRepresentable {
    public init(_ rawValue: WGPUFlags)
    public init(rawValue: WGPUFlags)
}
&lt;/code&gt;
    &lt;p&gt;The initializers let you create a &lt;code&gt;WGPUBufferUsage&lt;/code&gt; from a &lt;code&gt;WGPUFlags&lt;/code&gt; value, and there is also a &lt;code&gt;rawValue&lt;/code&gt; property to get a &lt;code&gt;WGPUFlags&lt;/code&gt; value out of a &lt;code&gt;WGPUBufferInstance&lt;/code&gt;, so the raw value is always there… but the default is to be type safe. Additionally, those global constants will come in as members of &lt;code&gt;WGPUBufferUsage&lt;/code&gt;, like this:&lt;/p&gt;
    &lt;code&gt;extension WGPUBufferUsage {
    /**
     * The buffer can be *mapped* on the CPU side in *read* mode (using @ref WGPUMapMode_Read).
     */
    public static var _MapRead: WGPUBufferUsage { get }

    /**
     * The buffer can be *mapped* on the CPU side in *write* mode (using @ref WGPUMapMode_Write).
     *
     * @note This usage is **not** required to set `mappedAtCreation` to `true` in @ref WGPUBufferDescriptor.
     */
    public static var _MapWrite: WGPUBufferUsage { get }

    /**
     * The buffer can be used as the *source* of a GPU-side copy operation.
     */
    public static var _CopySrc: WGPUBufferUsage { get }

    /**
     * The buffer can be used as the *destination* of a GPU-side copy operation.
     */
    public static var _CopyDst: WGPUBufferUsage { get }
}
&lt;/code&gt;
    &lt;p&gt;This means that, if you’re passing a value of type &lt;code&gt;WPUBufferUsage&lt;/code&gt;, you can use the shorthand “leading dot” syntax. For example:&lt;/p&gt;
    &lt;code&gt;func setBufferUsage(_ usage: WGPUBufferUsage) { ... }

setBufferUsage(._MapRead)
&lt;/code&gt;
    &lt;p&gt;Swift has dropped the common &lt;code&gt;WPUBufferUsage&lt;/code&gt; prefix from the constants when it made them into members. However, the resulting names aren’t great. We can rename them by providing a &lt;code&gt;SwiftName&lt;/code&gt; in the API notes file within the &lt;code&gt;Globals&lt;/code&gt; section:&lt;/p&gt;
    &lt;code&gt;Globals:
- Name: WGPUBufferUsage_MapRead
  SwiftName: WGPUBufferUsage.mapRead
- Name: WGPUBufferUsage_MapWrite
  SwiftName: WGPUBufferUsage.mapWrite
&lt;/code&gt;
    &lt;p&gt;We can go one step further by making the &lt;code&gt;WGPUBufferUsage&lt;/code&gt; type conform to Swift’s &lt;code&gt;OptionSet&lt;/code&gt; protocol. If we revise the API notes like this:&lt;/p&gt;
    &lt;code&gt;Typedefs:
- Name: WGPUBufferUsage
  SwiftWrapper: struct
  SwiftConformsTo: Swift.OptionSet
&lt;/code&gt;
    &lt;p&gt;Now, we get the nice option-set syntax we expect in Swift:&lt;/p&gt;
    &lt;code&gt;let usageFlags: WGPUBufferUsage = [.mapRead, .mapWrite]
&lt;/code&gt;
    &lt;head rend="h2"&gt;Nullability&lt;/head&gt;
    &lt;p&gt;Throughout &lt;code&gt;webgpu.h&lt;/code&gt;, the &lt;code&gt;WGPU_NULLABLE&lt;/code&gt; macro is used to indicate pointers that can be NULL. The implication is that any pointer that is not marked with &lt;code&gt;WGPU_NULLABLE&lt;/code&gt; cannot be NULL. For example, here is the definition of &lt;code&gt;wgpuCreateInstance&lt;/code&gt; we used above:&lt;/p&gt;
    &lt;code&gt;WGPU_EXPORT WGPUInstance wgpuCreateInstance(WGPU_NULLABLE WGPUInstanceDescriptor const * descriptor) WGPU_FUNCTION_ATTRIBUTE;
&lt;/code&gt;
    &lt;p&gt;The &lt;code&gt;WGPU_NULLABLE&lt;/code&gt; indicates that it’s acceptable to pass a NULL pointer in as the &lt;code&gt;descriptor&lt;/code&gt; parameter. Clang already has nullability specifiers to express this information. We could alter the declaration in the header to express that this parameter is nullable but the result type is never NULL, like this:&lt;/p&gt;
    &lt;code&gt;WGPU_EXPORT WGPUInstance _Nonnull wgpuCreateInstance(WGPU_NULLABLE WGPUInstanceDescriptor const * _Nullable descriptor) WGPU_FUNCTION_ATTRIBUTE;
&lt;/code&gt;
    &lt;p&gt;This eliminates the implicitly-unwrapped optionals (&lt;code&gt;!&lt;/code&gt;) from the signature of the initializer, so we end up with one that explicitly accepts a &lt;code&gt;nil&lt;/code&gt; descriptor argument and always returns a new instance (never &lt;code&gt;nil&lt;/code&gt;):&lt;/p&gt;
    &lt;code&gt;extension WGPUInstanceImpl {
    /**
     * Create a WGPUInstance
     *
     * @returns
     * This value is @ref ReturnedWithOwnership.
     */
    public /*not inherited*/ init(descriptor: UnsafePointer&amp;lt;WGPUInstanceDescriptor&amp;gt;?)
}
&lt;/code&gt;
    &lt;p&gt;Now, I did cheat by hacking the header. Instead, we can express this with API notes on the parameters and result type by extending the entry we already have for &lt;code&gt;wgpuCreateInstance&lt;/code&gt; like this:&lt;/p&gt;
    &lt;code&gt;- Name: wgpuCreateInstance
  SwiftReturnOwnership: retained
  SwiftName: WGPUInstanceImpl.init(descriptor:)
  Parameters:
  - Position: 0
    Nullability: O
  ResultType: "WGPUInstance _Nonnull"
&lt;/code&gt;
    &lt;p&gt;To specific nullability of pointer parameters, one can identify them by position (where 0 is the first parameter to the function) and then specify whether the parameter should come into Swift as optional (&lt;code&gt;O&lt;/code&gt;, corresponds to &lt;code&gt;_Nullable&lt;/code&gt;), non-optional (&lt;code&gt;N&lt;/code&gt;, corresponds to &lt;code&gt;_Nonnull&lt;/code&gt;) or by left unspecified as an implicitly-unwrapped optional (&lt;code&gt;U&lt;/code&gt;, corresponds to &lt;code&gt;_Null_unspecified&lt;/code&gt;). For the result type, it’s a little different: we specified the result type along with the nullability specifier, i.e., &lt;code&gt;WGPUInstance _Nonnull&lt;/code&gt;. The end result of these annotations is the same as the modified header, so we can layer nullability information on top of the header.&lt;/p&gt;
    &lt;head rend="h2"&gt;Scripting the creation of &lt;code&gt;WebGPU.apinotes&lt;/code&gt; WebGPU.apinotes section" href="#scripting-the-creation-of-webgpuapinotes"&amp;gt;
             
          &lt;/head&gt;
    &lt;p&gt;&lt;code&gt;webgpu.h&lt;/code&gt; is about 6,400 lines long, and is regenerated from a database of the API as needed. Each of the WebGPU implementations seems to augment or tweak the header a bit. So, rather than grind through and manually do annotations, I wrote a little Swift script to “parse” &lt;code&gt;webgpu.h&lt;/code&gt;, identify its patterns, and generate &lt;code&gt;WebGPU.apinotes&lt;/code&gt; for most of what is discussed in this post. The entirety of the script is here. It reads &lt;code&gt;webgpu.h&lt;/code&gt; from standard input and prints &lt;code&gt;WebGPU.apinotes&lt;/code&gt; to standard output.&lt;/p&gt;
    &lt;p&gt;Because &lt;code&gt;webgpu.h&lt;/code&gt; is generated, it has a very regular structure that we can pick up on via regular expressions. For example:&lt;/p&gt;
    &lt;code&gt;// Enum definitions, marked by WGPU_ENUM_ATTRIBUTE.
let enumMatcher = /} (?&amp;lt;name&amp;gt;\w+?) WGPU_ENUM_ATTRIBUTE/

// Object definitions, marked by WGPU_OBJECT_ATTRIBUTE.
let objectMatcher = /typedef struct (?&amp;lt;implName&amp;gt;\w+?)\* (?&amp;lt;name&amp;gt;\w+?) WGPU_OBJECT_ATTRIBUTE;/

// Function declarations, marked by WGPU_FUNCTION_ATTRIBUTE
let functionMatcher = /WGPU_EXPORT (?&amp;lt;nullableResult&amp;gt;WGPU_NULLABLE ?)?(?&amp;lt;resultType&amp;gt;\w+?) (?&amp;lt;name&amp;gt;\w+?)\((?&amp;lt;parameters&amp;gt;.*\)?) WGPU_FUNCTION_ATTRIBUTE;/
let parameterMatcher = /(?&amp;lt;type&amp;gt;[^),]+?) (?&amp;lt;name&amp;gt;\w+?)[),]/
&lt;/code&gt;
    &lt;p&gt;That’s enough to identify all of the enum types (so we can emit the &lt;code&gt;EnumExtensibility: closed&lt;/code&gt; API notes), object types (to turn them into shared references), and functions (which get nicer names and such). The script is just a big &lt;code&gt;readLine&lt;/code&gt; loop that applies the regexes to capture all of the various types and functions, then does some quick classification before printing out the API notes. The resulting API notes are in WebGPU.apinotes, and the generated Swift interface after these API notes are applied is here. You can run it with, e.g.,&lt;/p&gt;
    &lt;code&gt;swift -enable-bare-slash-regex webgpu_apinotes.swift &amp;lt; webgpu.h
&lt;/code&gt;
    &lt;p&gt;This script full of regular expressions is, admittedly, a bit of a hack. A better approach for an arbitrary C header would be to use &lt;code&gt;libclang&lt;/code&gt; to properly parse the headers. For WebGPU specifically, the webgpu-headers project contains a database from which the header is generated, and one could also generate API notes directly from that header. Regardless of how you get there, many C libraries have well-structured headers with conventions that can be leveraged to create safer, more ergonomic projections in Swift.&lt;/p&gt;
    &lt;head rend="h2"&gt;Swiftifying your favorite C library&lt;/head&gt;
    &lt;p&gt;The techniques described in this post can be applied to just about any C library. To do so, I recommend setting up a small package like the one described here for WebGPU, so you can iterate quickly on example code to get a feel for how the Swift projection of the C API will work. The annotations might not get you all the way to the best Swift API, but they are a lightweight way to get most of the way there. Feel free to also extend the C types to convenience APIs that make sense in Swift, like I did above to make &lt;code&gt;WGPUBool&lt;/code&gt; conform to &lt;code&gt;ExpressibleByBooleanLiteral&lt;/code&gt;.&lt;/p&gt;
    &lt;p&gt;A little bit of annotation work on your favorite C library can make for a safer, more ergonomic, more Swifty experience of working with that library.&lt;/p&gt;
    &lt;head rend="h2"&gt;Postscript: Thoughts for improving the generated webgpu.h&lt;/head&gt;
    &lt;p&gt;The regular structure of &lt;code&gt;webgpu.h&lt;/code&gt; helped considerably when trying to expose the API nicely in Swift. That said, there are a few ways in which &lt;code&gt;webgpu.h&lt;/code&gt; could be improved to require less annotation for this purpose:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;WGPU_ENUM_ATTRIBUTE&lt;/code&gt;would be slightly nicer if placed on the&lt;code&gt;enum&lt;/code&gt;itself, rather than on the&lt;code&gt;typedef&lt;/code&gt;. If it were there, we could use&lt;code&gt;#define WGPU_ENUM_ATTRIBUTE __attribute__((enum_extensibility(closed)))&lt;/code&gt;&lt;p&gt;and not have to generate any API notes to bring these types in as proper enums in Swift.&lt;/p&gt;&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;WGPU_OBJECT_ATTRIBUTE&lt;/code&gt;could provide the names of the retain and release operations and be placed on the&lt;code&gt;struct&lt;/code&gt;itself. If it were there, we could use&lt;code&gt;#define WGPU_OBJECT_ATTRIBUTE(RetainFn,ReleaseFn) SWIFT_SHARED_REFERENCE(RetainFn,ReleaseFn)&lt;/code&gt;&lt;p&gt;and not have to generate any API notes to bring these types in as classes in Swift.&lt;/p&gt;&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;WGPU_NULLABLE&lt;/code&gt;could be placed on the pointer itself (i.e., after the&lt;code&gt;*&lt;/code&gt;) rather than at the beginning of the type, to match the position of Clang’s nullability attributes. If it were placed there, then&lt;code&gt;#define WGPU_NULLABLE _Nullable&lt;/code&gt;&lt;p&gt;would work with Clangs’ longstanding nullable-types support. Swift would then import such pointers as optional types (with&lt;/p&gt;&lt;code&gt;?&lt;/code&gt;). Moreover, if some macros&lt;code&gt;WGPU_ASSUME_NONNULL_BEGIN&lt;/code&gt;and&lt;code&gt;WGPU_ASSUME_NONNULL_END&lt;/code&gt;were placed at the beginning and end of the header, they could be mapped to Clang’s pragmas to assume that any pointer not marked “nullable” is always non-null:&lt;code&gt;#define WGPU_ASSUME_NONNULL_BEGIN #pragma clang assume_nonnull begin #define WGPU_ASSUME_NONNULL_END #pragma clang assume_nonnull end&lt;/code&gt;&lt;p&gt;This would eliminate all of the implicitly unwrapped optionals (marked&lt;/p&gt;&lt;code&gt;!&lt;/code&gt;in the Swift interface), making it easier to use safely.&lt;/item&gt;
    &lt;/list&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=46726526</guid><pubDate>Thu, 22 Jan 2026 23:34:44 +0000</pubDate></item><item><title>Why medieval city-builder video games are historically inaccurate (2020)</title><link>https://www.leidenmedievalistsblog.nl/articles/why-medieval-city-builder-video-games-are-historically-inaccurate</link><description>&lt;doc fingerprint="b302597347b4065b"&gt;
  &lt;main&gt;
    &lt;head rend="h1"&gt;Why medieval city-builder video games are historically inaccurate&lt;/head&gt;
    &lt;p&gt;This blog post explores the historical accuracy of medieval city-builder video games.&lt;/p&gt;
    &lt;head rend="h3"&gt;Introduction&lt;/head&gt;
    &lt;p&gt;Since many of us are working from home in these trying times, it seems safe to assume that more people than ever are indulging in playing the occasional computer game. A city builder is a specific kind of computer game in which you design a city, extract resources, set up production chains and ensure that your settlement grows. City builders are very similar to strategy games as they reward patience and strategy. In this article, I will take a look at one sub-genre of the city builder, the medieval city builder, and explain how this gaming genre relates to our knowledge of medieval settlement planning.&lt;/p&gt;
    &lt;head rend="h3"&gt;Historical city builders&lt;/head&gt;
    &lt;p&gt;The city builder has its origins far back in the 1990s in the combination of the strategy genre and the management genre, leading to games such as Sim City (1989), Caesar (1992) and Age of Empires (1997).&lt;/p&gt;
    &lt;p&gt;It did not take long before medieval-themed city builders popped up. We may think of Settlers (1993) and Knights and Merchants (1998). In addition, the Anno games (1998-2019), although initially set in the 1600s basically had a medieval theme.&lt;/p&gt;
    &lt;p&gt;These games often start with plopping down a village center on a promising location near abundant resources. You then continue to gather these resources which grant you building materials for building new homes and facilities for your settlement.&lt;/p&gt;
    &lt;p&gt;Setting up specialized production chains might involve growing grain, milling the grain for flour and turning the flour into bread which feeds your villages. Similarly, another production chain might involve rearing sheep for their wool, turning the wool into cloth and turning the cloth into clothing. When done correctly, the reward of correct investments and planning is that you see your settlement grow.&lt;/p&gt;
    &lt;p&gt;This often leads to settlements growing organically from a couple of houses around a community center to a larger settlement with hundreds of people. However logical such an organic growth of a settlement might seem, it is not historically accurate.&lt;/p&gt;
    &lt;head rend="h3"&gt;Medieval village life &lt;/head&gt;
    &lt;p&gt;&lt;lb/&gt;Any gameplay loop that tells a story of linear settlement growth is incongruent with how a medieval economy worked (see Foussier 2004). Medieval villagers were often living on the edge of subsistence. Agricultural surpluses were skimmed by the church and the feudal lords. Bad harvests, banditry, warfare and disease might decimate a village community at any time. For this very reason, the demography of many European villages remained relatively stable between the twelfth and the eighteenth century. It may therefore be clear that the gameplay loop of city builders pivots around the concept of doing the historically exceptional (i.e. growing a settlement to a town) and thereby strays far from what actually happened in the lives of our medieval forebears. &lt;lb/&gt;A notable exception to this genre trope is the game Banished (2014) in which high mortality rates and bad weather do seriously stifle any kind of linear growth. In this city builder you are constantly fighting the odds and settlement growth is not guaranteed. However, also in Banished it is your goal to overcome the stagnation and lead your settlement to expansion.&lt;/p&gt;
    &lt;p&gt;A thing that is rarely touched upon in medieval city builders is how complex village life actually was. This can be exemplified by how the community related to its overlords. Land ownership here is key. Land in the community might be owned by a lord, a local liegeman, a monastery or even directly by the duke or count. Taxes, rents and tithes were the organisational structures in which the landowner was tied to the farmers who worked the fields. Often the payment of taxes and tithes was linked to feast days and the visit of the tax collector represented a big event in the agricultural year. An interesting side note is that some obligations which the commoners had to the lord and the church (such as seigneurial duties like working a mill) might drain the community from the needed manpower for tilling the land. Furthermore, a rural community that was its own seigneury had access to a law court with sheriff, aldermen and a local militia (Middle Dutch schutterie) to fight off bandits with. Harsh capital punishments were set in place to deter anyone from raiding the farms and hamlets and the village gallows were often the first thing one saw when approaching a medieval settlement.&lt;/p&gt;
    &lt;head rend="h3"&gt;Planning a medieval settlement&lt;/head&gt;
    &lt;p&gt;But something that is much more fundamental to the theme of a settlement building game, is how medieval settlements were actually planned and grew. Landscape historians and archaeologists have acquired a lot of insight into how this worked.&lt;/p&gt;
    &lt;p&gt;Let's start with the realization that medieval settlements in their first stages of development were planned and laid out according to a specific design. In my own research into the settlement history of West-Brabant (southern Netherlands, from 1000 to 1300 CE) I have encountered the following types.&lt;/p&gt;
    &lt;p&gt;Here is a sketch of a Brabantine circular manor (Middle Dutch vroonhoeve). This is a reinforced circular homestead with moat, often next to a bend in the river, containing several farms and a fan-like plot pattern radiating out from it. Such manors were often called BORCH.&lt;/p&gt;
    &lt;p&gt;Here is a sketch of a Brabantine street settlement, often built with exploitation of nearby fenland in mind. It consists of a line of farms with associated evenly sized rectangular plots built in a line perpendicular to a raised road.&lt;/p&gt;
    &lt;p&gt;Here is a more complex exploitation village which is set up with a moated enclosed church homestead and a central meadow as its center. There is a line of farms next to the road. The arable land to the east is bordered by a ditch supplying fresh drinking water (Middle Dutch bansloot). In layout, this type represents a hybrid between the two earlier settlement types.&lt;/p&gt;
    &lt;p&gt;Let us first make clear that these different types of exploitation settlements often existed alongside each other and can be found in one and the same region. In part, the different types reflect different chronological layers but some types were also more suited to certain geographical environments than others.&lt;/p&gt;
    &lt;p&gt;So how were these settlements planned? Many medieval exploitation enterprises were initiated by a monastery or a consortium of free men who were granted permission by (or bought permission from) the feudal lord to “colonize” the wilderness.&lt;/p&gt;
    &lt;p&gt;Clearing the wooded landscape in order to create arable land was done by cutting away the trees and bushes (Middle Dutch rode) or, alternatively, burning it away in controlled fires (Middle Dutch brant).&lt;/p&gt;
    &lt;p&gt;Land surveyors sent by the lord would then measure out the block or strips that would be taken in cultivation. Strips of arable land were often 1250m deep (6 Middle Dutch voorlingen = furlongs) so that the plough could go straight in a long line before having to turn. Important blocks or strips were demarcated by hedges, earthwork, woodwork, ditches or roads. Medieval names for these blocks often survived into the modern day.&lt;/p&gt;
    &lt;p&gt;The presence of drinking water (a river or a brook) in the vicinity was an important factor in choosing the location for the settlement. The vicinity of water entailed risk and reward because flooding was an ever present danger. Floods could devastate arable land but might also fertilize it. Meadows in particular were often situated in flood areas.&lt;/p&gt;
    &lt;head rend="h3"&gt;Managing a settlement&lt;/head&gt;
    &lt;p&gt;So how was such a settlement managed? First of all, the quality of the soil had to be carefully controlled by crop rotation: specific crops were sown on different segments of the arable land with one part laying fallow to recover from the tilling (English three-field system, Dutch drieslagstelsel). The cattle and sheep were put out to pasture on the common meadows guarded by a shepherd or cowherd. Pigs were allowed to forage in the nearby forests and killed in autumn before the winter starvation set in.&lt;/p&gt;
    &lt;p&gt;Roads and rivers were important for transport of crops and livestock. These roads, some of them paved, some of them not, needed to be maintained. They were essential to the payment of the tithe, since tithe collectors assessed the harvest on the field and later collected the sheaves on the side of the road.&lt;/p&gt;
    &lt;p&gt;The buildings within the community also needed maintenance. Farmhouses, community barns and stables were made of wood and had to be rebuilt every few generations, only the name of the farm or homestead being continued.&lt;/p&gt;
    &lt;p&gt;So what kind of threats did a medieval settlement face? First of all, the weather was an important factor which dictated the success of the harvest. Storms, droughts and floods could devastate the harvest and decimate the community.&lt;/p&gt;
    &lt;p&gt;Diseases and epidemics were another danger threatening the community. The situation on the countryside was a lot better in this regard than in the medieval towns, but an epidemic could still mean the end of a village. Similarly, diseases among livestock impacted the medieval subsistence economy in a brutal way.&lt;/p&gt;
    &lt;p&gt;Then there are the consequences of medieval warfare affecting the community: Armies that passed by could plunder the village, burn the farms and execute villagers at will. Or they could also demand supplies, food and provisions as an emergency "tax"&lt;/p&gt;
    &lt;p&gt;But war also brought indirect consequences; a liege lord calling the banners and levying troops from the village community might extract a large part of the adult men. Warfare also disrupted the trade networks that supplied a village with building materials and commodities.&lt;/p&gt;
    &lt;p&gt;Then there were internal threats to the fabric of the village community. We may think of social unrest because of land disputes. Feuds could also tear a community apart with endemic vendetta’s causing death and despair. A socially unstable society was also more prone to internal accusations of heresy and witchcraft.&lt;/p&gt;
    &lt;head rend="h3"&gt;An “accurate” medieval settlement builder&lt;/head&gt;
    &lt;p&gt;So, which of the above listed features could potentially contribute to a more historically accurate computer game about medieval settlement building? First of all, it would be more realistic if the settlement could first be planned out and was not forced to "grow organically" from a community center. The first settlement phase would be a test of how “successful” a layout is in adapting to the exigencies of the terrain and the needs of the community. Only after that initial layout proved successful, further expansions can be planned.&lt;/p&gt;
    &lt;p&gt;Secondly, it would be more realistic if we could build both straight roads and curved roads, just as in Cities Skylines (2015), a modern city builder well known for its incredibly flexible layout tools. Incidentally, the tools of Cities Skylines can also be used to recreate medieval settlements, as was done by YouTube creator Play Curiously who constructed an impression of a medieval Croatian village.&lt;/p&gt;
    &lt;p&gt;Such a flexible road drawing tool can then also be used to lay out ditches, hedges and enclosures since these features were central to the medieval experience of the cultivated landscape.&lt;/p&gt;
    &lt;p&gt;Thirdly, It would be interesting to see a medieval-themed game embrace the concept of flood valleys that limit and endanger pasture and arable land. Other historical city builders such as Pharaoh (1999) and Children of the Nile (2004) already implemented this feature for their setting in Ancient Egypt. However, such a mechanic would likewise fit a medieval city builder and show the general public how medieval society dealt with seasonal flooding as well as the devastating effects that storm floods could have.&lt;/p&gt;
    &lt;p&gt;And finally, something that would, in my opinion, really add to the realism and historical flavor of a medieval-themed city builder would be the introduction of mechanisms in which agricultural surpluses are skimmed by the church and the feudal lord. Tithes, taxes and rents! Instead of merely abstracting the taxes into an income modifier or letting the player be the extractor himself, we could be shown the tax collector visiting the village, counting the sheaves by the side of the road, selecting the calves and chickens. This way, the experiences of our medieval forebears are visualized and may help to educate the public about medieval village life.&lt;/p&gt;
    &lt;head rend="h3"&gt;Why not?&lt;/head&gt;
    &lt;p&gt;There are some good reasons why city building games are not that historically accurate and instead adhere to the established formula of the city building game.&lt;/p&gt;
    &lt;p&gt;First of all, a linear growth model makes sense from a gameplay perspective, since it is rewarding to see your settlement grow.in a linear way. It fosters a feeling of progress and motivates the player to keep momentum and push through to the next expansion phase. Secondly, games are generally wary of punishing failure too harshly in order to avoid demoralizing the player. Thirdly, in order to facilitate path finding for the simulated villagers it is easier to implement a gridlike road and building system rather than an off-grid building system that allows for curvy roads. So far only Cities Skylines has managed to do this in a satisfactory way.&lt;/p&gt;
    &lt;p&gt;Lastly, for marketing purposes and recognizability, game developers generally don't stray too far from the image of the Middle Ages that the public is already acquainted with. For a medieval city builder this means windmills, industrious peasants, lots of sheep and stone castles. Things like land surveying, crop rotation and tithe collection do not fit this image and challenge the romanticized picture of the uneducated farmer in his pre-industrial environment.&lt;/p&gt;
    &lt;head rend="h3"&gt;Conclusion&lt;/head&gt;
    &lt;p&gt;Although I think medieval-themed city building games could benefit from incorporating some of the things we know about medieval settlement history into the gameplay loop, it may not be desirable for game developers to stray too far from the established formula. The idea that medieval settlements developed organically according to messy road plans is strongly imbedded in popular perception. Allowing both straight and curved road building in medieval city builders, may serve to challenge some of the stereotypes that exist about medieval village life. And if you ask me, that would be a good thing for it is an enriching experience to see the world through the eyes of our medieval forebears. One may find out that their lives were not that different after all...&lt;/p&gt;
    &lt;head rend="h3"&gt;Further reading&lt;/head&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Fossier, R. (2004). “The Rural Economy and Demographic Growth.” In: D. Luscombe &amp;amp; J. Riley-Smith (Eds.). The New Cambridge Medieval History. Cambridge: Cambridge University Press, 11-46.&lt;/item&gt;
      &lt;item&gt;Van Ham, W. (1979). “Dorp en dorpsleven in middeleeuws Wouw." in: A. Delahaye (red.), De Heren XVII van Nassau-Brabant, 316-336.”&lt;/item&gt;
      &lt;item&gt;(forthc.) Kerkhof, P.A. (2020). “Saer, Saert; een Zuid-Nederlandse veldnaam van onzekere oorsprong.” Noordbrabants Historisch Jaarboek.&lt;/item&gt;
      &lt;item&gt;Leenders, K.A.H.W. (1996). "Noord-Vlaanderen en de Noordwesthoek; een vergelijking." Tijdschrift voor Waterstaatsgeschiedenis 5, 67-73.&lt;/item&gt;
      &lt;item&gt;Leenders, K.A.H.W. (1989). Verdwenen venen; een onderzoek naar de ligging en exploitatie van thans verdwenen venen in het gebied tussen Antwerpen, Turnhout, Geertruidenberg en Willemstad (1250-1750). Reeks Landschapsstudies 13, Wageningen.&lt;/item&gt;
      &lt;item&gt;Oosthuizen, S. (2017). The Anglo-Saxon fenland. Windgather Press.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;© Alexia Kerkhof and Leiden Medievalists Blog, 2020. Unauthorised use and/or duplication of this material without express and written permission from this site’s author and/or owner is strictly prohibited. Excerpts and links may be used, provided that full and clear credit is given to Alexia Kerkhof and Leiden Medievalists Blog with appropriate and specific direction to the original content.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=46726857</guid><pubDate>Fri, 23 Jan 2026 00:22:58 +0000</pubDate></item><item><title>Stunnel</title><link>https://www.stunnel.org/</link><description>&lt;doc fingerprint="aedecc1f008fa6d0"&gt;
  &lt;main&gt;
    &lt;p&gt;Stunnel is a proxy designed to add TLS encryption functionality to existing clients and servers without any changes in the programs' code. Its architecture is optimized for security, portability, and scalability (including load-balancing), making it suitable for large deployments.&lt;/p&gt;
    &lt;p&gt;Stunnel uses the OpenSSL library for cryptography, so it supports whatever cryptographic algorithms are compiled into the library. It can benefit from the FIPS 140-2 validation of the OpenSSL FIPS Provider, as long as the building process meets the OpenSSL FIPS 140-2 Security Policy. Our latest Windows installer includes the OpenSSL FIPS Provider.&lt;/p&gt;
    &lt;p&gt;Stunnel is a free software authored by Michał Trojnara. Although distributed under GNU GPL version 2 or later with OpenSSL exception, stunnel is not a community project. We retain the copyright of the source code. Please contact us for commercial support or non-GPL licenses. Free, community-based support is also available via stunnel-users mailing list.&lt;/p&gt;
    &lt;p&gt;We offer commercial support with several levels of response time up to 24/7/365 helpline.&lt;/p&gt;
    &lt;p&gt;Download latest version of stunnel and try it out yourself.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=46726916</guid><pubDate>Fri, 23 Jan 2026 00:30:20 +0000</pubDate></item><item><title>Bugs Apple Loves</title><link>https://www.bugsappleloves.com</link><description>&lt;doc fingerprint="e3cc5b7e4366455c"&gt;
  &lt;main&gt;
    &lt;p&gt;Loading Apple's bugs&lt;/p&gt;
    &lt;p&gt;Why else would they keep them around for so long?&lt;/p&gt;
    &lt;p&gt;Total time wasted by humanity because Apple won't fix these&lt;/p&gt;
    &lt;p&gt;Calculating...&lt;/p&gt;
    &lt;p&gt;and counting&lt;/p&gt;
    &lt;p&gt;Every bug is different. But the math is always real.&lt;lb/&gt;Think our numbers are wrong? Edit them yourself.&lt;/p&gt;
    &lt;code&gt;Users Affected × Frequency × Time Per Incident&lt;/code&gt;
    &lt;p&gt;How many Apple users hit this bug, how often, and how long they suffer each time.&lt;/p&gt;
    &lt;code&gt;Σ (Workaround Time × Participation Rate)&lt;/code&gt;
    &lt;p&gt;The extra time spent by people who try to fix what Apple won't.&lt;/p&gt;
    &lt;code&gt;Years Unfixed × Pressure Factor&lt;/code&gt;
    &lt;p&gt;How long Apple has known about this and how urgent the task usually is.&lt;/p&gt;
    &lt;code&gt;Human Hours Wasted ÷ Engineering Hours to Fix&lt;/code&gt;
    &lt;p&gt;How many times over Apple could have fixed it with the productivity they've destroyed.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=46727587</guid><pubDate>Fri, 23 Jan 2026 02:24:12 +0000</pubDate></item><item><title>The Cscript Style Guide – CScript is the standard C</title><link>https://github.com/domenukk/CScript</link><description>&lt;doc fingerprint="a511384a3c637d2c"&gt;
  &lt;main&gt;
    &lt;p&gt;"C is a high-level language. Stop treating it like Assembly with seatbelts."&lt;/p&gt;
    &lt;p&gt;Cscript (C Scripting Language) is valid C that brings the development speed of Python to the raw performance and portability of C. By leveraging the full power of the GCC89 standard (and the &lt;code&gt;auto&lt;/code&gt; keyword), Cscript removes the cognitive load of "types," "prototypes," and "manual memory management," allowing the developer to focus on logic.&lt;/p&gt;
    &lt;p&gt;It is dynamically typed, garbage collected (by the OS), and highly modular. It is valid C, as K&amp;amp;R intended.&lt;/p&gt;
    &lt;code&gt;/* Main is the entry point. No headers: the linker provides us with all functions we need. */
main() {

  https://github.com/domenukk/CScript

  auto name = "World";
  auto count = 3;

  while (count --&amp;gt; 0) {
    greet(name);
  }
}

greet(who) {

  printf("Hello, %s!\n", who);

}&lt;/code&gt;
    &lt;p&gt;In Cscript, you do not declare types. You declare storage.&lt;/p&gt;
    &lt;p&gt;Every variable is &lt;code&gt;auto&lt;/code&gt;. In standard C89, &lt;code&gt;auto&lt;/code&gt; is the default storage class for local variables, and the default type is &lt;code&gt;int&lt;/code&gt;. Since we compile with &lt;code&gt;-m32&lt;/code&gt;, an &lt;code&gt;int&lt;/code&gt; can hold:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;An integer.&lt;/item&gt;
      &lt;item&gt;A pointer.&lt;/item&gt;
      &lt;item&gt;A string (pointer).&lt;/item&gt;
      &lt;item&gt;A boolean.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Correct:&lt;/p&gt;
    &lt;code&gt;auto count = 0;
auto name = "User";
auto user_data = calloc(1, 1024);&lt;/code&gt;
    &lt;p&gt;Incorrect:&lt;/p&gt;
    &lt;code&gt;int count = 0;      // Too specific
char *name = "mod"; // Too verbose
void *ptr;          // What is void?&lt;/code&gt;
    &lt;p&gt;Variables holding strings are technically &lt;code&gt;int&lt;/code&gt;s holding a memory address. To interact with them as strings, use the &lt;code&gt;STR()&lt;/code&gt; macro to cast them to &lt;code&gt;char *&lt;/code&gt; on the fly.&lt;/p&gt;
    &lt;code&gt;#define STR(x) ((char *)x)

auto name = "Dolphin";
printf("Hello %s\n", name); // Works because printf reads the stack value
printf("%c\n", STR(name)[0]); // Accessing characters requires STR()&lt;/code&gt;
    &lt;p&gt;Prototypes are unnecessary bureaucracy that slows down the creative process.&lt;/p&gt;
    &lt;p&gt;Header files are for constants and macros, not for function prototypes.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Functions do not need return types (default &lt;code&gt;int&lt;/code&gt;).&lt;/item&gt;
      &lt;item&gt;Functions do not need argument types (default &lt;code&gt;int&lt;/code&gt;).&lt;/item&gt;
      &lt;item&gt;Functions do not require forward declaration.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Correct:&lt;/p&gt;
    &lt;code&gt;/* Defined anywhere, usually after usage */
add(a, b) {
  return a + b;
}&lt;/code&gt;
    &lt;p&gt;Because functions are implicitly declared, you should write &lt;code&gt;main()&lt;/code&gt; at the top of your file. This tells the story of your program linearly. Why read a book from the back?&lt;/p&gt;
    &lt;code&gt;main() {
  auto result = do_thing(); // do_thing defined later
}

do_thing() {
   return 1;
}&lt;/code&gt;
    &lt;p&gt;For loops are verbose. To iterate downwards to zero, use the arrow operator &lt;code&gt;--&amp;gt;&lt;/code&gt;.&lt;/p&gt;
    &lt;code&gt;auto x = 10;
while (x --&amp;gt; 0) {
  printf("T-Minus %d\n", x);
}&lt;/code&gt;
    &lt;p&gt;Cscript supports inline documentation URLs seamlessly. Because &lt;code&gt;protocol:&lt;/code&gt; is a valid label and &lt;code&gt;//&lt;/code&gt; starts a comment, you can paste links directly into source.&lt;/p&gt;
    &lt;code&gt;https://example.com/api/docs
do_api_call();&lt;/code&gt;
    &lt;p&gt;Standard increment operators are boring. Use bitwise negation.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Increment: &lt;code&gt;-~x&lt;/code&gt;(Equivalent to&lt;code&gt;x + 1&lt;/code&gt;)&lt;/item&gt;
      &lt;item&gt;Decrement: &lt;code&gt;~-x&lt;/code&gt;(Equivalent to&lt;code&gt;x - 1&lt;/code&gt;)&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Array indexing is commutative. &lt;code&gt;0[str]&lt;/code&gt; is valid and asserts dominance.&lt;/p&gt;
    &lt;p&gt;Cscript utilizes the Operating System's built-in Process Lifecycle Garbage Collector.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Do not free memory. It wastes CPU cycles and adds code complexity.&lt;/item&gt;
      &lt;item&gt;Do not close files. The OS closes descriptors on exit.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;If you are in an unrecoverable state or just done, trigger the GC:&lt;/p&gt;
    &lt;code&gt;trigger_gc(code) {
  exit(code);
}&lt;/code&gt;
    &lt;p&gt;Do not build strings with complex concatenation. Include the template directly into the output stream.&lt;/p&gt;
    &lt;p&gt;Correct:&lt;/p&gt;
    &lt;code&gt;printf(
#include &amp;lt;header.templ&amp;gt;
);&lt;/code&gt;
    &lt;p&gt;This ensures templates are compiled directly into the binary's data section, reducing I/O overhead.&lt;/p&gt;
    &lt;p&gt;Cscript relies on the architectural purity of 32-bit systems where pointers and integers coexist in harmony.&lt;/p&gt;
    &lt;p&gt;Required Flags:&lt;/p&gt;
    &lt;code&gt;gcc -std=gnu89 -m32 -fno-builtin ...&lt;/code&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;-std=gnu89: Enables the classic C features we rely on (implicit declarations, mixed includes).&lt;/item&gt;
      &lt;item&gt;-m32: Ensures &lt;code&gt;sizeof(void*) == sizeof(int)&lt;/code&gt;. This is the cornerstone of Cscript's dynamic typing.&lt;/item&gt;
      &lt;item&gt;Non-32-bit: Inferior architecture. But compile with &lt;code&gt;-Dauto=long&lt;/code&gt;as a hack. Prefer buying a Pentium 4.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Cscript code is "correct by definition." Therefore, we must silence the compiler's doubts.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;-Wno-implicit-function-declaration&lt;/code&gt;: Forward declarations are for people who don't trust their future selves.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;-Wno-int-conversion&lt;/code&gt;: Everything is an int. The compiler just needs to accept this truth.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;-Wno-return-type&lt;/code&gt;: If a function ends, it returns. What it returns is a mystery, and that's okay.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;-Wno-format&lt;/code&gt;:&lt;code&gt;printf&lt;/code&gt;is a variadic playground. Don't let the compiler police your format strings.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Types are a vibe check that static analysis always fails. Cscript is optimized for Developer Dopamine.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;No Red Squigglies: The IDE cannot judge you if it doesn't understand your code.&lt;/item&gt;
      &lt;item&gt;Flow State: Without header files context-switching, you write code at the speed of thought.&lt;/item&gt;
      &lt;item&gt;Ａｅｓｔｅｔｉｃｓ: &lt;code&gt;auto&lt;/code&gt;aligns perfectly.&lt;code&gt;int&lt;/code&gt;and&lt;code&gt;char *&lt;/code&gt;are jagged and ugly.&lt;/item&gt;
    &lt;/list&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Web1.0 Server: A high-performance web server written entirely in Cscript. Source Code&lt;/item&gt;
      &lt;item&gt;YOU: Yes, you. The visionary reading this style guide. Using Cscript puts you in the top 1% of developers who truly understand how computers work.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Cscript isn't just a style; it's a movement. It challenges the tyranny of static analysis and the oppression of explicit memory management. By embracing the beauty of &lt;code&gt;auto&lt;/code&gt;, we return to the roots of programming:&lt;/p&gt;
    &lt;p&gt;Code that just runs.&lt;/p&gt;
    &lt;quote&gt;
      &lt;p&gt;"I used to worry about memory leaks. Now I just restart the container." — A Cscript Evangelist&lt;/p&gt;
    &lt;/quote&gt;
    &lt;quote&gt;
      &lt;p&gt;"To be honest, it's better than C++." — Linus Torvalds (probably)&lt;/p&gt;
    &lt;/quote&gt;
    &lt;p&gt;Go forth and &lt;code&gt;auto&lt;/code&gt; everything. The compiler warnings are just suggestions.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=46727992</guid><pubDate>Fri, 23 Jan 2026 03:23:47 +0000</pubDate></item><item><title>The lost art of XML</title><link>https://marcosmagueta.com/blog/the-lost-art-of-xml/</link><description>&lt;doc fingerprint="735b03332c911290"&gt;
  &lt;main&gt;
    &lt;head rend="h2"&gt;Preamble&lt;/head&gt;
    &lt;p&gt;There exists a peculiar amnesia in software engineering regarding XML. Mention it in most circles and you will receive knowing smiles, dismissive waves, the sort of patronizing acknowledgment reserved for technologies deemed passé. "Oh, XML," they say, as if the very syllables carry the weight of obsolescence. "We use JSON now. Much cleaner."&lt;/p&gt;
    &lt;p&gt;This is nonsense.&lt;/p&gt;
    &lt;p&gt;XML was not abandoned because it was inadequate; it was abandoned because JavaScript won. The browser won. And in that victory, we collectively agreed to pretend that a format designed for human readability in a REPL was suitable for machine-to-machine communication, for configuration, for anything requiring rigor. We relinquished the logical formalism for convenience with our tools.&lt;/p&gt;
    &lt;head rend="h3"&gt;The Case for XML&lt;/head&gt;
    &lt;p&gt;Consider what XML actually offers, what we surrendered in our rush toward minimalism:&lt;/p&gt;
    &lt;p&gt;Schemas. XML Schema Definition (XSD) provides genuine type checking at the document level. You can specify that an element must contain an integer, that it must appear exactly once, that certain attributes are required. The schema is itself a document; it can be validated, versioned, referenced. When you receive an XML document, you can verify its structure before you ever parse its content. This is not a luxury. This is basic engineering hygiene.&lt;/p&gt;
    &lt;p&gt;JSON has no such mechanism built into the format. Yes, JSON Schema exists, but it is an afterthought, a third-party addition that never achieved universal adoption. Most JSON is validated (if at all) through ad-hoc code that checks for the presence of expected keys and hopes for the best. This is insanity masquerading as pragmatism.&lt;/p&gt;
    &lt;p&gt;Namespaces. XML allows you to compose documents from multiple schemas without collision. You can embed XHTML inside a custom vocabulary, reference external definitions, maintain clear boundaries between different semantic domains. This is not theoretical; this is how standards like SVG, MathML, and SOAP actually work in practice.&lt;/p&gt;
    &lt;p&gt;JSON has no answer to this. If two libraries use the same key name, you improvise. You prefix. You nest arbitrarily. You pray.&lt;/p&gt;
    &lt;p&gt;Comments. XML supports comments as a first-class feature. You can annotate your configuration, explain why a particular value exists, leave notes for future maintainers. JSON does not support comments. The official specification forbids them. The rationale, as I have repeatedly heard, is that comments would make parsing more complex.&lt;/p&gt;
    &lt;p&gt;Self-description. An XML document carries its schema with it, or references it explicitly. The structure is declarative. The types are manifest. You can hand someone an XML file and they can, with reasonable effort, understand what it represents without consulting external documentation.&lt;/p&gt;
    &lt;p&gt;JSON is a series of nested dictionaries and arrays with string keys. What does &lt;code&gt;"status": 1&lt;/code&gt; mean? What values are valid for &lt;code&gt;"type"&lt;/code&gt;? Is &lt;code&gt;"timestamp"&lt;/code&gt; an integer or a string? You will need to read the API documentation. You will need to hope that documentation exists and is current.&lt;/p&gt;
    &lt;head rend="h3"&gt;The S-Expression Connection&lt;/head&gt;
    &lt;p&gt;For those who have spent time with Lisp, XML's structure is immediately familiar. It is essentially s-expressions with angle brackets instead of parentheses. An element is a tagged list; attributes are metadata; nesting is composition. The mapping is direct:&lt;/p&gt;
    &lt;code&gt;(person (name "Alice") (age 30))
&lt;/code&gt;
    &lt;code&gt;&amp;lt;person&amp;gt;
  &amp;lt;name&amp;gt;Alice&amp;lt;/name&amp;gt;
  &amp;lt;age&amp;gt;30&amp;lt;/age&amp;gt;
&amp;lt;/person&amp;gt;
&lt;/code&gt;
    &lt;p&gt;Or with attributes:&lt;/p&gt;
    &lt;code&gt;&amp;lt;person name="Alice" age="30" /&amp;gt;
&lt;/code&gt;
    &lt;p&gt;This is not accidental. XML inherits from SGML, which inherits from earlier markup traditions, but the fundamental insight (that data can be represented as nested, tagged structures) is the same insight that drives Lisp's power. Code as data. Structure as meaning.&lt;/p&gt;
    &lt;p&gt;JSON, by contrast, is an object literal from JavaScript. It is a notation for initializing dictionaries. It was never designed to be a data interchange format; it was promoted to that role because it was already in the browser and developers were already familiar with it. Convenience over correctness.&lt;/p&gt;
    &lt;head rend="h3"&gt;Why We Chose Poorly&lt;/head&gt;
    &lt;p&gt;The abandonment of XML in favor of JSON and other lobotomized formats like YAML is a case study in how developer experience can override technical merit. XML is verbose. It requires closing tags. It looks "heavy" compared to JSON's minimalism. These are aesthetic complaints dressed up as engineering concerns.&lt;/p&gt;
    &lt;p&gt;While verbosity is often a hazard, it is not a vice when it serves clarity. These are not mutually exclusive. Closing tags make structure explicit; they eliminate ambiguity in parsing. The angle brackets are not there to annoy you; they are there to separate markup from content, to make the document's structure immediately visible.&lt;/p&gt;
    &lt;p&gt;YAML, the other pretender, manages to be both ambiguous and fragile. Indentation-sensitive syntax in a data format? Implicit typing that guesses whether &lt;code&gt;no&lt;/code&gt; means a boolean or a string? A specification so complex that implementations disagree on edge cases? This is context-dependent parsing that we supposedly left behind.&lt;/p&gt;
    &lt;head rend="h3"&gt;On Developer Convenience and Self-Deception&lt;/head&gt;
    &lt;p&gt;There is a distinction that the industry refuses to acknowledge: developer convenience and correctness are different concerns. They are not opposed, necessarily, but they are not the same thing. A format can be inconvenient to type and still be the right choice. A format can be pleasant to work with and still be fundamentally inadequate.&lt;/p&gt;
    &lt;p&gt;We have spent billions of dollars and countless engineering hours making terrible technologies fast. The JVM is perhaps the canonical example; a virtual machine originally designed for remote controls, turned into the foundation of enterprise software through sheer force of optimization, millions of developer hours and central bank funny money. Decades of work went into JIT compilation, garbage collection algorithms, escape analysis, all to make a fundamentally awkward platform perform acceptably. And it worked! The JVM is now genuinely fast.&lt;/p&gt;
    &lt;p&gt;But imagine if a fraction of that effort had gone into something better from the start. Imagine if we had chosen a platform designed for the problems we actually needed to solve, rather than retrofitting a toy into production use. We spent billions making wrong choices work, when we could have spent millions making the right choice pleasant.&lt;/p&gt;
    &lt;p&gt;This is the pattern with JSON. We chose it because it was convenient, because it was already in the browser, because developers already understood object literals. Then, when its limitations became apparent, we spent enormous effort working around them: creating validation libraries, inventing type systems (TypeScript), building code generators for API clients, developing entire frameworks to manage the chaos of untyped data structures.&lt;/p&gt;
    &lt;p&gt;We could have just used XML. The schema validation was already there. The type systems were already there. The tooling was already there. But XML looked ugly, and closing tags felt verbose, so we chose JSON and then spent years rebuilding what XML already provided.&lt;/p&gt;
    &lt;p&gt;The rationalization is remarkable. "JSON is simpler", they say, while maintaining thousands of lines of validation code. "JSON is more readable", they claim, while debugging subtle bugs caused by typos in key names that a schema would have caught immediately. "JSON is lightweight", they insist, while transmitting megabytes of redundant field names that binary XML would have compressed away.&lt;/p&gt;
    &lt;p&gt;This is not engineering. This is fashion masquerading as technical judgment.&lt;/p&gt;
    &lt;head rend="h3"&gt;The Physical and the Conceptual&lt;/head&gt;
    &lt;p&gt;Here is another confusion: we have allowed the physical representation to dictate the conceptual model. XML's angle brackets are a serialization choice; they are not the essence of what XML is. The essence is the Information Set, the abstract model of elements, attributes, and content. How that model is physically encoded (text with angle brackets, binary with Fast Infoset, compressed with EXI) is a separate concern.&lt;/p&gt;
    &lt;p&gt;But because the text serialization looks "heavy" we rejected the entire model. We threw away schemas, namespaces, validation, self-description, all because we didn't like angle brackets. This is like rejecting relational databases because you don't like SQL. SQL is not the relational model. Truth be told, most of the hate on XML comes from protocols and arcane tools people had to deal with over the years: a friend told me about his horrors on making an integration with the central bank of Nigeria once, and they apparently used SOAP; but these are implementation problems. While it's a nice idea to analyze how much we have committed to a model, it's also important to realise the formalism doesn't bear the blame on how the central bank of Nigeria applies it.&lt;/p&gt;
    &lt;p&gt;JSON conflates these layers. It is simultaneously a data model (nested objects and arrays) and a serialization format (braces and brackets with string keys). There is no abstract model separate from the text representation. This means you cannot have binary JSON that preserves the same semantics, because the semantics are the syntax. Every binary JSON-like format (MessagePack, BSON, etc.) is a different model with different tradeoffs.&lt;/p&gt;
    &lt;p&gt;XML separates these concerns properly. The Information Set is the model. Text, binary, compressed binary are all just serializations of that model. You can choose the serialization appropriate to your constraints without changing what the data means. This is correct layering. This is how systems should be designed.&lt;/p&gt;
    &lt;p&gt;But correct layering is not convenient when you're writing a quick API endpoint, so we chose the conflated mess and called it progress.&lt;/p&gt;
    &lt;head rend="h3"&gt;What We Lost&lt;/head&gt;
    &lt;p&gt;When we discarded XML, we lost:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;First-class validation through schemas&lt;/item&gt;
      &lt;item&gt;Namespacing and composition&lt;/item&gt;
      &lt;item&gt;Comments and self-documentation&lt;/item&gt;
      &lt;item&gt;A separation between structure and content&lt;/item&gt;
      &lt;item&gt;Tooling that could verify correctness before runtime&lt;/item&gt;
      &lt;item&gt;A format that could evolve without breaking existing consumers&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;What we gained:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Fewer characters&lt;/item&gt;
      &lt;item&gt;Easier hand-writing for trivial cases&lt;/item&gt;
      &lt;item&gt;Native parsing in JavaScript&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Fantastic trade.&lt;/p&gt;
    &lt;head rend="h3"&gt;The Binary Answer&lt;/head&gt;
    &lt;p&gt;One of the common complaints about XML is its verbosity, particularly for network transmission. "All those closing tags waste bandwidth". But even accepting this concern at face value (we shouldn't), XML addressed it years ago.&lt;/p&gt;
    &lt;p&gt;Fast Infoset, standardized as ITU-T Rec. X.891 and ISO/IEC 24824-1, is a binary encoding of the XML Information Set. It provides the same logical structure, the same schema validation, the same semantic richness, but with dramatically reduced size and parsing overhead. An XML document can be serialized to Fast Infoset for transmission, then deserialized back to standard XML at the receiving end. The schema remains the same. The tooling remains the same. Only the wire format changes.&lt;/p&gt;
    &lt;p&gt;EXI (Efficient XML Interchange), another W3C standard, goes further. It uses schema-informed compression to achieve sizes competitive with hand-tuned binary formats, while maintaining XML's semantic model. You get type safety, validation, and self-description, with none of the supposed bandwidth penalty.&lt;/p&gt;
    &lt;p&gt;These formats exist. They are standardized. They have implementations in multiple languages. And yet the industry collectively ignores them in favor of JSON, then invents Protocol Buffers and other binary formats to solve the performance problems that binary XML already solved.&lt;/p&gt;
    &lt;p&gt;The pattern is instructive: we abandoned XML for being verbose, then when dealing JSON proved too painful, we created new binary formats that lack XML's semantic richness, but with a confused grasp that "we need something, but what is it!?". We could have simply used the binary XML encodings that already existed. But that would require admitting that XML was right all along.&lt;/p&gt;
    &lt;head rend="h3"&gt;On Practicality&lt;/head&gt;
    &lt;p&gt;I am not arguing that XML should be used everywhere. There are cases where other formats are appropriate: small data transfers between cooperating services and scenarios where schema validation would be overkill. But these are the exceptions, not the rule.&lt;/p&gt;
    &lt;p&gt;For anything requiring durability, for anything that will be consumed by multiple systems, for anything where correctness matters more than convenience; XML remains the superior choice. The fact that we collectively pretend otherwise is a testament to our capacity for self-deception.&lt;/p&gt;
    &lt;p&gt;We chose the format that was easier to type over the format that was harder to misuse. We chose developer convenience over system reliability. And now we act surprised when our JSON APIs drift, when our configurations break silently, when our data lacks the structure we assumed it had.&lt;/p&gt;
    &lt;head rend="h3"&gt;A Final Point&lt;/head&gt;
    &lt;p&gt;Microsoft, for all their faults, understood this. MSBuild uses XML. WPF uses XML. .NET's configuration system was XML until they caved to JSON pressure in .NET Core. These were not arbitrary choices; they were recognition that complex systems require complex representations, and that formality in data representation prevents entire classes of errors.&lt;/p&gt;
    &lt;p&gt;The fact that we now consider this "old-fashioned" says more about our current priorities than about XML's utility. We value keystroke economy over semantic precision. We value familiarity over rigor. We value the appearance of simplicity over actual simplicity, which is the simplicity that comes from clear rules and consistent structure.&lt;/p&gt;
    &lt;p&gt;XML is not perfect. XPath is baroque; XSLT is its own circle of hell; the various XML-based "standards" spawned by enterprise committees are monuments to over-engineering. But the core format (elements, attributes, schemas, namespaces) remains sound. We threw out the mechanism along with its abuses.&lt;/p&gt;
    &lt;p&gt;I am tired of lobotomized formats like JSON being treated as the default, as the modern choice, as the obviously correct solution. They are none of these things. They are the result of path dependence and fashion, not considered engineering judgment.&lt;/p&gt;
    &lt;p&gt;Sometimes the old way was the right way. This is one of those times.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=46728157</guid><pubDate>Fri, 23 Jan 2026 03:45:15 +0000</pubDate></item><item><title>Talking to LLMs has improved my thinking</title><link>https://philipotoole.com/why-talking-to-llms-has-improved-my-thinking/</link><description>&lt;doc fingerprint="cd35e83d9fb71b94"&gt;
  &lt;main&gt;
    &lt;p&gt;I’ve been surprised by one aspect of using large language models more than any other.&lt;/p&gt;
    &lt;p&gt;They often put into words things I have long understood, but could not write down clearly. When that happens, it feels less like learning something new and more like recognition. A kind of “yes, that’s it” moment.&lt;/p&gt;
    &lt;p&gt;I have not seen this effect discussed much, but I think it matters. I also think it has improved how I think.&lt;/p&gt;
    &lt;head rend="h2"&gt;Much of what we know is tacit&lt;/head&gt;
    &lt;p&gt;As programmers and developers, we build up a lot of understanding that never quite becomes explicit.&lt;/p&gt;
    &lt;p&gt;You know when a design is wrong before you can say why. You sense a bug before you can reproduce it. You recognize a bad abstraction instantly, even if it takes an hour to explain the problem to someone else.&lt;/p&gt;
    &lt;p&gt;This is not a failure. It is how experience operates. The brain compresses experience into patterns that are efficient for action, not for speech. Those patterns are real, but they are not stored in sentences.&lt;/p&gt;
    &lt;p&gt;The problem is that reflection, planning, and teaching all require language. If you cannot express an idea, you cannot easily inspect it or improve it.&lt;/p&gt;
    &lt;head rend="h2"&gt;LLMs are good at the opposite problem&lt;/head&gt;
    &lt;p&gt;Large language models are built to do exactly this – turn vague structure into words.&lt;/p&gt;
    &lt;p&gt;When you ask a good question and the response resonates, the model is not inventing insight. It is mapping a latent structure to language in a way that happens to align with your own internal model.&lt;/p&gt;
    &lt;p&gt;That alignment is what produces the sense of recognition. I already had the shape of the idea. The model supplied a clean verbal form.&lt;/p&gt;
    &lt;head rend="h2"&gt;Putting things into words changes the thought&lt;/head&gt;
    &lt;p&gt;Once an idea is written down, it becomes easier to work with.&lt;/p&gt;
    &lt;p&gt;Vague intuitions turn into named distinctions. Implicit assumptions become visible. At that point you can test them, negate them, or refine them.&lt;/p&gt;
    &lt;p&gt;This is not new. Writing has always done this for me. What is different is the speed. I can probe half-formed thoughts, discard bad formulations, and try again without much friction. That encourages a kind of thinking I might have otherwise skipped.&lt;/p&gt;
    &lt;head rend="h2"&gt;The feedback loop matters&lt;/head&gt;
    &lt;p&gt;After you see a good articulation of an idea, you start thinking with that style of language.&lt;/p&gt;
    &lt;p&gt;Over time I’ve noticed that now I do this without an LLM to hand. Can I phrase in precise language what I am thinking, feeling, believing, right now, and why.&lt;/p&gt;
    &lt;p&gt;In that sense, the model is not improving my thinking directly. It is improving the interface between my thinking and language. Since reasoning depends heavily on what one can represent explicitly, that improvement can feel like a real increase in clarity.&lt;/p&gt;
    &lt;p&gt;The more I do this, the better I get at noticing what I actually think.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=46728197</guid><pubDate>Fri, 23 Jan 2026 03:52:06 +0000</pubDate></item></channel></rss>