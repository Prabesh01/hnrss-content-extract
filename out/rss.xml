<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>Hacker News: Front Page</title><link>https://raw.githubusercontent.com/Prabesh01/hnrss-content-extract/refs/heads/main/out/rss.xml</link><description>Hacker News RSS</description><atom:link href="https://raw.githubusercontent.com/Prabesh01/hnrss-content-extract/refs/heads/main/out/rss.xml" rel="self"/><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><language>en</language><lastBuildDate>Fri, 26 Dec 2025 21:09:45 +0000</lastBuildDate><item><title>Package managers keep using Git as a database, it never works out</title><link>https://nesbitt.io/2025/12/24/package-managers-keep-using-git-as-a-database.html</link><description>&lt;doc fingerprint="b32422190df047d9"&gt;
  &lt;main&gt;
    &lt;p&gt;Using git as a database is a seductive idea. You get version history for free. Pull requests give you a review workflow. It’s distributed by design. GitHub will host it for free. Everyone already knows how to use it.&lt;/p&gt;
    &lt;p&gt;Package managers keep falling for this. And it keeps not working out.&lt;/p&gt;
    &lt;head rend="h2"&gt;Cargo&lt;/head&gt;
    &lt;p&gt;The crates.io index started as a git repository. Every Cargo client cloned it. This worked fine when the registry was small, but the index kept growing. Users would see progress bars like “Resolving deltas: 74.01%, (64415/95919)” hanging for ages, the visible symptom of Cargo’s libgit2 library grinding through delta resolution on a repository with thousands of historic commits.&lt;/p&gt;
    &lt;p&gt;The problem was worst in CI. Stateless environments would download the full index, use a tiny fraction of it, and throw it away. Every build, every time.&lt;/p&gt;
    &lt;p&gt;RFC 2789 introduced a sparse HTTP protocol. Instead of cloning the whole index, Cargo now fetches files directly over HTTPS, downloading only the metadata for dependencies your project actually uses. (This is the “full index replication vs on-demand queries” tradeoff in action.) By April 2025, 99% of crates.io requests came from Cargo versions where sparse is the default. The git index still exists, still growing by thousands of commits per day, but most users never touch it.&lt;/p&gt;
    &lt;head rend="h2"&gt;Homebrew&lt;/head&gt;
    &lt;p&gt;GitHub explicitly asked Homebrew to stop using shallow clones. Updating them was “an extremely expensive operation” due to the tree layout and traffic of homebrew-core and homebrew-cask.&lt;/p&gt;
    &lt;p&gt;Users were downloading 331MB just to unshallow homebrew-core. The .git folder approached 1GB on some machines. Every &lt;code&gt;brew update&lt;/code&gt; meant waiting for git to grind through delta resolution.&lt;/p&gt;
    &lt;p&gt;Homebrew 4.0.0 in February 2023 switched to JSON downloads for tap updates. The reasoning was blunt: “they are expensive to git fetch and git clone and GitHub would rather we didn’t do that… they are slow to git fetch and git clone and this provides a bad experience to end users.”&lt;/p&gt;
    &lt;p&gt;Auto-updates now run every 24 hours instead of every 5 minutes, and they’re much faster because there’s no git fetch involved.&lt;/p&gt;
    &lt;head rend="h2"&gt;CocoaPods&lt;/head&gt;
    &lt;p&gt;CocoaPods is the package manager for iOS and macOS development. It hit the limits hard. The Specs repo grew to hundreds of thousands of podspecs across a deeply nested directory structure. Cloning took minutes. Updating took minutes. CI time vanished into git operations.&lt;/p&gt;
    &lt;p&gt;GitHub imposed CPU rate limits. The culprit was shallow clones, which force GitHub’s servers to compute which objects the client already has. The team tried various band-aids: stopping auto-fetch on &lt;code&gt;pod install&lt;/code&gt;, converting shallow clones to full clones, sharding the repository.&lt;/p&gt;
    &lt;p&gt;The CocoaPods blog captured it well: “Git was invented at a time when ‘slow network’ and ‘no backups’ were legitimate design concerns. Running endless builds as part of continuous integration wasn’t commonplace.”&lt;/p&gt;
    &lt;p&gt;CocoaPods 1.8 gave up on git entirely for most users. A CDN became the default, serving podspec files directly over HTTP. The migration saved users about a gigabyte of disk space and made &lt;code&gt;pod install&lt;/code&gt; nearly instant for new setups.&lt;/p&gt;
    &lt;head rend="h2"&gt;Nixpkgs&lt;/head&gt;
    &lt;p&gt;Nix already solved the client-side problem. The package manager fetches expressions as tarballs via channels, served from S3 and CDN, not git clones. Binary caches serve built packages over HTTP. End users never touch the git repository.&lt;/p&gt;
    &lt;p&gt;But the repository itself is stress-testing GitHub’s infrastructure. In November 2025, GitHub contacted the NixOS team about periodic maintenance jobs failing and causing “issues achieving consensus between replicas.” If unresolved, the repository could have become read-only.&lt;/p&gt;
    &lt;p&gt;The repository totals 83GB with half a million tree objects and 20,000 forks. A local clone is only 2.5GB. The rest is GitHub’s fork network storing every pull request branch and merge commit. The CI queries mergeability daily, creating new merge commits each time.&lt;/p&gt;
    &lt;head rend="h2"&gt;vcpkg&lt;/head&gt;
    &lt;p&gt;vcpkg is Microsoft’s C++ package manager. It uses git tree hashes to version its ports, with the curated registry at github.com/Microsoft/vcpkg containing over 2,000 libraries.&lt;/p&gt;
    &lt;p&gt;The problem is that vcpkg needs to retrieve specific versions of ports by their git tree hash. When you specify a &lt;code&gt;builtin-baseline&lt;/code&gt; in your vcpkg.json (functioning like a lockfile for reproducible builds), vcpkg looks up historical commits to find the exact port versions you need. This only works if you have the full commit history.&lt;/p&gt;
    &lt;p&gt;Shallow clones break everything. GitHub Actions uses shallow clones by default. DevContainers shallow-clone vcpkg to save space. CI systems optimize for fast checkouts. All of these result in the same error: “vcpkg was cloned as a shallow repository… Try again with a full vcpkg clone.”&lt;/p&gt;
    &lt;p&gt;The workarounds are ugly. One proposed solution involves parsing vcpkg.json to extract the baseline hash, deriving the commit date, then fetching with &lt;code&gt;--shallow-since=&amp;lt;date&amp;gt;&lt;/code&gt;. Another suggests including twelve months of history, hoping projects upgrade before their baseline falls off the cliff. For GitHub Actions, you need &lt;code&gt;fetch-depth: 0&lt;/code&gt; in your checkout step, downloading the entire repository history just to resolve dependencies.&lt;/p&gt;
    &lt;p&gt;A vcpkg team member explained the fundamental constraint: “Port versions don’t use commit hashes, we use the git tree hash of the port directory. As far as I know, there is no way to deduce the commit that added a specific tree hash.” An in-product fix is infeasible. The architecture baked in git deeply enough that there’s no escape hatch.&lt;/p&gt;
    &lt;p&gt;Unlike Cargo, Homebrew, and CocoaPods, vcpkg hasn’t announced plans to move away from git registries. Custom registries must still be git repositories. The documentation describes filesystem registries as an alternative, but these require local or mounted paths rather than HTTP access. There’s no CDN, no sparse protocol, no HTTP-based solution on the horizon.&lt;/p&gt;
    &lt;head rend="h2"&gt;Go modules&lt;/head&gt;
    &lt;p&gt;Grab’s engineering team went from 18 minutes for &lt;code&gt;go get&lt;/code&gt; to 12 seconds after deploying a module proxy. That’s not a typo. Eighteen minutes down to twelve seconds.&lt;/p&gt;
    &lt;p&gt;The problem was that &lt;code&gt;go get&lt;/code&gt; needed to fetch each dependency’s source code just to read its go.mod file and resolve transitive dependencies. Cloning entire repositories to get a single file.&lt;/p&gt;
    &lt;p&gt;Go had security concerns too. The original design wanted to remove version control tools entirely because “these fragment the ecosystem: packages developed using Bazaar or Fossil, for example, are effectively unavailable to users who cannot or choose not to install these tools.” Beyond fragmentation, the Go team worried about security bugs in version control systems becoming security bugs in &lt;code&gt;go get&lt;/code&gt;. You’re not just importing code; you’re importing the attack surface of every VCS tool on the developer’s machine.&lt;/p&gt;
    &lt;p&gt;GOPROXY became the default in Go 1.13. The proxy serves source archives and go.mod files independently over HTTP. Go also introduced a checksum database (sumdb) that records cryptographic hashes of module contents. This protects against force pushes silently changing tagged releases, and ensures modules remain available even if the original repository is deleted.&lt;/p&gt;
    &lt;head rend="h2"&gt;Beyond package managers&lt;/head&gt;
    &lt;p&gt;The same pattern shows up wherever developers try to use git as a database.&lt;/p&gt;
    &lt;p&gt;Git-based wikis like Gollum (used by GitHub and GitLab) become “somewhat too slow to be usable” at scale. Browsing directory structure takes seconds per click. Loading pages takes longer. GitLab plans to move away from Gollum entirely.&lt;/p&gt;
    &lt;p&gt;Git-based CMS platforms like Decap hit GitHub’s API rate limits. A Decap project on GitHub scales to about 10,000 entries if you have a lot of collection relations. A new user with an empty cache makes a request per entry to populate it, burning through the 5,000 request limit quickly. If your site has lots of content or updates frequently, use a database instead.&lt;/p&gt;
    &lt;p&gt;Even GitOps tools that embrace git as a source of truth have to work around its limitations. ArgoCD’s repo server can run out of disk space cloning repositories. A single commit invalidates the cache for all applications in that repo. Large monorepos need special scaling considerations.&lt;/p&gt;
    &lt;head rend="h2"&gt;The pattern&lt;/head&gt;
    &lt;p&gt;The hosting problems are symptoms. The underlying issue is that git inherits filesystem limitations, and filesystems make terrible databases.&lt;/p&gt;
    &lt;p&gt;Directory limits. Directories with too many files become slow. CocoaPods had 16,000 pod directories in a single Specs folder, requiring huge tree objects and expensive computation. Their fix was hash-based sharding: split directories by the first few characters of a hashed name, so no single directory has too many entries. Git itself does this internally with its objects folder, splitting into 256 subdirectories. You’re reinventing B-trees, badly.&lt;/p&gt;
    &lt;p&gt;Case sensitivity. Git is case-sensitive, but macOS and Windows filesystems typically aren’t. Check out a repo containing both &lt;code&gt;File.txt&lt;/code&gt; and &lt;code&gt;file.txt&lt;/code&gt; on Windows, and the second overwrites the first. Azure DevOps had to add server-side enforcement to block pushes with case-conflicting paths.&lt;/p&gt;
    &lt;p&gt;Path length limits. Windows restricts paths to 260 characters, a constraint dating back to DOS. Git supports longer paths, but Git for Windows inherits the OS limitation. This is painful with deeply nested node_modules directories, where &lt;code&gt;git status&lt;/code&gt; fails with “Filename too long” errors.&lt;/p&gt;
    &lt;p&gt;Missing database features. Databases have CHECK constraints and UNIQUE constraints; git has nothing, so every package manager builds its own validation layer. Databases have locking; git doesn’t. Databases have indexes for queries like “all packages depending on X”; with git you either traverse every file or build your own index. Databases have migrations for schema changes; git has “rewrite history and force everyone to re-clone.”&lt;/p&gt;
    &lt;p&gt;The progression is predictable. Start with a flat directory of files. Hit filesystem limits. Implement sharding. Hit cross-platform issues. Build server-side enforcement. Build custom indexes. Eventually give up and use HTTP or an actual database. You’ve built a worse version of what databases already provide, spread across git hooks, CI pipelines, and bespoke tooling.&lt;/p&gt;
    &lt;p&gt;None of this means git is bad. Git excels at what it was designed for: distributed collaboration on source code, with branching, merging, and offline work. The problem is using it for something else entirely. Package registries need fast point queries for metadata. Git gives you a full-document sync protocol when you need a key-value lookup.&lt;/p&gt;
    &lt;p&gt;If you’re building a package manager and git-as-index seems appealing, look at Cargo, Homebrew, CocoaPods, vcpkg, Go. They all had to build workarounds as they grew, causing pain for users and maintainers. The pull request workflow is nice. The version history is nice. You will hit the same walls they did.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=46391514</guid><pubDate>Fri, 26 Dec 2025 12:46:36 +0000</pubDate></item><item><title>Ask HN: What did you read in 2025?</title><link>https://news.ycombinator.com/item?id=46391572</link><description>&lt;doc fingerprint="3a6b93150cb6229f"&gt;
  &lt;main&gt;
    &lt;p&gt;I mostly read newspapers and technical journals, but two books that I read that made an impression: "The Changing World Order" and "The Gulag Archipelago".&lt;/p&gt;
    &lt;p&gt;The Gulag Archipelago is on my shelf, when I rotate back to Russian authors (big fan of Dostoevsky, Nabokov, Bulgakov) I will hopefully get to it.&lt;/p&gt;
    &lt;p&gt;Here's my log for 2025, most recent at the top. Currently I am slogging my way through Heinlein's "The Number of the Beast" which I'm not a fan of. Halfway done with it though!&lt;/p&gt;
    &lt;p&gt;Gabrielle Zevin, "The Hole We're In" (not my usual genre, enjoyed this though)&lt;/p&gt;
    &lt;p&gt;Robert A. Heinlein, "Stranger in a Strange Land" (pretty good)&lt;/p&gt;
    &lt;p&gt;Robert A. Heinlein, "Time Enough for Love" (PHENOMENAL, highly recommended)&lt;/p&gt;
    &lt;p&gt;Robert A. Heinlein, "Methuselah's Children" (pretty good, required to understand "Time Enough for Love")&lt;/p&gt;
    &lt;p&gt;Richard K. Morgan, "Altered Carbon" (very good)&lt;/p&gt;
    &lt;p&gt;Robert A. Heinlein, "The Rolling Stones" (young adult, but good all the same)&lt;/p&gt;
    &lt;p&gt;Robert A. Heinlein, "The Moon is a Harsh Mistress" (very good)&lt;/p&gt;
    &lt;p&gt;Piers Anthony, "On A Pale Horse" (very good, never got very far into the series though)&lt;/p&gt;
    &lt;p&gt;Lincoln Child, "Full Wolf Moon" (okay, not great)&lt;/p&gt;
    &lt;p&gt;Lincoln Child, "The Forgotten Room" (pretty good)&lt;/p&gt;
    &lt;p&gt;Lincoln Child, "The Third Gate" (very good)&lt;/p&gt;
    &lt;p&gt;Lincoln Child, "Terminal Freeze" (okay, not great)&lt;/p&gt;
    &lt;p&gt;William Gibson, "In the Beginning… Was the Command Line" (good, but outdated, look up what he's said about it more recently)&lt;/p&gt;
    &lt;p&gt;Lincoln Child, "Deep Storm" (very good)&lt;/p&gt;
    &lt;p&gt;James Patterson, "Along Came a Spider" (not my usual genre, okay though)&lt;/p&gt;
    &lt;p&gt;Jules Verne, "Around the World in 80 Days" (from childhood, revisited)&lt;/p&gt;
    &lt;p&gt;Ted Chang, Bunch Books on Roman Architecture, "You, me, and Ulysses S. Grant", Raving Fans (for work), 3 body Problem, Not the end of the world, Anti-fragile (3rd time), Transformed (for work, it was trash), Harry Potter (in Spanish), and some other things I can't think of off the top of my head.&lt;/p&gt;
    &lt;p&gt;The Will of the Many. An epic high fantasy adventure. I’m just about to finish the second book in the series - The Strength of a Few. I haven’t gasped this many times reading a book in a long time.&lt;/p&gt;
    &lt;p&gt;Technical followed by non-technical. I read more than these, but these are the highlights.&lt;/p&gt;
    &lt;p&gt;Mouse, a Language for Microcomputers by Peter Grogono - Mouse is basically an esolang with barely any abstraction facilities, but the book was well-written and the language compelling enough to explore further.&lt;/p&gt;
    &lt;p&gt;Notes on Distance Dialing (pdf) by AT&amp;amp;T - Described the telephone systems of the USA and Canada in the mid-1950s. The reading is a dry as it gets, but it was a fascinating dive into a vastly complex system solving extremely hard problems. This is a must-read for folks interested in systems-thinking. That said, I am actively looking for recommendations for books about the process of designing and building the unbelievably complex telephony system over the rudiments of the earlier systems. Recommendations welcomed!&lt;/p&gt;
    &lt;p&gt;The Eye of Osiris by R. Austin Freeman - This is the first book that I’ve read from Freeman and I suspect that I will read many more in the future. The story follows the disappearance of John Bellingham, Egyptologist and the subsequent investigation. As the investigation stalls, the eminent Dr. Thorndyke digs into the case. The story sets up the mystery nicely and indeed provides enough information to the reader to infer how the disappearance occurred and who or what facilitated it. The book is one of the best whodunits that I’ve ever read.&lt;/p&gt;
    &lt;p&gt;The Mystery of Edwin Drood by Charles Dickens - His final work remains unfinished as he passed away before he could complete it. Further complicating the meta-story is that he also didn’t outline the ending nor even put to paper the “villain” of the story. The meta-mystery of the ending has motivated a mountain of speculation around the ending including dozens of continuations of the story from other authors, all deriving their pet endings from textual hints, accounts from Dickens’ friends, illustration notes, and even in some cases seances supposedly accompanied by the spirit of Dickens himself. What was written by Dickens is spectacular and a compelling mystery and although it would be great to know the resolution, in some ways the “Droodiana” that has cropped up over the past 150+ years is reason enough for it to remain a mystery. The whole lore around Edwin Drood is a worthwhile hobby in itself and well-worth exploring. The Chiltern Library edition of the book contains the story and a good bit of the lore around the writing and the meta-works available at the time of its publication.&lt;/p&gt;
    &lt;p&gt;The Shadow People by Margaret St. Clair - Sadly out of print and difficult to find, but I’ve had it on my shelves for decades and finally got around to reading it. The book came onto my radar in the 1980s when I learned about it in the appendix-n of the 1st edition Advanced D&amp;amp;D Dungeon Masters Guide. I enjoyed many of the books at the time and have slowly swung around to re-reading them over the past few years. Sadly, most on the list do not stand the test of time for me, but St. Clair’s mixture of 60s counter-cultural leanings in a fantasy/sf world still works. The cultural touch-points in the book feel quite dated, but despite the occasional awkwardness, the story is unique even today.&lt;/p&gt;
    &lt;p&gt;Lolly Willowes by Sylvia Townsend Warner - The book started as a passable novel of manners focused on a turn of the century British middle-class family. The titular character was mostly background decoration for the first third of the novel and AFAIR was talked about only in the third-person. It’s only when she made the choice to move out on her own to the country in her middle age does she gain a central role in the narrative and her inner thoughts revealed. This is where things really pick up because I was shocked to learn that this unassuming woman’s inner thoughts had a delicious darkness to them. I don’t want to give away too much, but I’ll just say that you will not expect how the story ends.&lt;/p&gt;
    &lt;p&gt;Patience by Daniel Clowes - A profound graphic novel using time-travel to explore the idea of enduring love with a story that proceed through time, following Jack as he tries to alter the past and save the woman he loves. This well-known science fiction motif is elevated by Clowes’ signature psychological complexity.&lt;/p&gt;
    &lt;p&gt;Narcissus and Goldmund by Herman Hesse - I’ve read most of the books by Hermann Hesse but this one escaped my attention until this year. The story follows the parallel lives of a monk Narcissus and his passionate friend Goldmund as they respectively search for meaning in life through spiritual means and through pleasures of the flesh.&lt;/p&gt;
    &lt;p&gt;We Who Are About To… by Joanna Russ - A small group of astronauts crash land on a hostile alien world and quickly realize that rescue is unlikely to come. Many SF stories have started this way and so the expectation is that this is a colonization story… but Russ thrives on subverting reader expectations.&lt;/p&gt;
    &lt;p&gt;Fifty Forgotten Records by R.B. Russell - Another lovely entry in Russell’s series (one can hope) of autobiographical explorations of art, so far covering literature and now music. This book describes 50 records of varying popularity and Russell’s personal connections to each. While I certainly enjoyed finding a dozen or so new albums to explore, the true triumph of the book lies in the vulnerable, reflective memoir threaded throughout.&lt;/p&gt;
    &lt;p&gt;The Way of All Flesh by Samuel Butler A novel that follows 4-generations of the Ponitifex family, with a particular bildungsroman-esque thread around Ernest, a young man who’s naivete leads to his downfall and how his life unfolds thereafter.&lt;/p&gt;
    &lt;p&gt;Introduction to Telephones and Telephone Systems (3rd Ed.) by A. Michael Noll: A great system-level overview covering instruments, transmission media, switching, and signaling.&lt;/p&gt;
    &lt;p&gt;Understanding Telephone Electronics by Carr, Winder, &amp;amp; Bigelow: Focuses on the electronic components and workings of telephone systems.&lt;/p&gt;
    &lt;p&gt;Me too. It's phenomenal, especially the first book and the pilgrims' stories. Such a moving mix of religious mystics, science fiction and the dreaded AI. The second one builds up the tension and the last 2... are good.&lt;/p&gt;
    &lt;p&gt;Spoilers, but the excerpt posted here [0] of Aenea was one of my favorite scenes from Hyperion Cantos. "Choose again" as a gentle reminder to reevaluate our beliefs and structures, and to really choose, not just go along with whatever. You can always choose again.&lt;/p&gt;
    &lt;p&gt;I read the second two books this year and was unfortunately disappointed.&lt;/p&gt;
    &lt;p&gt;First two were so fun but I think I got hung up on some of the more clumsy stylistic parts of the Endymion books. I guess my “trust” in the author comes from the style and tropes they use, and if I they lose my trust none of the deeper parts resonate. Glad you enjoyed!&lt;/p&gt;
    &lt;p&gt;My favorite book this year was "Differential Privacy" (2025) by Simson Garfinkel. Differential privacy is a mathematical theory of data privacy sandwiched between cryptography, databases, and ML. This is the first book-length non-technical introduction, and it's well executed.&lt;/p&gt;
    &lt;p&gt;Started making side projects as a developer this year and hope to start working on my own products full-time from next year. Two books I found useful for positioning the product:&lt;/p&gt;
    &lt;p&gt;My favourite SF book this year was "Translation State" by Ann Leckie. It is set in the Imperial Radch world so having read the Ancillary trilogy is useful but not essential.&lt;/p&gt;
    &lt;p&gt;I like it because it contains the strangest aliens (the Presger) that I have come across. They are as far from humans in costumes as you could get. What the Presger do (and their proxies in the Human world the Translators) is totally unguessable.&lt;/p&gt;
    &lt;p&gt;A fabulous hard SF read and a must if you read the Ancillary trilogy.&lt;/p&gt;
    &lt;p&gt;I enjoyed Translation State so much. It thought that Leckie got lost in the depths of Octavia Butler’s extra weird shit (and Xenogensis) and cross bred it with the political novel style of the Ancillary trilogy, and the result was chefs kiss.&lt;/p&gt;
    &lt;p&gt;I feel comfortable recommending it even if you haven’t read any other Leckie.&lt;/p&gt;
    &lt;p&gt;Edit: if you haven’t read the Bloodchild anthology by Butler, give it a read. Some of the short stories will seem very familiar after Translation State, especially the alien parts.&lt;/p&gt;
    &lt;p&gt;My goal for the year was 15 books. I've finished 14 so far and should finish #15 in the next couple of days if all goes well. Here's what I've read (it's a mix of fiction and non-fiction) in reverse order by completion date:&lt;/p&gt;
    &lt;p&gt;Nash Falls - David Baldacci&lt;/p&gt;
    &lt;p&gt;Exit Strategy - Lee Child &amp;amp; Andrew Child&lt;/p&gt;
    &lt;p&gt;Perceptrons: An Introduction to Computational Geometry - Marvin Minsky &amp;amp; Seymour Papert&lt;/p&gt;
    &lt;p&gt;We are Legion (We are Bob) - Dennis Taylor&lt;/p&gt;
    &lt;p&gt;Parallel Distributed Processing: Explorations in the Microstructure of Cognition: Volume 1: Foundations - David Rumelhart &amp;amp; Jay McClelland&lt;/p&gt;
    &lt;p&gt;Semantic Information Processing - Marvin Minsky&lt;/p&gt;
    &lt;p&gt;Associative Engines: Connectionism, Concepts, and Representational Change - Andy Clark&lt;/p&gt;
    &lt;p&gt;Associative Networks: The Representation and Use of Knowledge of Computers - Nicholas Findler&lt;/p&gt;
    &lt;p&gt;The Analogical Mind: Perspectives from Cognitive Science - Dedre Gentner, Keith J. Holyoak, Boicho N. Kokinov (eds)&lt;/p&gt;
    &lt;p&gt;Similarity and Analogical Reasoning - Stella Vosniadou (ed)&lt;/p&gt;
    &lt;p&gt;Never Flinch - Stephen King&lt;/p&gt;
    &lt;p&gt;The Bad Weather Friend - Dean Koontz&lt;/p&gt;
    &lt;p&gt;Kluge: The Haphazard Construction of the Human Mind - Gary Marcus&lt;/p&gt;
    &lt;p&gt;After Death - Dean Koontz&lt;/p&gt;
    &lt;p&gt;The 15th book that I hope to finish will be:&lt;/p&gt;
    &lt;p&gt;Principles of Semantic Networks - John F. Sowa (ed)&lt;/p&gt;
    &lt;p&gt;I was actually writing, been doing it full time for months. I've spent probably over 1,000 hours ...&lt;/p&gt;
    &lt;p&gt;Not trying to make any money, just feel compelled to do this.&lt;/p&gt;
    &lt;p&gt;A fiction story about how personal computers have dismantled society over 40 years... it takes place in 1983 and involves a vulnerable opportunistic time traveler who's getting more than he bargained for.&lt;/p&gt;
    &lt;p&gt;Here's some quotes to give you a feel:&lt;/p&gt;
    &lt;p&gt;"The smartphone is the electrical stunner in the slaughterhouse of society"&lt;/p&gt;
    &lt;p&gt;"You’ll be able to access any TV or radio station in real time, around the world, talk to people overseas in high resolution video with live translations for free and be bored by it"&lt;/p&gt;
    &lt;p&gt;"In the future the hermetic spaces of solitude will be breached as we build a global village. The private will become public and, ironically, the public will become private as the streets empty of experiences taken indoors, inside of bedrooms, beneath our screens of glowing grace."&lt;/p&gt;
    &lt;p&gt;It's intentionally meant to be ambitious, brutal and challenging. And hopefully insight will materialize from the dust of forgotten dreams.&lt;/p&gt;
    &lt;p&gt;If you are interested in reading it, just hit me up&lt;/p&gt;
    &lt;p&gt;After reading Primo Levi's "The Drowned and the Saved", I went on a binge of his earlier works: "If This Is a Man", "The Truce", "If not now, when?". All great, but I keep coming back to "The Drowned and the Saved"; it's hard to put my finger on it, but it's a book that provides more meaning about life than anything I've ever read.&lt;/p&gt;
    &lt;p&gt;I mostly read fiction but I made time for a couple of nonfiction books this year. On the fiction side I really enjoyed "Luminous" and "When We Where Real".&lt;/p&gt;
    &lt;p&gt;I was surprised by how much I enjoyed Careless People. The unexpected peek into the author's personal childhood and family ethos was really interesting. The look at Facebook from within was a cautionary tale.&lt;/p&gt;
    &lt;p&gt;I also liked I Am Not Your Enemy by Reality Winner.&lt;/p&gt;
    &lt;p&gt;"Apple in China" was pretty good! I can second that one. If you haven't checked it out, "Chip War" is also pretty good and along the same style. I'm reading it right now.&lt;/p&gt;
    &lt;p&gt;For fiction I read a lot of Brandon Sanderson: the second Mistborn series, plus a few of the Secret Projects. I quite liked Tress of the Emerald Sea. Also currently reading R. F. Kuang's Katabasis which I'm really enjoying so far.&lt;/p&gt;
    &lt;p&gt;For nonfiction, I found Amanda Ripley's High Conflict to be excellent and insightful. I also finally got around to reading The Selfish Gene by Richard Dawkins; I expected it to be fine, but it far exceeded my expectations! On top of that, the edition I read also had "end notes" interspersed throughout the book with retrospectives from decades later, which only added to the book's richness.&lt;/p&gt;
    &lt;p&gt;Pachinko by Min Jin Lee stuck with me more than anything else I read this year. It is a work of simple beauty.&lt;/p&gt;
    &lt;p&gt;It’s a story of several generations of poor Korean women who eventually immigrate to Japan. The front half of the book is wonderfully paced to spend time with the characters. The back half can feel a bit rushed, but it becomes more of a page turner.&lt;/p&gt;
    &lt;p&gt;The Cold Millions by Jess Walter is another period novel about union organizing in the Pacific Northwest around the turn of the century, and follows two brothers. The depth of research makes this book wonderfully vibrant.&lt;/p&gt;
    &lt;p&gt;I was suffering from a burnout for much of the year and read mostly to relax. Reread a bunch of Discworld and read most of the Expanse series for the first time. Some Murakami. The Conway biography ("Genius At Play"), also a reread because it's fun.&lt;/p&gt;
    &lt;p&gt;But "The Dream Machine: JCR Licklider and the Revolution That Made Computing Personal", often recommended om HN, was amazing. It has so much of the history of how personal computers came to be, and so much that was new to me.&lt;/p&gt;
    &lt;p&gt;I read The Buddha: Biography of a Myth, by Donald S. Lopez after hearing him on Conversations With Tyler. That's probably my top non-fiction book this year. Key takeaway was that the history of Buddhism is incredibly deep. Two highlights: First, the Buddha said that minor rules could be disregarded after his passing, but the person that was informed of this forgot to ask for clarification of what rules were minor, so there's debate over which rules must be followed. Second, the Buddha left us because nobody asked him to stay. This second point makes me reflect on the importance of reminding people that they are valued.&lt;/p&gt;
    &lt;p&gt;I also read The Red Book, Reader's Edition, by Carl Jung. I'm still processing that one. The artwork in the book is breathtaking and I strongly suggest looking it up even if you only look at the art. Narratively, it feels a bit like rambling at times. I'd previously read Archetypes and the Collective Unconscious, and Aion, and felt like those had a bit more intelligible substance. The first few chapters of Aion are excellent, but then Jung just goes on for like a dozen chapters about fish symbolism which completely lost me.&lt;/p&gt;
    &lt;p&gt;I also read a few other books on occult and esoteric topics, but my thoughts on those books are more complex than what I'm willing to type out on mobile. Key takeaway from a book on Wiccan Witchcraft was that they also believe in a system of reincarnation. I'm interested in reading through some of the core texts of Chinese Mythology at some point, but there aren't any good audiobook recordings for some of them.&lt;/p&gt;
    &lt;p&gt;I'm sad to say that I made very little progress in getting through proper college level textbooks, but I'm working through Molecular Biology of the Cell.&lt;/p&gt;
    &lt;p&gt;Humble Bundle has spoiled me and my ebook library has grown by around a 100 books this year...&lt;/p&gt;
    &lt;p&gt;Tech book recommendations: 'Secure by Design', 'Designing Data-Intensive Applications', 'Building Secure and Reliable Systems' and 'Fundamentals of Software Architecture'.&lt;/p&gt;
    &lt;p&gt;For scifi: 'Murderbot Diaries' and 'The Expanse' - both are just great entertainment&lt;/p&gt;
    &lt;p&gt;Dungeon Crawler Carl - I laughed, I cried, perfect match for my sense of humor.&lt;/p&gt;
    &lt;p&gt;The Comfort Crisis by Michael Easter - Great read, changed some of my training because of it.&lt;/p&gt;
    &lt;p&gt;Fall of Giants by Ken Follett (#1 of The Century Trilogy series) - An amazing overview of the 20th century through the eyes of several families accross the globe (fiction).&lt;/p&gt;
    &lt;p&gt;Not enough. Going to try to rein in some sustained attention in the new year.&lt;/p&gt;
    &lt;p&gt;- Piranesi by Susanna Clarke&lt;/p&gt;
    &lt;p&gt;- Playground by Richard Powers&lt;/p&gt;
    &lt;p&gt;- Designing Data Intensive Applications by Martin Kleppman&lt;/p&gt;
    &lt;p&gt;I'm curious how much AI-generated stuff I read this year... likely at least a book's worth, but it would be more like one of those books with 365+ random deep dives into stuff that's not really relevant to my life.&lt;/p&gt;
    &lt;p&gt;Acting class - I found this book surprisingly compelling. It made me reflect on my own search for connection and identity, and how easily it is to be misled and manipulated when you've got no one close.&lt;/p&gt;
    &lt;p&gt;Earthlings - The book's plot gets really horrific (don't let the cover fool you). However, it did make me think about social norms and taboos a little differently.&lt;/p&gt;
    &lt;p&gt;1984 - It was my first time reading the book, and man, looking around and seeing bits and pieces of the surveillance mentioned in the book in real life is kind of terrifying...&lt;/p&gt;
    &lt;p&gt;Grapes of Wrath - It's definitely the most heart-wrenching book I've ever read. Watching the Joad family get absolutely devastated by the monster that is unchecked capitalism is so sad :(&lt;/p&gt;
    &lt;p&gt;Skunk works - Really good book on the development of Lockheed's stealth planes. However, I did wish I got more technical details.&lt;/p&gt;
    &lt;p&gt;I would love to see some more book recommendations :)&lt;/p&gt;
    &lt;p&gt;I really enjoyed The Technological Republic by Alexander C. Karp and Nicholas W. Zamiska. It’s sharp, opinionated, and unusually concrete about how state capacity, technology, and institutional competence intersect in practice. Even if you don’t agree with all of it, it’s a book that forces clearer thinking about power, technology, and governance.&lt;/p&gt;
    &lt;p&gt;A few years ago I promised myself to read the top of "must reads" from world literature. Many of them were literally unreadable (hello Moby Dick). But some of them are true gems, must-reads indeed. I just finished "The Grapes of Wrath" and holy cow, this is an impressive piece of literature. And unfortunately, more relevant than ever. Why not give science fiction a break and try this classic instead.&lt;/p&gt;
    &lt;p&gt;Frankenstein. Superb science fiction, very readable even though written 200 years ago. And Wuthering Heights, which strangely like Frankenstein, has a complex narrative structure and an unhinged, obsessive central character&lt;/p&gt;
    &lt;p&gt;I read it this year too. I was surprised by the amount of heartfelt soliloquising the monster did, he was much more compelling than I expected. Victor of course was the real monster in the story, self obsessed, not taking responsibility for his actions, I found myself actively rooting against him.&lt;/p&gt;
    &lt;p&gt;I'm on my fourth George Eliot novel this year, Adam Bede, which was her first published novel. I started with Middlemarch and proceeded to read Silas Mariner, Romola, and Daniel Deronda. The 1985 film adaptation of Silas Marner is very good and faithful to the novel. The 1970 Daniel Deronda film is similarly faithful and well-acted but the 2002 version is neither.&lt;/p&gt;
    &lt;p&gt;I had a crack at reading the first Game of Thrones novel (I think it's just called A Game of Thrones) but my brain seems to be in non-fiction mode at the moment. I think I'm drawn to a kind of sweet spot halfway between "related to my everyday experience" and "removed from my everyday experience" - not sure I could read about programming or business at the moment, though I also haven't tried.&lt;/p&gt;
    &lt;p&gt;How to Think Like Socrates - I normally have a difficult time digesting philosophy in older translations or language, but this one was really nicely written and well communicated.&lt;/p&gt;
    &lt;p&gt;Water by Rumi (translated by Haleh Liza Gafori) - also unexpectedly good. She uses a modern style and it reads so beautifully. It gave me glimpse of the beauty of the Persian language.&lt;/p&gt;
    &lt;p&gt;The Count of Monte Cristo was published in serial form. Daily from 1844 to 1846.&lt;/p&gt;
    &lt;p&gt;That explains a lot the format, which tended to try to retain the audience.&lt;/p&gt;
    &lt;p&gt;Also, the author wrote in advance of the daily publication, but the book was written "live", answering to public perception and response. This is a reason why the book is so "good": the author had the chance to adjust the story based on data from sales and feedback from readers.&lt;/p&gt;
    &lt;p&gt;Of course Dumas was a great writer too, but this live writing, data based is probably why the book resonates so well with audiences.&lt;/p&gt;
    &lt;p&gt;So, as a joke, if you read count of monte cristo in 3 weeks, you did the equivalent of bing reading it.&lt;/p&gt;
    &lt;p&gt;This happens with soap operas too. 10 years ago, they lasted 1 year. They had an initial structure, the story, the characters, but responded in "real-time" to audience feedback.&lt;/p&gt;
    &lt;p&gt;For those willing to read the book, give yourself some time. Try to read it over a course of some years. Read a little, come back to it.&lt;/p&gt;
    &lt;p&gt;There are several famous books written in the same form, like Crime and Punishment or The Three Musketeers.&lt;/p&gt;
    &lt;p&gt;Oh, and also authors got payed by installment, so that explains the lenght lol&lt;/p&gt;
    &lt;p&gt;Loved the stranger, I read it for the first time this year too. I read plenty of sub culture (mostly modern; Irvine welsh etc) but the stranger was just so different than anything I’ve ever read. Like the language is so olan yet it works so well, and then you have this great finish, it’s a weird masterpiece.&lt;/p&gt;
    &lt;p&gt;I got really into Hemingway’s work, reading all the best ones, but my favourite being ‘A moveable feast’ his diary essentially released at the end of his life set when he was mid-twenties in 1920s Paris. Me being the same age, I was inspired enough to go there and retrace some of his steps.&lt;/p&gt;
    &lt;p&gt;I reread “The Screwtape Letters” by CS Lewis for the first time since high school and appreciated it even more. Although it’s written from a Christian point of view, the principles are applicable to any moral framework.&lt;/p&gt;
    &lt;p&gt;I also read Meditations this year. Definitely not what I was expecting. It's not cohesive at all. My biggest takeaways were the inevitability of death and generally letting go of our sense of control.&lt;/p&gt;
    &lt;p&gt;One of my favourite reads from this past year was Infinite Powers: How Calculus Reveals the Secrets of the Universe by Steven Strogatz. It's a wonderful review of the history of calculus, including intuitive explanations of the basics.&lt;/p&gt;
    &lt;p&gt;I stumbled upon some great reddit posts this year with reading suggestions, and compiled my own "humanity is fucked" themed reading list, which included:&lt;/p&gt;
    &lt;p&gt;* Mercy of Gods by James S.A. Corey&lt;/p&gt;
    &lt;p&gt;* The Light Pirate by Lily Brooks-Dalton&lt;/p&gt;
    &lt;p&gt;* Oryx and Crake by Margaret Atwood&lt;/p&gt;
    &lt;p&gt;* Dawn by Octavia Butler&lt;/p&gt;
    &lt;p&gt;I then diverged from this list (I have more) to re-read (though it's not such a great divergence):&lt;/p&gt;
    &lt;p&gt;* If This Is a Man / The Truce by Primo Levi&lt;/p&gt;
    &lt;p&gt;Other books I enjoyed reading this year in no particular order:&lt;/p&gt;
    &lt;p&gt;* Tau Zero by Poul Anderson&lt;/p&gt;
    &lt;p&gt;* Machine Vendetta by Alastair Reynolds&lt;/p&gt;
    &lt;p&gt;* Elysium Fire by Alastair Reynolds&lt;/p&gt;
    &lt;p&gt;* Aurora Rising by Alastair Reynolds&lt;/p&gt;
    &lt;p&gt;* Shadow of the Silk Road by Colin Thubron (loved this)&lt;/p&gt;
    &lt;p&gt;* The Lord of the Rings (the god knows how many times re-read)&lt;/p&gt;
    &lt;p&gt;* The Centauri Device by M. John Harrison&lt;/p&gt;
    &lt;p&gt;* Future's Edge by Gareth Powell&lt;/p&gt;
    &lt;p&gt;* Blueshift by Joshua Dalzelle&lt;/p&gt;
    &lt;p&gt;* The Heart of a Continent by Francis Younghusband (I didn't quite manage to finish it, but it was a fascinating read nonetheless)&lt;/p&gt;
    &lt;p&gt;I stopped reading newspapers long back (early 2010s). During the Pandemic, I started a newspaper subscription (very common in India, delivered to the home) so I can use it to segregate wet waste properly. I started reading bits and pieces: horrors/misfortunes sell; news is stale, etc. Of late, I decided to look at it from a different angle, bringing back my childhood nostalgia, when I devoured every piece of reading material I could find. Now, I pick the ones I want to read, marking them as a reminder of continuity, a small bridge to a past life. I’m going to continue this slow reading with Newspapers. Wrote an article about my feelings, scheduled to be published on my personal blog in 2026-JAN.&lt;/p&gt;
    &lt;p&gt;For books, this year has been the year with the fewest books read.[1] I ended up reading the past: John Keats’s Poems, Marcus Aurelius, The Great Gatsby, Odyssey, and Iliad by Homer.&lt;/p&gt;
    &lt;p&gt;As a habit and a tribute to something I liked in the past, I read Dan Brown’s latest, “The Secret of Secrets.” I also started re-reading some of Sidney Sheldon’s books, but, as of this day, I could no longer summon the enthusiasm to continue beyond Master of the Game and The Sands of Time.&lt;/p&gt;
    &lt;p&gt;I also re-read the fantastic book, “Flatland: A Romance of Many Dimensions”[2] by Edwin Abbott Abbott.&lt;/p&gt;
    &lt;p&gt;I read Murder Must Advertise, by Dorothy L Sayers. Quote:&lt;/p&gt;
    &lt;p&gt;All over London the lights flickered in and out, calling on the public to save its body and purse: SOPO SAVES SCRUBBING—NUTRAX FOR NERVES—CRUNCHLETS ARE CRISPER—EAT PIPER PARRITCH—DRINK POMPAYNE—ONE WHOOSH AND IT'S CLEAN—OH, BOY! IT'S TOMBOY TOFFEE—NOURISH NERVES WITH NUTRAX—FARLEY'S FOOTWEAR TAKES YOU FURTHER—IT ISN'T DEAR, IT'S DARLING—DARLING'S FOR HOUSEHOLD APPLIANCES—MAKE ALL SAFE WITH SANFECT—WHIFFLETS FASCINATE. The presses, thundering and growling, ground out the same appeals by the million: ASK YOUR GROCER—ASK YOUR DOCTOR—ASK THE MAN WHO'S TRIED IT—MOTHERS! GIVE IT TO YOUR CHILDREN—HOUSEWIVES! SAVE MONEY—HUSBANDS! INSURE YOUR LIVES—WOMEN! DO YOU REALIZE?—DON'T SAY SOAP, SAY SOPO! Whatever you're doing, stop it and do something else! Whatever you're buying, pause and buy something different! Be hectored into health and prosperity! Never let up! Never go to sleep! Never be satisfied. If once you are satisfied, all our wheels will run down. Keep going—and if you can't, Try Nutrax for Nerves!&lt;/p&gt;
    &lt;p&gt;Technically last year, but less than 365 days ago:&lt;/p&gt;
    &lt;p&gt;* The Mom Test&lt;/p&gt;
    &lt;p&gt;* The SAAS Playbook&lt;/p&gt;
    &lt;p&gt;Actually in this year, the ones I remember the most:&lt;/p&gt;
    &lt;p&gt;* Start Small, Stay Small&lt;/p&gt;
    &lt;p&gt;* From Yao To Mao (more a series of lectures on chinese history)&lt;/p&gt;
    &lt;p&gt;The most recent one I haven't finished yet but was surprised I liked:&lt;/p&gt;
    &lt;p&gt;* Software Engeineering at Google&lt;/p&gt;
    &lt;p&gt;Many more things described ring true or feel desireable, and I recognize too many of the anti-patterns from companies I worked for. Although, I also recognized the good things people were doing and started to appreciate them more.&lt;/p&gt;
    &lt;p&gt;Early in the year I picked up "Dark Wire" by Joseph Cox. It was a fascinating dive into the world of "secure phones", particularly a company called Anom.&lt;/p&gt;
    &lt;p&gt;I also read:&lt;/p&gt;
    &lt;p&gt;"Digital Fortress" - Dan Brown (not strictly technically plausible but the suspense kept me hooked) "Never Enough" - Andrew Wilkinson (meh)&lt;/p&gt;
    &lt;p&gt;Currently working on: "The Technological Republic" - Andrew Karp "Designing Data-Intensive Applications" - Martin Kleppmann&lt;/p&gt;
    &lt;p&gt;I had a tendency of a lot of false starts on books this year. I picked up several recent LLM/AI books and would make it like a chapter before realizing it was mostly just AI generated slop and gave up.&lt;/p&gt;
    &lt;p&gt;For those interested in the subject (and who can also read French) I also heartily recommend the most recent edition of Augustin Thierry's Récits des temps mérovingiens [1]. Of course that it has most probably long been surpassed when it comes to historic accuracy, after all it was written almost 200 years ago, but it is very interesting nonetheless for being one of the first books that really put the focus on the Merovingians from a historical perspective that was "scientific", for lack of a better word.&lt;/p&gt;
    &lt;p&gt;if you do read french, proust’s “in search of lost time” (vol 1) is a lot more accessible and enjoyable than my high school teachers made it sound years and years ago. it even contains a depiction of what a learned engineer should be like.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=46391572</guid><pubDate>Fri, 26 Dec 2025 12:55:16 +0000</pubDate></item><item><title>LearnixOS</title><link>https://www.learnix-os.com</link><description>&lt;doc fingerprint="7fe43b9d48af5e9f"&gt;
  &lt;main&gt;
    &lt;head rend="h1"&gt;The Learnix Operating System&lt;/head&gt;
    &lt;p&gt;"If you can't explain it simply, you don't understand it well enough." - Albert Einstein&lt;/p&gt;
    &lt;p&gt;Hello there!1&lt;/p&gt;
    &lt;p&gt;In this book we are going to write and learn about operating systems together!&lt;/p&gt;
    &lt;p&gt;We are going to implement an entire POSIX compliant OS in Rust and not use ANY2 external libraries. All of the thought process, code and implementations will be explained and documented here as well as in this repo which all the code snippets are from.&lt;/p&gt;
    &lt;quote&gt;
      &lt;p&gt;Note: ALL the syntax highlighting of the Rust code is custom and create by me! If you see and bug, please write in the comments or submit an issue.&lt;/p&gt;
    &lt;/quote&gt;
    &lt;head rend="h2"&gt;Base Knowledge&lt;/head&gt;
    &lt;p&gt;This book will be technical, and will assume a little bit of a programming knowledge background, but not necessarily in rust&lt;/p&gt;
    &lt;p&gt;If you are not coming from a low level programming knowledge that's fine!&lt;/p&gt;
    &lt;p&gt;Just make sure you know this stuff or learn it as you read. Also if in any place on this book I take some things for granted, please, open an issue here and let me know so I could explain it better.&lt;/p&gt;
    &lt;p&gt;Some of the base knowledge that you would need to have:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;
        &lt;p&gt;Some assembly knowledge. (just understand simple movs, and arithmetic operations, at a very basic level3)&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Some knowledge on memory. (what's a pointer, what's an address)&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;A knowledge in rust is not that important, but knowing at least one programming language is. I myself have some more learning in Rust, and in this book I will also explain some great features that it has!&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;A lot of motivation to learn and understand because it is a complex subject.&lt;/p&gt;
      &lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h2"&gt;Roadmap of this book&lt;/head&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;
        &lt;p&gt;Compiling a stand alone binary&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Boot loading, Debugging, stages and some legacy stuff&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Important cpu modes and instructions&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Paging, writing out own malloc&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Utilizing the Interrupt Descriptor Table&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;File systems and Disk Drivers&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Thinking in terms of processes&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Writing a shell&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Running our first program! (Which off course will be Doom)&lt;/p&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;To be continued (Hopefully virtualization section and loading a vm of other OS)&lt;/p&gt;
      &lt;/item&gt;
    &lt;/list&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=46391599</guid><pubDate>Fri, 26 Dec 2025 12:59:56 +0000</pubDate></item><item><title>Rob Pike goes nuclear over GenAI</title><link>https://skyview.social/?url=https%3A%2F%2Fbsky.app%2Fprofile%2Frobpike.io%2Fpost%2F3matwg6w3ic2s&amp;viewtype=tree</link><guid isPermaLink="false">https://news.ycombinator.com/item?id=46392115</guid><pubDate>Fri, 26 Dec 2025 14:08:47 +0000</pubDate></item><item><title>Show HN: Xcc700: Self-hosting mini C compiler for ESP32 (Xtensa) in 700 lines</title><link>https://github.com/valdanylchuk/xcc700</link><description>&lt;doc fingerprint="3702985821161ae9"&gt;
  &lt;main&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;A compiler you can fully grasp and tweak, on a modern platform where small is still cool.&lt;/item&gt;
      &lt;item&gt;Basic features, not too entrenched, easy to morph into your language of choice.&lt;/item&gt;
      &lt;item&gt;Reusable ELF writer, and a basic Xtensa bytecodes emitter.&lt;/item&gt;
      &lt;item&gt;Possibly useful for hotfixes, CI, quick test/debug turnaround on esp32.&lt;/item&gt;
    &lt;/list&gt;
    &lt;code&gt;./xcc700 xcc700.c -o xcc700.elf 

[ xcc700 ] BUILD COMPLETED &amp;gt; OK
&amp;gt; IN  : 700 Lines / 7977 Tokens
&amp;gt; SYM : 69 Funcs / 91 Globals
&amp;gt; REL : 152 Literals / 1027 Patches
&amp;gt; MEM : 1041 B .rodata / 17120 B .bss
&amp;gt; OUT : 27735 B .text / 33300 B ELF
[ 40 ms ] &amp;gt;&amp;gt; 17500 Lines/sec &amp;lt;&amp;lt;
&lt;/code&gt;
    &lt;p&gt;Note: that timing is from esp32-s3. Timings on Mac/POSIX will be reported 1000x slower than they are, as on esp32 ticks are millisecond, and on POSIX microsecond, but there is no adjustment here.&lt;/p&gt;
    &lt;head class="px-3 py-2"&gt;xcc700_demo10s.mov&lt;/head&gt;
    &lt;p&gt;.&lt;/p&gt;
    &lt;p&gt;Several options:&lt;/p&gt;
    &lt;p&gt;A. Compile with &lt;code&gt;gcc xcc700.c&lt;/code&gt; and run it on your computer as a cross-compiler. It is fairly portable, tested on Mac x86_64 and arm64.&lt;/p&gt;
    &lt;p&gt;B. Compile for esp32 using xtensa-gcc or xcc700 from the option A (yes it can compile and cross-compile itself). Or grab the gcc-compiled version here: xcc700.elf (16kB). Run with ESP-IDF elf_loader.&lt;/p&gt;
    &lt;p&gt;C. Adapt the source code and call it as a function in your firmware.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;C features: minimum required to write something like this compiler. While loop, if/then/else, limited support for int/char/pointers/arrays, function calls and definitions, basic arithmetic and bitwise operators.&lt;/item&gt;
      &lt;item&gt;Single source .c file as input, single REL ELF file as output.&lt;/item&gt;
      &lt;item&gt;The output files can be run directly by the ESP-IDF elf_loader component, which links them on load via relocation table to anything you have exposed in your firmware: newlib libc, LVGL, your custom functions, anything you like. Just declare the functions you use.&lt;/item&gt;
    &lt;/list&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;The rest of the C: for/do, include/define, long/float/double, struct/union/typedef, switch/case, array initializers, .data section, multi-line comments, too much to list.&lt;/item&gt;
      &lt;item&gt;Many features are implemented only partially. E.g. you can have .bss globals but not global initializers; ++/-- are only supported in prefix position, assignment as statement not expression, types are mostly not checked, etc.&lt;/item&gt;
      &lt;item&gt;Error handling and reporting. It is wildly optimistic, enforces nothing, has only a few error checks, and will crash in spectacular and unexpected ways on the most trivial errors.&lt;/item&gt;
      &lt;item&gt;Optimization. It treats the Xtensa CPU as a stack machine, with no attempt at register allocation, and no benefit from the sliding window. It is a major sacrifice of performance for simplicity. GCC-compiled: 16kB, 17,500 lines/s; self-compiled: 33kB, 3,900 lines/s.&lt;/item&gt;
      &lt;item&gt;Miss a feature? Just fork it! With a working foundation in only 700 lines, it is fairly easy to get started.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;This is free software under MIT License, see LICENSE.&lt;/p&gt;
    &lt;p&gt;While I do not believe the world needs another C99 implementation, and do not intend to add features here, I am dead curious to see where the other creative minds can take a tiny self-hosting compiler on esp32.&lt;/p&gt;
    &lt;p&gt;If you organize hackathons, or assign coursework, or write tutorials, please consider xcc700 as a base to fork and extend! It can run on the available PCs, or on a $5 MCU if you want real cool hardware for the final test. Or you can port it to other systems, and use ld to link those ELF files.&lt;/p&gt;
    &lt;p&gt;I was making an esp32 "cyberdeck", and thought it cool to build some binaries directly on it. Esp32 is underrated in userland. It can do everything a 90s PC could do and more.&lt;/p&gt;
    &lt;p&gt;You can also take this as an artistic statement, and ask yourself:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;How many Watts do you need to do fun/useful stuff on a computer?&lt;/item&gt;
      &lt;item&gt;Isn't it nice to have simple, tinker-friendly versions of common apps?&lt;/item&gt;
      &lt;item&gt;Do we really need 300MB mouse drivers?&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Have fun!&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=46392736</guid><pubDate>Fri, 26 Dec 2025 15:07:01 +0000</pubDate></item><item><title>High school student discovers 1.5M potential new astronomical objects</title><link>https://www.smithsonianmag.com/smart-news/high-school-student-discovers-1-5-million-potential-new-astronomical-objects-by-developing-an-ai-algorithm-180986429/</link><description>&lt;doc fingerprint="ad5111b84a980758"&gt;
  &lt;main&gt;
    &lt;head rend="h1"&gt;High School Student Discovers 1.5 Million Potential New Astronomical Objects by Developing an A.I. Algorithm&lt;/head&gt;
    &lt;head rend="h2"&gt;The 18-year-old won $250,000 for training a machine learning model to analyze understudied data from NASA’s retired NEOWISE telescope&lt;/head&gt;
    &lt;p&gt;In a leap forward for astronomy, a researcher has developed an artificial intelligence algorithm and discovered more than one million objects in space by parsing through understudied data from a NASA telescope.&lt;/p&gt;
    &lt;p&gt;The breakthrough is detailed in a study published in November in The Astronomical Journal. What the study doesn’t detail, however, is that the paper’s sole author is 18 years old.&lt;/p&gt;
    &lt;p&gt;Matteo Paz from Pasadena, California, recently won the first place prize of $250,000 in the 2025 Regeneron Science Talent Search for combining machine learning with astronomy. Self-described as the nation’s “oldest and most prestigious science and math competition for high school seniors,” the contest recognized Paz for developing his A.I. algorithm. The young scientist’s tool processed 200 billion data entries from NASA’s now-retired Near-Earth Object Wide-field Infrared Survey Explorer (NEOWISE) telescope. His model revealed 1.5 million previously unknown potential celestial bodies.&lt;/p&gt;
    &lt;p&gt;“I was just happy to have had the privilege. Not only placing in the top ten, but winning first place, came as a visceral surprise,” the teenager tells Forbes’ Kevin Anderton. “It still hasn’t fully sunk in.”&lt;/p&gt;
    &lt;p&gt;Paz’s interest in astronomy turned into real research when he participated in the Planet Finder Academy at the California Institute of Technology (Caltech) in summer 2022. There, he studied astronomy and computer science under the guidance of his mentor, Davy Kirkpatrick, an astronomer and senior scientist at the university’s Infrared Processing and Analysis Center (IPAC).&lt;/p&gt;
    &lt;p&gt;Kirkpatrick had been working with data from the NEOWISE infrared telescope, which NASA launched in 2009 with the aim of searching for near-Earth asteroids and comets. The telescope’s survey, however, also collected data on the shifting heat of variable objects: rare phenomena that emit flashing, changing or otherwise dynamic light, such as exploding stars. It was Kirkpatrick’s idea to look for these elusive objects in NEOWISE’s understudied data.&lt;/p&gt;
    &lt;p&gt;“At that point, we were creeping up towards 200 billion rows in the table of every single [NEOWISE] detection that we had made over the course of over a decade,” Kirkpatrick explains in a Caltech statement. “So, my idea for the summer was to take a little piece of the sky and see if we could find some variable stars. Then we could highlight those to the astronomic community, saying, ‘Here’s some new stuff we discovered by hand; just imagine what the potential is in the dataset.’”&lt;/p&gt;
    &lt;p&gt;Paz, however, had no intention of doing it by hand. Instead, he worked on an A.I. model that sorted through the raw data in search of tiny changes in infrared radiation, which could indicate the presence of variable objects. Paz and Kirkpatrick continued working together after the summer to perfect the model, which ultimately flagged 1.5 million potential new objects, including supernovas and black holes.&lt;/p&gt;
    &lt;p&gt;“Prior to Matteo’s work, no one had tried to use the entire (200-billion-row) table to identify and classify all of the significant variability that was there,” Kirkpatrick tells Business Insider’s Morgan McFall-Johnsen in an email. He adds that Caltech researchers are already making use of Paz’s catalog of potential variable objects, called VarWISE, to study binary star systems.&lt;/p&gt;
    &lt;p&gt;“The variable candidates that he’s uncovered will be widely studied,” says Amy Mainzer, NEOWISE’s principal investigator for NASA, to Business Insider.&lt;/p&gt;
    &lt;p&gt;As for the A.I. model, Paz explains that it might be applicable to “anything else that comes in a temporal format,” such as stock market chart analysis and atmospheric effects like pollution, according to the statement. It’s no surprise the teenager is interested in the climate—as fires burned in L.A. earlier this year, the Eaton Fire forced him and his family to evacuate their home, Forbes reports.&lt;/p&gt;
    &lt;p&gt;Other teenage scientists recognized by the contest studied mosquito control, drug-resistant fungus, the human genome and mathematics.&lt;/p&gt;
    &lt;p&gt;“The remarkable creativity and dedication of these students bring renewed hope for our future,” Maya Ajmera, president of the Society for Science, which oversees the award, says in a statement. “Driven by their ingenuity, these young scientists are developing groundbreaking solutions that have the potential to transform our world and propel society forward.”&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=46392815</guid><pubDate>Fri, 26 Dec 2025 15:13:21 +0000</pubDate></item><item><title>Show HN: Witr – Explain why a process is running on your Linux system</title><link>https://github.com/pranshuparmar/witr</link><description>&lt;doc fingerprint="431a903f2dafc432"&gt;
  &lt;main&gt;
    &lt;p&gt;witr exists to answer a single question:&lt;/p&gt;
    &lt;quote&gt;
      &lt;p&gt;Why is this running?&lt;/p&gt;
    &lt;/quote&gt;
    &lt;p&gt;When something is running on a system—whether it is a process, a service, or something bound to a port—there is always a cause. That cause is often indirect, non-obvious, or spread across multiple layers such as supervisors, containers, services, or shells.&lt;/p&gt;
    &lt;p&gt;Existing tools (&lt;code&gt;ps&lt;/code&gt;, &lt;code&gt;top&lt;/code&gt;, &lt;code&gt;lsof&lt;/code&gt;, &lt;code&gt;ss&lt;/code&gt;, &lt;code&gt;systemctl&lt;/code&gt;, &lt;code&gt;docker ps&lt;/code&gt;) expose state and metadata. They show what is running, but leave the user to infer why by manually correlating outputs across tools.&lt;/p&gt;
    &lt;p&gt;witr makes that causality explicit.&lt;/p&gt;
    &lt;p&gt;It explains where a running thing came from, how it was started, and what chain of systems is responsible for it existing right now, in a single, human-readable output.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Explain why a process exists, not just that it exists&lt;/item&gt;
      &lt;item&gt;Reduce time‑to‑understanding during debugging and outages&lt;/item&gt;
      &lt;item&gt;Work with zero configuration&lt;/item&gt;
      &lt;item&gt;Be safe, read‑only, and non‑destructive&lt;/item&gt;
      &lt;item&gt;Prefer clarity over completeness&lt;/item&gt;
    &lt;/list&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Not a monitoring tool&lt;/item&gt;
      &lt;item&gt;Not a performance profiler&lt;/item&gt;
      &lt;item&gt;Not a replacement for systemd/docker tooling&lt;/item&gt;
      &lt;item&gt;Not a remediation or auto‑fix tool&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;witr treats everything as a process question.&lt;/p&gt;
    &lt;p&gt;Ports, services, containers, and commands all eventually map to PIDs. Once a PID is identified, witr builds a causal chain explaining why that PID exists.&lt;/p&gt;
    &lt;p&gt;At its core, witr answers:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;What is running?&lt;/item&gt;
      &lt;item&gt;How did it start?&lt;/item&gt;
      &lt;item&gt;What is keeping it running?&lt;/item&gt;
      &lt;item&gt;What context does it belong to?&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;witr supports multiple entry points that converge to PID analysis.&lt;/p&gt;
    &lt;code&gt;witr node
witr nginx&lt;/code&gt;
    &lt;p&gt;A single positional argument (without flags) is treated as a process or service name. If multiple matches are found, witr will prompt for disambiguation by PID.&lt;/p&gt;
    &lt;code&gt;witr --pid 14233&lt;/code&gt;
    &lt;p&gt;Explains why a specific process exists.&lt;/p&gt;
    &lt;code&gt;witr --port 5000&lt;/code&gt;
    &lt;p&gt;Explains the process(es) listening on a port.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Single screen by default (best effort)&lt;/item&gt;
      &lt;item&gt;Deterministic ordering&lt;/item&gt;
      &lt;item&gt;Narrative-style explanation&lt;/item&gt;
      &lt;item&gt;Best-effort detection with explicit uncertainty&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;What the user asked about.&lt;/p&gt;
    &lt;p&gt;Executable, PID, user, command, start time and restart count.&lt;/p&gt;
    &lt;p&gt;A causal ancestry chain showing how the process came to exist. This is the core value of witr.&lt;/p&gt;
    &lt;p&gt;The primary system responsible for starting or supervising the process (best effort).&lt;/p&gt;
    &lt;p&gt;Examples:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;systemd unit&lt;/item&gt;
      &lt;item&gt;docker container&lt;/item&gt;
      &lt;item&gt;pm2&lt;/item&gt;
      &lt;item&gt;cron&lt;/item&gt;
      &lt;item&gt;interactive shell&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Only one primary source is selected.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Working directory&lt;/item&gt;
      &lt;item&gt;Git repository name and branch&lt;/item&gt;
      &lt;item&gt;Docker container name / image&lt;/item&gt;
      &lt;item&gt;Public vs private bind&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Non‑blocking observations such as:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Process is running as root&lt;/item&gt;
      &lt;item&gt;Process is listening on a public interface (0.0.0.0 / ::)&lt;/item&gt;
      &lt;item&gt;Restarted multiple times (warning only if above threshold)&lt;/item&gt;
      &lt;item&gt;Process is using high memory (&amp;gt;1GB RSS)&lt;/item&gt;
      &lt;item&gt;Process has been running for over 90 days&lt;/item&gt;
    &lt;/list&gt;
    &lt;code&gt;--pid &amp;lt;n&amp;gt;         Explain a specific PID
--port &amp;lt;n&amp;gt;        Explain port usage
--short           One-line summary
--tree            Show full process ancestry tree
--json            Output result as JSON
--warnings        Show only warnings
--no-color        Disable colorized output
--env             Show only environment variables for the process
--help            Show this help message
&lt;/code&gt;
    &lt;p&gt;A single positional argument (without flags) is treated as a process or service name.&lt;/p&gt;
    &lt;code&gt;witr node&lt;/code&gt;
    &lt;code&gt;Target      : node

Process     : node (pid 14233)
User        : pm2
Command     : node index.js
Started     : 2 days ago (Mon 2025-02-02 11:42:10 +05:30)
Restarts    : 1

Why It Exists :
  systemd (pid 1) → pm2 (pid 5034) → node (pid 14233)

Source      : pm2

Working Dir : /opt/apps/expense-manager
Git Repo    : expense-manager (main)
Listening   : 127.0.0.1:5001
&lt;/code&gt;
    &lt;code&gt;witr --port 5000 --short&lt;/code&gt;
    &lt;code&gt;systemd (pid 1) → PM2 v5.3.1: God (pid 1481580) → python (pid 1482060)
&lt;/code&gt;
    &lt;code&gt;witr --pid 1482060 --tree&lt;/code&gt;
    &lt;code&gt;systemd (pid 1)
  └─ PM2 v5.3.1: God (pid 1481580)
    └─ python (pid 1482060)
&lt;/code&gt;
    &lt;code&gt;witr node&lt;/code&gt;
    &lt;code&gt;Multiple matching processes found:

[1] PID 12091  node server.js  (docker)
[2] PID 14233  node index.js   (pm2)
[3] PID 18801  node worker.js  (manual)

Re-run with:
  witr --pid &amp;lt;pid&amp;gt;
&lt;/code&gt;
    &lt;code&gt;witr nginx&lt;/code&gt;
    &lt;code&gt;Ambiguous target: "nginx"

The name matches multiple entities:

[1] PID 2311   nginx: master process   (service)
[2] PID 24891  nginx: worker process   (manual)

witr cannot determine intent safely.
Please re-run with an explicit PID:
  witr --pid &amp;lt;pid&amp;gt;
&lt;/code&gt;
    &lt;p&gt;witr is distributed as a single static Linux binary.&lt;/p&gt;
    &lt;p&gt;The easiest way to install witr is via the install script.&lt;/p&gt;
    &lt;code&gt;curl -fsSL https://raw.githubusercontent.com/pranshuparmar/witr/main/install.sh | bash&lt;/code&gt;
    &lt;code&gt;curl -fsSL https://raw.githubusercontent.com/pranshuparmar/witr/main/install.sh -o install.sh
cat install.sh
chmod +x install.sh
./install.sh&lt;/code&gt;
    &lt;p&gt;The script will:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Detect your CPU architecture (&lt;code&gt;amd64&lt;/code&gt;or&lt;code&gt;arm64&lt;/code&gt;)&lt;/item&gt;
      &lt;item&gt;Download the latest released binary and man page&lt;/item&gt;
      &lt;item&gt;Install it to &lt;code&gt;/usr/local/bin/witr&lt;/code&gt;&lt;/item&gt;
      &lt;item&gt;Install the man page to &lt;code&gt;/usr/local/share/man/man1/witr.1&lt;/code&gt;&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;You may be prompted for your password to write to system directories.&lt;/p&gt;
    &lt;p&gt;If you prefer manual installation, follow these simple steps for your architecture:&lt;/p&gt;
    &lt;code&gt;# Download the binary
curl -fsSL https://github.com/pranshuparmar/witr/releases/latest/download/witr-linux-amd64 -o witr-linux-amd64

# Verify checksum (Optional, should print OK)
curl -fsSL https://github.com/pranshuparmar/witr/releases/latest/download/SHA256SUMS -o SHA256SUMS
grep witr-linux-amd64 SHA256SUMS | sha256sum -c -

# Rename and install
mv witr-linux-amd64 witr &amp;amp;&amp;amp; chmod +x witr
sudo mv witr /usr/local/bin/witr

# Install the man page (Optional)
sudo curl -fsSL https://github.com/pranshuparmar/witr/releases/latest/download/witr.1 -o /usr/local/share/man/man1/witr.1
sudo mandb &amp;gt;/dev/null 2&amp;gt;&amp;amp;1 || true&lt;/code&gt;
    &lt;code&gt;# Download the binary
curl -fsSL https://github.com/pranshuparmar/witr/releases/latest/download/witr-linux-arm64 -o witr-linux-arm64

# Verify checksum (Optional, should print OK)
curl -fsSL https://github.com/pranshuparmar/witr/releases/latest/download/SHA256SUMS -o SHA256SUMS
grep witr-linux-arm64 SHA256SUMS | sha256sum -c -

# Rename and install
mv witr-linux-arm64 witr &amp;amp;&amp;amp; chmod +x witr
sudo mv witr /usr/local/bin/witr

# Install the man page (Optional)
sudo curl -fsSL https://github.com/pranshuparmar/witr/releases/latest/download/witr.1 -o /usr/local/share/man/man1/witr.1
sudo mandb &amp;gt;/dev/null 2&amp;gt;&amp;amp;1 || true&lt;/code&gt;
    &lt;p&gt;Explanation:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Download only the binary for your architecture and the SHA256SUMS file.&lt;/item&gt;
      &lt;item&gt;Verify the checksum for your binary only (prints OK if valid).&lt;/item&gt;
      &lt;item&gt;Rename to witr, make it executable, and move to your PATH.&lt;/item&gt;
      &lt;item&gt;Install man page.&lt;/item&gt;
    &lt;/list&gt;
    &lt;code&gt;witr --version
man witr&lt;/code&gt;
    &lt;p&gt;To completely remove witr:&lt;/p&gt;
    &lt;code&gt;sudo rm -f /usr/local/bin/witr
sudo rm -f /usr/local/share/man/man1/witr.1&lt;/code&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Linux&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;witr inspects &lt;code&gt;/proc&lt;/code&gt; and may require elevated permissions to explain certain processes.&lt;/p&gt;
    &lt;p&gt;If you are not seeing the expected information (e.g., missing process ancestry, user, working directory or environment details), try running witr with sudo for elevated permissions:&lt;/p&gt;
    &lt;code&gt;sudo witr [your arguments]&lt;/code&gt;
    &lt;p&gt;witr is successful if:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;An engineer can answer "why is this running?" within seconds&lt;/item&gt;
      &lt;item&gt;It reduces reliance on multiple tools&lt;/item&gt;
      &lt;item&gt;Output is understandable under stress&lt;/item&gt;
      &lt;item&gt;Users trust it during incidents&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;This project was developed with assistance from AI/LLMs (including GitHub Copilot, ChatGPT, and related tools), supervised by a human who occasionally knew what he was doing.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=46392910</guid><pubDate>Fri, 26 Dec 2025 15:20:36 +0000</pubDate></item><item><title>Show HN: AutoLISP interpreter in Rust/WASM – a CAD workflow invented 33 yrs ago</title><link>https://acadlisp.de/noscript.html</link><description>&lt;doc fingerprint="540ac491243baeb1"&gt;
  &lt;main&gt;
    &lt;head rend="h1"&gt;acadlisp: AutoLISP Interpreter in Rust/WebAssembly&lt;/head&gt;
    &lt;head rend="h2"&gt;What is acadlisp?&lt;/head&gt;
    &lt;p&gt;acadlisp is an AutoLISP interpreter written in Rust and compiled to WebAssembly. It runs AutoLISP code directly in the browser - no AutoCAD installation required.&lt;/p&gt;
    &lt;head rend="h2"&gt;The Story: Schematic Generator 1991&lt;/head&gt;
    &lt;p&gt;In 1991, a small electrical company in Bavaria, Germany faced a challenge: every machine installation required custom electrical schematics - a time-consuming manual process.&lt;/p&gt;
    &lt;p&gt;The solution: AutoLISP, the programming language built into AutoCAD. I invented a workflow using CSV files, templates, and LISP code to automate schematic generation. Define components in spreadsheets, feed them through templates, generate complete technical drawings automatically.&lt;/p&gt;
    &lt;p&gt;I've never met anyone else who used this approach. Now I've built an interpreter in Rust/WASM so this workflow can live on in the browser - partly nostalgia, partly preservation before this knowledge disappears entirely.&lt;/p&gt;
    &lt;head rend="h2"&gt;LISP as Early AI&lt;/head&gt;
    &lt;p&gt;LISP (List Processing) was developed in 1958 by John McCarthy and was for decades the language of Artificial Intelligence research. What makes LISP special?&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Homoiconicity: Code and data share the same structure (lists)&lt;/item&gt;
      &lt;item&gt;Self-modification: Programs can write and modify themselves&lt;/item&gt;
      &lt;item&gt;Symbolic processing: Manipulation of symbols, not just numbers&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;In the 1991 schematic generator, the code actually wrote itself: inserting a component could trigger more components, templates generated templates.&lt;/p&gt;
    &lt;head rend="h2"&gt;Technical Details&lt;/head&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Language: Rust&lt;/item&gt;
      &lt;item&gt;Target: WebAssembly (WASM)&lt;/item&gt;
      &lt;item&gt;Output formats: SVG, DXF (AutoCAD R12/AC1009)&lt;/item&gt;
      &lt;item&gt;Supported AutoLISP functions: defun, setq, if, while, cond, +, -, *, /, sin, cos, sqrt, car, cdr, list, nth, command, princ, and more&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h2"&gt;Example Code&lt;/head&gt;
    &lt;code&gt;; Draw a rectangle
(defun draw-box (x y w h)
  (command "LINE" (list x y) (list (+ x w) y) "")
  (command "LINE" (list (+ x w) y) (list (+ x w) (+ y h)) "")
  (command "LINE" (list (+ x w) (+ y h)) (list x (+ y h)) "")
  (command "LINE" (list x (+ y h)) (list x y) ""))

(draw-box 10 10 100 50)
&lt;/code&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=46393271</guid><pubDate>Fri, 26 Dec 2025 15:56:52 +0000</pubDate></item><item><title>ZJIT is now available in Ruby 4.0</title><link>https://railsatscale.com/2025-12-24-launch-zjit/</link><description>&lt;doc fingerprint="2269191b38b3cfb0"&gt;
  &lt;main&gt;
    &lt;head rend="h1"&gt;ZJIT is now available in Ruby 4.0&lt;/head&gt;
    &lt;p&gt;ZJIT is a new just-in-time (JIT) Ruby compiler built into the reference Ruby implementation, YARV, by the same compiler group that brought you YJIT. We (Aaron Patterson, Aiden Fox Ivey, Alan Wu, Jacob Denbeaux, Kevin Menard, Max Bernstein, Maxime Chevalier-Boisvert, Randy Stauner, Stan Lo, and Takashi Kokubun) have been working on ZJIT since the beginning of this year.&lt;/p&gt;
    &lt;p&gt;In case you missed the last post, we’re building a new compiler for Ruby because we want to both raise the performance ceiling (bigger compilation unit size and SSA IR) and encourage more outside contribution (by becoming a more traditional method compiler).&lt;/p&gt;
    &lt;p&gt;It’s been a long time since we gave an official update on ZJIT. Things are going well. We’re excited to share our progress with you. We’ve done a lot since May.&lt;/p&gt;
    &lt;head rend="h2"&gt;In brief&lt;/head&gt;
    &lt;p&gt;ZJIT is compiled by default—but not enabled by default—in Ruby 4.0. Enable it by passing the &lt;code&gt;--zjit&lt;/code&gt; flag or the &lt;code&gt;RUBY_ZJIT_ENABLE&lt;/code&gt; environment variable
or calling &lt;code&gt;RubyVM::ZJIT.enable&lt;/code&gt; after starting your application.&lt;/p&gt;
    &lt;p&gt;It’s faster than the interpreter, but not yet as fast as YJIT. Yet. But we have a plan, and we have some more specific numbers below. The TL;DR is we have a great new foundation and now need to pull out all the Ruby-specific stops to match YJIT.&lt;/p&gt;
    &lt;p&gt;We encourage you to experiment with ZJIT, but maybe hold off on deploying it in production for now. This is a very new compiler. You should expect crashes and wild performance degradations (or, perhaps, improvements). Please test locally, try to run CI, etc, and let us know what you run into on the Ruby issue tracker (or, if you don’t want to make a Ruby Bugs account, we would also take reports on GitHub).&lt;/p&gt;
    &lt;head rend="h2"&gt;State of the compiler&lt;/head&gt;
    &lt;p&gt;To underscore how much has happened since the announcement of being merged into CRuby, we present to you a series of comparisons:&lt;/p&gt;
    &lt;head rend="h3"&gt;Side-exits&lt;/head&gt;
    &lt;p&gt;Back in May, we could not side-exit from JIT code into the interpreter. This meant that the code we were running had to continue to have the same preconditions (expected types, no method redefinitions, etc) or the JIT would safely abort. Now, we can side-exit and use this feature liberally.&lt;/p&gt;
    &lt;quote&gt;
      &lt;p&gt;For example, we gracefully handle the phase transition from integer to string; a guard instruction fails and transfers control to the interpreter.&lt;/p&gt;
      &lt;code&gt;def add x, y x + y end add 3, 4 add 3, 4 add 3, 4 add "three", "four"&lt;/code&gt;
    &lt;/quote&gt;
    &lt;p&gt;This enables running a lot more code!&lt;/p&gt;
    &lt;head rend="h3"&gt;More code&lt;/head&gt;
    &lt;p&gt;Back in May, we could only run a handful of small benchmarks. Now, we can run all sorts of code, including passing the full Ruby test suite, the test suite and shadow traffic of a large application at Shopify, and the test suite of GitHub.com! Also a bank, apparently.&lt;/p&gt;
    &lt;p&gt;Back in May, we did not optimize much; we only really optimized operations on fixnums (small integers) and method sends to the &lt;code&gt;main&lt;/code&gt; object. Now,
we optimize a lot more: all sorts of method sends, instance variable reads
and writes, attribute accessor/reader/writer use, struct reads and writes,
object allocations, certain string operations, optional parameters, and more.&lt;/p&gt;
    &lt;quote&gt;&lt;p&gt;For example, we can constant-fold numeric operations. Because we also have a (small, limited) inliner borrowed from YJIT, we can constant-fold the entirety of&lt;/p&gt;&lt;code&gt;add&lt;/code&gt;down to&lt;code&gt;3&lt;/code&gt;—and still handle redefinitions of&lt;code&gt;one&lt;/code&gt;,&lt;code&gt;two&lt;/code&gt;,&lt;code&gt;Integer#+&lt;/code&gt;, …&lt;code&gt;def one 1 end def two 2 end def add one + two end&lt;/code&gt;&lt;/quote&gt;
    &lt;head rend="h3"&gt;Register spilling&lt;/head&gt;
    &lt;p&gt;Back in May, we could not compile many large functions due to limitations of our backend that we borrowed from YJIT. Now, we can compile absolutely enormous functions just fine. And quickly, too. Though we have not been focusing specifically on compiler performance, we compile even large methods in under a millisecond.&lt;/p&gt;
    &lt;head rend="h3"&gt;C methods&lt;/head&gt;
    &lt;p&gt;Back in May, we could not even optimize calls to built-in C methods. Now, we have a feature similar to JavaScriptCore’s DOMJIT, which allows us to emit inline HIR versions of certain well-known C methods. This allows the optimizer to reason about these methods and their effects (more on this in a future post) much more… er, effectively.&lt;/p&gt;
    &lt;quote&gt;&lt;p&gt;For example,&lt;/p&gt;&lt;code&gt;Integer#succ&lt;/code&gt;, which is defined as adding&lt;code&gt;1&lt;/code&gt;to an integer, is a C method. It’s used in&lt;code&gt;Integer#times&lt;/code&gt;to drive the&lt;code&gt;while&lt;/code&gt;loop. Instead of emitting a call to it, our C method “inliner” can emit our existing&lt;code&gt;FixnumAdd&lt;/code&gt;instruction and take advantage of the rest of the type inference and constant-folding.&lt;code&gt;fn inline_integer_succ(fun: &amp;amp;mut hir::Function, block: hir::BlockId, recv: hir::InsnId, args: &amp;amp;[hir::InsnId], state: hir::InsnId) -&amp;gt; Option&amp;lt;hir::InsnId&amp;gt; { if !args.is_empty() { return None; } if fun.likely_a(recv, types::Fixnum, state) { let left = fun.coerce_to(block, recv, types::Fixnum, state); let right = fun.push_insn(block, hir::Insn::Const { val: hir::Const::Value(VALUE::fixnum_from_usize(1)) }); let result = fun.push_insn(block, hir::Insn::FixnumAdd { left, right, state }); return Some(result); } None }&lt;/code&gt;&lt;/quote&gt;
    &lt;head rend="h3"&gt;Fewer C calls&lt;/head&gt;
    &lt;p&gt;Back in May, the machine code ZJIT generated called a lot of C functions from the CRuby runtime to implement our HIR instructions in LIR. We have pared this down significantly and now “open code” the implementations in LIR.&lt;/p&gt;
    &lt;quote&gt;&lt;p&gt;For example,&lt;/p&gt;&lt;code&gt;GuardNotFrozen&lt;/code&gt;used to call out to&lt;code&gt;rb_obj_frozen_p&lt;/code&gt;. Now, it requires that its input is a heap-allocated object and can instead do a load, a test, and a conditional jump.&lt;code&gt;fn gen_guard_not_frozen(jit: &amp;amp;JITState, asm: &amp;amp;mut Assembler, recv: Opnd, state: &amp;amp;FrameState) -&amp;gt; Opnd { let recv = asm.load(recv); // It's a heap object, so check the frozen flag let flags = asm.load(Opnd::mem(64, recv, RUBY_OFFSET_RBASIC_FLAGS)); asm.test(flags, (RUBY_FL_FREEZE as u64).into()); // Side-exit if frozen asm.jnz(side_exit(jit, state, GuardNotFrozen)); recv }&lt;/code&gt;&lt;/quote&gt;
    &lt;head rend="h3"&gt;More teammates&lt;/head&gt;
    &lt;p&gt;Back in May, we had four people working full-time on the compiler. Now, we have more internally at Shopify—and also more from the community! We have had several interested people reach out, learn about ZJIT, and successfully land complex changes. For this reason, we have opened up a chat room to discuss and improve ZJIT.&lt;/p&gt;
    &lt;head rend="h3"&gt;A cool graph visualization tool&lt;/head&gt;
    &lt;p&gt;You have to check out our intern Aiden’s integration of Iongraph into ZJIT. Now we have clickable, zoomable, scrollable graphs of all our functions and all our optimization passes. It’s great!&lt;/p&gt;
    &lt;p&gt;Try zooming (Ctrl-scroll), clicking the different optimization passes on the left, clicking the instruction IDs in each basic block (definitions and uses), and seeing how the IR for the below Ruby code changes over time.&lt;/p&gt;
    &lt;code&gt;class Point
  attr_accessor :x, :y
  def initialize x, y
    @x = x
    @y = y
  end
end

P = Point.new(3, 4).freeze

def test = P.x + P.y
&lt;/code&gt;
    &lt;head rend="h3"&gt;More&lt;/head&gt;
    &lt;p&gt;…and so, so many garbage collection fixes.&lt;/p&gt;
    &lt;p&gt;There’s still a lot to do, though.&lt;/p&gt;
    &lt;head rend="h2"&gt;To do&lt;/head&gt;
    &lt;p&gt;We’re going to optimize &lt;code&gt;invokeblock&lt;/code&gt; (&lt;code&gt;yield&lt;/code&gt;) and &lt;code&gt;invokesuper&lt;/code&gt; (&lt;code&gt;super&lt;/code&gt;)
instructions, each of which behaves similarly, but not identically, to a
normal &lt;code&gt;send&lt;/code&gt; instruction. These are pretty common.&lt;/p&gt;
    &lt;p&gt;We’re going to optimize &lt;code&gt;setinstancevariable&lt;/code&gt; in the case where we have to
transition the object’s shape. This will help normal &lt;code&gt;@a = b&lt;/code&gt; situations. It
will also help &lt;code&gt;@a ||= b&lt;/code&gt;, but I think we can even do better with the latter
using some kind of value numbering.&lt;/p&gt;
    &lt;p&gt;We only optimize monomorphic calls right now—cases where a method send only sees one class of receiver while being profiled. We’re going to optimize polymorphic sends, too. Right now we’re laying the groundwork (a new register allocator; see below) to make this much easier. It’s not as much of an immediate focus, though, because most (high 80s, low 90s percent) of sends are monomorphic.&lt;/p&gt;
    &lt;p&gt;We’re in the middle of re-writing the register allocator after reading the entire history of linear scan papers and several implementations. That will unlock performance improvements and also allow us to make the IRs easier to use.&lt;/p&gt;
    &lt;p&gt;We don’t handle phase changes particularly well yet; if your method call patterns change significantly after your code has been compiled, we will frequently side-exit into the interpreter. Instead, we would like to use these side-exits as additional profile information and re-compile the function.&lt;/p&gt;
    &lt;p&gt;Right now we have a lot of traffic to the VM frame. JIT frame pushes are reasonably fast, but with every effectful operation, we have to flush our local variable state and stack state to the VM frame. The instances in which code might want to read this reified frame state are rare: frame unwinding due to exceptions, &lt;code&gt;Binding#local_variable_get&lt;/code&gt;, etc. In the future, we will instead
defer writing this state until it needs to be read.&lt;/p&gt;
    &lt;p&gt;We only have a limited inliner that inlines constants, &lt;code&gt;self&lt;/code&gt;, and parameters.
In the fullness of time, we will add a general-purpose method inlining
facility. This will allow us to reduce the amount of polymorphic sends, do some
branch folding, and reduce the amount of method sends.&lt;/p&gt;
    &lt;p&gt;We only support optimizing positional parameters, required keyword parameters, and optional parameters right now but we will work on optimizing optional keyword arguments as well. Most of this work is in marshaling the complex Ruby calling convention into one coherent form that the JIT can understand.&lt;/p&gt;
    &lt;head rend="h2"&gt;Performance&lt;/head&gt;
    &lt;p&gt;We have public performance numbers for a selection of macro- and micro-benchmarks on rubybench. Here is a screenshot of what those per-benchmark graphs look like. The Y axis is speedup multiplier vs the interpreter and the X axis is time. Higher is better:&lt;/p&gt;
    &lt;p&gt;You can see that we are improving performance on nearly all benchmarks over time. Some of this comes from from optimizing in a similar way as YJIT does today (e.g. specializing ivar reads and writes), and some of it is optimizing in a way that takes advantage of ZJIT’s high-level IR (e.g. constant folding, branch folding, more precise type inference).&lt;/p&gt;
    &lt;p&gt;We are using both raw time numbers and also our internal performance counters (e.g. number of calls to C functions from generated code) to drive optimization.&lt;/p&gt;
    &lt;head rend="h2"&gt;Try it out&lt;/head&gt;
    &lt;p&gt;While Ruby now ships with ZJIT compiled into the binary by default, it is not enabled by default at run-time. Due to performance and stability, YJIT is still the default compiler choice in Ruby 4.0.&lt;/p&gt;
    &lt;p&gt;If you want to run your test suite with ZJIT to see what happens, you absolutely can. Enable it by passing the &lt;code&gt;--zjit&lt;/code&gt; flag or the
&lt;code&gt;RUBY_ZJIT_ENABLE&lt;/code&gt; environment variable or calling &lt;code&gt;RubyVM::ZJIT.enable&lt;/code&gt; after
starting your application.&lt;/p&gt;
    &lt;head rend="h2"&gt;On YJIT&lt;/head&gt;
    &lt;p&gt;We devoted a lot of our resources this year to developing ZJIT. While we did not spend much time on YJIT (outside of a great allocation speed up), YJIT isn’t going anywhere soon.&lt;/p&gt;
    &lt;head rend="h2"&gt;Thank you&lt;/head&gt;
    &lt;p&gt;This compiler was made possible by contributions to your &lt;del&gt;PBS station&lt;/del&gt; open source project from programmers like you. Thank you!&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Aaron Patterson&lt;/item&gt;
      &lt;item&gt;Abrar Habib&lt;/item&gt;
      &lt;item&gt;Aiden Fox Ivey&lt;/item&gt;
      &lt;item&gt;Alan Wu&lt;/item&gt;
      &lt;item&gt;Alex Rocha&lt;/item&gt;
      &lt;item&gt;André Luiz Tiago Soares&lt;/item&gt;
      &lt;item&gt;Benoit Daloze&lt;/item&gt;
      &lt;item&gt;Charlotte Wen&lt;/item&gt;
      &lt;item&gt;Daniel Colson&lt;/item&gt;
      &lt;item&gt;Donghee Na&lt;/item&gt;
      &lt;item&gt;Eileen Uchitelle&lt;/item&gt;
      &lt;item&gt;Étienne Barrié&lt;/item&gt;
      &lt;item&gt;Godfrey Chan&lt;/item&gt;
      &lt;item&gt;Goshanraj Govindaraj&lt;/item&gt;
      &lt;item&gt;Hiroshi SHIBATA&lt;/item&gt;
      &lt;item&gt;Hoa Nguyen&lt;/item&gt;
      &lt;item&gt;Jacob Denbeaux&lt;/item&gt;
      &lt;item&gt;Jean Boussier&lt;/item&gt;
      &lt;item&gt;Jeremy Evans&lt;/item&gt;
      &lt;item&gt;John Hawthorn&lt;/item&gt;
      &lt;item&gt;Ken Jin&lt;/item&gt;
      &lt;item&gt;Kevin Menard&lt;/item&gt;
      &lt;item&gt;Max Bernstein&lt;/item&gt;
      &lt;item&gt;Max Leopold&lt;/item&gt;
      &lt;item&gt;Maxime Chevalier-Boisvert&lt;/item&gt;
      &lt;item&gt;Nobuyoshi Nakada&lt;/item&gt;
      &lt;item&gt;Peter Zhu&lt;/item&gt;
      &lt;item&gt;Randy Stauner&lt;/item&gt;
      &lt;item&gt;Satoshi Tagomori&lt;/item&gt;
      &lt;item&gt;Shannon Skipper&lt;/item&gt;
      &lt;item&gt;Stan Lo&lt;/item&gt;
      &lt;item&gt;Takashi Kokubun&lt;/item&gt;
      &lt;item&gt;Tavian Barnes&lt;/item&gt;
      &lt;item&gt;Tobias Lütke&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;(via a lightly touched up &lt;code&gt;git log --pretty="%an" zjit | sort -u&lt;/code&gt;)&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=46393906</guid><pubDate>Fri, 26 Dec 2025 17:04:42 +0000</pubDate></item><item><title>C/C++ Embedded Files (2013)</title><link>https://www.4rknova.com//blog/2013/01/27/cpp-embedded-files</link><description>&lt;doc fingerprint="400ac4e72c92a3d"&gt;
  &lt;main&gt;
    &lt;p&gt;Sometimes it is desirable to embed resource files in c or c++ programs. There are many ways to go about it but in most cases you must convert the files with external tools or scripts.&lt;/p&gt;
    &lt;head rend="h1"&gt;Using external tools&lt;/head&gt;
    &lt;p&gt;For image files, image-magick can be used:&lt;/p&gt;
    &lt;quote&gt;$ imagick input.png output.h&lt;/quote&gt;
    &lt;p&gt;Another common tool that can convert all types of files is xxd.&lt;/p&gt;
    &lt;quote&gt;$ xxd -i input.whatever output.h&lt;/quote&gt;
    &lt;p&gt;While the above methods are perfectly valid, some extra dependencies are added to the build process.&lt;/p&gt;
    &lt;head rend="h1"&gt;Using the preprocessor&lt;/head&gt;
    &lt;p&gt;One interesting way to do this for plain ascii files (eg. shaders) can be found in Bullet's MiniCL example programs and more specifically in lines 31-33 of MiniCL_VectorAdd.cpp&lt;/p&gt;
    &lt;p&gt;A preprocessor macro is defined and a string declaration is placed before the file inclusion directive.&lt;/p&gt;
    &lt;code&gt;[...]

#define STRINGIFY(A) #A
char *fsource =
#include "file.ext"

[...]
&lt;/code&gt;
    &lt;p&gt;Then the external ascii file is wrapped in the STRINGIFY block.&lt;/p&gt;
    &lt;code&gt;STRINGIFY (

[...]

)
&lt;/code&gt;
    &lt;p&gt;Note that the above method still requires that the file is edited to add the macro block but the operation is rundimentary and usually relatively simple to automate.&lt;/p&gt;
    &lt;head rend="h1"&gt;Using ASM&lt;/head&gt;
    &lt;p&gt;Another way is to use an assembly code block that emdeds the data to the .rodata sections of the final binary.&lt;/p&gt;
    &lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#define STR2(x) #x
#define STR(x) STR2(x)

#define INCBIN(name, file) \
	__asm__(".section .rodata\n" \
		".global incbin_" STR(name) "_start\n" \
		".type incbin_" STR(name) "_start, @object\n" \
		".balign 16\n" \
		"incbin_" STR(name) "_start:\n" \
		".incbin \"" file "\"\n" \
		\
		".global incbin_" STR(name) "_end\n" \
		".type incbin_" STR(name) "_end, @object\n" \
		".balign 1\n" \
		"incbin_" STR(name) "_end:\n" \
		".byte 0\n" \
	); \
extern const __attribute__((aligned(16))) void* incbin_ ## name ## _start; \
extern const void* incbin_ ## name ## _end; \

INCBIN(foobar, "binary.bin");

int main()
{
	printf("start = %p\n", &amp;amp;incbin_foobar_start);
	printf("end = %p\n", &amp;amp;incbin_foobar_end);
	printf("size = %zu\n", (char*)&amp;amp;incbin_foobar_end - (char*)&amp;amp;incbin_foobar_start);
	printf("first byte = 0x%02x\n", ((unsigned char*)&amp;amp;incbin_foobar_start)[0]);
}
&lt;/code&gt;
    &lt;p&gt;This is obviously a platform specific solution that will not work on all platforms.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=46393924</guid><pubDate>Fri, 26 Dec 2025 17:06:35 +0000</pubDate></item><item><title>Experts explore new mushroom which causes fairytale-like hallucinations</title><link>https://nhmu.utah.edu/articles/experts-explore-new-mushroom-which-causes-fairytale-hallucinations</link><description>&lt;doc fingerprint="aa651b7faa11411a"&gt;
  &lt;main&gt;
    &lt;head rend="h1"&gt;Experts Explore New Mushroom Which Causes Fairytale-Like Hallucinations&lt;/head&gt;
    &lt;head rend="h4"&gt;By Colin Domnauer&lt;/head&gt;
    &lt;p&gt;Picture this: You're enjoying a delicious bowl of mushroom soup, when suddenly you notice hundreds of tiny people dressed in cartoonish clothing marching across your tablecloth, jumping into your bowl, swimming around, and clinging to your spoon as you lift it for another taste. You're not dreaming — you've just experienced the effects of a mushroom known scientifically as Lanmaoa asiatica. It belongs to an entirely different class of Fungi than the more commonly known “magic mushrooms” and remains far more mysterious.&lt;/p&gt;
    &lt;p&gt;When outsiders first embarked into the Western Highlands of Papua New Guinea in 1934, they encountered a perplexing sight: after consuming a type of wild mushroom which they called “nonda,” the local people would appear to go temporarily insane, exhibiting a sudden and striking change in mood and behavior. Subsequent accounts of the “mushroom madness” phenomenon, as it was termed, provided more details into the mushroom's strange psychological effects.&lt;/p&gt;
    &lt;p&gt;Specifically, it was reported that those affected would experience lilliputian hallucinations — a rare, clinically defined psychiatric syndrome (named after the tiny people in Gulliver's Travels) characterized by the perception of numerous little people autonomously moving about and interacting in the real-world environment. One elder tribesman in Papua New Guinea describes this effect, explaining how “he saw tiny people with mushrooms around their faces. They were teasing him, and he was trying to chase them away.”&lt;/p&gt;
    &lt;p&gt;By the 1960s, scientists were working to identify the species of mushrooms involved and what chemicals within them might be responsible for such bizarre effects. However, both questions have remained unanswered to this day. As a Ph.D. student at the Natural History Museum of Utah, I've been working to solve this puzzle: What exactly is the identity of this mushroom, how widespread is the cultural knowledge of its effects, and why does it produce such fantastical visions?&lt;/p&gt;
    &lt;head rend="h3"&gt;Investigating Lilliputian Mushrooms in China&lt;/head&gt;
    &lt;p&gt;Home to 40 percent of the world's wild edible fungi, Yunnan, China has always been remarkable for mushroom lovers. But in the last decade or so, the summer rains have brought more than just mushrooms; they’ve been accompanied by an explosion of news articles that read like something out of children's fairy tales: after consuming a popular wild mushroom known locally as “Jian shou qing,” locals frequently report having unbelievably bizarre experiences, most notable characterized by seeing “xiao ren ren,” or little people.&lt;/p&gt;
    &lt;p&gt;A professor in Yunnan recounted how one evening during dinner (Jian shou qing is openly sold in markets and restaurants), he began seeing swirling shapes and colors after eating stir-fried mushrooms. Since the psychoactive effects are familiar to most locals, he began looking for xiao ren ren but was disappointed to find none — until he lifted the tablecloth and peeked underneath, seeing “hundreds of xiao ren ren, marching like soldiers.”&lt;/p&gt;
    &lt;p&gt;Even more curious, he said, “when I lifted the tablecloth higher, the heads came off and stuck to the bottom of the cloth and the bodies kept marching in place… I did this many times, at two-minute intervals, and each time they were there, marching and grinning… I measured them, too… they were 2 cm high.” According to records at Yunnan Hospital, 96 percent of patients affected by this mushroom report seeing an abundance of "little people" or "elves," often dancing, jumping, or marching around their real-world environment.&lt;/p&gt;
    &lt;p&gt;As recently as 2014, the taxonomic identity of the psychoactive Jian shou qing mushroom remained unknown. It wasn’t until mycologists in Yunnan purchased and sequenced the mushrooms being sold in an open-air street market (where it had been sold for decades) that the species was officially described and recognized as being new to science. Its formal Latin name is Lanmaoa asiatica, and, interestingly, it’s more closely related to the common porcini (Utah’s official state mushroom) than to any other currently known hallucinogenic mushroom species.&lt;/p&gt;
    &lt;p&gt;Although Lanmaoa asiatica is a recent scientific discovery, the knowledge and use of this psychoactive mushroom may have much deeper ancient roots in Chinese culture. A prominent Daoist text from the 3rd century CE refers to a “flesh spirit mushroom,” which, according to the text, if consumed raw, allows one to “see a little person” and “attain transcendence immediately.”&lt;/p&gt;
    &lt;p&gt;Tiny People in Your Soup&lt;/p&gt;
    &lt;p&gt;Got two minutes? Listen to Colin explain the strange effects of Lilliputian mushrooms, including the sudden appearance of tiny people!&lt;/p&gt;
    &lt;head rend="h3"&gt;A Global Experience&lt;/head&gt;
    &lt;p&gt;Surprisingly, I became aware of yet another independent report of the exact same phenomenon — a mushroom that caused lilliputian hallucinations, but this time from an entirely different region of the world. Indigenous communities in the Philippines' remote Northern Cordillera were collecting and consuming a wild mushroom which, according to local knowledge, occasionally evokes visions of little people, which they call the “ansisit.” The mushroom is known locally as "Sedesdem." Just as the “Nonda” in Papua New Guinea and “Jian shou qing” in Yunnan, it is a culturally esteemed wild edible mushroom that, if undercooked, produces bizarre yet remarkably consistent psychoactive effect.&lt;/p&gt;
    &lt;p&gt;As no scientific surveys of the mushrooms in the Northern Philippines had been conducted, Sedesdem’s taxonomic identity remained unknown, leaving me with the obvious task. I travelled to this community in 2024 to explore the mushrooms and experience the culture surrounding this phenomenon. By working with local guides and foraging through the forest, we collected samples that are now preserved for scientific study at the Natural History Museum of Utah — allowing us to perform the first DNA sequencing of this region's fungi.&lt;/p&gt;
    &lt;p&gt;What surprised me most was the unexpected discovery of the Sedesdem mushroom’s identity: it was none other than Lanmaoa asiatica, the exact same species as in Yunnan. The puzzle was coming together.&lt;/p&gt;
    &lt;head rend="h3"&gt;More Than Folklore or Tall Tales&lt;/head&gt;
    &lt;p&gt;That the same peculiar hallucinations are independently reported across such distant cultures indicates that these bizarre psychological effects are not cultural fabrications or coincidences, but manifestations of a shared underlying chemical and neurological basis.&lt;/p&gt;
    &lt;p&gt;Chemical and genomic analyses performed on Lanmaoa asiatica at the Natural History Museum of Utah have revealed no traces of any known psychoactive compounds, suggesting that something entirely new is waiting to be discovered. In other words, Lanmaoa asiatica appears to harbor a chemical compound capable of reliably evoking this unusual experience of lilliputian hallucinations. The discovery of that chemical may, in fact, hold the key to understanding one of the most mysterious dimensions of the human psyche.&lt;/p&gt;
    &lt;head rend="h3"&gt;Ongoing Research Into the Fairytale Mushroom&lt;/head&gt;
    &lt;p&gt;Our efforts to identify this compound are ongoing, and the progress so far has been exciting! When mice are given chemical extracts of Lanmaoa asiatica, their behavior shifts noticeably compared to controls. By continuing to fractionate these extracts and testing each in turn, we’ve been steadily narrowing in on isolating the specific bioactive molecules involved.&lt;/p&gt;
    &lt;p&gt;But the chemistry is only part of the mystery. In parallel, I’m building a global database of all Lanmaoa species. In doing so, I’ve discovered four new species previously unknown to science. Through full-genome sequencing, I’ve been able to clearly map the evolutionary relationships and history of Lanmaoa for the first time, allowing us to search for patterns that might reveal where and why psychoactivity evolved in this group. For example, genomic analysis reveals that the closest relative of L. asiatica is a species commonly found (though rarely eaten) here in North America. While there are no reports of it being psychoactive in the US, it’s entirely plausible its effects have simply gone unnoticed.&lt;/p&gt;
    &lt;head rend="h3"&gt;Exciting Discoveries Are Waiting for Us&lt;/head&gt;
    &lt;p&gt;I’m fascinated by how far the knowledge of these mushrooms extends, across both space and time. Are there additional cultural traditions and groups surrounding this psychoactive species that have yet to be documented? Does humanity’s knowledge of this mushroom and its most bizarre effects stretch further into history, and deeper into folkloric beliefs, that we currently appreciate? Given the remarkable findings we’ve made in just the past few years, I believe the answer to both these questions is yes.&lt;/p&gt;
    &lt;p&gt;While many questions remain, one thing is for certain: Lanmaoa asiatica reminds us that the world of mushrooms, even those found in markets and on dinner plates, conceals mysteries and wonders we’ve yet to imagine. Somewhere between traditional folklore and modern biology, between the wild forest floor and the sterile scientific laboratory, lies a story still unfolding, a story that may begin with something as seemingly innocuous as a bowl of mushroom soup.&lt;/p&gt;
    &lt;p&gt;1 of 8&lt;/p&gt;
    &lt;p&gt;NHMU is an active research institution.&lt;/p&gt;
    &lt;p&gt;The Museum is full of more than 1.6 million objects and countless stories. We are constantly writing and recording these for our online audience, sharing blog posts, videos, and podcasts about the latest scientific research happening at NHMU.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=46393936</guid><pubDate>Fri, 26 Dec 2025 17:07:53 +0000</pubDate></item><item><title>How uv got so fast</title><link>https://nesbitt.io/2025/12/26/how-uv-got-so-fast.html</link><description>&lt;doc fingerprint="a779de5d8dd2f750"&gt;
  &lt;main&gt;
    &lt;p&gt;uv installs packages faster than pip by an order of magnitude. The usual explanation is “it’s written in Rust.” That’s true, but it doesn’t explain much. Plenty of tools are written in Rust without being notably fast. The interesting question is what design decisions made the difference.&lt;/p&gt;
    &lt;p&gt;Charlie Marsh’s Jane Street talk and a Xebia engineering deep-dive do an excellent job at covering the technical details. Let’s dig into the design decisions that led to it: standards that enable fast paths, things uv drops that pip supports, and optimizations that don’t require Rust at all.&lt;/p&gt;
    &lt;head rend="h2"&gt;The standards that made uv possible&lt;/head&gt;
    &lt;p&gt;pip’s slowness isn’t a failure of implementation. For years, Python packaging required executing code to find out what a package needed.&lt;/p&gt;
    &lt;p&gt;The problem was setup.py. You couldn’t know a package’s dependencies without running its setup script. But you couldn’t run its setup script without installing its build dependencies. PEP 518 in 2016 called this out explicitly: “You can’t execute a setup.py file without knowing its dependencies, but currently there is no standard way to know what those dependencies are in an automated fashion without executing the setup.py file.”&lt;/p&gt;
    &lt;p&gt;This chicken-and-egg problem forced pip to download packages, execute untrusted code, fail, install missing build tools, and try again. Every install was potentially a cascade of subprocess spawns and arbitrary code execution. Installing a source distribution was essentially &lt;code&gt;curl | bash&lt;/code&gt; with extra steps.&lt;/p&gt;
    &lt;p&gt;The fix came in stages:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;PEP 518 (2016) created pyproject.toml, giving packages a place to declare build dependencies without code execution. The TOML format was borrowed from Rust’s Cargo, which makes a Rust tool returning to fix Python packaging feel less like coincidence.&lt;/item&gt;
      &lt;item&gt;PEP 517 (2017) separated build frontends from backends, so pip didn’t need to understand setuptools internals.&lt;/item&gt;
      &lt;item&gt;PEP 621 (2020) standardized the &lt;code&gt;[project]&lt;/code&gt;table, so dependencies could be read by parsing TOML rather than running Python.&lt;/item&gt;
      &lt;item&gt;PEP 658 (2022) put package metadata directly in the Simple Repository API, so resolvers could fetch dependency information without downloading wheels at all.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;PEP 658 went live on PyPI in May 2023. uv launched in February 2024. The timing isn’t coincidental. uv could be fast because the ecosystem finally had the infrastructure to support it. A tool like uv couldn’t have shipped in 2020. The standards weren’t there yet.&lt;/p&gt;
    &lt;p&gt;Other ecosystems figured this out earlier. Cargo has had static metadata from the start. npm’s package.json is declarative. Python’s packaging standards finally bring it to parity.&lt;/p&gt;
    &lt;head rend="h2"&gt;What uv drops&lt;/head&gt;
    &lt;p&gt;Speed comes from elimination. Every code path you don’t have is a code path you don’t wait for.&lt;/p&gt;
    &lt;p&gt;uv’s compatibility documentation is a list of things it doesn’t do:&lt;/p&gt;
    &lt;p&gt;No .egg support. Eggs were the pre-wheel binary format. pip still handles them; uv doesn’t even try. The format has been obsolete for over a decade.&lt;/p&gt;
    &lt;p&gt;No pip.conf. uv ignores pip’s configuration files entirely. No parsing, no environment variable lookups, no inheritance from system-wide and per-user locations.&lt;/p&gt;
    &lt;p&gt;No bytecode compilation by default. pip compiles .py files to .pyc during installation. uv skips this step, shaving time off every install. You can opt in if you want it.&lt;/p&gt;
    &lt;p&gt;Virtual environments required. pip lets you install into system Python by default. uv inverts this, refusing to touch system Python without explicit flags. This removes a whole category of permission checks and safety code.&lt;/p&gt;
    &lt;p&gt;Stricter spec enforcement. pip accepts malformed packages that technically violate packaging specs. uv rejects them. Less tolerance means less fallback logic.&lt;/p&gt;
    &lt;p&gt;Ignoring requires-python upper bounds. When a package says it requires &lt;code&gt;python&amp;lt;4.0&lt;/code&gt;, uv ignores the upper bound and only checks the lower. This reduces resolver backtracking dramatically since upper bounds are almost always wrong. Packages declare &lt;code&gt;python&amp;lt;4.0&lt;/code&gt; because they haven’t tested on Python 4, not because they’ll actually break. The constraint is defensive, not predictive.&lt;/p&gt;
    &lt;p&gt;First-index wins by default. When multiple package indexes are configured, pip checks all of them. uv picks from the first index that has the package, stopping there. This prevents dependency confusion attacks and avoids extra network requests.&lt;/p&gt;
    &lt;p&gt;Each of these is a code path pip has to execute and uv doesn’t.&lt;/p&gt;
    &lt;head rend="h2"&gt;Optimizations that don’t need Rust&lt;/head&gt;
    &lt;p&gt;Some of uv’s speed comes from Rust. But not as much as you’d think. Several key optimizations could be implemented in pip today:&lt;/p&gt;
    &lt;p&gt;HTTP range requests for metadata. Wheel files are zip archives, and zip archives put their file listing at the end. uv tries PEP 658 metadata first, falls back to HTTP range requests for the zip central directory, then full wheel download, then building from source. Each step is slower and riskier. The design makes the fast path cover 99% of cases. This is HTTP protocol work, not Rust.&lt;/p&gt;
    &lt;p&gt;Parallel downloads. pip downloads packages one at a time. uv downloads many at once. This is concurrency, not language magic.&lt;/p&gt;
    &lt;p&gt;Global cache with hardlinks. pip copies packages into each virtual environment. uv keeps one copy globally and uses hardlinks (or copy-on-write on filesystems that support it). Installing the same package into ten venvs takes the same disk space as one. This is filesystem ops, not language-dependent.&lt;/p&gt;
    &lt;p&gt;Python-free resolution. pip needs Python running to do anything, and invokes build backends as subprocesses to get metadata from legacy packages. uv parses TOML and wheel metadata natively, only spawning Python when it hits a setup.py-only package that has no other option.&lt;/p&gt;
    &lt;p&gt;PubGrub resolver. uv uses the PubGrub algorithm, originally from Dart’s pub package manager. pip uses a backtracking resolver. PubGrub is faster at finding solutions and better at explaining failures. It’s an algorithm choice, not a language choice.&lt;/p&gt;
    &lt;head rend="h2"&gt;Where Rust actually matters&lt;/head&gt;
    &lt;p&gt;Some optimizations do require Rust:&lt;/p&gt;
    &lt;p&gt;Zero-copy deserialization. uv uses rkyv to deserialize cached data without copying it. The data format is the in-memory format. This is a Rust-specific technique.&lt;/p&gt;
    &lt;p&gt;Lock-free concurrent data structures. Rust’s ownership model makes concurrent access safe without locks. Python’s GIL makes this difficult.&lt;/p&gt;
    &lt;p&gt;No interpreter startup. Every time pip spawns a subprocess, it pays Python’s startup cost. uv is a single static binary with no runtime to initialize.&lt;/p&gt;
    &lt;p&gt;Compact version representation. uv packs versions into u64 integers where possible, making comparison and hashing fast. Over 90% of versions fit in one u64. This is micro-optimization that compounds across millions of comparisons.&lt;/p&gt;
    &lt;p&gt;These are real advantages. But they’re smaller than the architectural wins from dropping legacy support and exploiting modern standards.&lt;/p&gt;
    &lt;head rend="h2"&gt;The actual lesson&lt;/head&gt;
    &lt;p&gt;uv is fast because of what it doesn’t do, not because of what language it’s written in. The standards work of PEP 518, 517, 621, and 658 made fast package management possible. Dropping eggs, pip.conf, and permissive parsing made it achievable. Rust makes it a bit faster still.&lt;/p&gt;
    &lt;p&gt;pip could implement parallel downloads, global caching, and metadata-only resolution tomorrow. It doesn’t, largely because backwards compatibility with fifteen years of edge cases takes precedence. But it means pip will always be slower than a tool that starts fresh with modern assumptions.&lt;/p&gt;
    &lt;p&gt;The takeaway for other package managers: the things that make uv fast are static metadata, no code execution to discover dependencies, and the ability to resolve everything upfront before downloading. Cargo and npm have operated this way for years. If your ecosystem requires running arbitrary code to find out what a package needs, you’ve already lost.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=46393992</guid><pubDate>Fri, 26 Dec 2025 17:13:07 +0000</pubDate></item><item><title>A Proclamation Regarding the Restoration of the Dash</title><link>https://blog.nawaz.org/posts/2025/Dec/a-proclamation-regarding-the-restoration-of-the-dash/</link><description>&lt;doc fingerprint="67b84390b3e808cb"&gt;
  &lt;main&gt;
    &lt;quote&gt;
      &lt;p&gt;WHEREAS, the emâdash (â) has long served as the elegant scaffolding of the English sentence, providing the necessary breadth for parenthetical thought, sudden turns of phrase, and rhythmicÂ pause;&lt;/p&gt;
      &lt;p&gt;WHEREAS, a modern and unfounded prejudice has arisen, wherein the presence of the emâdash is viewed with suspicion and cited as the âtellâtale signâ of the unthinkingÂ machine;&lt;/p&gt;
      &lt;p&gt;WHEREAS, the Large Language Model has merely mimicked a sophistication it cannot truly possess, thereby unfairly maligning a mark of punctuation that predates the silicon chip byÂ centuries;&lt;/p&gt;
      &lt;p&gt;WHEREAS, the humble hyphen (-) is a utilitarian stitch for compound words and lineâbreaks, yet is increasingly used as a cowardly substitute for the bold, expansive stroke of theÂ emâdash;&lt;/p&gt;
      &lt;p&gt;WHEREAS, I refuse to cede the beauty of classical punctuation to the algorithms, nor shall I allow my prose to be flattened by the fear of lookingÂ âartificialâ;&lt;/p&gt;
      &lt;p&gt;NOW, THEREFORE, BE IT RESOLVED, that I reclaim this mark from the domain of the bot and return it to the hand of theÂ writer.&lt;/p&gt;
      &lt;p&gt;I HEREBY DECREE that henceforth, within the borders of this blog, the hyphen shall be banished from all roles of punctuation and pauseâto be replaced, in every instance of stylistic flair, by the glorious, unrepentantÂ emâdash.&lt;/p&gt;
    &lt;/quote&gt;
    &lt;p&gt;When writing in both LaTeX and Microsoft Word, I routinely use double or triple dashes to form emâdashes. It pains me to see people jumping to conclusions when they encounter an emâdash in theÂ wild.&lt;/p&gt;
    &lt;p&gt;In protest, I wrote [1] a plugin to convert all hyphens in this blog to emâdashes. Even ones that really should just beÂ hyphens.&lt;/p&gt;
    &lt;p&gt;Come join the revolution! (mjd)&lt;/p&gt;
    &lt;table&gt;
      &lt;row&gt;
        &lt;cell&gt;[1]&lt;/cell&gt;
        &lt;cell&gt;OK, OK, I vibe coded it.&lt;/cell&gt;
      &lt;/row&gt;
    &lt;/table&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=46394169</guid><pubDate>Fri, 26 Dec 2025 17:29:31 +0000</pubDate></item><item><title>FFmpeg has issued a DMCA takedown on GitHub</title><link>https://twitter.com/FFmpeg/status/2004599109559496984</link><description>&lt;doc fingerprint="d635f48b34542867"&gt;
  &lt;main&gt;
    &lt;p&gt;We’ve detected that JavaScript is disabled in this browser. Please enable JavaScript or switch to a supported browser to continue using x.com. You can see a list of supported browsers in our Help Center.&lt;/p&gt;
    &lt;p&gt;Help Center&lt;/p&gt;
    &lt;p&gt;Terms of Service Privacy Policy Cookie Policy Imprint Ads info © 2025 X Corp.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=46394327</guid><pubDate>Fri, 26 Dec 2025 17:48:25 +0000</pubDate></item><item><title>MongoBleed</title><link>https://github.com/joe-desimone/mongobleed/blob/main/mongobleed.py</link><description>&lt;doc fingerprint="3b74d0de090e4684"&gt;
  &lt;main&gt;
    &lt;p&gt;We read every piece of feedback, and take your input very seriously.&lt;/p&gt;
    &lt;p&gt;To see all available qualifiers, see our documentation.&lt;/p&gt;
    &lt;p&gt;There was an error while loading. Please reload this page.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=46394620</guid><pubDate>Fri, 26 Dec 2025 18:17:00 +0000</pubDate></item><item><title>How Lewis Carroll computed determinants</title><link>https://www.johndcook.com/blog/2023/07/10/lewis-carroll-determinants/</link><description>&lt;doc fingerprint="358c12c671a59fa2"&gt;
  &lt;main&gt;
    &lt;p&gt;Charles Dodgson, better known by his pen name Lewis Carroll, discovered a method of calculating determinants now known variously as the method of contractants, Dodgson condensation, or simply condensation.&lt;/p&gt;
    &lt;p&gt;The method was devised for ease of computation by hand, but it has features that make it a practical method for computation by machine.&lt;/p&gt;
    &lt;head rend="h2"&gt;Overview&lt;/head&gt;
    &lt;p&gt;The basic idea is to repeatedly condense a matrix, replacing it by a matrix with one less row and one less column. Each element is replaced by the determinant of the 2×2 matrix formed by that element and its neighbors to the south, east, and southeast. The bottom row and rightmost column have no such neighbors and are removed. There is one additional part of the algorithm that will be easier to describe after introducing some notation.&lt;/p&gt;
    &lt;head rend="h2"&gt;Details&lt;/head&gt;
    &lt;p&gt;Let A be the matrix whose determinant we want to compute and let A(k) be the matrix obtained after k steps of the condensation algorithm.&lt;/p&gt;
    &lt;p&gt;The matrix A(1) is computed as described in the overview:&lt;/p&gt;
    &lt;p&gt;Starting with A(2) the terms are similar, except each 2×2 determinant is divided by an element from two steps back:&lt;/p&gt;
    &lt;p&gt;Dodgson’s original paper from 1867 is quite readable, surprisingly so given that math notation and terminology changes over time.&lt;/p&gt;
    &lt;p&gt;One criticism I have of the paper is that it is hard to understand which element should be in the denominator, whether the subscripts should be i and j or i+1 and j+1. His first example doesn’t clarify this because these elements happen to be equal in the example.&lt;/p&gt;
    &lt;head rend="h2"&gt;Example&lt;/head&gt;
    &lt;p&gt;Here’s an example using condensation to find the determinant of a 4×4 matrix.&lt;/p&gt;
    &lt;p&gt;We can verify this with Mathematica:&lt;/p&gt;
    &lt;quote&gt;Det[{{3, 1, 4, 1}, {5, 9, 2, 6}, {0, 7, 1, 0}, {2, 0, 2, 3}}]&lt;/quote&gt;
    &lt;p&gt;which also produces 228.&lt;/p&gt;
    &lt;head rend="h2"&gt;Division&lt;/head&gt;
    &lt;p&gt;The algorithm above involves a division and so we should avoid dividing by zero. Dodgson says to&lt;/p&gt;
    &lt;quote&gt;
      &lt;p&gt;Arrange the given block, if necessary, so that no ciphers [zeros] occur in its interior. This may be done either by transposing rows or columns, or by adding to certain rows the several terms of other rows multiplied by certain multipliers.&lt;/p&gt;
    &lt;/quote&gt;
    &lt;p&gt;He expands on this remark and gives examples. I’m not sure whether this preparation is necessary only to avoid division by zero, but it does avoid the problem of dividing by a zero.&lt;/p&gt;
    &lt;p&gt;If the original matrix has all integer entries, then the division in Dodgson’s condensation algorithm is exact. The sequence of matrices produced by the algorithm will all have integer entries.&lt;/p&gt;
    &lt;head rend="h2"&gt;Efficiency&lt;/head&gt;
    &lt;p&gt;Students usually learn cofactor expansion as their first method of calculating determinants. This rule is easy to explain, but inefficient since the number of steps required is O(n!).&lt;/p&gt;
    &lt;p&gt;The more efficient way to compute determinants is by Gaussian elimination with partial pivoting. As with condensation, one must avoid dividing by zero, hence the partial pivoting.&lt;/p&gt;
    &lt;p&gt;Gaussian elimination takes O(n³) operations, and so does Dodgson’s condensation algorithm. Condensation is easy to teach and easy to carry out by hand, but unlike cofactor expansion it scales well.&lt;/p&gt;
    &lt;p&gt;If a matrix has all integer entries, Gaussian elimination can produce non-integer values in intermediate steps. Condensation does not. Also, condensation is inherently parallelizable: each of the 2 × 2 determinants can be calculated simultaneously.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=46395106</guid><pubDate>Fri, 26 Dec 2025 19:03:32 +0000</pubDate></item><item><title>My insulin pump controller uses the Linux kernel. It also violates the GPL</title><link>https://old.reddit.com/r/linux/comments/1puojsr/the_device_that_controls_my_insulin_pump_uses_the/</link><description></description><guid isPermaLink="false">https://news.ycombinator.com/item?id=46395184</guid><pubDate>Fri, 26 Dec 2025 19:13:22 +0000</pubDate></item><item><title>Gaussian Splatting 3 Ways</title><link>https://github.com/NullandKale/NullSplats</link><description>&lt;doc fingerprint="35dde8510fb295b0"&gt;
  &lt;main&gt;
    &lt;p&gt;Tkinter + OpenGL desktop app for training and viewing 3D Gaussian splats from casual captures. It wraps COLMAP for camera poses, uses PyTorch + gsplat for training, and stores everything in a reproducible cache tree so scenes can be resumed later.&lt;/p&gt;
    &lt;head class="px-3 py-2"&gt;nullsplats_720p30_h265_under10MB_noaudio.mp4&lt;/head&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Ingest a video or image folder, extract and score frames, and auto-select a subset.&lt;/item&gt;
      &lt;item&gt;Run COLMAP SfM to produce camera poses and sparse points.&lt;/item&gt;
      &lt;item&gt;Train Gaussian splats on the GPU with gsplat; export checkpoints as .ply or .splat.&lt;/item&gt;
      &lt;item&gt;View splats in an embedded OpenGL viewer inside the app.&lt;/item&gt;
      &lt;item&gt;Keep per-scene inputs/outputs under cache for repeatable workflows.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Nullsplats supports 3 methods of creating splats:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Traditional colmap + gsplat training.&lt;/item&gt;
      &lt;item&gt;Depth Anything 3 3D Gaussian Estimation.&lt;/item&gt;
      &lt;item&gt;SHARP Monocular View Synthesis.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Here are some sample splats trained using this program.&lt;/p&gt;
    &lt;p&gt;Gsplat 50-view&lt;/p&gt;
    &lt;head class="px-3 py-2"&gt;gsplat_50view_720p.mp4&lt;/head&gt;
    &lt;p&gt;Gsplat closeup&lt;/p&gt;
    &lt;head class="px-3 py-2"&gt;gsplat_closeup.mp4&lt;/head&gt;
    &lt;p&gt;DA3 5-view&lt;/p&gt;
    &lt;head class="px-3 py-2"&gt;DA3_5view_720p.mp4&lt;/head&gt;
    &lt;p&gt;DA3 closeup&lt;/p&gt;
    &lt;head class="px-3 py-2"&gt;DA3_closeup.mp4&lt;/head&gt;
    &lt;p&gt;SHARP 1-view&lt;/p&gt;
    &lt;head class="px-3 py-2"&gt;SHARP_1view_720p.mp4&lt;/head&gt;
    &lt;p&gt;SHARP closeup&lt;/p&gt;
    &lt;head class="px-3 py-2"&gt;SHARP_Closeup.mp4&lt;/head&gt;
    &lt;p&gt;Side-by-side comparison&lt;/p&gt;
    &lt;head class="px-3 py-2"&gt;Comparison_Closeup.mp4&lt;/head&gt;
    &lt;p&gt;On my RTX pro 6000 Blackwell the gsplat trained in around 5 minutes including colmap time. Depth Anything 3 took around 3-4 minutes but used a significant 16GB of vram. SHARP produced a splat in around 2.5 minutes.&lt;/p&gt;
    &lt;p&gt;Overall each is pretty good considering the input. The single view SHARP splat is particularly impressive. If DA3 was less weird, was less transparent it would be significantly better. The geometry looks pretty good.&lt;/p&gt;
    &lt;p&gt;Want to discuss development or get support? Open an Issue or checkout the discord.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;main.py - app entrypoint (Tk root + tabs).&lt;/item&gt;
      &lt;item&gt;nullsplats/ &lt;list rend="ul"&gt;&lt;item&gt;ui/ - Tk UI, tabs, OpenGL viewers, shaders (ui/shaders/.vert|.frag).&lt;/item&gt;&lt;item&gt;backend/ - frame extraction, COLMAP pipeline, splat training.&lt;/item&gt;&lt;item&gt;util/ - logging, config, threading helpers and tool path defaults.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;build.bat - portable bundle builder.&lt;/item&gt;
      &lt;item&gt;run.bat - launcher used inside the portable bundle.&lt;/item&gt;
      &lt;item&gt;requirements.txt - Python dependencies.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The app is organized around a small core state object (AppState), four UI tabs (Inputs, COLMAP, Training, Exports), and a backend pipeline that handles frame extraction, COLMAP structure-from-motion, and gsplat training.&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;main.py sets up logging, creates AppState, and builds the Tk root in ui/root.py.&lt;/item&gt;
      &lt;item&gt;ui/root.py wires the four tabs and routes scene selection between them.&lt;/item&gt;
      &lt;item&gt;Inputs tab creates scenes, extracts frames, and persists selected/resized frames.&lt;/item&gt;
      &lt;item&gt;COLMAP tab runs SfM to generate camera poses and sparse points.&lt;/item&gt;
      &lt;item&gt;Training tab runs gsplat training and streams live previews.&lt;/item&gt;
      &lt;item&gt;Exports tab lists checkpoints and renders previews/turntables.&lt;/item&gt;
    &lt;/list&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;nullsplats/app_state.py owns AppState (config + SceneManager + current scene).&lt;/item&gt;
      &lt;item&gt;nullsplats/backend/io_cache.py defines ScenePaths and metadata read/write.&lt;/item&gt;
      &lt;item&gt;Cache layout (per scene): &lt;list rend="ul"&gt;&lt;item&gt;cache/inputs/&amp;lt;scene_id&amp;gt;/source (original source copy)&lt;/item&gt;&lt;item&gt;cache/inputs/&amp;lt;scene_id&amp;gt;/frames_all&lt;/item&gt;&lt;item&gt;cache/inputs/&amp;lt;scene_id&amp;gt;/frames_selected&lt;/item&gt;&lt;item&gt;cache/inputs/&amp;lt;scene_id&amp;gt;/metadata.json&lt;/item&gt;&lt;item&gt;cache/outputs/&amp;lt;scene_id&amp;gt;/sfm&lt;/item&gt;&lt;item&gt;cache/outputs/&amp;lt;scene_id&amp;gt;/splats&lt;/item&gt;&lt;item&gt;cache/outputs/&amp;lt;scene_id&amp;gt;/renders&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;nullsplats/backend/scene_manager.py handles scene discovery, selection persistence, and thumbnail caching (thumbnails.db).&lt;/item&gt;
    &lt;/list&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;ui/root.py builds the ttk.Notebook, instantiates tabs, and coordinates tab changes.&lt;/item&gt;
      &lt;item&gt;Tabs: &lt;list rend="ul"&gt;&lt;item&gt;Inputs: ui/tab_inputs.py + mixins&lt;/item&gt;&lt;item&gt;COLMAP: ui/tab_colmap.py&lt;/item&gt;&lt;item&gt;Training: ui/tab_training.py + layout/preview mixins&lt;/item&gt;&lt;item&gt;Exports: ui/tab_exports.py&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;Wizard flows: &lt;list rend="ul"&gt;&lt;item&gt;Inline wizard in Inputs: ui/tab_inputs_wizard.py (single popup with inputs + training preset + COLMAP options).&lt;/item&gt;&lt;item&gt;Standalone wizard window: ui/wizard.py&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
    &lt;/list&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;ui/tab_inputs.py is the coordinator for the Inputs workflow.&lt;/item&gt;
      &lt;item&gt;ui/tab_inputs_scenes.py renders the scene sidebar and scene management.&lt;/item&gt;
      &lt;item&gt;ui/tab_inputs_grid.py renders the virtualized frame grid and thumbnails.&lt;/item&gt;
      &lt;item&gt;Key backend usage: backend/video_frames.py, backend/scene_manager.py.&lt;/item&gt;
    &lt;/list&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;ui/tab_colmap.py runs SfM and manages COLMAP settings/logs.&lt;/item&gt;
      &lt;item&gt;Backend calls: &lt;list rend="ul"&gt;&lt;item&gt;backend/sfm_pipeline.py (COLMAP CLI)&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
    &lt;/list&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;ui/tab_training.py orchestrates training runs, manages logging, and owns preview state.&lt;/item&gt;
      &lt;item&gt;Training method is selectable (gsplat or DA3). Live preview is gsplat-only.&lt;/item&gt;
      &lt;item&gt;ui/tab_training_layout.py builds the UI widgets.&lt;/item&gt;
      &lt;item&gt;ui/tab_training_preview.py handles preview polling + in-memory preview queue.&lt;/item&gt;
      &lt;item&gt;Backend calls: &lt;list rend="ul"&gt;&lt;item&gt;backend/splat_train.py (gsplat training loop)&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
    &lt;/list&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;ui/tab_exports.py lists checkpoints, opens a preview viewer, and renders turntables.&lt;/item&gt;
      &lt;item&gt;Uses GLCanvas to display .ply checkpoints and imageio for video output.&lt;/item&gt;
    &lt;/list&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;backend/video_frames.py handles: &lt;list rend="ul"&gt;&lt;item&gt;ffmpeg/ffprobe extraction&lt;/item&gt;&lt;item&gt;sharpness/variance scoring&lt;/item&gt;&lt;item&gt;auto-select of best frames&lt;/item&gt;&lt;item&gt;cache persistence of selections&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
    &lt;/list&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;backend/sfm_pipeline.py runs COLMAP feature extraction, matching, mapping, and model conversion. Logs go to cache/outputs/&amp;lt;scene_id&amp;gt;/sfm/logs.&lt;/item&gt;
    &lt;/list&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;backend/splat_train.py is the training entry point.&lt;/item&gt;
      &lt;item&gt;Supporting modules: &lt;list rend="ul"&gt;&lt;item&gt;backend/splat_train_config.py (dataclasses and callbacks)&lt;/item&gt;&lt;item&gt;backend/splat_train_io.py (COLMAP text parsing + frame loading)&lt;/item&gt;&lt;item&gt;backend/splat_train_ops.py (CUDA config, optimizers, export helpers)&lt;/item&gt;&lt;item&gt;backend/gs_utils.py (camera/appearance optimization utilities)&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;DA3 backend: backend/splat_backends/depth_anything3_trainer.py (Depth Anything 3 inference + gs_ply export)&lt;/item&gt;
    &lt;/list&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;ui/gl_canvas.py is the main preview surface: &lt;list rend="ul"&gt;&lt;item&gt;Wraps GaussianSplatViewer for live OpenGL display.&lt;/item&gt;&lt;item&gt;Uses SplatRenderer (gsplat rasterization) for offline renders and turntables.&lt;/item&gt;&lt;item&gt;Supports in-memory previews via PreviewPayload.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;ui/gaussian_splat_viewer.py is the OpenGL renderer (instanced quads + shaders).&lt;/item&gt;
      &lt;item&gt;ui/gaussian_splat_camera.py contains camera math helpers.&lt;/item&gt;
      &lt;item&gt;Shaders live in ui/shaders/gaussian_splat.vert and ui/shaders/gaussian_splat.frag.&lt;/item&gt;
      &lt;item&gt;Control panels: &lt;list rend="ul"&gt;&lt;item&gt;ui/render_controls.py (basic controls)&lt;/item&gt;&lt;item&gt;ui/advanced_render_controls.py (debug/scale/camera)&lt;/item&gt;&lt;item&gt;ui/colmap_camera_panel.py (apply COLMAP poses)&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
    &lt;/list&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;util/threading.py runs background tasks and marshals callbacks to the Tk thread.&lt;/item&gt;
      &lt;item&gt;util/logging.py sets a consistent console + file logger under logs/app.log.&lt;/item&gt;
      &lt;item&gt;util/tooling_paths.py resolves default COLMAP and CUDA paths.&lt;/item&gt;
    &lt;/list&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;requirements.txt contains core deps (torch, gsplat, PyOpenGL, etc.).&lt;/item&gt;
      &lt;item&gt;build.bat creates a portable bundle with venv, COLMAP, and CUDA DLLs.&lt;/item&gt;
      &lt;item&gt;run.bat is the launcher inside the portable bundle.&lt;/item&gt;
    &lt;/list&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Windows (primary target) or a Linux environment with matching binaries.&lt;/item&gt;
      &lt;item&gt;Python 3.10+ with pip/venv.&lt;/item&gt;
      &lt;item&gt;GPU with a CUDA-capable driver; PyTorch CUDA build installed.&lt;/item&gt;
      &lt;item&gt;ffmpeg/ffprobe on PATH (for video extraction).&lt;/item&gt;
      &lt;item&gt;COLMAP binaries (CUDA build recommended) under tools/colmap or user-provided path.&lt;/item&gt;
      &lt;item&gt;Optional: GLOMAP binaries under tools/glomap (future use).&lt;/item&gt;
      &lt;item&gt;Optional: Depth Anything 3 backend (pip install from GitHub; no submodule).&lt;/item&gt;
      &lt;item&gt;Optional: SHARP backend (tools/sharp is included; install editable deps).&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;DA3 uses the official Depth Anything 3 API and emits &lt;code&gt;.ply&lt;/code&gt; splats into the cache.
It requires installing the project via pip from GitHub:&lt;/p&gt;
    &lt;code&gt;pip install git+https://github.com/ByteDance-Seed/Depth-Anything-3
&lt;/code&gt;
    &lt;p&gt;DA3 settings live in the Training tab (process resolution, view selection, and COLMAP-based view scoring). If COLMAP confidence is missing, DA3 falls back to evenly spaced views.&lt;/p&gt;
    &lt;p&gt;SHARP runs on single images and can optionally use COLMAP intrinsics for multi-view runs. The repo includes the SHARP source under tools/sharp; install it in editable mode:&lt;/p&gt;
    &lt;code&gt;pip install -e tools/sharp
&lt;/code&gt;
    &lt;p&gt;From repo root:&lt;/p&gt;
    &lt;code&gt;python -m venv .venv
.venv\Scripts\activate.bat
pip install -r requirements.txt
&lt;/code&gt;
    &lt;p&gt;If you need to bootstrap CUDA-friendly PyTorch/gsplat, run tools\setup_cuda_venv.bat (optional helper if present).&lt;/p&gt;
    &lt;p&gt;For DA3 support:&lt;/p&gt;
    &lt;code&gt;pip install git+https://github.com/ByteDance-Seed/Depth-Anything-3
&lt;/code&gt;
    &lt;p&gt;For SHARP support (if you skipped it in requirements):&lt;/p&gt;
    &lt;code&gt;pip install -e tools/sharp
&lt;/code&gt;
    &lt;p&gt;With the venv active:&lt;/p&gt;
    &lt;code&gt;python main.py
&lt;/code&gt;
    &lt;p&gt;Logs go to logs and stdout; cache lives under cache/inputs/&amp;lt;scene_id&amp;gt; and cache/outputs/&amp;lt;scene_id&amp;gt;.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Inputs tab: choose or create a Scene ID, select video or image folder, set candidate/target frame counts, then Extract Frames. Frames and metadata land in cache/inputs//.&lt;/item&gt;
      &lt;item&gt;COLMAP tab: verify COLMAP path, matcher, and camera model, then run SfM. Outputs land in cache/outputs//sfm.&lt;/item&gt;
      &lt;item&gt;Training tab: configure CUDA device and training hyperparams, then run training. Outputs land in cache/outputs//splats.&lt;/item&gt;
      &lt;item&gt;Exports tab: browse checkpoints and preview them in the viewer.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;build.bat creates a self-contained bundle under build\NullSplats-portable and build\NullSplats-portable.zip.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Prereq: .venv populated with all deps (including CUDA PyTorch/gsplat).&lt;/item&gt;
      &lt;item&gt;Optional: set SKIP_CLEAN=1 to reuse an existing bundle; pass a CUDA path as the first arg to override CUDA_PATH/CUDA_HOME for DLL copy. Set REQUIRE_CUDA=0 if you intentionally want to skip bundling CUDA DLLs (otherwise the build fails when CUDA is missing). CUDA copy pulls DLLs from CUDA_SRC\bin (cud*/nv*).&lt;/item&gt;
      &lt;item&gt;Optional: set SKIP_ZIP=1 to skip creating the zip (faster). If 7z is on PATH, zipping uses -mx=0 (store-only) for speed; otherwise falls back to PowerShell Compress-Archive -CompressionLevel Fastest.&lt;/item&gt;
      &lt;item&gt;The builder prunes unused Python packages (tqdm, tyro, opencv-python, PyYAML) and copies only core CUDA DLLs; COLMAP is bundled, GLOMAP is not.&lt;/item&gt;
      &lt;item&gt;If you need to debug CUDA bundling, build.bat prints source and destination paths plus directory listings for the copied DLLs. Set REQUIRE_CUDA=1 to fail fast when none are copied.&lt;/item&gt;
      &lt;item&gt;Run from repo root:&lt;/item&gt;
    &lt;/list&gt;
    &lt;code&gt;build.bat
&lt;/code&gt;
    &lt;p&gt;Inside the bundle, use run.bat to launch; it activates the bundled venv and prepends bundled CUDA and COLMAP paths.&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Download is Windows + CUDA only.&lt;/item&gt;
      &lt;item&gt;COLMAP is not built during build process.&lt;/item&gt;
      &lt;item&gt;Download is large.&lt;/item&gt;
      &lt;item&gt;Thumbnails fail to load sometimes.&lt;/item&gt;
      &lt;item&gt;Splat rendering is slightly off.&lt;/item&gt;
      &lt;item&gt;Camera control is not great.&lt;/item&gt;
      &lt;item&gt;Does not include ffmpeg with the build.&lt;/item&gt;
      &lt;item&gt;May need CUDA SDK on the path, even though it is included.&lt;/item&gt;
    &lt;/list&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;COLMAP default: bundled tools/colmap/COLMAP.bat if present; otherwise user-specified.&lt;/item&gt;
      &lt;item&gt;CUDA default: bundled cuda/ inside the bundle; otherwise CUDA_PATH/CUDA_HOME, then C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.8.&lt;/item&gt;
      &lt;item&gt;Cache: created on demand under cache/inputs and cache/outputs.&lt;/item&gt;
    &lt;/list&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=46395273</guid><pubDate>Fri, 26 Dec 2025 19:23:28 +0000</pubDate></item><item><title>NYC phone ban reveals some students can't read clocks</title><link>https://gothamist.com/news/nyc-phone-ban-reveals-some-students-cant-read-clocks</link><description>&lt;doc fingerprint="2e3310283ac88d0c"&gt;
  &lt;main&gt;
    &lt;p&gt;Some New York City teachers say it’s high time for a refresher on old-fashioned clocks.&lt;/p&gt;
    &lt;p&gt;Tiana Millen, an assistant principal at Cardozo High School in Queens, said this year’s ban on smartphones revealed that many teens struggle to read traditional clocks. “That's a major skill that they're not used to at all,” she said.&lt;/p&gt;
    &lt;p&gt;Overall, Millen said, the phone ban has been a major success at the school, and has helped kids focus in class and socialize at lunch. Foot traffic is moving more swiftly in hallways. Without eyes glued to their phones, more students are getting to class on time. The problem is they don’t know it, she said, “because they don't know how to read the clocks.”&lt;/p&gt;
    &lt;p&gt;For years, parents and teachers have blamed technology for a range of lapsed skills — from legible handwriting to sustained attention to reading whole books — even as their proficiency with technology far outstrips their elders. Still, while educators have widely praised New York’s statewide smartphone ban that went into effect this fall, multiple teachers told Gothamist it has also laid bare an unexpected gap: How to tell time.&lt;/p&gt;
    &lt;p&gt;“The constant refrain is ‘Miss, what time is it?’ said Madi Mornhinweg, who teaches high school English in Manhattan. “It’s a source of frustration because everyone wants to know how many minutes are left in class. … It finally got to the point where we I started saying ‘Where’s the big hand and where’s the little hand?’”&lt;/p&gt;
    &lt;p&gt;According to the education department, students learn how to read clocks in first and second grade. "At NYCPS, we recognize how essential it is for our students to tell the time on both analog and digital clocks,” education department spokesperson Isla Gething said. “As our young people are growing up in an increasingly digital world, no traditional time-reading skills should be left behind.” Officials said kids are taught to master terms including “o’clock,” “half-past” and “quarter-to” in early elementary years.&lt;/p&gt;
    &lt;p&gt;After dismissal outside Midwood High School in Brooklyn, many students said they do know how to read wall clocks — but they have classmates who can’t.&lt;/p&gt;
    &lt;p&gt;“They just forgot that skill because they never used it, because they always pulled out their phone,” said Cheyenne Francis, 14.&lt;/p&gt;
    &lt;p&gt;“I know how to read a clock,” she added. ”The only time I guess I would struggle is if the time is wrong on the clock. Because sometimes they don’t set the proper time.”&lt;/p&gt;
    &lt;p&gt;Several students said clocks in their school are often broken.&lt;/p&gt;
    &lt;p&gt;Farzona Yakuba, 15, said she can tell time the old-fashioned way, but she empathizes with classmates who struggle.&lt;/p&gt;
    &lt;p&gt;“I feel like I'm one of those students sometimes because I know how to read the clock if I really need to. But I feel like most students here, they just get lazy and they ask. And I feel like I do that a lot,” she said.&lt;/p&gt;
    &lt;p&gt;Concern about students’ analog clock literacy predates the phone ban. In 2017, an Oklahoma study found only one in five kids ages 6-12 knew how to read clocks. England started replacing analog clocks in classrooms with digital ones in 2018. Grandfather and cuckoo clocks just aren’t as common as they used to be. Even kids who master clocks early on don’t have to practice that skill the way they used to.&lt;/p&gt;
    &lt;p&gt;“It’s underutilized,” said Travis Malekpour, who teaches English and math at Cardozo. He said he’s integrated telling time and managing calendars into some of his algebra lessons.&lt;/p&gt;
    &lt;p&gt;Kris Perry, executive director of Children and Screens: Institute of Digital Media and Child Development, said it makes sense that teens who have grown up in a fully digital environment haven’t had to practice analog clock-reading. She said the question is whether the shift amounts to a “a cognitive downgrade or just a replacement.”&lt;/p&gt;
    &lt;p&gt;She noted that brain scans have shown that holding books and handwriting generally lead to more brain activity than reading and typing on screens.&lt;/p&gt;
    &lt;p&gt;But several educators pointed out that while students’ clock-reading skills may be lagging, their digital skills are strong. Many schools have sophisticated coding and robotics programs, and teachers said they sometimes turn to kids for help with technology.&lt;/p&gt;
    &lt;p&gt;Mornhinweg said she recently had trouble opening a PDF for a lesson because of new software. She said her students calmly walked her through it.&lt;/p&gt;
    &lt;p&gt;“I was freaking out and they were like, ‘Miss it’s fine, this is what you do.’ I felt really old,” she said.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=46395757</guid><pubDate>Fri, 26 Dec 2025 20:18:02 +0000</pubDate></item><item><title>I Think about Kubernetes</title><link>https://garnaudov.com/writings/how-i-think-about-kubernetes/</link><description>&lt;doc fingerprint="a70aa10d8422cf30"&gt;
  &lt;main&gt;
    &lt;head rend="h1"&gt;How I think about Kubernetes&lt;/head&gt;
    &lt;p&gt;More than a container orchastrator&lt;/p&gt;
    &lt;p&gt;Kubernetes is most often described as a container orchestration tool, but after youâve spent some time with it, that mental model doesnât always feel like the most useful way to think about whatâs happening.&lt;/p&gt;
    &lt;p&gt;In many cases for me Kubernetes feels less like an orchestrator and more like a platform where you declare the desired state of your infrastructure and let the system continuously work to match your intent.&lt;/p&gt;
    &lt;p&gt;Thatâs why I like to think of Kubernetes as a runtime for declarative infrastructure with a type system. Let me break it down.&lt;/p&gt;
    &lt;head rend="h3"&gt;Type System #&lt;/head&gt;
    &lt;p&gt;Consider this manifest:&lt;/p&gt;
    &lt;code&gt;apiVersion: v1
kind: Pod
metadata:
  name: nginx
  labels:
    app: nginx
spec:
  containers:
    - name: nginx
      image: nginx:stable
      ports:
        - containerPort: 80&lt;/code&gt;
    &lt;p&gt;If youâve spent a bit of time with k8s you probably know what this is. Itâs a resource of type Pod - the smallest unit Kubernetes schedules and runs. This one runs an nginx container and declares that the container listens on port 80.&lt;/p&gt;
    &lt;p&gt;Pods donât usually live on their own. In real systems you wrap them in higher-level resources: a ReplicaSet to keep N copies around, a Deployment to manage rollouts on top of that, a Service to give them a stable network identity and an Ingress to route traffic between Services.&lt;/p&gt;
    &lt;p&gt;You see how Kubernetes comes with a whole vocabulary of resource kinds that are responsible for different parts of your infrastructure and the more you think about it, the more that vocabulary starts to behave a lot like a type system.&lt;/p&gt;
    &lt;p&gt;A Pod isnât âjust a containerâ and a Deployment isnât âjust a script that creates Podsâ. Each one is a type with a strict definition and specific semantics - what it means, what fields are valid, how itâs allowed to change and which other types it composes with.&lt;/p&gt;
    &lt;p&gt;Just like a standard type system in a programming language, except instead of types like int, char, and string, you get Pod, Deployment and Service.&lt;/p&gt;
    &lt;p&gt;And just like in a programming language, you can define your own types too. Thatâs what CRDs are - new resource kinds that extend the API, with operators that implement what those new types mean.&lt;/p&gt;
    &lt;p&gt;Traditionally we think about workloads as processes or containers. Kubernetes still runs those, but it abstracts them away by giving your infrastructure a type system.&lt;/p&gt;
    &lt;head rend="h3"&gt;Runtime #&lt;/head&gt;
    &lt;p&gt;The manifest I showed before is just a file in which you declare a desired state. Now let’s examine what happens when you apply it to your cluster.&lt;/p&gt;
    &lt;code&gt;kubectl apply -f pod.yaml&lt;/code&gt;
    &lt;p&gt;Kubernetes doesnât execute your YAML the way a script runs. What happens is you submit a typed declaration to a runtime and that runtime continuously works to make the infrastructure match your intent.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;The API server accepts your object. It parses the request, checks that the object is valid, applies admission and policy rules and then stores it as part of cluster’s state.&lt;/item&gt;
      &lt;item&gt;The cluster now “remembers” your intent. That object becomes durable state. Itâs not a command that ran itâs a thing that exists (until you modify or delete it).&lt;/item&gt;
      &lt;item&gt;Controllers continuously reconcile. Controllers watch for relevant objects and react to changes. They compare desired state (what you declared) with actual state (what exists right now) and take actions to reduce the difference.&lt;/item&gt;
      &lt;item&gt;In our case, the scheduler picks a node to place the Pod on.&lt;/item&gt;
      &lt;item&gt;The kubelet makes it real on the node. The node agent turns âa Pod should exist hereâ into âcontainers are actually running hereâ.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;declare â persist â reconcile â place â execute, on repeat.&lt;/p&gt;
    &lt;p&gt;The part that makes Kubernetes feel different from orchestration is the word continuously. Kubernetes doesnât just try once. If something drifts, the runtime tries to pull it back.&lt;/p&gt;
    &lt;p&gt;Thatâs why manual fixes often donât work:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;deleting a Pod doesnât remove the workload if the desired state still says it should exist&lt;/item&gt;
      &lt;item&gt;editing live resources can get reverted if a controller owns that intent&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;This isnât Kubernetes being annoying. Itâs Kubernetes doing what a runtime does - enforcing the meaning of your declarations.&lt;/p&gt;
    &lt;p&gt;Once you see the runtime behavior spec and status start to feel like inputs and outputs:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;spec is what you want&lt;/item&gt;
      &lt;item&gt;status is what the runtime observed and computed&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;This is a very practical way to debug. When something isnât working I look at whether the runtime is progressing toward the spec and what it says in status about why it isnât.&lt;/p&gt;
    &lt;p&gt;Kubernetes controllers donât just loop blindly though. They react to changes.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;you change a declaration&lt;/item&gt;
      &lt;item&gt;the runtime notices and converges&lt;/item&gt;
      &lt;item&gt;you remove something&lt;/item&gt;
      &lt;item&gt;the runtime reverts it if the spec still demands it&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Once you see that, GitOps fits into the picture perfectly:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Kubernetes stores the desired state inside the cluster.&lt;/item&gt;
      &lt;item&gt;GitOps states that true desired state lives in Git.&lt;/item&gt;
      &lt;item&gt;A GitOps controller continuously compares Git (desired) vs cluster (actual) and applies changes until they match.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;So in this model, Git becomes your âsource code repository", the cluster the runtime and the GitOps controller is the piece that keeps runtime state aligned with source.&lt;/p&gt;
    &lt;p&gt;If you &lt;code&gt;kubectl edit&lt;/code&gt; something that GitOps manages, youâre changing runtime state, but the source of truth is still Git, so the GitOps controller will likely revert it back.&lt;/p&gt;
    &lt;p&gt;Thatâs not a fight between tools, itâs two reconciliations doing their job:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Kubernetes reconciles toward the API objects&lt;/item&gt;
      &lt;item&gt;GitOps reconciles the API objects toward Git&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Which leads to a really practical rule of thumb. If something is GitOps managed, treat kubectl as a debugging tool, not as the way you make changes.&lt;/p&gt;
    &lt;p&gt;Thinking of Kubernetes as a runtime for declarative infrastructure instead of a mere orchestrator results in very practical approaches to operate your cluster.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;change the desired state, not the symptoms&lt;/item&gt;
      &lt;item&gt;let reconciliation do the work&lt;/item&gt;
      &lt;item&gt;make ownership explicit (especially with GitOps)&lt;/item&gt;
      &lt;item&gt;use the type system (choose the right resource kind) instead of inventing your own conventions&lt;/item&gt;
    &lt;/list&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=46396043</guid><pubDate>Fri, 26 Dec 2025 20:44:28 +0000</pubDate></item></channel></rss>