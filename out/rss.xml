<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>Hacker News: Front Page</title><link>https://raw.githubusercontent.com/Prabesh01/hnrss-content-extract/refs/heads/main/out/rss.xml</link><description>Hacker News RSS</description><atom:link href="https://raw.githubusercontent.com/Prabesh01/hnrss-content-extract/refs/heads/main/out/rss.xml" rel="self"/><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><language>en</language><lastBuildDate>Sat, 22 Nov 2025 23:09:28 +0000</lastBuildDate><item><title>Helping Valve to power up Steam devices</title><link>https://www.igalia.com/2025/11/helpingvalve.html</link><description>&lt;doc fingerprint="961b0d5348912672"&gt;
  &lt;main&gt;
    &lt;head rend="h1"&gt;Helping Valve to Power Up Steam Devices&lt;/head&gt;
    &lt;p&gt;Last week, Valve stunned the computer gaming world by unveiling three new gaming devices at once: the Steam Frame, a wireless VR headset; the Steam Machine, a gaming console in the vein of a PlayStation or Xbox; and the Steam Controller, a handheld game controller. Successors to the highly successful Valve Index and Steam Deck, these devices are set to be released in the coming year.&lt;/p&gt;
    &lt;p&gt;Igalia has long worked with Valve on SteamOS, which will power the Machine and Frame, and is excited to be contributing to these new devices, particularly the Frame. The Frame, unlike the Machine or Deck which have x86 CPUs, runs on an ARM-based CPU.&lt;/p&gt;
    &lt;p&gt;Under normal circumstances, this would mean that only games compiled to run on ARM chips could be played on the Frame. In order to get around this barrier, a translation layer called FEX is used to run applications compiled for x86 chips (which are used in nearly all gaming PCs) on ARM chips by translating the x86 machine code into ARM64 machine code.&lt;/p&gt;
    &lt;p&gt;âIf you love video games, like I do, working on FEX with Valve is a dream come true,â said Paulo Matos, an engineer with Igaliaâs Compilers Team. Even so, the challenges can be daunting, because making sure the translation is working often requires manual QA rather than automated testing. âYou have to start a game, sometimes the error shows up in the colors or sound, or how the game behaves when you break down the door in the second level. Just debugging this can take a while,â said Matos. âFor optimization work I did early last year, I used a game called Psychonauts to test it. I must have played the first 3 to 4 minutes of the game many, many times for debugging. Looking at my history, Steam tells me I played it for 29 hours, but it was always the first few minutes, nothing else.â&lt;/p&gt;
    &lt;p&gt;Beyond the CPU, the Qualcomm Adreno 750 GPU used in the Steam Frame introduced its own set of challenges when it came to running desktop games, and other complex workloads, on these devices. Doing so requires a rock-solid Vulkan driver that can ensure correctness, eliminating major rendering bugs, while maintaining high performance. This is a very difficult combination to achieve, and yet thatâs exactly what weâve done for Valve with Mesa3D Turnip, a FOSS Vulkan driver for Qualcomm Adreno GPUs.&lt;/p&gt;
    &lt;p&gt;Before we started our work, critical optimizations such as LRZ (which you can learn more about from our blog post here) or the autotuner (and its subsequent overhaul) werenât in place. Even worse, there wasnât support for the Adreno 700-series GPUs at all, which we eventually added along with support for tiled rendering.&lt;/p&gt;
    &lt;p&gt;âWe implemented many Vulkan extensions and reviewed numerous others,â said Danylo Piliaiev, an engineer on the Graphics Team. âOver the years, we ensured that D3D11, D3D12, and OpenGL games rendered correctly through DXVK, vkd3d-proton, and Zink, investigating many rendering issues along the way. We achieved higher correctness than the proprietary driver and, in many cases, Mesa3D Turnip is faster as well.â&lt;/p&gt;
    &lt;p&gt;Weâve worked with many wonderful people from Valve, Google, and other companies to iterate on the Vulkan driver over the years in order to introduce new features, bug fixes, performance improvements, as well as debugging workflows. Some of those people decided to join Igalia later on, such as our colleague and Graphics Team developer Emma Anholt. âIâve been working on Mesa for 22 years, and itâs great to have a home now where I can keep doing that work, across hardware projects, where the organization prioritizes the work experience of its developers and empowers them within the organization.â&lt;/p&gt;
    &lt;p&gt;Valveâs support in all this cannot be understated, either. Their choice to build their devices using open software like Mesa3D Turnip and FEX means theyâre committed to working on and supporting improvements and optimizations that become available to anyone who uses the same open-source projects.&lt;/p&gt;
    &lt;p&gt;âWeâve received a lot of positive feedback about significantly improved performance and fewer rendering glitches from hobbyists who use these projects to run PC games on Android phones as a result of our work,â said Dhruv Mark Collins, another Graphics Team engineer working on Turnip. âAnd it goes both ways! Weâve caught a couple of nasty bugs because of that widespread testing, which really emphasizes why the FOSS model is beneficial for everyone involved.â&lt;/p&gt;
    &lt;p&gt;An interesting area of graphics driver development is all the compiler work that is involved. Vulkan drivers such as Mesa3D Turnip need to process shader programs sent by the application to the GPU, and these programs govern how pixels in our screens are shaded or colored with geometry, textures, and lights while playing games. Job Noorman, an engineer from our Compilers Team, made significant contributions to the compiler used by Mesa3D Turnip. He also contributed to the Mesa3D NIR shader compiler, a common part that all Mesa drivers use, including RADV (most popularly used on the Steam Deck) or V3DV (used on Raspberry Pi boards).&lt;/p&gt;
    &lt;p&gt;As is normal for Igalia, while we focused on delivering results for our customer, we also made our work as widely useful as possible. For example: âWhile our target throughout our work has been the Snapdragon 8 Gen 3 thatâs in the Frame, much of our work extends back through years of Snapdragon hardware, and we regression test it to make sure it stays Vulkan conformant,â said Anholt. This means that Igaliaâs work for the Frame has consistently passed Vulkanâs Conformance Test Suite (CTS) of over 2.8 million tests, some of which Igalia is involved in creating.&lt;/p&gt;
    &lt;p&gt;Our very own Vulkan CTS expert Ricardo GarcÃa says:&lt;/p&gt;
    &lt;quote&gt;
      &lt;p&gt;Igalia and other Valve contractors actively participate in several areas inside the Khronos Group, the organization maintaining and developing graphics API standards like Vulkan. We contribute specification fixes and feedback, and we are regularly involved in the development of many new Vulkan extensions. Some of these end up being critical for game developers, like mesh shading. Others ensure a smooth and efficient translation of other APIs like DirectX to Vulkan, or help take advantage of hardware features to ensure applications perform great across multiple platforms, both mobile like the Steam Frame or desktop like the Steam Machine. Having Vulkan CTS coverage for these new extensions is a critical step in the release process, helping make sure the specification is clear and drivers implement it correctly, and Igalia engineers have contributed millions of source code lines and tests since our collaboration with Valve started.&lt;/p&gt;
    &lt;/quote&gt;
    &lt;p&gt;A huge challenge we faced in moving forward with development is ensuring that we didnât introduce regressions, small innocent-seeming changes can completely break rendering on games in a way that even CTS might not catch. What automated testing could be done was often quite constrained, but Igalians found ways to push through the barriers. âI made a continuous integration test to automatically run single-frame captures of a wide range of games spanning D3D11, D3D9, D3D8, Vulkan, and OpenGL APIs,â said Piliaiev, about the development covered in his recent XDC 2025 talk, âensuring that we donât have rendering or performance regressions.â&lt;/p&gt;
    &lt;p&gt;Looking ahead, Igaliaâs work for Valve will continue to deliver benefits to the wider Linux Gaming ecosystem. For example, the Steam Frame, as a battery-powered VR headset, needs to deliver high performance within a limited power budget. A way to address this is to create a more efficient task scheduler, which is something Changwoo Min of Igaliaâs Kernel Team has been working on. As he says, âI have been developing a customized CPU scheduler for gaming, named LAVD: Latency-criticality Aware Virtual Deadline scheduler.â&lt;/p&gt;
    &lt;p&gt;In general terms, a scheduler automatically identifies critical tasks and dynamically boosts their deadlines to improve responsiveness. Most task schedulers donât take energy consumption into account, but the Rust-based LAVD is different. âLAVD makes scheduling decisions considering each chipâs performance versus energy trade-offs. It measures and predicts the required computing power on the fly, then selects the best set of CPUs to meet that demand with minimal energy consumption,â said Min.&lt;/p&gt;
    &lt;p&gt;One of our other kernel engineers, Melissa Wen, has been working on AMD kernel display drivers to maintain good color management and HDR support for SteamOS across AMD hardware families, both for the Steam Deck and the Steam Machine. This is especially important with newer display hardware in the Steam Machine, which features some notable differences in color capabilities, aiming for more powerful and efficient color management which necessitated driver work.&lt;/p&gt;
    &lt;p&gt;â¦and thatâs a wrap! We will continue our efforts toward improving future versions of SteamOS, and with a partner as strongly supportive as Valve, we expect to do more work to make Linux gaming even better. If any of that sounded interesting and youâd like to work with us to tackle tricky problems of your own, please get in touch!&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=46006616</guid><pubDate>Fri, 21 Nov 2025 17:29:59 +0000</pubDate></item><item><title>We Induced Smells With Ultrasound</title><link>https://writetobrain.com/olfactory</link><description>&lt;doc fingerprint="260999164f2bc5f8"&gt;
  &lt;main&gt;
    &lt;head rend="h1"&gt;We Induced Smells With Ultrasound&lt;/head&gt;
    &lt;p&gt;We stimulated the scent-processing brain regions with focused ultrasound. As far as we know, no one seems to have done this kind of stimulation before - even in animals. We reliably produced distinct scents such as a campfire burn or fresh air!&lt;/p&gt;
    &lt;p&gt;We pointed an ultrasound probe at the scent-processing region of the brain to obtain different sensations. Different focal spots corresponded to different smells, which we’ve replicated first-try on two people and validated with a blind trial. The sensations we obtained are:&lt;/p&gt;
    &lt;p&gt;Here is a video from our blind tasting:&lt;/p&gt;
    &lt;head rend="h2"&gt;The Setup&lt;/head&gt;
    &lt;p&gt;Smells are processed in the olfactory bulb. We decided to try to stimulate it with focused ultrasound through the skull. As far as we know, no one seems to have done this kind of olfactory stimulation before - even in animals.&lt;lb/&gt; However, after being able to induce sensations of motion the previous week, it seemed promising to try the same for olfactory.&lt;/p&gt;
    &lt;head rend="h3"&gt;The Anatomy&lt;/head&gt;
    &lt;p&gt;The olfactory bulb, our target, is tucked behind the top of the nose. That turns out to be a pretty inconvenient location for a couple of reasons:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;The nose doesn’t provide a flat surface for mounting a transducer for stimulation.&lt;/item&gt;
      &lt;item&gt;It's mostly filled with air, which interferes with ultrasound. Ultrasound needs a continuous medium to travel through, and filling the nose with gel seemed rather unappealing.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Instead, we found that you can place the transducer on the forehead and aim the ultrasound downward towards the olfactory bulb. While this isn’t a perfect solution because the frontal sinuses can weaken the signal, careful device positioning above the sinuses still allows us to reach our general target region.&lt;/p&gt;
    &lt;head rend="h3"&gt;The ultrasound&lt;/head&gt;
    &lt;p&gt;We got our first effects using just a handheld probe and some gel, but it quickly became obvious that holding a probe steady by hand makes it nearly impossible to keep the focal spot in the same place. To improve stability, we improvised a makeshift headset, allowing for more reliable positioning. We switched from gel to a solid, jello-like pad for stability and general comfort. In the end, our headset got a bit hacky:&lt;/p&gt;
    &lt;p&gt;It ended up having a knife taped to the probe for mechanical support At the time, all of our headsets had a knife taped to the probe, as untaping the knife lead to software errors.. At some point we thought of using a mouthguard for fixing the probe relative to the brain. This was a great idea considering the teeth are the only exposed part of the skull, except it turns out you can’t talk about smells while wearing a mouthguard.&lt;/p&gt;
    &lt;p&gt;To guide placement, we used an MRI of Lev’s skull to roughly determine where the transducer would point and how the focal region (where ultrasound waves actually concentrate) aligned with the olfactory bulb (the target for stimulation).&lt;/p&gt;
    &lt;p&gt;We found our “sweet spot” to be low-frequency ultrasound focused right below the forehead and angled downward toward the bulbs. Specifically:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;300 kHz frequency (low enough to penetrate the skull well)&lt;/item&gt;
      &lt;item&gt;Focal depth of about 39 mm (where the ultrasound energy converged beneath the forehead)&lt;/item&gt;
      &lt;item&gt;50–55° steering angles (to point the focus down toward the bulbs)&lt;/item&gt;
      &lt;item&gt;5-cycle pulses at a 1200 Hz repetition rate (short, rapidly repeating bursts)&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;While Albert did not have an MRI available, this general configuration still worked for him with minor adjustments to the focal spot position.&lt;/p&gt;
    &lt;head rend="h3"&gt;Safety&lt;/head&gt;
    &lt;p&gt;The largest chunk of the time was spent on making sure the ultrasound sequences behaved safely and in the manner we expected, split between two directions:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Measuring the output field. We put the transducer in a water tank and measured the pressure at the focal spot. With our parameters, it ranged from 150 to 250 kPa, which corresponded to a mechanical index of at most 0.4. That implied that the average intensity at the focal spot was by an order of magnitude lower than what's typically used in tFUS and has been proven safe. We were also far within safety limits on mechanical index and thermal dose.&lt;/item&gt;
      &lt;item&gt;Avoiding the optic nerve by reducing asymmetry in the system: the nerves are further from the middle of the head. The olfactory bulb also has its two components slightly off-center, so a bit of asymmetry was necessary: we focused at an angle of 2 degrees to the side in one of the presets. However, we stayed within the limit of 15 degrees, which is enough not to touch the optic nerves.&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h2"&gt;Results&lt;/head&gt;
    &lt;p&gt;We have managed to induce four different sensations, all of them in two people:&lt;/p&gt;
    &lt;p&gt;We distinguish between a smell and a sensation here because, subjectively, they feel different. The smells are strong and localized to the noise, almost like you could sniff around and find the source. The sensations are more diffuse: a weak, slow-onset impression of a smell, often paired with other (likely placebo) feelings, such as a light tingling on the face.&lt;/p&gt;
    &lt;p&gt;Both smells and sensations are strongest on a light in-breath, so we tested by sitting there, with a probe to the forehead, mildly sniffing. Sometimes there is a slight waft of a smell that comes on over a few breaths, and sometimes it just hits you. The first time Albert smelled the garbage, he jerked his eyes open thinking a garbage truck just drove in! This was indoors.&lt;/p&gt;
    &lt;p&gt;Many of these scents correspond not to specific receptor types but rather combinations of receptors. We think this is because the focal spot is pretty large—300kHz ultrasound in tissue has a wavelength of 5mm, while the adult human olfactory bulb is roughly 6-14mm in length The olfactory bulb can vary in size by up to 3x, depending on "age and olfactory experience", so perhaps (we're making this up) with more usage your olfactory bulb might actually get bigger, leading to better resolution stimulation!.&lt;/p&gt;
    &lt;p&gt;We found different scents by steering the beam over ~14 mm (20 degrees at 4 cm radius). The distance between freshness and burning was ~3.5 mm. We ensured that the effect was not placebo with an auditory mask (blasting music through airpods) so you don’t hear the probe, though you cannot distinguish the different focal spots through sound anyways. We then tested discrimination in a trial where Thomas selected the focal spots, and Lev was naming the scents. You can check out the full video here.&lt;/p&gt;
    &lt;p&gt;It is remarkable that we could induce different scents with such little steering (40% of the diffraction-limited focal spot size And potentially even higher, because there was some dead space in between the focal spots, where you don't feel anything.). This suggests that the resolution we have access to is much higher than the spatial resolution of the ultrasound (a kind of super-resolution for neurostim!) In particular, we do not need single-neuron resolution to find an independent basis of scents, upon which we can construct our latent space. To improve this system, the next steps are a more stable setup, increased frequency, more play with focal location, spot size, and stimulus waveform.&lt;/p&gt;
    &lt;head rend="h3"&gt;Can you feel the meaning&lt;/head&gt;
    &lt;p&gt;The reason stimulating olfactory sensations is interesting is not just "VR for smells", as one might initially assume. The nose has 400 distinct receptor types, and we can distinguish subtle combinations of their activations, so they could serve as a channel of writing directly into the brain, as a means of non-invasive neuromodulation.&lt;/p&gt;
    &lt;p&gt;The olfactory system potentially allows writing up to 400, if not 800 due to two nostrils, dimensions into the brain. That is comparable to the dimensionality of latent spaces of LLMs, which implies you could reasonably encode the meaning of a paragraph into a 400-dimensional vector. If you had a device which allows for this kind of writing, you could learn to associate the input patterns with their corresponding meanings. After that, you could directly smell the latent space. A bit of ultrasound, a breath in - and you understood a paragraph.&lt;/p&gt;
    &lt;p&gt;People are able to develop synesthesia - being able to hear colors and see smells, and it might be possible to extend that to semantics. However, at this stage it is speculative.&lt;/p&gt;
    &lt;p&gt;One could try to make a similar argument for the eyes: take 400 cones on the retina, hijack them, and you've got yourself a 400-dimensional channel. But we think the nose is better. The olfactory system is much simpler and more directly interfaces with core brain regions, like the hippocampus. The signal through the olfactory system is simply less filtered and processed. If you tried to write arbitrary light intensities into a patch of cones, the next step of the processing would be a convolutional neural network-like structure in the visual cortex, and the signal would get averaged out. The embeddings you'd write would never make it into the higher levels of processing in the brain. You can try to encode the information in a more easily perceptible way, such as Chernoff faces, but it would reduce the bandwidth, and learning the remapping would still be very difficult.&lt;/p&gt;
    &lt;p&gt;In contrast, only a few synapses separate the olfactory receptors from the hippocampus This is why certain smells bring up such strong memories!, which is responsible for memory, as well as from the amygdala, which does emotional regulation.&lt;/p&gt;
    &lt;p&gt;Finally, personally speaking, the authors use their eyes and ears more than their noses during office work Raphael Hotter noted that this is in fact a general statement, as the usage of eyes and ears extends beyond office work.. The nose is an underutilized channel that imposes fewer bad priors (spatial/tonal maps) than the visual, auditory, and somatosensory.&lt;/p&gt;
    &lt;p&gt;We found four scents in a couple of days. With a little more engineering, it should be possible to increase the bit rate of olfactory stimulation by a lot.&lt;/p&gt;
    &lt;p&gt;If we gain control of all 400 basis vectors, we might be able to smell meaning.&lt;lb/&gt; And we’ve already covered the first one percent.&lt;/p&gt;
    &lt;head rend="h2"&gt;Acknowledgements&lt;/head&gt;
    &lt;p&gt;We thank Raffi Hotter, Aidan Smith, and especially Mason Wang for thoughtful feedback on this blogpost.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=46008332</guid><pubDate>Fri, 21 Nov 2025 20:02:45 +0000</pubDate></item><item><title>Personal blogs are back, should niche blogs be next?</title><link>https://disassociated.com/personal-blogs-back-niche-blogs-next/</link><description>&lt;doc fingerprint="3b8090076bc54e9f"&gt;
  &lt;main&gt;
    &lt;head rend="h2"&gt;Personal blogs are back, should niche blogs be next?&lt;/head&gt;
    &lt;p&gt;20 November 2025&lt;/p&gt;
    &lt;p&gt;When it comes to blogging there are few rules. Write content that is somehow meaningful might be one of them though. I think it’s down to the individual to determine what constitutes meaningful.&lt;/p&gt;
    &lt;p&gt;In the hey-day, the so-called golden age of blogging, there were plenty of people prepared to offer definitions of meaningful, and how to write accordingly. It was natural. The web was once awash with all sorts of blogs. Likewise people who wanted to show others how to blog “successfully”.&lt;/p&gt;
    &lt;p&gt;Again, the definition of successful resided with the individual, but it was obvious this involved monetary return for some people. And why not. If you’re going to invest time and energy in creating a resource that is useful to other people, why shouldn’t you earn money, make a living even, from it?&lt;/p&gt;
    &lt;p&gt;One of these people blogging about blogging was Melbourne based Australian writer and author Darren Rowse, who launched his blogging resource Problogger in 2004. Without going into detail, because you can look it up for yourself, Rowse, as one of the earlier bloggers about blogging, did, and still does presumably, rather well for himself.&lt;/p&gt;
    &lt;p&gt;Rowse’s writing, and that of his contributors, attracted numerous readers keen to learn what they could about blogging, and the potential to make money from it.&lt;/p&gt;
    &lt;p&gt;Problogger is what’s called a niche blog. As a blog about blogging, it has a reasonably singular focus. Some people considered this niche principle to be a core tenet of blogging. There was this idea, in the earlier days of blogging, which possibly still persists, that blogs would do better if they had a speciality. Not only were search engines said to be in favour the approach, but the author of a speciality, or niche blog, would generally be considered to be an expert, of some sort, in their field.&lt;/p&gt;
    &lt;p&gt;A master of one trade, rather than the proverbial jack of all trades.&lt;/p&gt;
    &lt;p&gt;Regardless, the world was once full of blogs on every topic imaginable. It was a great time to be alive. If you wanted to learn about something in particular, there was a blog for you. Some publications featured quality content, others required a little fact checking, while some were definitely to be taken with a pinch of salt.&lt;/p&gt;
    &lt;p&gt;But niche blogging was never a format that suited everyone. There are people who did, still do, well, writing about a range, sometimes a wide range, of topics. Kottke is one of the better known blogs that does not have a specific speciality. Here, the publication itself is the speciality. To repeat what I wrote in the first sentence of this article: the rules of blogging are few.&lt;/p&gt;
    &lt;p&gt;But the facets of blogging covered at Problogger, and numerous other similar websites, usually only applied to blogs of a commercial nature. That’s not to say one or two personal bloggers might have looked at the tips posted there for increasing their audience, or improving their writing though. But in my view, personal bloggers were not, are not, part of Problogger’s target audience.&lt;/p&gt;
    &lt;p&gt;It’s been a long time since I last wrote about Problogger, let alone visited the website, maybe fifteen plus years, but a recent mention of it by Kev Quick, via ldstephens, caught my eye. But I don’t believe Rowse is being critical, in any way, of personal bloggers because they do not adhere to a niche or speciality publishing format. That’s not what Problogger, or Rowse, is about.&lt;/p&gt;
    &lt;p&gt;But this started me thinking, and writing another of my long posts.&lt;/p&gt;
    &lt;p&gt;In an age where social media, and influencers, have usurped blogs and their A-List authors, in the jostle for supremacy, it has to be wondered what role websites like Problogger still have. Only a handful of blogs generate liveable incomes today. Despite the doom and gloom though, the form has not completely died off. A backlash against social media, and a growing IndieWeb/SmallWeb community, has precipitated a revival in personal websites.&lt;/p&gt;
    &lt;p&gt;This is a largely non-commercial movement. Of course, there’s nothing wrong with personal websites. Many of us started out with them in the early days of the web. But the web was not only intended for personal journals. It was a vehicle for sharing all manner of information. The web could also empower individuals, and partnerships, to not only set up shop online, be that blogs, or quite literally shops, but potentially make a living at the same time.&lt;/p&gt;
    &lt;p&gt;But with the revival of personal blogs well underway, I think it’s time to bring niche blogs back into the fold. I’m talking about well written, quality, topic focused resources. This is material fast vanishing from the web, leaving ever diminishing options to source useful and accurate information. What are the alternatives? The misinformation morass that is social media? Being served AI generated summaries in response to search engine queries? A web choke full of AI slop?&lt;/p&gt;
    &lt;p&gt;At the same time, I’m not advocating for a return of niche blogs plastered with adverts, and popup boxes urging visitors to subscribe to say a newsletter, before they’ve even had a chance to blink at what they came to read.&lt;/p&gt;
    &lt;p&gt;I’m talking about work produced by independent writers, with an interest in their subject matter, who are not backed by large media organisations, or private equity. This is bringing back reliable sources of information, that also recompenses the content writers in some way. Hopefully we’ve learned a few lessons about monetisation since the earlier wave of niche blogging. We know it is possible to generate revenue without compromising the reader experience.&lt;/p&gt;
    &lt;p&gt;A resurgence in personal blogging is the first step in rebuilding a vibrant, thriving, web, or if you like, blogosphere. Now the focus needs to be on restoring the flow of accessible and trusted information.&lt;/p&gt;
    &lt;p&gt;RELATED CONTENT&lt;/p&gt;
    &lt;p&gt;blogs, history, IndieWeb, self publishing, SmallWeb, technology, trends&lt;/p&gt;
    &lt;head rend="h3"&gt;There's 2 comments on this post&lt;/head&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt; On 22 November 2025 at 11:34 AM, Jorge Arango said:&lt;p&gt;Thanks for sharing. I’d like to believe a resurgence of personal blogs is underway. Is there data that substantiates this claim?&lt;/p&gt;&lt;/item&gt;
    &lt;/list&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=46009894</guid><pubDate>Fri, 21 Nov 2025 22:40:28 +0000</pubDate></item><item><title>Agent design is still hard</title><link>https://lucumr.pocoo.org/2025/11/21/agents-are-hard/</link><description>&lt;doc fingerprint="67169c5569238917"&gt;
  &lt;main&gt;
    &lt;p&gt;written on November 21, 2025&lt;/p&gt;
    &lt;p&gt;I felt like it might be a good time to write about some new things I’ve learned. Most of this is going to be about building agents, with a little bit about using agentic coding tools.&lt;/p&gt;
    &lt;p&gt;TL;DR: Building agents is still messy. SDK abstractions break once you hit real tool use. Caching works better when you manage it yourself, but differs between models. Reinforcement ends up doing more heavy lifting than expected, and failures need strict isolation to avoid derailing the loop. Shared state via a file-system-like layer is an important building block. Output tooling is surprisingly tricky, and model choice still depends on the task.&lt;/p&gt;
    &lt;p&gt;When you build your own agent, you have the choice of targeting an underlying SDK like the OpenAI SDK or the Anthropic SDK, or you can go with a higher level abstraction such as the Vercel AI SDK or Pydantic. The choice we made a while back was to adopt the Vercel AI SDK but only the provider abstractions, and to basically drive the agent loop ourselves. At this point we would not make that choice again. There is absolutely nothing wrong with the Vercel AI SDK, but when you are trying to build an agent, two things happen that we originally didn’t anticipate:&lt;/p&gt;
    &lt;p&gt;The first is that the differences between models are significant enough that you will need to build your own agent abstraction. We have not found any of the solutions from these SDKs that build the right abstraction for an agent. I think this is partly because, despite the basic agent design being just a loop, there are subtle differences based on the tools you provide. These differences affect how easy or hard it is to find the right abstraction (cache control, different requirements for reinforcement, tool prompts, provider-side tools, etc.). Because the right abstraction is not yet clear, using the original SDKs from the dedicated platforms keeps you fully in control. With some of these higher-level SDKs you have to build on top of their existing abstractions, which might not be the ones you actually want in the end.&lt;/p&gt;
    &lt;p&gt;We also found it incredibly challenging to work with the Vercel SDK when it comes to dealing with provider-side tools. The attempted unification of messaging formats doesn’t quite work. For instance, the web search tool from Anthropic routinely destroys the message history with the Vercel SDK, and we haven’t yet fully figured out the cause. Also, in Anthropic’s case, cache management is much easier when targeting their SDK directly instead of the Vercel one. The error messages when you get things wrong are much clearer.&lt;/p&gt;
    &lt;p&gt;This might change, but right now we would probably not use an abstraction when building an agent, at least until things have settled down a bit. The benefits do not yet outweigh the costs for us.&lt;/p&gt;
    &lt;p&gt;Someone else might have figured it out. If you’re reading this and think I’m wrong, please drop me a mail. I want to learn.&lt;/p&gt;
    &lt;p&gt;The different platforms have very different approaches to caching. A lot has been said about this already, but Anthropic makes you pay for caching. It makes you manage cache points explicitly, and this really changes the way you interact with it from an agent engineering level. I initially found the manual management pretty dumb. Why doesn’t the platform do this for me? But I’ve fully come around and now vastly prefer explicit cache management. It makes costs and cache utilization much more predictable.&lt;/p&gt;
    &lt;p&gt;Explicit caching allows you to do certain things that are much harder otherwise. For instance, you can split off a conversation and have it run in two different directions simultaneously. You also have the opportunity to do context editing. The optimal strategy here is unclear, but you clearly have a lot more control, and I really like having that control. It also makes it much easier to understand the cost of the underlying agent. You can assume much more about how well your cache will be utilized, whereas with other platforms we found it to be hit and miss.&lt;/p&gt;
    &lt;p&gt;The way we do caching in the agent with Anthropic is pretty straightforward. One cache point is after the system prompt. Two cache points are placed at the beginning of the conversation, where the last one moves up with the tail of the conversation. And then there is some optimization along the way that you can do.&lt;/p&gt;
    &lt;p&gt;Because the system prompt and the tool selection now have to be mostly static, we feed a dynamic message later to provide information such as the current time. Otherwise, this would trash the cache. We also leverage reinforcement during the loop much more.&lt;/p&gt;
    &lt;p&gt;Every time the agent runs a tool you have the opportunity to not just return data that the tool produces, but also to feed more information back into the loop. For instance, you can remind the agent about the overall objective and the status of individual tasks. You can also provide hints about how the tool call might succeed when a tool fails. Another use of reinforcement is to inform the system about state changes that happened in the background. If you have an agent that uses parallel processing, you can inject information after every tool call when that state changed and when it is relevant for completing the task.&lt;/p&gt;
    &lt;p&gt;Sometimes it’s enough for the agent to self-reinforce. In Claude Code, for instance, the todo write tool is a self-reinforcement tool. All it does is take from the agent a list of tasks that it thinks it should do and echo out what came in. It’s basically just an echo tool; it really doesn’t do anything else. But that is enough to drive the agent forward better than if the only task and subtask were given at the beginning of the context and too much has happened in the meantime.&lt;/p&gt;
    &lt;p&gt;We also use reinforcements to inform the system if the environment changed during execution in a way that’s problematic for the agent. For instance, if our agent fails and retries from a certain step forward but the recovery operates off broken data, we inject a message informing it that it might want to back off a couple of steps and redo an earlier step.&lt;/p&gt;
    &lt;p&gt;If you expect a lot of failures during code execution, there is an opportunity to hide those failures from the context. This can happen in two ways. One is to run tasks that might require iteration individually. You would run them in a subagent until they succeed and only report back the success, plus maybe a brief summary of approaches that did not work. It is helpful for an agent to learn about what did not work in a subtask because it can then feed that information into the next task to hopefully steer away from those failures.&lt;/p&gt;
    &lt;p&gt;The second option doesn’t exist in all agents or foundation models, but with Anthropic you can do context editing. So far we haven’t had a lot of success with context editing, but we believe it’s an interesting thing we would love to explore more. We would also love to learn if people have success with it. What is interesting about context editing is that you should be able to preserve tokens for further down the iteration loop. You can take out of the context certain failures that didn’t drive towards successful completion of the loop, but only negatively affected certain attempts during execution. But as with the point I made earlier: it is also useful for the agent to understand what didn’t work, but maybe it doesn’t require the full state and full output of all the failures.&lt;/p&gt;
    &lt;p&gt;Unfortunately, context editing will automatically invalidate caches. There is really no way around it. So it can be unclear when the trade-off of doing that compensates for the extra cost of trashing the cache.&lt;/p&gt;
    &lt;p&gt;As I mentioned a couple of times on this blog already, most of our agents are based on code execution and code generation. That really requires a common place for the agent to store data. Our choice is a file system—in our case a virtual file system—but that requires different tools to access it. This is particularly important if you have something like a subagent or subinference.&lt;/p&gt;
    &lt;p&gt;You should try to build an agent that doesn’t have dead ends. A dead end is where a task can only continue executing within the sub-tool that you built. For instance, you might build a tool that generates an image, but is only able to feed that image back into one more tool. That’s a problem because you might then want to put those images into a zip archive using the code execution tool. So there needs to be a system that allows the image generation tool to write the image to the same place where the code execution tool can read it. In essence, that’s a file system.&lt;/p&gt;
    &lt;p&gt;Obviously it has to go the other way around too. You might want to use the code execution tool to unpack a zip archive and then go back to inference to describe all the images so that the next step can go back to code execution and so forth. The file system is the mechanism that we use for that. But it does require tools to be built in a way that they can take file paths to the virtual file system to work with.&lt;/p&gt;
    &lt;p&gt;So basically an &lt;code&gt;ExecuteCode&lt;/code&gt; tool would have access to the same file system as
the &lt;code&gt;RunInference&lt;/code&gt; tool which could take a &lt;code&gt;path&lt;/code&gt; to a file on that same
virtual file system.&lt;/p&gt;
    &lt;p&gt;One interesting thing about how we structured our agent is that it does not represent a chat session. It will eventually communicate something to the user or the outside world, but all the messages that it sends in between are usually not revealed. The question is: how does it create that message? We have one tool which is the output tool. The agent uses it explicitly to communicate to the human. We then use a prompt to instruct it when to use that tool. In our case the output tool sends an email.&lt;/p&gt;
    &lt;p&gt;But that turns out to pose a few other challenges. One is that it’s surprisingly hard to steer the wording and tone of that output tool compared to just using the main agent loop’s text output as the mechanism to talk to the user. I cannot say why this is, but I think it’s probably related to how these models are trained.&lt;/p&gt;
    &lt;p&gt;One attempt that didn’t work well was to have the output tool run another quick LLM like Gemini 2.5 Flash to adjust the tone to our preference. But this increases latency and actually reduces the quality of the output. In part, I think the model just doesn’t word things correctly and the subtool doesn’t have sufficient context. Providing more slices of the main agentic context into the subtool makes it expensive and also didn’t fully solve the problem. It also sometimes reveals information in the final output that we didn’t want to be there, like the steps that led to the end result.&lt;/p&gt;
    &lt;p&gt;Another problem with an output tool is that sometimes it just doesn’t call the tool. One of the ways in which we’re forcing this is we remember if the output tool was called. If the loop ends without the output tool, we inject a reinforcement message to encourage it to use the output tool.&lt;/p&gt;
    &lt;p&gt;Overall our choices for models haven’t dramatically changed so far. I think Haiku and Sonnet are still the best tool callers available, so they make for excellent choices in the agent loop. They are also somewhat transparent with regards to what the RL looks like. The other obvious choices are the Gemini models. We so far haven’t found a ton of success with the GPT family of models for the main loop.&lt;/p&gt;
    &lt;p&gt;For the individual sub-tools, which in part might also require inference, our current choice is Gemini 2.5 if you need to summarize large documents or work with PDFs and things like that. That is also a pretty good model for extracting information from images, in particular because the Sonnet family of models likes to run into a safety filter which can be annoying.&lt;/p&gt;
    &lt;p&gt;There’s also probably the very obvious realization that token cost alone doesn’t really define how expensive an agent. A better tool caller will do the job in fewer tokens. There are some cheaper models available than sonnet today, but they are not necessarily cheaper in a loop.&lt;/p&gt;
    &lt;p&gt;But all things considered, not that much has changed in the last couple of weeks.&lt;/p&gt;
    &lt;p&gt;We find testing and evals to be the hardest problem here. This is not entirely surprising, but the agentic nature makes it even harder. Unlike prompts, you cannot just do the evals in some external system because there’s too much you need to feed into it. This means you want to do evals based on observability data or instrumenting your actual test runs. So far none of the solutions we have tried have convinced us that they found the right approach here. Unfortunately, I have to report that at the moment we haven’t found something that really makes us happy. I hope we’re going to find a solution for this because it is becoming an increasingly frustrating aspect of building an agent.&lt;/p&gt;
    &lt;p&gt;As for my experience with coding agents, not really all that much has changed. The main new development is that I’m trialing Amp more. In case you’re curious why: it’s not that it’s objectively a better agent than what I’m using, but I really quite like the way they’re thinking about agents from what they’re posting. The interactions of the different sub agents like the Oracle with the main loop is beautifully done, and not many other harnesses do this today. It’s also a good way for me to validate how different agent designs work. Amp, similar to Claude Code, really feels like a product built by people who also use their own tool. I do not feel every other agent in the industry does this.&lt;/p&gt;
    &lt;p&gt;That’s just a random assortment of things that I feel might also be worth sharing:&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=46013935</guid><pubDate>Sat, 22 Nov 2025 11:27:24 +0000</pubDate></item><item><title>The Uncertain Origins of Aspirin</title><link>https://press.asimov.com/articles/aspirin</link><description>&lt;doc fingerprint="be8150d52a335197"&gt;
  &lt;main&gt;
    &lt;head rend="h1"&gt;The Uncertain Origins of Aspirin&lt;/head&gt;
    &lt;p&gt;â&lt;/p&gt;
    &lt;quote&gt;On a cool starlit night in ancient Egypt, a wife brews willow-bark tea for her husband, hot with fever;&lt;lb/&gt;While Athens and Sparta wage war, Hippocrates hurries to the river to shave some more willow bark, intending to cool down another sick child brought to his door;&lt;lb/&gt;While George III marries Princess Charlotte, a son dashes off into the woods in search of willow bark to treat his motherâs worsening fever.&lt;/quote&gt;
    &lt;p&gt;While these anecdotes are familiar from cinema and literature, the history of aspirin and the willow bark from which it is (supposedly) derived is far from clear.&lt;/p&gt;
    &lt;p&gt;For instance, it is often said that Hippocrates prescribed willow bark tea to treat inflammatory pain. In a perfect world, we would know this because a verified scroll from around 400 BC would exist, stating: âFor inflammation, I recommend willow bark tea, and so does everyone I know. So sayeth Hippocrates of Kos, future father of medicine and writer of the eponymous oath.â&lt;/p&gt;
    &lt;p&gt;Of course, such primary material does not always come to light. And many who recount medical and scientific histories (or, indeed, any history at all) do so despite incomplete information. In these cases, however, itâs still important to cite what evidence there is: what, for example, has led so many people to believe Hippocrates prescribed willow bark tea for inflammatory pain? If the answer is âsomeone said so,â who was that someone, and why did they think it was true?&lt;/p&gt;
    &lt;p&gt;This history of one of the worldâs most widely consumed classes of drugs demonstrates the difficulties that surround the fact-finding of its origins. Some of these difficulties are historic, such as bad record keeping or obscure translations, and some are of continued relevance, such as political upheaval or the prejudice that often interferes with science.&lt;/p&gt;
    &lt;p&gt;My goal is not only to tell the story of a pharmaceutical staple but to share what my decades-long work in evidence synthesis in epidemiology has taught me about researching scientific history. In doing so, Iâll differentiate claims that are known from original evidence â such as the writings of Hippocrates and Pliny the Elder or original journal articles â from those made without primary support. I have sourced as much of the latter as possible, but both conflicting and unsupported claims remain, which Iâll note.&lt;/p&gt;
    &lt;p&gt;The origins of aspirin make a good subject for exposing the challenges of scientific research for a couple of reasons. Firstly, the stories stretch back millennia, and secondly, aspirin is such a successful drug that there is ample material to work with. Aspirin and other non-steroidal anti-inflammatory drugs (NSAIDs)1 are among the most widely prescribed drugs worldwide,2 are safe enough that many are available without a prescription, and are some of the cheapest available drugs of any class. Itâs often claimed that 30 million people take NSAIDs worldwide every day, although this assertion originally dates back to 1987 and wasnât referenced. Nonetheless, if it were true, we would expect that number to be substantially higher now, given the increase in global population.&lt;/p&gt;
    &lt;p&gt;But before we can contend with the popularity of NSAIDs, we must first look at their origins.&lt;/p&gt;
    &lt;p&gt;{{signup}}&lt;/p&gt;
    &lt;head rend="h2"&gt;Ancient History: Antiquity to 1763 AD&lt;/head&gt;
    &lt;p&gt;When I was in medical school in 2007, I learned that willow bark tea has been used for thousands of years to treat pain and fever. Iâve read at least a handful of books â historical and fantasy alike â that make the same claim. The fifth Bridgerton book, To Sir Philip, With Love, includes a scene with an urgent search for willow bark to bring down a characterâs fever. Diarmuid Jeffreys wrote an entire book on aspirin, The Remarkable Story of a Wonder Drug, which detailed how willow was used from Ancient Egypt, through Ancient Greece and Rome, to the Middle Ages in Europe, and beyond. This is repeated by journal articles, though their claims are rarely referenced.&lt;/p&gt;
    &lt;p&gt;Even if their sources are sketchy, these accounts seem plausible. Willow trees are relatively common, grow worldwide (though mostly in colder and wetter parts of the Northern Hemisphere), and have had various uses since antiquity. For example, a willow fishing net was found in Finland dating from 8,300 BC, and willow has also been used for wattle fences, wattle and daub houses, coracles, cricket bats, and even World War II parachute baskets.&lt;/p&gt;
    &lt;p&gt;However, the most plausible reason that willow bark could be the antecedent of aspirin is that it contains salicin (named for the genus of willow trees, Salix). Salicin is converted into salicylic acid in the body when an enzyme bisects salicin, one half of which is then oxidized to become salicylic acid. Acetylsalicylic acid, known today as aspirin, is also converted into salicylic acid in the body: an enzyme simply cuts off the acetyl group to give salicylic acid. Salicylic acid is likely the active compound that blocks the enzyme cyclooxygenase, giving aspirin its efficacy, and was used as a treatment for fever and gout before aspirin was developed.&lt;/p&gt;
    &lt;p&gt;It seems reasonable, therefore, to believe that willow bark tea could act like aspirin, reducing fever, inflammation, and pain. Willow grew in abundance across the world, and people have been using it for thousands of years. Additionally, myrtle and poplar trees, as well as meadowsweet, likewise contain salicin and could have been used for the same purpose.&lt;/p&gt;
    &lt;p&gt;However, there is a problem with the claim that willow bark and similar plants are the ancient equivalent of aspirin when brewed as tea or simply chewed. And it is this: most of the extant evidence referenced by histories of aspirin fail entirely to mention using willow bark or similar plants to reduce fever, pain, or inflammation.Â&lt;/p&gt;
    &lt;p&gt;When people talk about evidence of the ancients brewing or chewing willow and similar plants, they often invoke the Ebers papyrus, Hippocrates, Celsus, Pliny the Elder, and Pedanius Dioscorides.3&lt;/p&gt;
    &lt;p&gt;The Ebers papyrus is an ancient Egyptian medical scroll from about 1550 BC, though it may have been copied from earlier texts. Translated by German Egyptologist Georg Ebers in 1875, the papyrus has 110 pages, is 20 meters long, and includes 700 remedies for various afflictions. As a piece of history, itâs fantastic. And some of the remedies are still practiced today: the treatment for Guinea-worm disease was, and still is, to wrap the emerging end of the worm around a stick and slowly pull it out.4&lt;/p&gt;
    &lt;p&gt;When I searched through a translation of the papyrus, however, I saw no evidence of willow bark used similarly to aspirin. I did find a treatment for an âear-that-discharges-foul-smelling-matterâ that used âberry-of-the-willowâ and a remedy to âput the Heart into proper working order and make it take up nourishmentâ that used âWillow-tree, one-eighth part, added as a stiffening.â&lt;/p&gt;
    &lt;p&gt;There was also a remedy to make the âmetâ supple (nerves or possibly blood vessels, Egyptologists appear uncertain) that used âsplinters-of-the-willow-tree,â although this particular remedy also required âhogâs dungâ and âmyrrhâ among 34 other ingredients. Still, there was nothing about using willow bark specifically concerning pain, inflammation, or fever.&lt;/p&gt;
    &lt;p&gt;In his 1992 book Murder, Magic, and Medicine, author John Mann wrote that the Ebers papyrus contains the following remedy: âWhen you examine a man with an irregular wound â¦ and that wound is inflamed â¦ [there is] a concentration of heat; the lips of that wound are reddened and that man is hot in consequence â¦ then you must make cooling substances for him to draw the heat out â¦ [from the] leaves of the willow,â but Iâve been unable to find this in any translation of the papyrus, and Mann doesnât reference the translation he claims to be using.&lt;/p&gt;
    &lt;p&gt;Uncertainty about the role of willow bark in treating inflammation remains as we move to Hippocrates, the ancient Greek physician and philosopher often regarded as the father of (clinical) medicine.5 Pharmacology lecturer Philippa Martyr suggests the works ascribed to Hippocrates only reference willow once, specifically in the context of burning willow leaves to make smoke for fumigating the uterus to get rid of a miscarried pregnancy. Indeed, a French translation of Hippocratesâs complete works confirms this. I was, however, unable to find any reference to willow in other translations. It is also said that Hippocrates recommended chewing willow bark to relieve fever and pain, but this, too, lacked evidence.&lt;/p&gt;
    &lt;p&gt;Other ancient sources are similarly unclear. The Roman encyclopedist Celsus, who wrote De Medicina in the first century, suggested willow leaves boiled in vinegar could be used to treat ulcerations of the anus and prolapse of the anus and uterus (Iâm not sure whether that would work, and it certainly isnât a common use of aspirin today).&lt;/p&gt;
    &lt;p&gt;Pliny the Elder, a first-century Roman author and natural philosopher, expounds the uses of poplar and willow trees in his encyclopedia Natural History. For poplar trees, he suggests, âA potion prepared from the bark is good for sciatica,â and âThe leaves, boiled in vinegar, are applied topically for gout.â And for willow: âThe leaves, too, boiled and beaten up with wax, are employed as a liniment for â¦Â gout.â This treatment is echoed by Pedanius Dioscorides, a Greek physician in the Roman army, also writing in the first century, who describes a similar treatment in his pharmacopeia, De materia medica. This is the earliest reference I have found to using salicin-containing plants as weâd potentially use aspirin today.&lt;/p&gt;
    &lt;p&gt;So ultimately, while we have a smattering of evidence that some version of a poplar bark potion may have been used for sciatica and that poplar and willow leaves may have been used for gout, we arrive at our second problem with the claim that willow bark and similar plants are the ancient equivalent of aspirin â that of effectiveness.&lt;/p&gt;
    &lt;p&gt;The amount of salicin in plants, even willow bark, is negligible compared to the aspirin dosages that we deem effective today. When researchers gave people willow bark extract corresponding to 240 mg of salicin, then looked at how much salicylic acid was present in their blood over time, it was the equivalent of taking 87 mg of aspirin (300 mg to 600 mg is recommended per dose, with up to 3600 mg allowed per day). Notably, 240 mg of salicin is the recommended daily dose specified by the European Scientific Cooperative on Phytotherapy.&lt;/p&gt;
    &lt;p&gt;But 240 mg of salicin today comes from concentrated and standardized willow bark extracts, not raw bark or leaves. The actual salicin concentration in willow bark is wildly variable, ranging between 0.04 percent and 12.06 percent across different species, according to one study. Salicin concentrations also vary across plants seasonally and based on a treeâs age. Only a fraction of the salicin would remain in tea or chewed bark.&lt;/p&gt;
    &lt;p&gt;If, for example, each cup of tea provided 240 mg salicin (possible with a good steeping and a high salicin content in the bark), then one would need to drink 41 cups of tea to get a full, therapeutic aspirin dose of 3600 mg. This is about 10 liters or two-and-a-half gallons.&lt;/p&gt;
    &lt;p&gt;Willow bark tea is also notoriously bitter, likely due to the high concentration of tannins, which can cause an upset stomach and nausea. Even if you could push through the bitterness, itâs unlikely youâd be able to stomach the bucketfuls of tea required to get enough salicin from willow bark (or similar plants) to ease your discomfort.&lt;/p&gt;
    &lt;p&gt;Thatâs not to say willow bark and similar plants couldnât be effective in reducing pain, inflammation, and fever when steeped or chewed, however. Unlike aspirin, willow bark contains other compounds â flavonoids and polyphenols â that may contribute to alleviating such symptoms. However, few (if any) human studies have been conducted looking specifically at simply brewing or chewing these plants. While some research has been done on the efficacy of willow bark extract in the treatment of pain and inflammation, the extract is much more concentrated than in chewed bark, and results have varied.&lt;/p&gt;
    &lt;p&gt;Philippa Martyr adds an additional caveat when she notes:&lt;/p&gt;
    &lt;quote&gt;If willow bark and leaves were handy and potent painkillers, we would have used them almost to extinction by now.&lt;/quote&gt;
    &lt;p&gt;Overall, given patchy evidence and dubious efficacy, I am skeptical that the history of aspirin began in antiquity. The mythology of aspirinâs ancient history is, most likely, a coincidence: itâs easy to believe that because willow bark contains salicin, and it was possibly used for some of the same things as aspirin, and it was possibly effective, it must work, and therefore willow bark tea was ancient aspirin. It makes for a plausible story with historical continuity, but I believe it remains just that â a story.&lt;/p&gt;
    &lt;p&gt;For what I believe to be the most credible origins of aspirin and other NSAIDs, we must advance to 18th-century England.&lt;/p&gt;
    &lt;head rend="h2"&gt;Discovery of Aspirin: 1763 to 1877&lt;/head&gt;
    &lt;p&gt;The Reverend Edward Stone appears to have given the first published account of using willow bark extract to treat patients in Chipping Norton, England, in 1763. The patients were suffering from malarial fever (ague),Â which was still endemic to England at the time. He writes:&lt;/p&gt;
    &lt;quote&gt;There is a bark of an Englifh tree, which I have found by experience to be a powerful aftringent, and very efficacious in curing aguifh [agues] and intermitting diforders.&lt;/quote&gt;
    &lt;p&gt;Like many of his predecessors, Reverend Stone believed that the remedy to a malady could be found close to the cause. That is, if people were becoming sick in a certain place, there should be a plant or other remedy nearby.6 As willow trees grew in abundance in âmoist and wet soil where agues chiefly abound,â and because it was as bitter as âPeruvian barkâ (Chichona tree bark, which contains quinine, a traditional remedy for malaria), Reverend Stone thought he could use the dried, powdered bark to treat fevers.7&lt;/p&gt;
    &lt;p&gt;Drying the bark increases its potency, which gets around the issues of having to drink bucketfuls of tea â similar to using willow bark extract today. For three months, Stone dried a pound of bark next to a bakerâs oven before pulverizing it into a powder. He started small, giving his first patient âtwenty grains of powderâ in âwater, tea, small beer and such like,â but quickly increased the dose after noticing no side effects. He treated fifty people over five years, all of whom he said were either cured or helped by the treatment.&lt;/p&gt;
    &lt;p&gt;Notably, Stone had investigated whether his treatment had precedent, but came up empty-handed:&lt;/p&gt;
    &lt;quote&gt;My curiofity prompted me to look into the difpenfatories and books of botany, and examine what they faid concerning it; but there it exifted only by name. I could not find, that it hath, or ever had, any place in pharmacy, or any fuch qualities, as I fufpected afcribed to it by the botanifts.&lt;/quote&gt;
    &lt;p&gt;Stoneâs observation of the novelty of his treatment is corroborated by the medicinal herbalist Anne Stobart, who looked through 6,500 17th-century medicinal recipes for 40 plants with longstanding use in the UK, determining that willow had six or fewer mentions.8 It seems fair to conclude that, at least in the UK in the 17th and 18th centuries, willow was not a well-known treatment for pain, fever, or inflammation. Stone documented his use of it, but it was by no means a widespread curative.&lt;/p&gt;
    &lt;p&gt;Around 1824, about 50 years after Stoneâs investigation of willow bark powder, Italian pharmacist Bartolomeo Rigatelli extracted a âvery bitter antipyreticâ called âsalineâ from a plant native to Europe. The âsalineâ was subsequently renamed âsalicinâ by Francesco Fontana, who also extracted it from white willow and used it as a substitute for quinine sulfate. Fontana reported it was effective against fevers of all types, even âquartan feversâ (one of the four types of malaria). And while Fontana did not reference Rigatelli, he did reference someone named âStone.â While thereâs no way to be certain, it seems likely this was Reverend Stone.&lt;/p&gt;
    &lt;p&gt;The progression from salicin to aspirin would take over 70 years. In 1829, French chemist Henri Leroux refined the process used by Rigatelli, Fontana, and others and managed to extract pure salicin. His method was further refined in 1838 when Raffaele PirÃ¬a, an Italian chemist, produced salicylic acid from salicin, after determining its molecular formula. By 1859, the German chemist Hermann Kolbe used the discovery of salicinâs molecular structure to synthesize salicylic acid directly. Kolbeâs process was refined by his assistant, Rudolf Wilhelm Schmitt, with the resulting process known as the Kolbe-Schmitt Reaction.9&lt;/p&gt;
    &lt;p&gt;In the 1870s, salicylic acid took off as a treatment, and in 1874, Friedrich von Heyden, another student of Kolbe, opened a factory in Radebeul (near Dresden) to produce it, reportedly selling it ten times more cheaply than its naturally derived counterpart. This spurred research into its clinical applications. In 1876, a Scottish physician, Thomas MacLagan, and a German physician, Franz Stricker, both published studies showing that salicin and salicylic acid were effective in treating rheumatic fever, particularly in reducing fever and pain. A year later, in 1877, a French physician, Germain SÃ©e, showed that chronic rheumatism and gout could also be treated with salicylic acid.&lt;/p&gt;
    &lt;p&gt;Salicylic acid had proven effective in reducing pain, fever, and inflammation, and it could be manufactured cheaply and in large quantities. However, it had several serious side effects, such as nausea, gastric irritation, and tinnitus. If a drug manufacturer were able to create a better alternative, patients and doctors would be grateful, and it would likely be extremely successful.&lt;/p&gt;
    &lt;p&gt;With their synthesis of aspirin, chemists at Bayer did exactly that.&lt;/p&gt;
    &lt;head rend="h2"&gt;Aspirin Synthesis Controversy: 1897 to 1949&lt;/head&gt;
    &lt;p&gt;While the events of the 18th and 19th centuries relate to a verifiable history of aspirin, the next period becomes muddied once again. However, here it does not relate to lost or convoluted records, but prejudice.&lt;/p&gt;
    &lt;p&gt;We know the following to be absolutely true: Felix Hoffman, a chemist working for Bayer, synthesized pure acetylsalicylic acid (later known as aspirin) from salicylic acid in 1897. His name is on the U.S. patent for aspirin, and his lab notebook details his synthesis of acetylsalicylic acid. Hoffmanâs method was relatively simple, reliable, and efficient. Hoffman heated a combination of salicylic acid and acetic anhydride (an acetylating agent) for two hours, which resulted in a clear liquid. Upon cooling, this liquid yielded a mass of acetylsalicylic acid crystals, which he separated out and recrystallized, using dry chloroform to remove any remaining impurities.&lt;/p&gt;
    &lt;p&gt;The controversy, then, refers both to why Hoffman synthesized aspirin and what happened afterward.&lt;/p&gt;
    &lt;p&gt;On the one hand, we have the official story from Bayer, which claims that Hoffman created aspirin to help his father, who was suffering from severe rheumatism. Hoffman had treated his father with salicylic acid, but his father had severe side effects, including nausea, gastric irritation, and tinnitus. Hoffman, therefore, set out to produce a purer derivative of salicylic acid that would be as effective. This version of events was first reported in a footnote in a 1934 book on the history of chemical engineering.10&lt;/p&gt;
    &lt;p&gt;On the other hand, we have a story from Arthur EichengrÃ¼n. EichengrÃ¼n was a Jewish chemist who also worked at Bayer. In 1949, he wrote a journal article describing why aspirin was synthesized, and what happened after.11&lt;/p&gt;
    &lt;p&gt;In this article, EichengrÃ¼n stated that he was appointed, in 1895, to establish and manage a pharmaceutical laboratory at Bayer. He also claimed that it was he who instructed Hoffman to synthesize acetylsalicylic acid in 1898 and that Hoffman had done so without knowing why. Notably, EichengrÃ¼n also claimed that several Bayer chemists made various derivatives of salicylic acid, each of which was tested further.&lt;/p&gt;
    &lt;p&gt;Drugs developed in EichengrÃ¼nâs laboratory were tested at Bayerâs pharmacological laboratory, led by Heinrich Dreser.12 When the salicylic acid derivatives were tested, it was clear that acetylsalicylic acid was the most favorable, producing only minor deleterious effects on a frog heart. However, in a Bayer management meeting to discuss whether acetylsalicylic acid should go forward to clinical trials, Dreser asserted that it was a direct cardiac poison and opposed it progressing to trials. Dreser had the right to veto any drug going to clinical trials, so this is where the story of aspirin could have ended.&lt;/p&gt;
    &lt;p&gt;However, in this article, EichengrÃ¼n stated he couldnât accept the decision to stop work on acetylsalicylic acid, and, against his contract, continued to conduct tests privately. He tested the drug on himself, then enlisted the help of doctors to test 100 grams of homemade acetylsalicylic acid.13 None of the doctors reported side effects in their patients, and they asked for larger quantities for more detailed testing. From these tests, it was clear that acetylsalicylic acid retained the beneficial clinical effects of salicylic acid, including potent pain relief, but produced fewer side effects.&lt;/p&gt;
    &lt;p&gt;A report was sent to Bayer detailing the results of these tests, upon which Dreser commented: âthe product has no value.â Nonetheless, Bayer decided to conduct more tests, the results of which confirmed that acetylsalicylic acid worked. EichengrÃ¼n stated he suggested the name âaspirin.â14&lt;/p&gt;
    &lt;p&gt;Despite his condemnation of aspirin, Dreser was commissioned to write the paper on Bayerâs synthesis and testing of aspirin, which was published in 1899. His article focused on the pharmacology and animal studies, omitted details of tests in humans, and contains no mention of either Hoffman or EichengrÃ¼n. EichengrÃ¼n acknowledged this was standard practice at the time: only the company that made the drug was reported, not the inventors.15&lt;/p&gt;
    &lt;p&gt;While EichengrÃ¼nâs article makes it very clear that he and Hoffman should be credited with the invention of aspirin and not Dreser, he waited until 1949 to publish his account. The account with Hoffman as the sole inventor, however, was published in 1934. So why did EichengrÃ¼n wait?&lt;/p&gt;
    &lt;p&gt;In 1999, Walter Sneader published a reappraisal of the discovery of aspirin, in which he looked at EichengrÃ¼nâs 1949 article and other relevant documents. In it, Sneader argued that EichengrÃ¼nâs ethnicity forced him to remain quiet. EichengrÃ¼n was a Jew living in 1930s and 1940s Germany. The Nazis were making life successively more difficult for Jews, even for successful factory owners like EichengrÃ¼n. While EichengrÃ¼n had hired a gentile associate to avoid the loss of state contracts, his company was forcibly transferred to a non-Jew in 1938. And although 76 and married to an âaryan,â he was interned at Theresienstadt in 1944 for 14 months.Â&lt;/p&gt;
    &lt;p&gt;In his 1949 article, EichengrÃ¼n recalled that he saw a display for aspirin in the Hall of Honor of the chemical department of the German Museum in Munich in 1941, with the inscription: "Aspirin; Inventors Dreser and Hoffman." Also at the entrance to the museum was a sign prohibiting Non-Aryans from entering. To this, EichengrÃ¼n simply stated: âSapienti sat!â (translated as: âEnough for the wise!â)Â&lt;/p&gt;
    &lt;p&gt;Given this context, itâs not difficult to imagine why EichengrÃ¼n may have been reluctant to claim credit, even if he were aware of the 1934 book. Aspirin was successful and important: if a Jew were to have claimed credit for its invention, when at every level Jews were being forced out of public life and their accomplishments erased, such a person would have undoubtedly provoked a hostile response.&lt;/p&gt;
    &lt;p&gt;Additionally, EichengrÃ¼nâs article is only the account of one man, written at the very end of his life (he died the same month his article was published), and could be biased, deceptive, or otherwise incorrect. In a press release responding to Sneaderâs article, Bayer stated that EichengrÃ¼nâs claims cannot be proven. Bayer also claimed that Hoffman was EichengrÃ¼nâs equal hierarchically, so EichengrÃ¼n couldnât have ordered Hoffman to create acetylsalicylic acid. The press release also questioned why EichengrÃ¼n didnât object at the time of the patent being awarded solely to Hoffman, and seemed troubled that EichengrÃ¼n waited 50 years to claim his role in the development of aspirin.&lt;/p&gt;
    &lt;p&gt;Against this, we have the knowledge that Nazi censorship, anti-Jewish legislation and sentiment, and propaganda (including in textbooks) could have removed EichengrÃ¼n from the history of aspirin. Even this year, we have examples of erasure of accomplishments due to peopleâs ethnicity, gender, or both.&lt;/p&gt;
    &lt;p&gt;Ultimately, this controversy remains unresolved. While it is entirely possible that evidence for EichengrÃ¼nâs contributions at Bayer were purged due to antisemitism, we cannot be certain.&lt;/p&gt;
    &lt;head rend="h2"&gt;NSAID Expansion: 1949 to present&lt;/head&gt;
    &lt;p&gt;While it is seemingly impossible to find figures for aspirin consumption or production over time, it is clear that it took off after Bayer began marketing the drug in 1899. EichengrÃ¼n noted that it wasnât just that aspirin was effective with limited side effects, but also that it came packaged as tablets rather than as a powder in a paper bag. Tablets were a novelty at the end of the 19th century. Additionally, while the trade name âaspirinâ was protected from imitation, the process for making it was not. This meant the availability of generic acetylsalicylic acid sold under different names16 soon drove down prices.&lt;/p&gt;
    &lt;p&gt;Aspirinâs popularity diminished once paracetamol and ibuprofen became available in the late 1950s and early 1960s, as the latter drugs had even fewer gastrointestinal side effects. However, its use rose again after the ISIS-2 trial, published in 1988. This trial tested whether low-dose aspirin and streptokinase, separately or together, were effective at preventing mortality after suspected acute myocardial infarction (heart attack). The results were so unambiguously positive for aspirin (and streptokinase, although aspirin was far cheaper) that aspirin use sharply increased worldwide in acute coronary care. The use of aspirin amongst people in hospitals with acute myocardial infarction, for example, increased in the UK from 10 percent in 1987 to over 90 percent in 1989.&lt;/p&gt;
    &lt;p&gt;Further studies looked at whether aspirin was effective at preventing cardiovascular disease (including heart attacks and strokes), and led to recommendations promoting low-dose aspirin use. A study using 2017 interview data suggested that 23.4 percent of adults 40 years or older in the U.S. (estimated to be about 29 million people) took daily aspirin to prevent cardiovascular disease. Although there are disputes around who should take aspirin for cardiovascular disease prevention, it nonetheless remains extremely popular.&lt;/p&gt;
    &lt;p&gt;The origins of other NSAIDs are not nearly as dramatic as aspirin. Starting in the 1960s, multiple NSAIDs were developed and patented: indomethacin (1961), ibuprofen (1962),17 mefenamic acid (1964), naproxen (1967), diclofenac (1978), celecoxib (1993), etoricoxib (1996), among others.18&lt;/p&gt;
    &lt;p&gt;Despite the numerous brands of NSAIDs, their mechanism of action remained unknown until 1971, when John Vane discovered the mechanism of action of aspirin, and, by extension, other NSAIDs. These molecules, he found, work by blocking cyclooxygenase (COX) enzymes. COX enzymes produce compounds19 that cause pain, inflammation, and fever: if you block them, fewer of those compounds are produced.20 This discovery led to a rapid expansion in the number of available NSAIDs and a Nobel Prize for Vane in 1982.&lt;/p&gt;
    &lt;p&gt;While future NSAID development is likely to focus on maintaining or improving clinical effectiveness while reducing side effects, there may be novel roles for NSAIDs to fulfil, such as occurred in the 1980s when aspirin was promoted as a treatment and preventative for cardiovascular disease. NSAIDs may likewise play some as yet undetermined role in neurodegenerative diseases, diabetes, and cancer disease therapy.&lt;/p&gt;
    &lt;head rend="h2"&gt;A Search in the Cabinet&lt;/head&gt;
    &lt;p&gt;When setting out to write the history of NSAIDs, I thought the project would be reasonably straightforward; people used to drink willow bark tea, and someone clever turned that into aspirin. What I found instead was a labyrinth of oft-repeated myths, partial histories, and conjecture. While piecing the story together, I couldnât help but feel that scientists could do a better job of preserving their work and methods for posterity.Â&lt;/p&gt;
    &lt;p&gt;At its heart, the issue is one of knowing when information is fact, conjecture, or mythology. This is as relevant today as it has ever been, for while the internet has allowed unprecedented access to information, it is as unclear as ever whether that information represents truth. With the rise of artificial intelligence, as well as malicious agents intent on creating and propagating misinformation, determining what is factual will become increasingly more difficult.Â&lt;/p&gt;
    &lt;p&gt;Knowing who synthesized aspirin for the first time and why may seem relatively trivial when compared with questions of more immediate relevance and consequence, such as whether facemasks help prevent the spread of COVID-19. But as someone who has attempted to answer both questions, the difficulties in establishing the facts are similar. We need to know who did what, how, and why.&lt;/p&gt;
    &lt;p&gt;Newton said that scientists stand on the shoulders of giants. However, scientists can only stand above the clouds when there is an unbroken chain of giants beneath them. As soon as one giant is missing, as soon as one link in the unbroken chain of scientific evidence breaks, the whole thing comes tumbling down.&lt;/p&gt;
    &lt;p&gt;I have one piece of advice for scientists and science communicators: your references matter. They are the evidence that we even have giants supporting us. All scientific claims should be referenced. It isnât sufficient for you to state that Hippocrates prescribed willow bark tea to treat inflammatory pain. You need to show why you think that is true.&lt;/p&gt;
    &lt;p&gt;The risk of not providing reputable sources is not just that myths get propagated, itâs that lies get propagated. After all, it likely doesnât really matter in 2025 whether Hippocrates made people drink 41 cups of willow bark tea a day, or if people write historical fiction where characters rush off to find willow bark to quell a fever. But it does matter whether people believe, for instance, that vaccination is the best way to prevent measles.&lt;/p&gt;
    &lt;p&gt;I also have one request for people who read scientific literature (of any description): demand better. People may claim to be standing on the shoulders of giants, but are actually shouting from two feet off the ground on a rusty, broken bicycle. Do authors present quality evidence to support their claims, or does it fall apart when you dig a little deeper?Â&lt;/p&gt;
    &lt;p&gt;Before researching its origins, I believed that willow bark tea was ancient aspirin. Now, I believe itâs simply willow bark tea. It may behave similarly to aspirin, but not because it is aspirin.&lt;/p&gt;
    &lt;p&gt;However, by using direct evidence to piece together the rest of the story, Iâve come to trust the following:Â Reverend Stone found a successful application of powdered willow bark sometime before 1763. He didnât do this because of any historical precedent, but simply because he thought it might work. Fontana then extracted and named salicin, likely referencing Stone in his report. This led to the use and manufacture of salicylic acid, and then to Arthur EichengrÃ¼n, who likely asked Felix Hoffman to synthesize acetylsalicylic acid in 1897.&lt;/p&gt;
    &lt;p&gt;Ultimately, while I donât think willow bark tea is ancient aspirin, I do think aspirin can still trace its origins back to the willow bark infusions that Reverend Stone used to treat the people of Chipping Norton over 250 years ago. So fancy that: aspirin was ultimately derived from willow bark after all, maybe just not as long ago as the histories would have us believe.&lt;/p&gt;
    &lt;p&gt;{{divider}}&lt;/p&gt;
    &lt;p&gt;Watch our behind-the-scenes interview with the author. Available now on YouTube.&lt;/p&gt;
    &lt;p&gt;Sean Harrison is an expert in epidemiology and evidence synthesis. He has spent the last decade answering research questions by finding, analysing, and synthesizing all available evidence to answer those questions. During the COVID-19 pandemic, he worked at the UK Health Security Agency, providing evidence reviews to inform COVID-19 policy. He is currently a research fellow at the University of Exeter and blogs at seanharrison.blog. Find him on BlueSky at @sean-h.bsky.social.&lt;/p&gt;
    &lt;p&gt;Cite: Harrison, S. âThe Uncertain Origins of Aspirin.â Asimov Press (2025). https://doi.org/10.62211/58qw-41hg&lt;/p&gt;
    &lt;p&gt;Header image by Ella Watkins-Dulaney.&lt;/p&gt;
    &lt;p&gt;This article was published on 14 July 2025.&lt;/p&gt;
    &lt;p&gt;{{divider}}&lt;/p&gt;
    &lt;head rend="h2"&gt;Footnotes&lt;/head&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;If you have a headache, a sprained ankle, a temperature, or some other minor complaint, thereâs a good chance that if you reach for any drug, itâll either be an NSAID, such as aspirin or ibuprofen, or paracetamol (a different class of drug).&lt;/item&gt;
      &lt;item&gt;Accurate global statistics are difficult (possibly impossible) to find for the total number of prescribed NSAIDs, but in 2022 in the U.S., ibuprofen was the 33rd most prescribed medication (17.5 million prescriptions), followed by aspirin at 36th (17.0 million), diclofenac at 51st (12.5 million), naproxen at 89th (7.4 million), celecoxib at 93rd (7.0 million), and indomethacin at 256th (1.1 million). Mefenamic acid and indomethacin werenât in the top 300 most prescribed medications.&lt;/item&gt;
      &lt;item&gt;There are other, more infrequent references to ancient people using willow to reduce pain, inflammation, or fever found among the Chinese and the indigenous peoples of America and South Africa. Additionally, although it is claimed that an Ancient Assyrian clay tablet (3,500 to 2,000 BC) described the use of willow leaves for pain and inflammation, I havenât found original evidence for this, nor the current location of the tablet, nor its translation.&lt;/item&gt;
      &lt;item&gt;The symbol of medicine as a staff with a serpent coiled around it â the staff of Asclepius â may have been derived from this treatment for guinea worm. However, like the rest of the historical details in this article, we canât be sure. We do know, however, that the âcaduceus,â a rod with two snakes coiled around it, often with wings at the top, originally had nothing to do with healing or healthcare. Various healthcare-aligned groups, as well as the U.S. Public Health Service, have adopted it nevertheless, possibly confusing the two symbols. In fairness, the two symbols look similar, and a winged rod with two snakes does look better than a wingless rod with only a single snake.&lt;/item&gt;
      &lt;item&gt;The Hippocratic oath was named for Hippocrates, although it was unlikely to have been written by Hippocrates, and doesnât start with âfirst, do no harm,â as many (including myself, until recently) believe. Whether any of the surviving works attributed to Hippocrates were actually written by him is debatable, given they are anonymous, written at different times by different hands, and have different ideas about the body and healing. Franz Zacharias Ermerins, a Dutch physician and editor, apparently identified at least 19 different authors of works attributed to Hippocrates.&lt;/item&gt;
      &lt;item&gt;This is, evidently, part of the Doctrine of Signatures. This is the belief that there must be some (divine) sign telling us which plants to use to cure which diseases. Often, it was the appearance of a plant that was the clue: eyebright flowers resemble eyes, so must be able to treat eye issues; liverwort resembles the shape and colour of the liver, so must be able to treat liver issues; lungwort resembles disease lungs, so must be able to treat lung issues. In this case, it was the location of willow trees: âthe general maxim, that many natural maladies carry their cures along with them, or that their remedies lie not far from their caufes, was fo very appofite to this particular cafe, that I could not help applying it; and that this might be the intention of Providence here, I muft own had fome little weight with me.â&lt;/item&gt;
      &lt;item&gt;Cinchona is almost certainly named for the Countess of ChinchÃ³n, a Spanish noblewoman married to the Viceroy of Peru, who developed fever and chills (likely malaria) in 1631. Jesuit priests made a remedy that included the bark of the Cinchona tree, which, presumably, previously had a different name. The remedy worked, and the tree was named Cinchona in her honor.&lt;/item&gt;
      &lt;item&gt;Other plants with six or fewer mentions were buttercup, foxglove, lesser celandine, and pennywort. Notably, foxgloves were the initial source of digoxin, used to treat various heart conditions, including heart failure. The origins of digoxin also involves medical history mythology: William Withering was an 18th century botanist and physician who, in 1785, first wrote about using foxgloves to treat dropsy (edema caused by heart failure, among other things). However, in 1928, the pharmaceutical company manufacturing digoxin invented âMother Huttonâ as part of a marketing campaign. âMother Huttonâ was an old herbalist from Shropshire, who originally discovered that foxglove tea helped dropsy, and who was paid by Withering for that information. Many people now believe the myth that âMother Huttonâ first used foxglove tea for dropsy, despite her being entirely fictional.&lt;/item&gt;
      &lt;item&gt;Charles Gerhardt was credited with the first synthesis of aspirin in 1852.Â He reportedly reacted sodium salicylate with acetyl chloride, creating acetylsalicylic acid. However, the final compound was unstable and impure, and the process to make it inconsistent and cumbersome, so Gerhardt reportedly did not investigate further. I was unable to verify this when translating the original evidence: it is both technical and in German, so Iâm leaving this as âreportedly.â Itâs one of the challenges of working with 19th century foreign-language technical journal articles â¦&lt;/item&gt;
      &lt;item&gt;Iâve been unable to access a copy.&lt;/item&gt;
      &lt;item&gt;I went to some length to find a copy of this article. It didnât exist online, but I found a physical copy for sale on eBay in Poland. Unfortunately, the seller wouldnât initially ship to me in the UK, so I used Google Translate to ask them (in German) to allow shipping to the UK, which they very kindly did. Subsequently, DHL managed to lose the parcel, which is a shame as it was one of the few extant copies of this article in existence. However, the British Library is, thankfully, magnificent: they had a copy, and someone very generously managed to dig it out of the archives and photograph it for me. I transcribed the German text, translated it with Google translate, and put both the original German transcription and the English translation on the Internet Archive for posterity. Weeks later, DHL found the article and delivered it, so I scanned the original and uploaded it to the Internet Archive.&lt;/item&gt;
      &lt;item&gt;EichengrÃ¼n did not go into specifics of these tests in his article. Dreserâs introductory paper on aspirin mentions a number of different tests, but it is unclear when they were conducted, and by whom. Nonetheless, Dreser mentions tests using acids and alkalis, taking aspirin himself and then testing his urine (concluding the aspirin had turned into salicylic acid), and tests in rabbits (including body temperature), frogs (including blood vessel constriction, isolated heart function, and lethal dosage), and fish (including lethal dosage). Other tests may have been conducted that were not reported in this paper.&lt;/item&gt;
      &lt;item&gt;This, quite obviously, could have gone horrendously wrong: thankfully, clinical testing of new drugs has far stronger safeguards these days.&lt;/item&gt;
      &lt;item&gt;âAspirinâ is derived from âa-â for acetyl, â-spir-â from âSpirsaÃ¼reâ (spiric acid, an older name for salicylic acid, derived from the Latin for meadowsweet: Spiraea ulmaria), and â-inâ, a common chemical suffix.&lt;/item&gt;
      &lt;item&gt;EichengrÃ¼n also stated that they couldnât patent aspirin in Germany as only the preparation process, not the end result, could be patented. The process for making aspirin, however, also couldnât be patented because an earlier publication described how acetyl chloride had been mixed with salicylic acid under pressure in a gun barrel. Although the end result was not described, this was evidently sufficient grounds to not award a patent for the process of making aspirin. As a result, and because Bayer would only financially compensate EichengrÃ¼n and Hoffman if a patent were granted for a new drug, neither benefited financially from creating aspirin.&lt;/item&gt;
      &lt;item&gt;For example, salicyl acetate and acidum acetylo-salicylicum: the latter I imagine being a challenge for anyone to pronounce quickly and easily upon first reading it.&lt;/item&gt;
      &lt;item&gt;The development of ibuprofen shares striking similarities to the development of aspirin. Ibuprofen was developed while searching for a derivative of aspirin that would be suitable for long-term use for rheumatoid arthritis with fewer side effects, much as aspirin was developed as an alternative to salicylic acid. The lead scientist, Dr Stewart Adams, was also happy to test the compounds on himself first (after toxicity tests), and was reportedly âexcited to be the first person to take a dose of ibuprofenâ, much as EichengrÃ¼n first tested aspirin on himself.&lt;/item&gt;
      &lt;item&gt;Iâd be lying if I said I knew all those drug names before writing this article.&lt;/item&gt;
      &lt;item&gt;Thromboxanes, which play a role in platelet adhesion; prostaglandins, which cause vasodilation (expansion of blood vessels), increase body temperature by interacting with the hypothalamus, and reduce pain; and prostacyclins, which inhibit platelet activation and cause vasodilation.&lt;/item&gt;
      &lt;item&gt;There are two cyclooxygenase (COX) enzymes, which are both affected to a greater or lesser extent by NSAIDs. The first of which (COX-1) is found all over the body (in particular the gastrointestinal lining and kidneys), and the second (COX-2) is only around during an inflammatory response. As they affect these two enzymes differently, NSAIDs have different levels of effectiveness and side effect profiles.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Always free. No ads. Richly storied.&lt;/p&gt;
    &lt;p&gt;Always free. No ads. Richly storied.&lt;/p&gt;
    &lt;p&gt;Always free. No ads. Richly storied.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=46015860</guid><pubDate>Sat, 22 Nov 2025 16:23:06 +0000</pubDate></item><item><title>The privacy nightmare of browser fingerprinting</title><link>https://kevinboone.me/fingerprinting.html</link><description>&lt;doc fingerprint="d73014573db7254d"&gt;
  &lt;main&gt;
    &lt;head rend="h1"&gt;The privacy nightmare of browser fingerprinting&lt;/head&gt;
    &lt;p&gt;I imagine that most people who take an interest in de-Googling are concerned about privacy. Privacy on the Internet is a somewhat nebulous concept, but one aspect of privacy is surely the prevention of your web browsing behaviour being propagated from one organization to another. I don’t want my medical insurers to know, for example, that I’ve been researching coronary artery disease. And even though my personal safety and liberty probably aren’t at stake, I don’t want to give any support to the global advertising behemoth, by allowing advertisers access to better information about me.&lt;/p&gt;
    &lt;p&gt;Unfortunately, while distancing yourself from Google and its services might be a necessary first step in protecting your privacy, it’s far from the last. There’s more to do, and it’s getting harder to do it, because of browser fingerprinting.&lt;/p&gt;
    &lt;head rend="h2"&gt;How we got here&lt;/head&gt;
    &lt;p&gt;Until about five years ago, our main concern surrounding browser privacy was probably the use of third-party tracking cookies. The original intent behind cookies was that they would allow a web browser and a web server to engage in a conversation over a period of time. The HTTP protocol that web servers use is stateless; that is, each interaction between browser and server is expected to be complete in itself. Having the browser and the server exchange a cookie (which could just be a random number) in each interaction allowed the server to associate each browser with an ongoing conversation. This was, and is, a legitimate use of cookies, one that is necessary for almost all interactive web-based services. If the cookie is short-lived, and only applies to a single conversation with a single web server, it’s not a privacy concern.&lt;/p&gt;
    &lt;p&gt;Unfortunately, web browsers for a long time lacked the ability to distinguish between privacy-sparing and privacy-breaking uses of cookies. If many different websites issue pages that contain links to the same server – usually some kind of advertising service – then the browser would send cookies to that server, thinking it was being helpful. This behaviour effectively linked web-based services together, allowing them to share information about their users. The process is a bit more complicated than I’m making it out to be, but these third-party cookies were of such concern that, in Europe at least, legislation was enacted to force websites to disclose that they were using them.&lt;/p&gt;
    &lt;p&gt;Browsers eventually got better at figuring out which cookies were helpful and which harmful and, for the most part, we don’t need to be too concerned about ‘tracking cookies’ these days. Not only can browsers mitigate their risks, there’s a far more sinister one: browser fingerprinting.&lt;/p&gt;
    &lt;head rend="h2"&gt;Browser fingerprinting&lt;/head&gt;
    &lt;p&gt;Browser fingerprinting does not depend on cookies. It’s resistant, to some extent, to privacy measures like VPNs. Worst of all, steps that we might take to mitigate the risk of fingerprinting can actually worsen the risk. It’s a privacy nightmare, and it’s getting worse.&lt;/p&gt;
    &lt;p&gt;Fingerprinting works by having the web server extract certain discrete elements of information from the browser, and combining those elements into a numerical identifier. Some of the information supplied by the browser is fundamental and necessary and, although a browser could fake it, such a measure is likely to break the website.&lt;/p&gt;
    &lt;p&gt;For example, a fingerprinting system knows, just from information that my browser always supplies (and probably has to), that I’m using version 144 of the Firefox browser, on Linux; my preferred language is English, and my time-zone is GMT. That, by itself, isn’t enough information to identify me uniquely, but it’s a step towards doing so.&lt;/p&gt;
    &lt;p&gt;To get more information, the fingerprinter needs to use more sophisticated methods which the browser could, in theory, block. For example, if the browser supports JavaScript – and they nearly all do – then the fingerprinter can figure out what fonts I have installed, what browser extensions I use, perhaps even what my hardware is. Worst of all, perhaps, it can extract a canvas fingerprint. Canvas fingerprinting works by having the browser run code that draws text (perhaps invisibly), and then retrieving the individual pixel data that it drew. This pixel data will differ subtly from one system to another, even drawing the same text, because of subtle differences in the graphics hardware and the operating system.&lt;/p&gt;
    &lt;p&gt;It appears that only about one browser in every thousand share the same canvas fingerprint. Again, this alone isn’t enough to identify me, but it’s another significant data point.&lt;/p&gt;
    &lt;p&gt;Fingerprinting can make use of even what appears to be trivial information. If, for example, I resize my browser window, the browser will probably make the next window the same size. It will probably remember my preference from one day to the next. If the fingerprinter knows my preferred browser window size is, say, 1287x892 pixels, that probably narrows down the search for my identify by a factor of a thousand or more.&lt;/p&gt;
    &lt;head rend="h2"&gt;Why crude methods to defeat fingerprinting don’t work&lt;/head&gt;
    &lt;p&gt;You might think that a simple way to prevent, or at least hamper, fingerprinting would be simply to disable JavaScript support in the browser. While this does defeat measures like canvas fingerprinting, it generates a significant data point of its own: the fact that JavaScript is disabled. Since almost every web browser in the world now supports JavaScript, turning it off as a measure to protect privacy is like going to the shopping mall wearing a ski mask. Sure, it hides your identify; but nobody’s going to want to serve you in stores. And disabling JavaScript will break many websites, including some pages on this one, because I use it to render math equations.&lt;/p&gt;
    &lt;p&gt;Less dramatic approaches to fingerprinting resistance have their own problems. For example, a debate has long raged about whether a browser should actually identify itself at all. The fact that I’m running Firefox on Linux probably puts me in a small, easily identified group. Perhaps my browser should instead tell the server I’m running Chrome on Windows? That’s a much larger group, after all.&lt;/p&gt;
    &lt;p&gt;The problem is that the fingerprinters can guess the browser and platform with pretty good accuracy using other methods, whether the browser reports this information or not. If the browser says something different to what the fingerprinter infers, we’re back in ski-mask territory.&lt;/p&gt;
    &lt;p&gt;What about more subtle methods to spoof the client’s behaviour? Browsers (or plug-ins) can modify the canvas drawing procedures, for example, to spoof the results of canvas fingerprinting. Unfortunately, these methods leave traces of their own, if they aren’t applied subtly. What’s more, if they’re applied rigorously enough to be effective, they can break websites that rely on them for normal operation.&lt;/p&gt;
    &lt;p&gt;All in all, browser fingerprinting is very hard to defeat, and organizations that want to track us have gotten disturbingly good at it.&lt;/p&gt;
    &lt;head rend="h2"&gt;Is there any good news?&lt;/head&gt;
    &lt;p&gt;Not much, frankly.&lt;/p&gt;
    &lt;p&gt;Before sinking into despondency, it’s worth bearing in mind that websites that attempt to demonstrate the efficacy of fingerprinting, like amiunique and fingerprint.com do not reflect how fingerprinting works in the real world. They’re operating on comparatively small sets of data and, for the most part, they’re not tracking users over days. Real-world tracking is much harder than these sites make it out to be. That’s not to say it’s too hard but it is, at best, a statistical approach, rather than an exact one.&lt;/p&gt;
    &lt;p&gt;In addition ‘uniqueness’, in itself, is not a strong measure of traceability. That my browser fingerprint is unique at some point in time is irrelevant if my fingerprint will be different tomorrow, whether it remains unique within the fingerprinter’s database or not.&lt;/p&gt;
    &lt;p&gt;Of course, these facts also mean that it’s difficult to assess the effectiveness of our countermeasures: our assessment can only be approximate, because we don’t actually know what real fingerprinters are doing.&lt;/p&gt;
    &lt;p&gt;Another small piece of good news is that browser developers are starting to realize how much of a hazard fingerprinting is, and to integrate more robust countermeasures. We don’t necessarily need to resort to plug-ins and extensions, which are themselves detectable and become part of the fingerprint. At present, Brave and Mullvad seems to be doing the most to resist fingerprinting, albeit in different ways. Librewolf has the same fingerprint resistance as Firefox, but it is turned on by default. Probably anti-fingerprinting methods will improve over time but, of course, the fingerprinters will get better at what they do, too.&lt;/p&gt;
    &lt;head rend="h2"&gt;So what can we do?&lt;/head&gt;
    &lt;p&gt;First, and most obviously, if you care about avoiding tracking, you must prevent long-lived cookies hanging around in the browser, and you must use a VPN. Ideally the VPN should rotate its endpoint regularly.&lt;/p&gt;
    &lt;p&gt;The fact that you’re using a VPN, of course, is something that the fingerprinters will know, and it is does make you stand out. Sophisticated fingerprinters won’t be defeated by a VPN alone. But if you don’t use a VPN, the trackers don’t even need to fingerprint you: your IP number, combined with a few other bits of routine information, will identify you immediately, and with near-certainty.&lt;/p&gt;
    &lt;p&gt;Many browsers can be configured to remove cookies when they seem not to be in use; Librewolf does this by default, and Firefox and Chrome do it in ‘incognito’ mode. The downside, of course, is that long-lived cookies are often used to store authentication status so, if you delete them, you’ll find yourself having to log in every time you look at a site that requires authentication. To mitigate this annoyance, browsers generally allow particular sites to be excluded from their cookie-burning policies.&lt;/p&gt;
    &lt;p&gt;Next, you need to be as unremarkable as possible. Fingerprinting is about uniqueness, so you should use the most popular browser on the most popular operating system on the kind of hardware you can buy from PC World. If you’re running the latest Chrome on the latest Windows 11 on a two-year-old, bog-standard laptop, you’re going to be one of a very large group. Of course Chrome, being a Google product, has its own privacy concerns, so you might be better off using a Chromium-based browser with reduced Google influence, like Brave.&lt;/p&gt;
    &lt;p&gt;You should endeavour to keep your computer in as near its stock configuration as possible. Don’t install anything (like fonts) that are reportable by the browser. Don’t install any extensions, and don’t change any settings. Use the same ‘light’ theme as everybody else, and use the browser with a maximized window, and always the same size. And so on.&lt;/p&gt;
    &lt;p&gt;If possible, use a browser that has built-in fingerprint resistance, like Mullvad or Librewolf (or Firefox with these features turned on).&lt;/p&gt;
    &lt;p&gt;If you take all these precautions, you can probably reduce the probability that you can be tracked by you browser fingerprint, over days or weeks, from about 99% to about 50%.&lt;/p&gt;
    &lt;p&gt;50% is still too high, of course.&lt;/p&gt;
    &lt;head rend="h2"&gt;The downsides of resisting fingerprinting&lt;/head&gt;
    &lt;p&gt;If you enable fingerprinting resistance in Firefox, or use Librewolf, you’ll immediately encounter oddities. Most obviously, every time you open a new browser window, it will be the same size. Resizing the window may have odd results, as the browser will try to constrain certain screen elements to common size multiples. In addition, you won’t be able to change the theme.&lt;/p&gt;
    &lt;p&gt;You’ll probably find yourself facing more ‘CAPTCHA’ and similar identity challenges, because your browser will be unknown to the server. Websites don’t do this out of spite: hacking and fraud are rife on the Internet, and the operators of web-based services are rightly paranoid about client behaviour.&lt;/p&gt;
    &lt;p&gt;You’ll likely find that some websites just don’t work properly, in many small ways: wrong colours, misplaced text, that kind of thing. I’ve found these issues to be irritations rather than show-stoppers, but you might discover otherwise.&lt;/p&gt;
    &lt;head rend="h2"&gt;Is browser fingerprinting legal?&lt;/head&gt;
    &lt;p&gt;The short answer, I think, is that nobody knows, even within a specific jurisdiction. In the UK, the Information Commissioner’s Office takes a dim view of it, and it probably violates the spirit of the GDPR, if not the letter.&lt;/p&gt;
    &lt;p&gt;The GDPR is, for the most part, technologically neutral, although it has specific provisions for cookies, which were a significant concern at the time it was drafted. So far as I know, nobody has yet challenged browser fingerprinting under the GDPR, even though it seems to violate the provisions regarding consent. Since there are legitimate reasons for fingerprinting, such as hacking detection, organizations that do it could perhaps defend against a legal challenge on the basis that fingerprinting is necessary to operate their services safely. In the end, we really need specific, new legislation to address this privacy threat.&lt;/p&gt;
    &lt;head rend="h2"&gt;Closing remarks&lt;/head&gt;
    &lt;p&gt;I suspect that many people who take an interest in Internet privacy don’t appreciate how hard it is to resist browser fingerprinting. Taking steps to reduce it leads to inconvenience and, with the present state of technology, even the most intrusive approaches are only partially effective. The data collected by fingerprinting is invisible to the user, and stored somewhere beyond the user’s reach.&lt;/p&gt;
    &lt;p&gt;On the other hand, browser fingerprinting produces only statistical results, and usually can’t be used to track or identify a user with certainty. The data it collects has a relatively short lifespan – days to weeks, not months or years. While it probably can be used for sinister purposes, my main concern is that it supports the intrusive, out-of-control online advertising industry, which has made a wasteland of the Internet.&lt;/p&gt;
    &lt;p&gt;In the end, it’s probably only going to be controlled by legislation and, even when that happens, the advertisers will seek new ways to make the Internet even more of a hellscape – they always do.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=46016249</guid><pubDate>Sat, 22 Nov 2025 17:08:36 +0000</pubDate></item><item><title>The realities of being a pop star</title><link>https://itscharlibb.substack.com/p/the-realities-of-being-a-pop-star</link><description></description><guid isPermaLink="false">https://news.ycombinator.com/item?id=46016613</guid><pubDate>Sat, 22 Nov 2025 17:47:23 +0000</pubDate></item><item><title>Gwern's "Stem Humor" Directory</title><link>https://gwern.net/doc/math/humor/index</link><description>&lt;doc fingerprint="ad63379805be0bff"&gt;
  &lt;main&gt;
    &lt;head rend="h1"&gt;‘STEM humor’ directory&lt;/head&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;See Also&lt;/item&gt;
      &lt;item&gt;Gwern &lt;list rend="ul"&gt;&lt;item&gt;“Conference Fermi Problems ”, Gwern 2025&lt;/item&gt;&lt;item&gt;“Human Cannibalism Alignment Chart ”, Gwern et al 2025&lt;/item&gt;&lt;item&gt;“The Meta-LW Doomsday Argument ”, Gwern 2025&lt;/item&gt;&lt;item&gt;“Estimated Cost of DMT Machine Elf Prime Factorization Experiment ”, Gwern 2015&lt;/item&gt;&lt;item&gt;“A Christmas Protestation ”, o1-pro et al 2024&lt;/item&gt;&lt;item&gt;“Second Life Sentences ”, Gwern 2024&lt;/item&gt;&lt;item&gt;“The Carcinisation of Satan ”, Gwern 2024&lt;/item&gt;&lt;item&gt;“On the Impossibility of Superintelligent Rubik’s Cube Solvers ”, Gwern et al 2023&lt;/item&gt;&lt;item&gt;“Paperclip Alignment Chart ”, Gwern 2023&lt;/item&gt;&lt;item&gt;“Rare Greek Variables ”, Gwern 2021&lt;/item&gt;&lt;item&gt;“Gilles Goullet, Author of the Blindsight ”, Gwern 2010&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;Links &lt;list rend="ul"&gt;&lt;item&gt;“Placebo Emporium: 2025 Annual Shareholder Letter ”, Troesh 2025&lt;/item&gt;&lt;item&gt;“The Fine Art of Being Too Dumb to Regulate; Or: How I Learned to Stop Worrying and Love Betting on Earnings Buzzwords ”, Vagabonds 2025&lt;/item&gt;&lt;item&gt;“My Antichrist Lecture: Forecasting Transformative AI Using the Book of Revelation [Anthropic gematria] ”, Alexander 2025&lt;/item&gt;&lt;item&gt;“Gwern Visits BAIR ”, Liu 2025&lt;/item&gt;&lt;item&gt;The Way of Code: The Timeless Art of Vibe Coding, Rubin 2025&lt;/item&gt;&lt;item&gt;“[Social Acceptability of Eating Human Meat Alignment Chart] ”, Hero 2025&lt;/item&gt;&lt;item&gt;“You Can Never Reproduce The Same Bug Twice [Demotivational Poster] ”, Gwern 2025&lt;/item&gt;&lt;item&gt;“NeuRaLaTeX: A Machine Learning Library Written in Pure LaTeX ”, Gardner et al 2025&lt;/item&gt;&lt;item&gt;“Regex Chess: A 2-Ply Minimax Chess Engine in 84,688 Regular Expressions ”, Carlini 2025&lt;/item&gt;&lt;item&gt;“Trajectoid ”, Weinersmith 2024&lt;/item&gt;&lt;item&gt;“Age against the Machine—Susceptibility of Large Language Models to Cognitive Impairment: Cross Sectional Analysis ”&lt;/item&gt;&lt;item&gt;“A Numerical Evaluation of the Finite Monkeys Theorem ”, Woodcock &amp;amp; Falletta 2024&lt;/item&gt;&lt;item&gt;“How a Silly Science Prize Changed My Career: A Levitating Frog, a Necrophiliac Duck, Taxi Drivers’ Brains—The Ig Nobel Prizes Have Shined a Spotlight on Offbeat Work. Here’s an inside Look at How Winners Feel about This Sometimes Unwanted ‘Honor’ ”, Clarke 2024&lt;/item&gt;&lt;item&gt;“On the Impossibility of Superintelligent Rubik’s Cube Solvers [Claude-3.5-Sonnet] ”, Claude-3 2024&lt;/item&gt;&lt;item&gt;“Towel Day: The Aerodynamics of Freefalling Sperm Whales [Terminal Velocity: 178.3 M/s] ”, Ferguson 2024&lt;/item&gt;&lt;item&gt;“A Programming Language Embedded in Magic: The Gathering ”, Yin &amp;amp; Churchill 2024&lt;/item&gt;&lt;item&gt;“An Abundance of Katherines: The Game Theory of Baby Naming ”, Blumer et al 2024&lt;/item&gt;&lt;item&gt;“Are We Safe from Lightning Inside Buildings? A Study of Lightning Fatalities Inside Buildings Using Smartphones ”, Souza et al 2024&lt;/item&gt;&lt;item&gt;“Polyamorous Scheduling ”, Gąsieniec et al 2024&lt;/item&gt;&lt;item&gt;“An Incomplete Primer of Caselaw Appertaining To Bigfoot, AKA Sasquatch, LNU ”, White 2024&lt;/item&gt;&lt;item&gt;“IOCCC 2024: Stedolan—Best One Liner ”&lt;/item&gt;&lt;item&gt;“Paperclip Alignment Chart (Alternate) ”, saturn2 2023&lt;/item&gt;&lt;item&gt;“A LLM Assisted Exploitation of AI-Guardian ”, Carlini 2023&lt;/item&gt;&lt;item&gt;“Can a Good Philosophical Contribution Be Made Just by Asking a Question? ”, Habgood-Coote et al 2022&lt;/item&gt;&lt;item&gt;“Immaterials and Methods: Reagents for the Total Laboratory Synthesis of the Chocolate Chip Cookie ”, Schlonk 2022&lt;/item&gt;&lt;item&gt;“A Modest Spelling Reform to Increase Autologicity, Symmetry, and Readability ”&lt;/item&gt;&lt;item&gt;“Rare Greek Variables ”, Bayer 2021&lt;/item&gt;&lt;item&gt;“Flinch ”, Munroe 2021&lt;/item&gt;&lt;item&gt;“Proposed Detection of Ghosts by Mass Spectrometry-Spectral Presence Origin-Omics Kinetic Yield (MS-SPOOKY) ”, Schlonk 2021&lt;/item&gt;&lt;item&gt;“Are Cats Good? An Important Study ”, Owen &amp;amp; Lamon 2021b&lt;/item&gt;&lt;item&gt;“My Cat Chester’s Dynamical Systems Analysyyyyy7777777777777777y7is of the Laser Pointer and the Red Dot on the Wall: Correlation, Causation, or SARS-Cov-2 Hallucination? ”, Armstrong &amp;amp; Chester 2021&lt;/item&gt;&lt;item&gt;“How Fast Can Evangelion Run? Application Of Aerodynamics And Scaling Laws To The Super Robot ”, Ryu et al 2020&lt;/item&gt;&lt;item&gt;“The Treachery of Image Files ”, Earnest 2020&lt;/item&gt;&lt;item&gt;“My Immortal As Alchemical Allegory ”, Alexander 2020&lt;/item&gt;&lt;item&gt;“Single Headed Attention RNN: Stop Thinking With Your Head ”, Merity 2019&lt;/item&gt;&lt;item&gt;“A Mulching Proposal ”, Keyes et al 2019&lt;/item&gt;&lt;item&gt;“30 Weird Chess Algorithms: Elo World ”, Tom7 2019&lt;/item&gt;&lt;item&gt;“Real Numbers, Data Science and Chaos: How to Fit Any Dataset With a Single Parameter ”, Boué 2019&lt;/item&gt;&lt;item&gt;“Spooky Fizz Buzz § Pg42 ”, Menghrajani 2019 (page 42)&lt;/item&gt;&lt;item&gt;“Blueberry Earth ”, Sandberg 2018&lt;/item&gt;&lt;item&gt;“The Random Walk of Cars and Their Collision Probabilities With Planets ”, Rein et al 2018&lt;/item&gt;&lt;item&gt;“Super-Earths in Need for Extremely Big Rockets ”, Hippke 2018&lt;/item&gt;&lt;item&gt;“It’s a Man Eat Man World ”, Graham et al 2017&lt;/item&gt;&lt;item&gt;“How Sheep With Cameras Got Some Tiny Islands onto Google Street View ”, Brulliard 2017&lt;/item&gt;&lt;item&gt;“Factoring in the Chicken McNugget Monoid ”, Chapman &amp;amp; O’Neill 2017&lt;/item&gt;&lt;item&gt;“F—K Nuance ”, Healy 2017&lt;/item&gt;&lt;item&gt;“On the Impossibility of Supersized Machines ”, Garfinkel et al 2017&lt;/item&gt;&lt;item&gt;“Seasonality of Auricular Amputations in Rabbits ”, Yaremchuk et al 2017&lt;/item&gt;&lt;item&gt;“Sheep View: Where There’s a Wool, There’s a Way ”, Vega 2016&lt;/item&gt;&lt;item&gt;“Identifying the Source of Perytons at the Parkes Radio Telescope ”, Petroff et al 2015&lt;/item&gt;&lt;item&gt;“Optimal Tip-To-Tip Efficiency: a Model for Male Audience Stimulation ”, Chugtai &amp;amp; Gilfoyle 2014&lt;/item&gt;&lt;item&gt;“Heaven Is Hotter Than Hell &amp;amp; A Refutation ”, Simanek 2014&lt;/item&gt;&lt;item&gt;“A Few Goodmen: Surname-Sharing Economist Coauthors ”, Goodman et al 2014&lt;/item&gt;&lt;item&gt;“Two Curious Integrals and a Graphic Proof ”, Schmid 2014&lt;/item&gt;&lt;item&gt;“Searching the Internet for Evidence of Time Travelers ”, Nemiroff &amp;amp; Wilson 2013&lt;/item&gt;&lt;item&gt;“XKCD Plots Have Landed in Matplotlib! ”&lt;/item&gt;&lt;item&gt;“[What Deals Should the Devil Optimally Betray in Any given Social Graph?] ”, Schou 2013&lt;/item&gt;&lt;item&gt;“Robert Bunsen’s Sweet Tooth ”, Jensen 2013&lt;/item&gt;&lt;item&gt;“Your Right Arm For A Publication In AER? ”, Attema et al 2013&lt;/item&gt;&lt;item&gt;“Vigil, the Eternal Morally Vigilant Programming Language ”, munificent 2013&lt;/item&gt;&lt;item&gt;“The Survival Time of Chocolates on Hospital Wards: Covert Observational Study ”, Gajendragadkar et al 2013&lt;/item&gt;&lt;item&gt;“Possible Bubbles of Spacetime Curvature in the South Pacific ”, Tippett 2012&lt;/item&gt;&lt;item&gt;“On the Tumbling Toast Problem ”, Borghi 2012&lt;/item&gt;&lt;item&gt;“Robust Soldier Crab Ball Gate ”, Gunji et al 2012&lt;/item&gt;&lt;item&gt;“Non-Detection of the Tooth Fairy at Optical Wavelengths ”, Armstrong 2012&lt;/item&gt;&lt;item&gt;“Gods As Topological Invariants ”, Schoch 2012&lt;/item&gt;&lt;item&gt;“Tiramisu [Lexical Gaps in English Borrowing from Latin] ”, Pullum 2011&lt;/item&gt;&lt;item&gt;“A Parasite from Outer Space: How Sergei Kurekhin Proved That Lenin Was a Mushroom ”, Yurchak 2011&lt;/item&gt;&lt;item&gt;“Quantum Computation With Devices Whose Contents Are Never Read ”, Yakaryilmaz et al 2010&lt;/item&gt;&lt;item&gt;“The Optimal Taxation of Height: A Case Study of Utilitarian Income Redistribution ”, Mankiw &amp;amp; Weinzierl 2010&lt;/item&gt;&lt;item&gt;“Are Birds Smarter Than Mathematicians? Pigeons (Columba Livia) Perform Optimally on a Version of the Monty Hall Dilemma ”, Herbranson &amp;amp; Schroeder 2010&lt;/item&gt;&lt;item&gt;“The Name Is Shrdlu… Etaoin Shrdlu ”, D. 2009&lt;/item&gt;&lt;item&gt;“Woosh: A Wonderful Object-Oriented Shell Environment [Unix Directories As Objects] ”, mhinsch 2009&lt;/item&gt;&lt;item&gt;“Time Variation of a Fundamental Dimensionless Constant ”, Scherrer 2009&lt;/item&gt;&lt;item&gt;“Japan’s Phillips Curve Looks Like Japan ”, Smith 2008&lt;/item&gt;&lt;item&gt;“BREATHTAKING Design Strategy ”, Group 2008&lt;/item&gt;&lt;item&gt;“Possible Girls ”, Sinhababu 2008&lt;/item&gt;&lt;item&gt;“Down-Sizing Forever ”, Scott &amp;amp; Frolop 2008&lt;/item&gt;&lt;item&gt;The SICP Saga, Anonymous 2008&lt;/item&gt;&lt;item&gt;“Rugby (The Religion of Wales) and Its Influence on the Catholic Church: Should Pope Benedict XVI Be Worried? ”, Payne 2008&lt;/item&gt;&lt;item&gt;“Of Cinema, Food, and Desire: Franz Kafka’s ‘Investigations of a Dog’ ”, Williams 2007&lt;/item&gt;&lt;item&gt;“Sex, Aggression, and Humour: Responses to Unicycling ”, Shuster 2007&lt;/item&gt;&lt;item&gt;“The Wisdom of Hendrik W. Lenstra Junior ”, Magidin 2006&lt;/item&gt;&lt;item&gt;“Serge Lang, 1927–2005 § Part 1: Paul Vojta, University of California, Berkeley ”, Jorgenson &amp;amp; Krantz 2006 (page 12)&lt;/item&gt;&lt;item&gt;“We Are Sorry to Inform You... ”, Santini 2005&lt;/item&gt;&lt;item&gt;“A Box, Darkly: Obfuscation, Weird Languages, and Code Esthetics ”, Mateas &amp;amp; Montfort 2005&lt;/item&gt;&lt;item&gt;“Patent Office Annual Performance Review: Albert Einstein ”, Norvig 2005&lt;/item&gt;&lt;item&gt;“The Case of the Disappearing Teaspoons: Longitudinal Cohort Study of the Displacement of Teaspoons in an Australian Research Institute ”, Lim et al 2005&lt;/item&gt;&lt;item&gt;“Lewis Carroll’s Humpty Dumpty: an Early Report of Prosopagnosia? ”, Larner 2004&lt;/item&gt;&lt;item&gt;“Some AI Koans § Http://www.catb.org/esr/jargon/html/koans.html#id3141241 ”, Raymond 2003&lt;/item&gt;&lt;item&gt;“Some AI Koans ”, Raymond 2003&lt;/item&gt;&lt;item&gt;“Electron Band Structure In Germanium, My Ass ”, Kovar 2002&lt;/item&gt;&lt;item&gt;“A Tour of Accounting: Random Number Generator [Dilbert] ”, Adams 2001&lt;/item&gt;&lt;item&gt;“The Temperature of Heaven and Hell [Retrospective] ”, Pérez 2001&lt;/item&gt;&lt;item&gt;“Storks Deliver Babies (p = 0.008) ”, Matthews 2001&lt;/item&gt;&lt;item&gt;“Some Remarkable Properties of Sinc and Related Integrals ”, Borwein &amp;amp; Borwein 2001&lt;/item&gt;&lt;item&gt;“A Closer Look at Tumbling Toast ”, Bacon et al 2001&lt;/item&gt;&lt;item&gt;“The Evolution of a Haskell Programmer ”, Ruehr 2001&lt;/item&gt;&lt;item&gt;“Is Hell Endothermic or Exothermic? Old Collegiate Legend Involves a Student’s Coming up With a Clever Proof about the Physical Properties of Hell ”, Mikkelson 2000&lt;/item&gt;&lt;item&gt;“Area Man Consults Internet Whenever Possible ”, Onion 2000&lt;/item&gt;&lt;item&gt;“A Letter from the Frustrated Author of a Journal Paper ”, Glass 2000&lt;/item&gt;&lt;item&gt;“What Do Animals Do All Day? The Division of Labor, Class Bodies, and Totemic Thinking in the Popular Imagination ”, Martin 2000&lt;/item&gt;&lt;item&gt;“Klingon Programmers ”, Baker 1999&lt;/item&gt;&lt;item&gt;“I M A G I N E ”, Krishnamurthi 1996&lt;/item&gt;&lt;item&gt;“Tumbling Toast, Murphy’s Law and the Fundamental Constants ”, Matthews 1995&lt;/item&gt;&lt;item&gt;“Knockdown Arguments ”, Wreen 1995&lt;/item&gt;&lt;item&gt;“The Love Song of J. Random Hacker ”, Duntemann 1995&lt;/item&gt;&lt;item&gt;“(Para)bosons, (Para)fermions, Quons and Other Beasts in the Menagerie of Particle Statistics ”, Greenberg et al 1993&lt;/item&gt;&lt;item&gt;“Szeged in 1934 ”, Lorch &amp;amp; Hersh 1993&lt;/item&gt;&lt;item&gt;Geoffrey Sonnabend: Obliscence, Theories of Forgetting and the Problem of Matter—An Encapsulation (Fourth Edition, Abridged), Worth 1991&lt;/item&gt;&lt;item&gt;“Mustard Watches: An Integrated Approach To Time and Food ”, Ringard et al 1990&lt;/item&gt;&lt;item&gt;“What’s Wrong With This Lagrangean? ”, Mermin 1988&lt;/item&gt;&lt;item&gt;“Presentation Announcement / Automatic Weapons, Parts I–III ”, Shivers 1987&lt;/item&gt;&lt;item&gt;“Humour: The Interdisciplinary Denominator in Science ”, Kohn 1982&lt;/item&gt;&lt;item&gt;“An Epistemological Nightmare ”, Smullyan 1982&lt;/item&gt;&lt;item&gt;“Child’s Play: A Distorting Factor in Archaeological Distribution ”, Hammond &amp;amp; Hammond 1981&lt;/item&gt;&lt;item&gt;“A Rebuke of A. B. Smith‘s Paper, 'A Note on Piffles’ ”, Farlow 1980&lt;/item&gt;&lt;item&gt;“Paul Darwin Foote (1888–1971) § The Temperature of Heaven &amp;amp; Hell ”, Astin 1979 (page 12)&lt;/item&gt;&lt;item&gt;“The First Sally (A), Or, Trurl’s Electronic Bard § Love And Tensor Algebra ”, Lem &amp;amp; Kandel 1974 (page 7)&lt;/item&gt;&lt;item&gt;“Principia Discordia (1970) ”&lt;/item&gt;&lt;item&gt;“On the Enfeeblement of Mathematical Skills by ‘Modern Mathematics’ and by Similar Soft Intellectual Trash in Schools and Universities ”, Hammersley 1968&lt;/item&gt;&lt;item&gt;“A Note On Piffles, By A. B. Smith ”, Austin 1967&lt;/item&gt;&lt;item&gt;A Stress Analysis of a Strapless Evening Gown: Essays for a Scientific Age, Baker 1963&lt;/item&gt;&lt;item&gt;“On The Nature Of Mathematical Proof ”, Cohen 1961&lt;/item&gt;&lt;item&gt;“Hiawatha’s Lipid ”, Sinclair 1960&lt;/item&gt;&lt;item&gt;“Mathmanship ”, Vanserg 1958&lt;/item&gt;&lt;item&gt;“How to Write Geologese ”, Vansberg 1952&lt;/item&gt;&lt;item&gt;“How Newton Discovered the Law of Gravitation ”, Miller 1951&lt;/item&gt;&lt;item&gt;“A Royal Practical Joke ”, Oesper 1948&lt;/item&gt;&lt;item&gt;“Investigations of a Dog ”, Kafka et al 1922&lt;/item&gt;&lt;item&gt;“The Chaos ”, Trenité 1922&lt;/item&gt;&lt;item&gt;“Some Unattractive Meta-Ethical Positions, Free to a Good Home ”&lt;/item&gt;&lt;item&gt;“Theological Engineering Exam ”, Anonymous 2025&lt;/item&gt;&lt;item&gt;“Center for the Alignment of AI Alignment Centers ”&lt;/item&gt;&lt;item&gt;“Bahfest ”&lt;/item&gt;&lt;item&gt;“Determining Cat Chirality ”&lt;/item&gt;&lt;item&gt;The Space Child’s Mother Goose, Regehr 2025&lt;/item&gt;&lt;item&gt;“How to Install Linux on a Dead Badger ”&lt;/item&gt;&lt;item&gt;“&lt;code&gt;roguetype&lt;/code&gt;: The First Ever Rogue-Like Written in the OCaml Type System ”, Octachron 2025&lt;/item&gt;&lt;item&gt;“Extremely Linear Git History ”, zegl 2025&lt;/item&gt;&lt;item&gt;“The Hardest Chess Problem in the World? ”&lt;/item&gt;&lt;item&gt;“HTTP Cats ”&lt;/item&gt;&lt;item&gt;“Is the Great Attractor a Tengen Toppa Gurren Lagann? ”&lt;/item&gt;&lt;item&gt;“King James Programming ”&lt;/item&gt;&lt;item&gt;“Occupy Babel! ”&lt;/item&gt;&lt;item&gt;“The New Economics of Chess ”&lt;/item&gt;&lt;item&gt;“How Can I Draw a Homer Simpson With Epicycloids? ”&lt;/item&gt;&lt;item&gt;“A Congress of Robert Reichs ”&lt;/item&gt;&lt;item&gt;“Does Garlic Protect against Vampires? An Experimental Study ”&lt;/item&gt;&lt;item&gt;“Blogging versus Blog Setups ”&lt;/item&gt;&lt;item&gt;“The Association for Computational Heresy ”&lt;/item&gt;&lt;item&gt;“SIGBOVIK 2019 ”&lt;/item&gt;&lt;item&gt;“Turing-Complete Chess Computation ”&lt;/item&gt;&lt;item&gt;“How to Burn a Magnesium NeXT Cube ”&lt;/item&gt;&lt;item&gt;“Opinions of Doron Zeilberger ”, Zeilberger 2025&lt;/item&gt;&lt;item&gt;“Akin’s Laws of Spacecraft Design ”&lt;/item&gt;&lt;item&gt;“Futurama Theorem ”&lt;/item&gt;&lt;item&gt;“Sheepview360 ”&lt;/item&gt;&lt;item&gt;“Scunthorpe Sans: a Profanity-Blocking Font ”&lt;/item&gt;&lt;item&gt;“Computer Error Haikus ”, WikiWikiWeb 2025&lt;/item&gt;&lt;item&gt;“Population Dynamics in Madoka ”&lt;/item&gt;&lt;item&gt;“BMJ Christmas Issue ”&lt;/item&gt;&lt;item&gt;“The Roentgen Standard ”, Niven 2025&lt;/item&gt;&lt;item&gt;“VDT: a Solution to Decision Theory ”&lt;/item&gt;&lt;item&gt;“Voo Doo: the MIT Journal of Rational Disco and Campus Intercourse ”&lt;/item&gt;&lt;item&gt;“The Most Popular Chess Streamer on Twitch ”&lt;/item&gt;&lt;item&gt;“What Are You Paying For in a $300 Chess Set? Mostly the Knights ”&lt;/item&gt;&lt;item&gt;“How Magnus Carlsen Turned Chess Skill Into a Business Empire ”&lt;/item&gt;&lt;item&gt;“[A Magic: The Gathering Combo That Deals Infinite Damage If the Twin Prime Conjecture Is True] ”&lt;/item&gt;&lt;item&gt;“Frayn’s Spoof of Wittgenstein ”&lt;/item&gt;&lt;item&gt;“Seraphim: An Angelic Conlang for Agma Schwa’s Cursed Conlang Contest ”&lt;/item&gt;&lt;item&gt;“Harder Drive: Hard Drives We Didn’t Want or Need ”, tom7 2025&lt;/item&gt;&lt;item&gt;“Ptolemy and Homer (Simpson) ”&lt;/item&gt;&lt;item&gt;erowidrecruiter&lt;/item&gt;&lt;item&gt;kimkierkegaard&lt;/item&gt;&lt;item&gt;“Random Number ”, Munroe 2025&lt;/item&gt;&lt;item&gt;“Bracket Symbols ”, Munroe 2025&lt;/item&gt;&lt;item&gt;“Correlation ”, Munroe 2025&lt;/item&gt;&lt;item&gt;Sort By Magic&lt;/item&gt;&lt;item&gt;Wikipedia (19)&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;Miscellaneous&lt;/item&gt;
      &lt;item&gt;Bibliography&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h1"&gt;See Also&lt;/head&gt;
    &lt;head rend="h1"&gt;Gwern&lt;/head&gt;
    &lt;head rend="h2"&gt;“Conference Fermi Problems ”, Gwern 2025&lt;/head&gt;
    &lt;head rend="h2"&gt;“Human Cannibalism Alignment Chart ”, Gwern et al 2025&lt;/head&gt;
    &lt;head rend="h2"&gt;“The Meta-LW Doomsday Argument ”, Gwern 2025&lt;/head&gt;
    &lt;head rend="h2"&gt;“Estimated Cost of DMT Machine Elf Prime Factorization Experiment ”, Gwern 2015&lt;/head&gt;
    &lt;p&gt;Estimated Cost of DMT Machine Elf Prime Factorization Experiment&lt;/p&gt;
    &lt;head rend="h2"&gt;“A Christmas Protestation ”, o1-pro et al 2024&lt;/head&gt;
    &lt;head rend="h2"&gt;“Second Life Sentences ”, Gwern 2024&lt;/head&gt;
    &lt;head rend="h2"&gt;“The Carcinisation of Satan ”, Gwern 2024&lt;/head&gt;
    &lt;head rend="h2"&gt;“On the Impossibility of Superintelligent Rubik’s Cube Solvers ”, Gwern et al 2023&lt;/head&gt;
    &lt;p&gt;On the Impossibility of Superintelligent Rubik’s Cube Solvers&lt;/p&gt;
    &lt;head rend="h2"&gt;“Paperclip Alignment Chart ”, Gwern 2023&lt;/head&gt;
    &lt;head rend="h2"&gt;“Rare Greek Variables ”, Gwern 2021&lt;/head&gt;
    &lt;head rend="h2"&gt;“Gilles Goullet, Author of the Blindsight ”, Gwern 2010&lt;/head&gt;
    &lt;head rend="h1"&gt;Links&lt;/head&gt;
    &lt;head rend="h2"&gt;“Placebo Emporium: 2025 Annual Shareholder Letter ”, Troesh 2025&lt;/head&gt;
    &lt;head rend="h2"&gt;“The Fine Art of Being Too Dumb to Regulate; Or: How I Learned to Stop Worrying and Love Betting on Earnings Buzzwords ”, Vagabonds 2025&lt;/head&gt;
    &lt;head rend="h2"&gt;“My Antichrist Lecture: Forecasting Transformative AI Using the Book of Revelation [Anthropic gematria] ”, Alexander 2025&lt;/head&gt;
    &lt;head rend="h2"&gt;“Gwern Visits BAIR ”, Liu 2025&lt;/head&gt;
    &lt;head rend="h2"&gt;The Way of Code: The Timeless Art of Vibe Coding, Rubin 2025&lt;/head&gt;
    &lt;head rend="h2"&gt;“[Social Acceptability of Eating Human Meat Alignment Chart] ”, Hero 2025&lt;/head&gt;
    &lt;p&gt;[Social acceptability of eating human meat alignment chart] :&lt;/p&gt;
    &lt;head rend="h2"&gt;“You Can Never Reproduce The Same Bug Twice [Demotivational Poster] ”, Gwern 2025&lt;/head&gt;
    &lt;p&gt;You Can Never Reproduce The Same Bug Twice [demotivational poster]&lt;/p&gt;
    &lt;head rend="h2"&gt;“NeuRaLaTeX: A Machine Learning Library Written in Pure LaTeX ”, Gardner et al 2025&lt;/head&gt;
    &lt;p&gt;NeuRaLaTeX: A machine learning library written in pure LaTeX&lt;/p&gt;
    &lt;head rend="h2"&gt;“Regex Chess: A 2-Ply Minimax Chess Engine in 84,688 Regular Expressions ”, Carlini 2025&lt;/head&gt;
    &lt;p&gt;Regex Chess: A 2-ply minimax chess engine in 84,688 regular expressions&lt;/p&gt;
    &lt;head rend="h2"&gt;“Trajectoid ”, Weinersmith 2024&lt;/head&gt;
    &lt;head rend="h2"&gt;“Age against the Machine—Susceptibility of Large Language Models to Cognitive Impairment: Cross Sectional Analysis ”&lt;/head&gt;
    &lt;head rend="h2"&gt;“A Numerical Evaluation of the Finite Monkeys Theorem ”, Woodcock &amp;amp; Falletta 2024&lt;/head&gt;
    &lt;head rend="h2"&gt;“How a Silly Science Prize Changed My Career: A Levitating Frog, a Necrophiliac Duck, Taxi Drivers’ Brains—The Ig Nobel Prizes Have Shined a Spotlight on Offbeat Work. Here’s an inside Look at How Winners Feel about This Sometimes Unwanted ‘Honor’ ”, Clarke 2024&lt;/head&gt;
    &lt;head rend="h2"&gt;“On the Impossibility of Superintelligent Rubik’s Cube Solvers [Claude-3.5-Sonnet] ”, Claude-3 2024&lt;/head&gt;
    &lt;p&gt;On the Impossibility of Superintelligent Rubik’s Cube Solvers [Claude-3.5-sonnet]&lt;/p&gt;
    &lt;head rend="h2"&gt;“Towel Day: The Aerodynamics of Freefalling Sperm Whales [Terminal Velocity: 178.3 M/s] ”, Ferguson 2024&lt;/head&gt;
    &lt;p&gt;Towel Day: The Aerodynamics of Freefalling Sperm Whales [terminal velocity: 178.3 m/s] :&lt;/p&gt;
    &lt;head rend="h2"&gt;“A Programming Language Embedded in Magic: The Gathering ”, Yin &amp;amp; Churchill 2024&lt;/head&gt;
    &lt;head rend="h2"&gt;“An Abundance of Katherines: The Game Theory of Baby Naming ”, Blumer et al 2024&lt;/head&gt;
    &lt;head rend="h2"&gt;“Are We Safe from Lightning Inside Buildings? A Study of Lightning Fatalities Inside Buildings Using Smartphones ”, Souza et al 2024&lt;/head&gt;
    &lt;head rend="h2"&gt;“Polyamorous Scheduling ”, Gąsieniec et al 2024&lt;/head&gt;
    &lt;head rend="h2"&gt;“An Incomplete Primer of Caselaw Appertaining To Bigfoot, AKA Sasquatch, LNU ”, White 2024&lt;/head&gt;
    &lt;p&gt;An Incomplete Primer of Caselaw Appertaining To Bigfoot, AKA Sasquatch, LNU&lt;/p&gt;
    &lt;head rend="h2"&gt;“IOCCC 2024: Stedolan—Best One Liner ”&lt;/head&gt;
    &lt;head rend="h2"&gt;“Paperclip Alignment Chart (Alternate) ”, saturn2 2023&lt;/head&gt;
    &lt;head rend="h2"&gt;“A LLM Assisted Exploitation of AI-Guardian ”, Carlini 2023&lt;/head&gt;
    &lt;head rend="h2"&gt;“Can a Good Philosophical Contribution Be Made Just by Asking a Question? ”, Habgood-Coote et al 2022&lt;/head&gt;
    &lt;p&gt;Can a good philosophical contribution be made just by asking a question?&lt;/p&gt;
    &lt;head rend="h2"&gt;“Immaterials and Methods: Reagents for the Total Laboratory Synthesis of the Chocolate Chip Cookie ”, Schlonk 2022&lt;/head&gt;
    &lt;p&gt;Immaterials and Methods: Reagents for the Total Laboratory Synthesis of the Chocolate Chip Cookie :&lt;/p&gt;
    &lt;p&gt;View PDF:&lt;/p&gt;
    &lt;head rend="h2"&gt;“A Modest Spelling Reform to Increase Autologicity, Symmetry, and Readability ”&lt;/head&gt;
    &lt;p&gt;A modest spelling reform to increase autologicity, symmetry, and readability&lt;/p&gt;
    &lt;head rend="h2"&gt;“Rare Greek Variables ”, Bayer 2021&lt;/head&gt;
    &lt;head rend="h2"&gt;“Flinch ”, Munroe 2021&lt;/head&gt;
    &lt;head rend="h2"&gt;“Proposed Detection of Ghosts by Mass Spectrometry-Spectral Presence Origin-Omics Kinetic Yield (MS-SPOOKY) ”, Schlonk 2021&lt;/head&gt;
    &lt;head rend="h2"&gt;“Are Cats Good? An Important Study ”, Owen &amp;amp; Lamon 2021b&lt;/head&gt;
    &lt;head rend="h2"&gt;“My Cat Chester’s Dynamical Systems Analysyyyyy7777777777777777y7is of the Laser Pointer and the Red Dot on the Wall: Correlation, Causation, or SARS-Cov-2 Hallucination? ”, Armstrong &amp;amp; Chester 2021&lt;/head&gt;
    &lt;head rend="h2"&gt;“How Fast Can Evangelion Run? Application Of Aerodynamics And Scaling Laws To The Super Robot ”, Ryu et al 2020&lt;/head&gt;
    &lt;p&gt;How Fast Can Evangelion Run? Application Of Aerodynamics And Scaling Laws To The Super Robot&lt;/p&gt;
    &lt;head rend="h2"&gt;“The Treachery of Image Files ”, Earnest 2020&lt;/head&gt;
    &lt;head rend="h2"&gt;“My Immortal As Alchemical Allegory ”, Alexander 2020&lt;/head&gt;
    &lt;head rend="h2"&gt;“Single Headed Attention RNN: Stop Thinking With Your Head ”, Merity 2019&lt;/head&gt;
    &lt;head rend="h2"&gt;“A Mulching Proposal ”, Keyes et al 2019&lt;/head&gt;
    &lt;head rend="h2"&gt;“30 Weird Chess Algorithms: Elo World ”, Tom7 2019&lt;/head&gt;
    &lt;head rend="h2"&gt;“Real Numbers, Data Science and Chaos: How to Fit Any Dataset With a Single Parameter ”, Boué 2019&lt;/head&gt;
    &lt;p&gt;Real numbers, data science and chaos: How to fit any dataset with a single parameter&lt;/p&gt;
    &lt;head rend="h2"&gt;“Spooky Fizz Buzz § Pg42 ”, Menghrajani 2019 (page 42)&lt;/head&gt;
    &lt;head rend="h2"&gt;“Blueberry Earth ”, Sandberg 2018&lt;/head&gt;
    &lt;head rend="h2"&gt;“The Random Walk of Cars and Their Collision Probabilities With Planets ”, Rein et al 2018&lt;/head&gt;
    &lt;p&gt;The Random Walk of Cars and Their Collision Probabilities with Planets&lt;/p&gt;
    &lt;head rend="h2"&gt;“Super-Earths in Need for Extremely Big Rockets ”, Hippke 2018&lt;/head&gt;
    &lt;head rend="h2"&gt;“It’s a Man Eat Man World ”, Graham et al 2017&lt;/head&gt;
    &lt;head rend="h2"&gt;“How Sheep With Cameras Got Some Tiny Islands onto Google Street View ”, Brulliard 2017&lt;/head&gt;
    &lt;p&gt;How sheep with cameras got some tiny islands onto Google Street View&lt;/p&gt;
    &lt;head rend="h2"&gt;“Factoring in the Chicken McNugget Monoid ”, Chapman &amp;amp; O’Neill 2017&lt;/head&gt;
    &lt;head rend="h2"&gt;“F—K Nuance ”, Healy 2017&lt;/head&gt;
    &lt;head rend="h2"&gt;“On the Impossibility of Supersized Machines ”, Garfinkel et al 2017&lt;/head&gt;
    &lt;head rend="h2"&gt;“Seasonality of Auricular Amputations in Rabbits ”, Yaremchuk et al 2017&lt;/head&gt;
    &lt;head rend="h2"&gt;“Sheep View: Where There’s a Wool, There’s a Way ”, Vega 2016&lt;/head&gt;
    &lt;head rend="h2"&gt;“Identifying the Source of Perytons at the Parkes Radio Telescope ”, Petroff et al 2015&lt;/head&gt;
    &lt;p&gt;Identifying the source of perytons at the Parkes radio telescope&lt;/p&gt;
    &lt;head rend="h2"&gt;“Optimal Tip-To-Tip Efficiency: a Model for Male Audience Stimulation ”, Chugtai &amp;amp; Gilfoyle 2014&lt;/head&gt;
    &lt;p&gt;Optimal Tip-to-Tip Efficiency: a model for male audience stimulation&lt;/p&gt;
    &lt;head rend="h2"&gt;“Heaven Is Hotter Than Hell &amp;amp; A Refutation ”, Simanek 2014&lt;/head&gt;
    &lt;head rend="h2"&gt;“A Few Goodmen: Surname-Sharing Economist Coauthors ”, Goodman et al 2014&lt;/head&gt;
    &lt;head rend="h2"&gt;“Two Curious Integrals and a Graphic Proof ”, Schmid 2014&lt;/head&gt;
    &lt;p&gt;Two curious integrals and a graphic proof :&lt;/p&gt;
    &lt;p&gt;View PDF:&lt;/p&gt;
    &lt;head rend="h2"&gt;“Searching the Internet for Evidence of Time Travelers ”, Nemiroff &amp;amp; Wilson 2013&lt;/head&gt;
    &lt;head rend="h2"&gt;“XKCD Plots Have Landed in Matplotlib! ”&lt;/head&gt;
    &lt;p&gt;XKCD Plots have Landed in Matplotlib! :&lt;/p&gt;
    &lt;p&gt;View External Link:&lt;/p&gt;
    &lt;p&gt;
      &lt;code&gt;https://jakevdp.github.io/blog/2013/07/10/XKCD-plots-in-matplotlib/&lt;/code&gt;
    &lt;/p&gt;
    &lt;head rend="h2"&gt;“[What Deals Should the Devil Optimally Betray in Any given Social Graph?] ”, Schou 2013&lt;/head&gt;
    &lt;p&gt;[What deals should the Devil optimally betray in any given social graph?] :&lt;/p&gt;
    &lt;head rend="h2"&gt;“Robert Bunsen’s Sweet Tooth ”, Jensen 2013&lt;/head&gt;
    &lt;head rend="h2"&gt;“Your Right Arm For A Publication In AER? ”, Attema et al 2013&lt;/head&gt;
    &lt;head rend="h2"&gt;“Vigil, the Eternal Morally Vigilant Programming Language ”, munificent 2013&lt;/head&gt;
    &lt;head rend="h2"&gt;“The Survival Time of Chocolates on Hospital Wards: Covert Observational Study ”, Gajendragadkar et al 2013&lt;/head&gt;
    &lt;p&gt;The survival time of chocolates on hospital wards: covert observational study&lt;/p&gt;
    &lt;head rend="h2"&gt;“Possible Bubbles of Spacetime Curvature in the South Pacific ”, Tippett 2012&lt;/head&gt;
    &lt;p&gt;Possible Bubbles of Spacetime Curvature in the South Pacific&lt;/p&gt;
    &lt;head rend="h2"&gt;“On the Tumbling Toast Problem ”, Borghi 2012&lt;/head&gt;
    &lt;head rend="h2"&gt;“Robust Soldier Crab Ball Gate ”, Gunji et al 2012&lt;/head&gt;
    &lt;head rend="h2"&gt;“Non-Detection of the Tooth Fairy at Optical Wavelengths ”, Armstrong 2012&lt;/head&gt;
    &lt;head rend="h2"&gt;“Gods As Topological Invariants ”, Schoch 2012&lt;/head&gt;
    &lt;head rend="h2"&gt;“Tiramisu [Lexical Gaps in English Borrowing from Latin] ”, Pullum 2011&lt;/head&gt;
    &lt;head rend="h2"&gt;“A Parasite from Outer Space: How Sergei Kurekhin Proved That Lenin Was a Mushroom ”, Yurchak 2011&lt;/head&gt;
    &lt;p&gt;A Parasite from Outer Space: How Sergei Kurekhin Proved That Lenin Was a Mushroom&lt;/p&gt;
    &lt;head rend="h2"&gt;“Quantum Computation With Devices Whose Contents Are Never Read ”, Yakaryilmaz et al 2010&lt;/head&gt;
    &lt;p&gt;Quantum computation with devices whose contents are never read&lt;/p&gt;
    &lt;head rend="h2"&gt;“The Optimal Taxation of Height: A Case Study of Utilitarian Income Redistribution ”, Mankiw &amp;amp; Weinzierl 2010&lt;/head&gt;
    &lt;p&gt;The Optimal Taxation of Height: A Case Study of Utilitarian Income Redistribution&lt;/p&gt;
    &lt;head rend="h2"&gt;“Are Birds Smarter Than Mathematicians? Pigeons (Columba Livia) Perform Optimally on a Version of the Monty Hall Dilemma ”, Herbranson &amp;amp; Schroeder 2010&lt;/head&gt;
    &lt;head rend="h2"&gt;“The Name Is Shrdlu… Etaoin Shrdlu ”, D. 2009&lt;/head&gt;
    &lt;head rend="h2"&gt;“Woosh: A Wonderful Object-Oriented Shell Environment [Unix Directories As Objects] ”, mhinsch 2009&lt;/head&gt;
    &lt;p&gt;Woosh: A wonderful object-oriented shell environment [Unix directories as objects]&lt;/p&gt;
    &lt;head rend="h2"&gt;“Time Variation of a Fundamental Dimensionless Constant ”, Scherrer 2009&lt;/head&gt;
    &lt;head rend="h2"&gt;“Japan’s Phillips Curve Looks Like Japan ”, Smith 2008&lt;/head&gt;
    &lt;head rend="h2"&gt;“BREATHTAKING Design Strategy ”, Group 2008&lt;/head&gt;
    &lt;head rend="h2"&gt;“Possible Girls ”, Sinhababu 2008&lt;/head&gt;
    &lt;head rend="h2"&gt;“Down-Sizing Forever ”, Scott &amp;amp; Frolop 2008&lt;/head&gt;
    &lt;head rend="h2"&gt;The SICP Saga, Anonymous 2008&lt;/head&gt;
    &lt;head rend="h2"&gt;“Rugby (The Religion of Wales) and Its Influence on the Catholic Church: Should Pope Benedict XVI Be Worried? ”, Payne 2008&lt;/head&gt;
    &lt;head rend="h2"&gt;“Of Cinema, Food, and Desire: Franz Kafka’s ‘Investigations of a Dog’ ”, Williams 2007&lt;/head&gt;
    &lt;p&gt;Of Cinema, Food, and Desire: Franz Kafka’s ‘Investigations of a Dog’&lt;/p&gt;
    &lt;head rend="h2"&gt;“Sex, Aggression, and Humour: Responses to Unicycling ”, Shuster 2007&lt;/head&gt;
    &lt;head rend="h2"&gt;“The Wisdom of Hendrik W. Lenstra Junior ”, Magidin 2006&lt;/head&gt;
    &lt;head rend="h2"&gt;“Serge Lang, 1927–2005 § Part 1: Paul Vojta, University of California, Berkeley ”, Jorgenson &amp;amp; Krantz 2006 (page 12)&lt;/head&gt;
    &lt;p&gt;Serge Lang, 1927–2005 § Part 1: Paul Vojta, University of California, Berkeley&lt;/p&gt;
    &lt;head rend="h2"&gt;“We Are Sorry to Inform You... ”, Santini 2005&lt;/head&gt;
    &lt;head rend="h2"&gt;“A Box, Darkly: Obfuscation, Weird Languages, and Code Esthetics ”, Mateas &amp;amp; Montfort 2005&lt;/head&gt;
    &lt;p&gt;A Box, Darkly: Obfuscation, Weird Languages, and Code esthetics&lt;/p&gt;
    &lt;head rend="h2"&gt;“Patent Office Annual Performance Review: Albert Einstein ”, Norvig 2005&lt;/head&gt;
    &lt;head rend="h2"&gt;“The Case of the Disappearing Teaspoons: Longitudinal Cohort Study of the Displacement of Teaspoons in an Australian Research Institute ”, Lim et al 2005&lt;/head&gt;
    &lt;head rend="h2"&gt;“Lewis Carroll’s Humpty Dumpty: an Early Report of Prosopagnosia? ”, Larner 2004&lt;/head&gt;
    &lt;p&gt;Lewis Carroll’s Humpty Dumpty: an early report of prosopagnosia? :&lt;/p&gt;
    &lt;p&gt;View PDF:&lt;/p&gt;
    &lt;head rend="h2"&gt;“Some AI Koans § Http://www.catb.org/esr/jargon/html/koans.html#id3141241 ”, Raymond 2003&lt;/head&gt;
    &lt;p&gt;Some AI Koans § http://www.catb.org/esr/jargon/html/koans.html#id3141241 :&lt;/p&gt;
    &lt;head rend="h2"&gt;“Some AI Koans ”, Raymond 2003&lt;/head&gt;
    &lt;head rend="h2"&gt;“Electron Band Structure In Germanium, My Ass ”, Kovar 2002&lt;/head&gt;
    &lt;head rend="h2"&gt;“A Tour of Accounting: Random Number Generator [Dilbert] ”, Adams 2001&lt;/head&gt;
    &lt;head rend="h2"&gt;“The Temperature of Heaven and Hell [Retrospective] ”, Pérez 2001&lt;/head&gt;
    &lt;p&gt;The temperature of heaven and hell [retrospective] :&lt;/p&gt;
    &lt;p&gt;View PDF:&lt;/p&gt;
    &lt;head rend="h2"&gt;“Storks Deliver Babies (p = 0.008) ”, Matthews 2001&lt;/head&gt;
    &lt;head rend="h2"&gt;“Some Remarkable Properties of Sinc and Related Integrals ”, Borwein &amp;amp; Borwein 2001&lt;/head&gt;
    &lt;head rend="h2"&gt;“A Closer Look at Tumbling Toast ”, Bacon et al 2001&lt;/head&gt;
    &lt;head rend="h2"&gt;“The Evolution of a Haskell Programmer ”, Ruehr 2001&lt;/head&gt;
    &lt;head rend="h2"&gt;“Is Hell Endothermic or Exothermic? Old Collegiate Legend Involves a Student’s Coming up With a Clever Proof about the Physical Properties of Hell ”, Mikkelson 2000&lt;/head&gt;
    &lt;head rend="h2"&gt;“Area Man Consults Internet Whenever Possible ”, Onion 2000&lt;/head&gt;
    &lt;head rend="h2"&gt;“A Letter from the Frustrated Author of a Journal Paper ”, Glass 2000&lt;/head&gt;
    &lt;p&gt;A letter from the frustrated author of a journal paper :&lt;/p&gt;
    &lt;p&gt;View PDF:&lt;/p&gt;
    &lt;head rend="h2"&gt;“What Do Animals Do All Day? The Division of Labor, Class Bodies, and Totemic Thinking in the Popular Imagination ”, Martin 2000&lt;/head&gt;
    &lt;p&gt;View PDF:&lt;/p&gt;
    &lt;head rend="h2"&gt;“Klingon Programmers ”, Baker 1999&lt;/head&gt;
    &lt;head rend="h2"&gt;“I M A G I N E ”, Krishnamurthi 1996&lt;/head&gt;
    &lt;head rend="h2"&gt;“Tumbling Toast, Murphy’s Law and the Fundamental Constants ”, Matthews 1995&lt;/head&gt;
    &lt;head rend="h2"&gt;“Knockdown Arguments ”, Wreen 1995&lt;/head&gt;
    &lt;head rend="h2"&gt;“The Love Song of J. Random Hacker ”, Duntemann 1995&lt;/head&gt;
    &lt;head rend="h2"&gt;“(Para)bosons, (Para)fermions, Quons and Other Beasts in the Menagerie of Particle Statistics ”, Greenberg et al 1993&lt;/head&gt;
    &lt;p&gt;(Para)bosons, (para)fermions, quons and other beasts in the menagerie of particle statistics&lt;/p&gt;
    &lt;head rend="h2"&gt;“Szeged in 1934 ”, Lorch &amp;amp; Hersh 1993&lt;/head&gt;
    &lt;p&gt;View PDF:&lt;/p&gt;
    &lt;head rend="h2"&gt;Geoffrey Sonnabend: Obliscence, Theories of Forgetting and the Problem of Matter—An Encapsulation (Fourth Edition, Abridged), Worth 1991&lt;/head&gt;
    &lt;head rend="h2"&gt;“Mustard Watches: An Integrated Approach To Time and Food ”, Ringard et al 1990&lt;/head&gt;
    &lt;head rend="h2"&gt;“What’s Wrong With This Lagrangean? ”, Mermin 1988&lt;/head&gt;
    &lt;head rend="h2"&gt;“Presentation Announcement / Automatic Weapons, Parts I–III ”, Shivers 1987&lt;/head&gt;
    &lt;p&gt;Presentation announcement / Automatic weapons, parts I–III :&lt;/p&gt;
    &lt;head rend="h2"&gt;“Humour: The Interdisciplinary Denominator in Science ”, Kohn 1982&lt;/head&gt;
    &lt;head rend="h2"&gt;“An Epistemological Nightmare ”, Smullyan 1982&lt;/head&gt;
    &lt;head rend="h2"&gt;“Child’s Play: A Distorting Factor in Archaeological Distribution ”, Hammond &amp;amp; Hammond 1981&lt;/head&gt;
    &lt;p&gt;Child’s Play: A Distorting Factor in Archaeological Distribution&lt;/p&gt;
    &lt;head rend="h2"&gt;“A Rebuke of A. B. Smith‘s Paper, 'A Note on Piffles’ ”, Farlow 1980&lt;/head&gt;
    &lt;p&gt;A rebuke of A. B. Smith‘s paper, 'A Note on Piffles’ :&lt;/p&gt;
    &lt;p&gt;View PDF:&lt;/p&gt;
    &lt;head rend="h2"&gt;“Paul Darwin Foote (1888–1971) § The Temperature of Heaven &amp;amp; Hell ”, Astin 1979 (page 12)&lt;/head&gt;
    &lt;p&gt;Paul Darwin Foote (1888–1971) § The Temperature of Heaven &amp;amp; Hell&lt;/p&gt;
    &lt;head rend="h2"&gt;“The First Sally (A), Or, Trurl’s Electronic Bard § Love And Tensor Algebra ”, Lem &amp;amp; Kandel 1974 (page 7)&lt;/head&gt;
    &lt;p&gt;The First Sally (A), or, Trurl’s Electronic Bard § Love And Tensor Algebra :&lt;/p&gt;
    &lt;head rend="h2"&gt;“Principia Discordia (1970) ”&lt;/head&gt;
    &lt;p&gt;View External Link:&lt;/p&gt;
    &lt;p&gt;
      &lt;code&gt;https://en.wikisource.org/wiki/Page:Principia_Discordia_(1970).djvu/19&lt;/code&gt;
    &lt;/p&gt;
    &lt;head rend="h2"&gt;“On the Enfeeblement of Mathematical Skills by ‘Modern Mathematics’ and by Similar Soft Intellectual Trash in Schools and Universities ”, Hammersley 1968&lt;/head&gt;
    &lt;p&gt;View PDF:&lt;/p&gt;
    &lt;head rend="h2"&gt;“A Note On Piffles, By A. B. Smith ”, Austin 1967&lt;/head&gt;
    &lt;p&gt;A Note On Piffles, By A. B. Smith :&lt;/p&gt;
    &lt;p&gt;View PDF:&lt;/p&gt;
    &lt;head rend="h2"&gt;A Stress Analysis of a Strapless Evening Gown: Essays for a Scientific Age, Baker 1963&lt;/head&gt;
    &lt;p&gt;A Stress Analysis of a Strapless Evening Gown: Essays for a Scientific Age :&lt;/p&gt;
    &lt;head rend="h2"&gt;“On The Nature Of Mathematical Proof ”, Cohen 1961&lt;/head&gt;
    &lt;p&gt;On The Nature Of Mathematical Proof :&lt;/p&gt;
    &lt;p&gt;View PDF:&lt;/p&gt;
    &lt;head rend="h2"&gt;“Hiawatha’s Lipid ”, Sinclair 1960&lt;/head&gt;
    &lt;head rend="h2"&gt;“Mathmanship ”, Vanserg 1958&lt;/head&gt;
    &lt;p&gt;View PDF:&lt;/p&gt;
    &lt;head rend="h2"&gt;“How to Write Geologese ”, Vansberg 1952&lt;/head&gt;
    &lt;p&gt;View PDF:&lt;/p&gt;
    &lt;head rend="h2"&gt;“How Newton Discovered the Law of Gravitation ”, Miller 1951&lt;/head&gt;
    &lt;p&gt;How Newton Discovered the Law of Gravitation :&lt;/p&gt;
    &lt;p&gt;View PDF:&lt;/p&gt;
    &lt;head rend="h2"&gt;“A Royal Practical Joke ”, Oesper 1948&lt;/head&gt;
    &lt;head rend="h2"&gt;“Investigations of a Dog ”, Kafka et al 1922&lt;/head&gt;
    &lt;head rend="h2"&gt;“The Chaos ”, Trenité 1922&lt;/head&gt;
    &lt;head rend="h2"&gt;“Some Unattractive Meta-Ethical Positions, Free to a Good Home ”&lt;/head&gt;
    &lt;p&gt;Some Unattractive Meta-Ethical Positions, Free to a Good Home :&lt;/p&gt;
    &lt;head rend="h2"&gt;“Theological Engineering Exam ”, Anonymous 2025&lt;/head&gt;
    &lt;head rend="h2"&gt;“Center for the Alignment of AI Alignment Centers ”&lt;/head&gt;
    &lt;head rend="h2"&gt;“Bahfest ”&lt;/head&gt;
    &lt;p&gt;Bahfest :&lt;/p&gt;
    &lt;head rend="h2"&gt;“Determining Cat Chirality ”&lt;/head&gt;
    &lt;head rend="h2"&gt;The Space Child’s Mother Goose, Regehr 2025&lt;/head&gt;
    &lt;head rend="h2"&gt;“How to Install Linux on a Dead Badger ”&lt;/head&gt;
    &lt;head rend="h2"&gt;“&lt;code&gt;roguetype&lt;/code&gt;: The First Ever Rogue-Like Written in the OCaml Type System ”, Octachron 2025&lt;/head&gt;
    &lt;p&gt;&lt;code&gt;roguetype&lt;/code&gt;: The first ever rogue-like written in the OCaml type system&lt;/p&gt;
    &lt;head rend="h2"&gt;“Extremely Linear Git History ”, zegl 2025&lt;/head&gt;
    &lt;head rend="h2"&gt;“The Hardest Chess Problem in the World? ”&lt;/head&gt;
    &lt;head rend="h2"&gt;“HTTP Cats ”&lt;/head&gt;
    &lt;head rend="h2"&gt;“Is the Great Attractor a Tengen Toppa Gurren Lagann? ”&lt;/head&gt;
    &lt;head rend="h2"&gt;“King James Programming ”&lt;/head&gt;
    &lt;head rend="h2"&gt;“Occupy Babel! ”&lt;/head&gt;
    &lt;p&gt;View External Link:&lt;/p&gt;
    &lt;head rend="h2"&gt;“The New Economics of Chess ”&lt;/head&gt;
    &lt;head rend="h2"&gt;“How Can I Draw a Homer Simpson With Epicycloids? ”&lt;/head&gt;
    &lt;head rend="h2"&gt;“A Congress of Robert Reichs ”&lt;/head&gt;
    &lt;head rend="h2"&gt;“Does Garlic Protect against Vampires? An Experimental Study ”&lt;/head&gt;
    &lt;head rend="h2"&gt;“Blogging versus Blog Setups ”&lt;/head&gt;
    &lt;head rend="h2"&gt;“The Association for Computational Heresy ”&lt;/head&gt;
    &lt;head rend="h2"&gt;“SIGBOVIK 2019 ”&lt;/head&gt;
    &lt;head rend="h2"&gt;“Turing-Complete Chess Computation ”&lt;/head&gt;
    &lt;head rend="h2"&gt;“How to Burn a Magnesium NeXT Cube ”&lt;/head&gt;
    &lt;head rend="h2"&gt;“Opinions of Doron Zeilberger ”, Zeilberger 2025&lt;/head&gt;
    &lt;head rend="h2"&gt;“Akin’s Laws of Spacecraft Design ”&lt;/head&gt;
    &lt;head rend="h2"&gt;“Futurama Theorem ”&lt;/head&gt;
    &lt;head rend="h2"&gt;“Sheepview360 ”&lt;/head&gt;
    &lt;head rend="h2"&gt;“Scunthorpe Sans: a Profanity-Blocking Font ”&lt;/head&gt;
    &lt;head rend="h2"&gt;“Computer Error Haikus ”, WikiWikiWeb 2025&lt;/head&gt;
    &lt;head rend="h2"&gt;“Population Dynamics in Madoka ”&lt;/head&gt;
    &lt;head rend="h2"&gt;“BMJ Christmas Issue ”&lt;/head&gt;
    &lt;head rend="h2"&gt;“The Roentgen Standard ”, Niven 2025&lt;/head&gt;
    &lt;head rend="h2"&gt;“VDT: a Solution to Decision Theory ”&lt;/head&gt;
    &lt;head rend="h2"&gt;“Voo Doo: the MIT Journal of Rational Disco and Campus Intercourse ”&lt;/head&gt;
    &lt;p&gt;Voo Doo: the MIT Journal of Rational Disco and Campus Intercourse&lt;/p&gt;
    &lt;head rend="h2"&gt;“The Most Popular Chess Streamer on Twitch ”&lt;/head&gt;
    &lt;head rend="h2"&gt;“What Are You Paying For in a $300 Chess Set? Mostly the Knights ”&lt;/head&gt;
    &lt;p&gt;What Are You Paying For in a $300 Chess Set? Mostly the Knights&lt;/p&gt;
    &lt;head rend="h2"&gt;“How Magnus Carlsen Turned Chess Skill Into a Business Empire ”&lt;/head&gt;
    &lt;p&gt;How Magnus Carlsen Turned Chess Skill Into a Business Empire&lt;/p&gt;
    &lt;head rend="h2"&gt;“[A Magic: The Gathering Combo That Deals Infinite Damage If the Twin Prime Conjecture Is True] ”&lt;/head&gt;
    &lt;p&gt;[A Magic: The Gathering combo that deals infinite damage if the Twin Prime Conjecture is true] :&lt;/p&gt;
    &lt;head rend="h2"&gt;“Frayn’s Spoof of Wittgenstein ”&lt;/head&gt;
    &lt;head rend="h2"&gt;“Seraphim: An Angelic Conlang for Agma Schwa’s Cursed Conlang Contest ”&lt;/head&gt;
    &lt;p&gt;Seraphim: An Angelic Conlang for Agma Schwa’s Cursed Conlang Contest :&lt;/p&gt;
    &lt;head rend="h2"&gt;“Harder Drive: Hard Drives We Didn’t Want or Need ”, tom7 2025&lt;/head&gt;
    &lt;head rend="h2"&gt;“Ptolemy and Homer (Simpson) ”&lt;/head&gt;
    &lt;head rend="h2"&gt;erowidrecruiter&lt;/head&gt;
    &lt;head rend="h2"&gt;kimkierkegaard&lt;/head&gt;
    &lt;head rend="h2"&gt;“Random Number ”, Munroe 2025&lt;/head&gt;
    &lt;head rend="h2"&gt;“Bracket Symbols ”, Munroe 2025&lt;/head&gt;
    &lt;p&gt;View External Link:&lt;/p&gt;
    &lt;head rend="h2"&gt;“Correlation ”, Munroe 2025&lt;/head&gt;
    &lt;p&gt;View External Link:&lt;/p&gt;
    &lt;head rend="h2"&gt;Sort By Magic&lt;/head&gt;
    &lt;p&gt;Annotations sorted by machine learning into inferred 'tags'. This provides an alternative way to browse: instead of by date order, one can browse in topic order. The 'sorted' list has been automatically clustered into multiple sections &amp;amp; auto-labeled for easier browsing.&lt;/p&gt;
    &lt;p&gt;Beginning with the newest annotation, it uses the embedding of each annotation to attempt to create a list of nearest-neighbor annotations, creating a progression of topics. For more details, see the link.&lt;/p&gt;
    &lt;head rend="h3"&gt;
      &lt;code&gt;playful-absurdity&lt;/code&gt;
    &lt;/head&gt;
    &lt;head rend="h3"&gt;
      &lt;code&gt;demotivational-comedy&lt;/code&gt;
    &lt;/head&gt;
    &lt;head rend="h3"&gt;
      &lt;code&gt;absurd-intelligence&lt;/code&gt;
    &lt;/head&gt;
    &lt;head rend="h3"&gt;
      &lt;code&gt;weird-algorithms&lt;/code&gt;
    &lt;/head&gt;
    &lt;head rend="h2"&gt;Wikipedia (19)&lt;/head&gt;
    &lt;head rend="h1"&gt;Miscellaneous&lt;/head&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;/doc/math/humor/2024-06-30-michelangelo-thecreationofadam-editedwithrubikscube.jpg&lt;/code&gt;:&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;/doc/cs/security/2001-12-02-treginaldgibbons-isyoursonacomputerhacker.html&lt;/code&gt;:&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;https://andreas-zeller.blogspot.com/2017/01/twelve-latex-packages-to-get-your-paper.html&lt;/code&gt;:&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;https://andreasjhkarlsson.github.io/jekyll/update/2023/12/27/4-billion-if-statements.html&lt;/code&gt;:&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;https://ctan.org/pkg/coffeestains&lt;/code&gt;:&lt;p&gt;View External Link:&lt;/p&gt;&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;https://james-iry.blogspot.com/2009/05/brief-incomplete-and-mostly-wrong.html&lt;/code&gt;:&lt;/item&gt;
      &lt;item&gt;
        &lt;code&gt;https://kieranhealy.org/blog/archives/2023/06/19/the-naming-of-stats/&lt;/code&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;code&gt;https://mathwithbaddrawings.com/2023/11/07/mathematicians-play-set/&lt;/code&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;code&gt;https://merrillmarkoe.substack.com/p/dylans-christmas-lights-a-scholarly&lt;/code&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;code&gt;https://pages.cpsc.ucalgary.ca/~robin/class/449/Evolution.htm&lt;/code&gt;
      &lt;/item&gt;
      &lt;item&gt;&lt;code&gt;https://scholar.harvard.edu/files/mickens/files/thisworldofours.pdf&lt;/code&gt;:&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;https://www.cs.purdue.edu/homes/comer/essay.criticize.html&lt;/code&gt;:&lt;/item&gt;
      &lt;item&gt;
        &lt;code&gt;https://www.eveonline.com/news/view/information-is-power-excel-release&lt;/code&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;code&gt;https://www.lesswrong.com/posts/YKfNZAmiLdepDngwi/gpt-175bee&lt;/code&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;code&gt;https://www.lesswrong.com/posts/YMo5PuXnZDwRjhHhE/i-have-been-a-good-bing&lt;/code&gt;
      &lt;/item&gt;
      &lt;item&gt;&lt;code&gt;https://www.lesswrong.com/posts/tBy4RvCzhYyrrMFj3/introducing-open-asteroid-impact&lt;/code&gt;:&lt;/item&gt;
      &lt;item&gt;
        &lt;code&gt;https://www.protocol.com/chess-streaming-twitch-hikaru-botez&lt;/code&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;code&gt;https://www.quantamagazine.org/why-mathematicians-re-prove-what-they-already-know-20230426/&lt;/code&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;code&gt;https://www.stavros.io/posts/compressing-images-with-stable-diffusion/&lt;/code&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;code&gt;https://www.theonion.com/u-s-economy-grinds-to-halt-as-nation-realizes-money-ju-1819571322&lt;/code&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;View External Link:&lt;/p&gt;
      &lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h1"&gt;Bibliography&lt;/head&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;&lt;code&gt;https://arxiv.org/abs/2503.24187&lt;/code&gt;: “NeuRaLaTeX: A Machine Learning Library Written in Pure LaTeX ”,&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;https://arxiv.org/abs/2404.00732&lt;/code&gt;: “An Abundance of Katherines: The Game Theory of Baby Naming ”,&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;https://arxiv.org/abs/2403.00465&lt;/code&gt;: “Polyamorous Scheduling ”,&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;https://journals.open.tudelft.nl/superhero/article/download/5332/4801&lt;/code&gt;: “How Fast Can Evangelion Run? Application Of Aerodynamics And Scaling Laws To The Super Robot ”,&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;https://arxiv.org/abs/1911.11423&lt;/code&gt;: “Single Headed Attention RNN: Stop Thinking With Your Head ”,&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;1979-astin.pdf#page=12&lt;/code&gt;: “Paul Darwin Foote (1888–1971) § The Temperature of Heaven &amp;amp; Hell ”,&lt;/item&gt;
    &lt;/list&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=46016630</guid><pubDate>Sat, 22 Nov 2025 17:49:05 +0000</pubDate></item><item><title>China reaches energy milestone by "breeding" uranium from thorium</title><link>https://www.scmp.com/news/china/science/article/3331312/china-reaches-energy-independence-milestone-breeding-uranium-thorium</link><description>&lt;doc fingerprint="35c25b54af5ed989"&gt;
  &lt;main&gt;
    &lt;head rend="h1"&gt;China reaches energy independence milestone by ‘breeding’ uranium from thorium&lt;/head&gt;
    &lt;p&gt;Chinese research institute confirms success of fission-based innovation that is poised to reshape clean, sustainable nuclear power&lt;/p&gt;
    &lt;p&gt;The achievement makes the 2 megawatt liquid-fuelled thorium-based molten salt reactor (TMSR) the only operating example of the technology in the world to have successfully loaded and used thorium fuel.&lt;/p&gt;
    &lt;p&gt;According to the academy, the experiment has provided initial proof of the technical feasibility of using thorium resources in molten salt reactor systems and represents a major leap forward for the technology.&lt;/p&gt;
    &lt;p&gt;It is the first time in the world that scientists have been able to acquire experimental data on thorium operations from inside a molten salt reactor, according to a report by Science and Technology Daily.&lt;/p&gt;
    &lt;p&gt;The article, published on Saturday, was China’s first official confirmation of its success in the development of TMSR technology, an innovation that is poised to reshape the future of clean sustainable nuclear energy.&lt;/p&gt;
    &lt;p&gt;Li Qingnuan, Communist Party secretary and deputy director at the Shanghai Institute of Applied Physics, told the newspaper that “since achieving first criticality on October 11, 2023, the thorium molten salt reactor has been steadily generating heat through nuclear fission”.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=46016639</guid><pubDate>Sat, 22 Nov 2025 17:49:27 +0000</pubDate></item><item><title>Depot (YC W23) Is Hiring a Staff Infrastructure Engineer</title><link>https://www.ycombinator.com/companies/depot/jobs/O2iB56E-staff-infrastructure-engineer</link><description>&lt;doc fingerprint="2cccf64b3f052532"&gt;
  &lt;main&gt;
    &lt;p&gt;Build faster. Waste less time.&lt;/p&gt;
    &lt;p&gt;At Depot, we are on a mission to redefine software collaboration and accelerate developers everywhere. We are creating a build performance and developer platform unlike any other, combining performance, empathy, and centralized collaboration to enable companies to iterate exponentially faster.&lt;/p&gt;
    &lt;p&gt;We launch millions of EC2 instances per month and orchestrate half a petabyte of cache data to accelerate CI jobs and local builds. We are looking to hire a Staff Infrastructure Engineer who can build for the next level of scale.&lt;/p&gt;
    &lt;p&gt;For this role, you should be a seasoned expert with robust systems engineering skills and the ability to engage deeply in technical discussions. As part of a small team, you will work side-by-side with other engineers to test ideas, build proofs of concept, and ultimately ship quality solutions to customers. You will be a key contributor with the ownership and autonomy to see projects through from beginning to end.&lt;/p&gt;
    &lt;p&gt;Please note: We are an equal opportunity employer and remote-only company. At this time, we can only support hiring within North America and Europe for this role.&lt;/p&gt;
    &lt;p&gt;Depot is a fully remote and globally distributed team across the US, Europe, and Canada. As a remote startup, there are several key values and expectations:&lt;/p&gt;
    &lt;p&gt;Depot is a build acceleration and developer productivity platform that saves companies like PostHog, Wistia, Semgrep, and Secoda thousands of hours in build time every week.&lt;/p&gt;
    &lt;p&gt;We are developers. We started Depot because we were frustrated with the constant pain of slow build performance. We were fed up waiting for builds and annoyed by the lack of tooling and providers that actually made builds performant. So, we went and built the solution we had always wanted.&lt;/p&gt;
    &lt;p&gt;Slow builds are the dam standing in the way between mediocrity and innovation. They’re wasteful, expensive, and a drain on developer happiness &amp;amp; productivity. They slow down innovation.&lt;/p&gt;
    &lt;p&gt;Taking a 40-minute build down to a minute, changes everything. We help folks save literal years in build time every single week.&lt;/p&gt;
    &lt;p&gt;And we’re just getting started. For us, it’s all about iteration speed and keeping developers in their flow state. Our mission is to be relentless in accelerating software development.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=46016799</guid><pubDate>Sat, 22 Nov 2025 18:05:47 +0000</pubDate></item><item><title>Show HN: Forty.News – Daily news, but on a 40-year delay</title><link>https://forty.news</link><guid isPermaLink="false">https://news.ycombinator.com/item?id=46017175</guid><pubDate>Sat, 22 Nov 2025 18:47:08 +0000</pubDate></item><item><title>Markdown Is Holding You Back</title><link>https://newsletter.bphogan.com/archive/issue-45-markdown-is-holding-you-back/</link><description>&lt;doc fingerprint="64c4d8137a1d1bd0"&gt;
  &lt;main&gt;&lt;p&gt;I've used many content formats over the years, and while I love Markdown, I run into its limitations daily when I work on larger documentation projects.&lt;/p&gt;&lt;p&gt;In this issue, you'll look at Markdown and explore why it might not be the best fit for technical content, and what else might work instead.&lt;/p&gt;&lt;p&gt;Markdown is everywhere. It's human-readable, approachable, and has just enough syntax to make docs look good in GitHub or a static site. That ease of use is why it's become the default choice for developer documentation. I'm using Markdown right now to write this newsletter issue. I love it.&lt;/p&gt;&lt;p&gt;But Markdown's biggest advantage is its biggest drawback: it doesn't describe the content like other formats can.&lt;/p&gt;&lt;p&gt;Think about how your content gets consumed. Your content isn't just for human readers. Machines use it too. Your content gets indexed by search engines, and parsed by LLMs, and those things parse the well-formed HTML your systems publish. Markdown's basic syntax only emits a small subset of the available semantic tags HTML allows.&lt;/p&gt;&lt;p&gt;IDE integrations can use your docs, too. And AI agents rely on structure to answer developer questions. If you're only feeding them plain-text Markdown documents to reduce the number of tokens you send, you're not providing as much context as you could.&lt;/p&gt;&lt;p&gt;Worse, when you want to reuse your content or syndicate content into another system, you quickly find out that Markdown is more of the lowest common denominator than a source of truth, as not all Markdown flavors are the same.&lt;/p&gt;&lt;p&gt;There are other options you can use that give you more control. But first, let's look deeper into why you should move away from Markdown for serious work.&lt;/p&gt;&lt;p&gt;If you're a developer, you know all about type systems in programming languages. Some languages use Implicit typing, in which the compiler or interpreter infers the data type from the value. These languages give you flexibility, but no guarantees. That's why many developers prefer languages that use explicit typing, where you predefine data types when writing the code. In those languages, the compiler doesn't just build your code; it guarantees specific rules are followed. That's the main reason for the rise of TypeScript over JavaScript: compile-time guarantees.&lt;/p&gt;&lt;p&gt;Markdown is implicit typing. It lets you write quickly, but without constraints or guarantees. There's no schema. No way to enforce consistency. A heading in one file might be a concept, in another it might be a step, and there's no machine-readable distinction between the two.&lt;/p&gt;&lt;p&gt;To complicate things further, there are multiple flavors of Markdown, each with its own features and markup. Here are just a few:&lt;/p&gt;&lt;p&gt;You think you're writing "Markdown," but what works in one tool may not render in another. Some Markdown processors allow footnotes, Others ignore soft line breaks. And some even require different formatting for code blocks. Inconsistency makes Markdown a shaky foundation for anything beyond the most basic document.&lt;/p&gt;&lt;p&gt;And then there's MDX, which people often use to extend Markdown to support things it doesn't:&lt;/p&gt;&lt;p&gt;Here's a typical MDX snippet:&lt;/p&gt;&lt;code&gt;# Install

&amp;lt;Command&amp;gt;npm install my-library&amp;lt;/Command&amp;gt;
&lt;/code&gt;&lt;p&gt;That &lt;code&gt;&amp;lt;Command&amp;gt;&lt;/code&gt; tag isn't Markdown at all; it's a React component. Instead of using a code block, the author chose to create a special component to standardize how all commands would display in the documentation. &lt;/p&gt;&lt;p&gt;It works beautifully on their site because their publishing system knows what &lt;code&gt;&amp;lt;Command&amp;gt;&lt;/code&gt; means. But if they try to syndicate this content to another system, it breaks because that system also needs to implement that component. And even if it was supported elsewhere, there's no guarantee that the component is implemented the same way. &lt;/p&gt;&lt;p&gt;MDX shows that even in Markdown-centric ecosystems, people instinctively add more expressive markup. They know plain Markdown isn't enough. They're reinventing semantic markup, but in a way that's custom, brittle, and not portable.&lt;/p&gt;&lt;p&gt;Semantic markup describes what content is, not just how it should look. It's the difference between saying "here's a bullet with some text" and "here's a step in a procedure." To a human, those may look the same on a page. To a machine or to a publishing pipeline, they are entirely different.&lt;/p&gt;&lt;p&gt;Web developers already went through all this with HTML. Prior to HTML5, you had &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; as a logical container. But HTML5 introduced &lt;code&gt;&amp;lt;section&amp;gt;&lt;/code&gt;,  &lt;code&gt;&amp;lt;article&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;aside&amp;gt;&lt;/code&gt;, and many other elements that described the content. &lt;/p&gt;&lt;p&gt;Semantic markup matters for two important and related reasons:&lt;/p&gt;&lt;code&gt;&amp;lt;step&amp;gt;&lt;/code&gt; or a paragraph into a &lt;code&gt;&amp;lt;para&amp;gt;&lt;/code&gt; without guessing. You can't add context if it wasn't there to begin with, but you can strip out what you don't need when you transform the document, and you can choose how to present each thing in a consistent way. &lt;code&gt;&amp;lt;step&amp;gt;&lt;/code&gt; is unambiguous. A bullet point might be a step, or a note, or just a list item. The machine has to guess. This is why XML was a preferred mechanism for web services for a long time, and why JSON Schema exists.&lt;p&gt;Let's explore four formats that give you more control over structure than plain Markdown.&lt;/p&gt;&lt;p&gt;reStructuredText is a plain-text markup language from the Python/Docutils ecosystem that supports directives, roles, and structural semantics. It is the foundational format used by Sphinx for generating documentation.&lt;/p&gt;&lt;code&gt;Installation
============

.. code-block:: bash

   npm install my-library

.. note::  
   This library requires Node.JS ≥ 22.

See also :ref:`usage-guide`.
&lt;/code&gt;&lt;p&gt;Here you see a &lt;code&gt;code-block&lt;/code&gt; directive, an admonition (&lt;code&gt;note&lt;/code&gt;), and an explicit cross-reference via &lt;code&gt;:ref:&lt;/code&gt;. You'll find support for images, figures, topics, sidebars, pull quotes, epigraphs, and citations as well.&lt;/p&gt;&lt;p&gt;All of those encode semantics, not just presentation.&lt;/p&gt;&lt;p&gt;AsciiDoc aims to be human-readable but semantically expressive. It has attributes, conditional content, include mechanisms, and more.&lt;/p&gt;&lt;p&gt;Here's an example of AsciiDoc:&lt;/p&gt;&lt;code&gt;= Installation
:revnumber: 1.2
:platform: linux
:prev_section: introduction
:next_section: create-project

[source,bash]
----
npm install my-library
----

NOTE: This library requires Node.JS ≥ 22.

See &amp;lt;&amp;lt;usage,Usage Guide&amp;gt;&amp;gt; for examples.
&lt;/code&gt;&lt;p&gt;AsciiDoc has native support for document front-matter. Attributes like &lt;code&gt;:revnumber:&lt;/code&gt; or &lt;code&gt;:platform:&lt;/code&gt; let you parameterize content. &lt;/p&gt;&lt;p&gt;&lt;code&gt;&amp;lt;&amp;lt;usage,Usage Guide&amp;gt;&amp;gt;&lt;/code&gt; is a cross-reference syntax. &lt;/p&gt;&lt;p&gt;Like reStructuredText, AsciiDoc supports admonitions like &lt;code&gt;NOTE&lt;/code&gt; and &lt;code&gt;WARNING&lt;/code&gt; so you don't have to build your own custom renderer. It also has support for sidebars, and you can add line highlighting and callouts to your code blocks without additional extensions. &lt;/p&gt;&lt;p&gt;And if you're writing technical documentation, there's explicit support for marking up UI elements and keyboard shortcuts.&lt;/p&gt;&lt;p&gt;Using AsciiDoctor, you can transform AsciiDoc into other formats, including HTML, PDF, ePub, and DocBook, which you'll look at next.&lt;/p&gt;&lt;p&gt;DocBook is an XML-based document model explicitly designed for technical publishing. It expresses hierarchical and semantic structure in tags and attributes, enabling industrial-grade transformations.&lt;/p&gt;&lt;p&gt;Here's an example&lt;/p&gt;&lt;code&gt;&amp;lt;article id="install-library"&amp;gt;
  &amp;lt;title&amp;gt;Installation&amp;lt;/title&amp;gt;
  &amp;lt;command&amp;gt;npm install my-library&amp;lt;/command&amp;gt;
  &amp;lt;note&amp;gt;This library requires Node.JS &amp;amp;gt;= 22&amp;lt;/note&amp;gt;
  &amp;lt;xref linkend="usage-chapter"&amp;gt;Usage Guide&amp;lt;/xref&amp;gt;
&amp;lt;/article&amp;gt;
&lt;/code&gt;&lt;p&gt;Every tag is meaningful: &lt;code&gt;&amp;lt;command&amp;gt;&lt;/code&gt; vs &lt;code&gt;&amp;lt;para&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;note&amp;gt;&lt;/code&gt; vs &lt;code&gt;&amp;lt;xref&amp;gt;&lt;/code&gt;. You'll find predefined tags for function names, variables, application names, keyboard shortcuts, UI elements, and much more. Being able to mark up the specific product names and terminology you use makes it so much easier to create glossaries and indexes. And Docbook has tags for defining index terms, too.&lt;/p&gt;&lt;p&gt;DocBook's rich ecosystem of XSLT stylesheets supports transforming to HTML, PDF, man pages, and even Markdown. Using DocBook ensures structure and validation at scale, as long as you use the tags it provides.&lt;/p&gt;&lt;p&gt;Then there's DITA.&lt;/p&gt;&lt;p&gt;DITA is a standard for writing, managing, and publishing content. It's a topic-based XML architecture with built-in reuse, specialization, and modular content design. It's an open standard, and it's widely used in enterprises for multi-channel, structured content that needs standardization and reuse.&lt;/p&gt;&lt;p&gt;Here's an example:&lt;/p&gt;&lt;code&gt;&amp;lt;task id="install"&amp;gt;
  &amp;lt;title&amp;gt;Installation&amp;lt;/title&amp;gt;
  &amp;lt;steps&amp;gt;
    &amp;lt;step&amp;gt;&amp;lt;cmd&amp;gt;npm install my-library&amp;lt;/cmd&amp;gt;&amp;lt;/step&amp;gt;
  &amp;lt;/steps&amp;gt;
  &amp;lt;prolog&amp;gt;
    &amp;lt;note&amp;gt;This library requires Node.js &amp;amp;gt;= 22&amp;lt;/note&amp;gt;
  &amp;lt;/prolog&amp;gt;
&amp;lt;/task&amp;gt;
&lt;/code&gt;&lt;p&gt;DITA defines types like &lt;code&gt;&amp;lt;task&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;step&amp;gt;&lt;/code&gt;, which cleanly map to procedural structure. You can compose topics, reuse via content references (conrefs), and specialize as your domain evolves. &lt;/p&gt;&lt;p&gt;One of the more interesting features DITA provides is the ability to filter content and create multiple versions from a single document.&lt;/p&gt;&lt;p&gt;The DITA Open Toolkit and many enterprise tools handle rendering, transformation, and reuse pipelines.&lt;/p&gt;&lt;p&gt;Yes, XML. The syntax is more verbose than Markdown. Tooling is less ubiquitous than Markdown. Migration requires effort, and your team may resist the learning curve. For small docs, Markdown's features are often enough.&lt;/p&gt;&lt;p&gt;But if you're already bolting semantics onto Markdown with MDX or plugins or custom scripts, you're paying that complexity cost anyway, and you don't get the benefits of standardization or portability. You're building a fragile, custom semantic layer instead of adopting one that already works.&lt;/p&gt;&lt;p&gt;If you're writing a quick &lt;code&gt;README&lt;/code&gt; or a short-lived doc, Markdown is fine. It's fast, approachable, and does the job. If you're building a developer documentation site that needs some structure, reStructuredText or AsciiDoc are better choices. They balance expressiveness with usability. And if you're managing a large doc set that needs syndication, reuse, and multi-channel publishing, DocBook and DITA give you the semantics and tooling to make that process more manageable.&lt;/p&gt;&lt;p&gt;The key is to start with the richest format you can manage and export downward. Markdown makes a great output for developers. It's approachable and familiar. But be careful not to lock yourself into it as your source of truth, because you can't add context back as easily as you can strip it out.&lt;/p&gt;&lt;p&gt;Before the next issue, here are a couple of things you should try to get some hands-on experience with a different format.&lt;/p&gt;&lt;p&gt;As always, thanks for reading. Share this issue with someone who you think would find this helpful.&lt;/p&gt;&lt;p&gt;I'd love to talk with you about this issue on BlueSky, Mastodon, Twitter, or LinkedIn. Let's connect!&lt;/p&gt;&lt;p&gt;Please support this newsletter and my work by encouraging others to subscribe and by buying a friend a copy of Write Better with Vale, tmux 3, Exercises for Programmers, Small, Sharp Software Tools, or any of my other books.&lt;/p&gt;&lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=46017782</guid><pubDate>Sat, 22 Nov 2025 20:03:14 +0000</pubDate></item><item><title>The Mozilla Cycle, Part III: Mozilla Dies in Ignominy</title><link>https://taggart-tech.com/mozilla-cycle-pt3/</link><description>&lt;doc fingerprint="3f2a935d1a8f875c"&gt;
  &lt;main&gt;
    &lt;p&gt;I owe Mozilla a thank-you. Really, I do. Maybe an Edible Arrangement? People like those. Some lil pineapples cut into stars on sticks and chocolate strawberries might brighten their day. For the note, I'm thinking something like:&lt;/p&gt;
    &lt;quote&gt;
      &lt;p&gt;Thank you for proving me exactly right.&lt;/p&gt;
      &lt;p&gt;XOXO MT&lt;/p&gt;
    &lt;/quote&gt;
    &lt;p&gt;Eight months ago, in the fallout of Mozilla's fumbling of a Privacy Policy update, I wrote:&lt;/p&gt;
    &lt;quote&gt;
      &lt;p&gt;Mozilla is pursuing its primary objective, which is the survival of Mozilla. Its mission statement is more than broad enough to accommodate that, and Firefox is not a real priority. The community should accept that and stop waiting for Mozilla to be the hero they deserve.&lt;/p&gt;
    &lt;/quote&gt;
    &lt;p&gt;Regrettably, I was unable to take my own advice on the last part. So here we are yet again, marveling at Mozilla's dedication toward eroding decades of good will in the community they purportedly serve. To quote one of my sacred texts, it's a focus and intensity normally seen only in successes.&lt;/p&gt;
    &lt;p&gt;Back in the present, we have Mozilla &lt;del&gt;doubling&lt;/del&gt;&lt;del&gt;tripling&lt;/del&gt; nthing down on this direction. First, with their announcement of "AI Window," a new feature (used very loosely) coming to Firefox which seems to emulate the user experience offered by AI browsers like Perplexity's Comet or OpenAI's Atlas. In other words, instead of performing search from the address bar and interacting with websites like browsers have done since they were invented, your first interaction will be with a language model prompt, which then mediates your experience of the web.&lt;/p&gt;
    &lt;p&gt;Not to gloat, but I told you so.&lt;/p&gt;
    &lt;p&gt;The response from the Firefox community has not just been overwhelmingly negative, it is universally negative as far as I can tell. At least among users willing to post on Mozilla's forums about the issue, which is absolutely a biased sample set. I have received some comments separately in support of Firefox, but they are countable and the vast, vast minority. Mozilla's core audience hates this move. At the very least, they would want all the AI components of Firefox to be opt-in, a choice that Firefox has been unwilling to make so far, instead enabling these new features by default.&lt;/p&gt;
    &lt;p&gt;What does Mozilla do? Temper the plan? Ease up on the forced features?&lt;/p&gt;
    &lt;p&gt;Nah, they do what any good corporate PR person would tell you to do when facing public backlash: post through it.&lt;/p&gt;
    &lt;p&gt;This post is a summary of Mozilla's new Strategic Plan, which is viewable in full here. I read it through a few times, and my brain nearly ripped in half from the cognitive dissonance involved. But I think it's worth examining Mozilla's claims carefully. They are:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;AI (by which they mean generative AI) is a transformative technology that will fundamentally alter how we interact with machines and the web.&lt;/item&gt;
      &lt;item&gt;The current landscape is dangerous and controlled by big tech and "closed source" models.&lt;/item&gt;
      &lt;item&gt;Mozilla should therefore pivot to develop and support "open source" AI implementations the same way they advocated for open web standards.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The strategy details the "what" and "how" of Mozilla's transformation in this direction. We're going to touch on some of those points, but let's begin with these big claims, affording Mozilla maximum benefit of the doubt.&lt;/p&gt;
    &lt;p&gt;Is generative AI a transformative technology? The Corpos sure seem to want it to be, although its actual usage seems mostly to be chatbot-related. All other attempts to use this trick in other realms have failed rather miserably. Microsoft, for example, wants you to talk to your computer instead of using a mouse and keyboard like a dinosaur. The results, unfortunately, are much worse than the Jurassic version of computer interaction. The pattern holds true across the board. Google's AI Overview continues to be an inferior provider of information than solid web search results. Also, as it turns out, people learn less from LLM output.&lt;/p&gt;
    &lt;p&gt;Even the AI browsers Mozilla wants to emulate have significant issues, vulnerable to old web vulnerabilities and new attacks against the models themselves.&lt;/p&gt;
    &lt;p&gt;Generative AI is transforming something, but I don't think it's the web, and I don't think it's for the better.&lt;/p&gt;
    &lt;p&gt;Which means their second claim is definitely true! The current landscape is dangerous, as I've been decrying for years.&lt;/p&gt;
    &lt;p&gt;But because Mozilla is convinced that generative AI is a force for good (with no evidence to back that claim up), they conclude that their mission must be to create "open source" alternatives to commercial ("big tech") offerings.&lt;/p&gt;
    &lt;p&gt;If you truly believe generative AI is a net good but with potential for significant harm, there are arguments to be made for ethical implementations. This same instinct is what propelled researchers from OpenAI to split and found Anthropic.&lt;/p&gt;
    &lt;p&gt;This, however, is an article of faith. It cannot be argued rationally because no empirical evidence exists to support it. The entirety of the belief is predicated on future potential—and it always will be, right up until the harms are so inescapably clear that even the most ardent of believers suffer because of them. Even then, not all of the Flock will lose faith. And as we now see, Mozilla leadership are not just the Flock, but Disciples.&lt;/p&gt;
    &lt;p&gt;Mozilla has had a conversion experience, while its core audience has not. This results in a schism of purpose.&lt;/p&gt;
    &lt;head rend="h2"&gt;The Actual Strategy&lt;/head&gt;
    &lt;p&gt;Digging into the plan itself, Mozilla's ambitions are remarkable. Mozilla has, as the plan notes, always measured itself against a "double bottom line" of mission and market success. However, it seems these two criteria are now separately defined by: "a. AI that advances the Manifesto; and b. diversifying revenue away from search."&lt;/p&gt;
    &lt;p&gt;Their specific goals include:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;All Mozilla orgs have a flagship AI product by 2028&lt;/item&gt;
      &lt;item&gt;10% year-over-year community growth&lt;/item&gt;
      &lt;item&gt;20% year-over-year growth in non-search revenue&lt;/item&gt;
      &lt;item&gt;3 Mozilla orgs have more than $25M in revenue (currently: 1)&lt;/item&gt;
      &lt;item&gt;10% year-over-year investment portfolio returns&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;I am dumbfounded by these goals. I can't even be snarky about them. They seem so disconnected from reality that I can't imagine how a Board arrived at them.&lt;/p&gt;
    &lt;p&gt;Let's go through them one at a time.&lt;/p&gt;
    &lt;head rend="h3"&gt;"Flagship" AI Products&lt;/head&gt;
    &lt;p&gt;What "orgs" are we talking about here? Historically there have been two Mozilla organizations: the Mozilla Foundation, which is the not-for-profit to which you donate to preserve the open web); and the Mozilla Corporation, which develops Firefox, makes deals with search engines, and creates other revenue-generating projects like, uh, Pocket.&lt;/p&gt;
    &lt;p&gt;There now exist three other for-profit subsidiaries of the Foundation, although these are not mentioned in the official listings. The first is MZLA Technologies Corporation, which is responsible for Thunderbird. I can't tell what else they do, if anything.&lt;/p&gt;
    &lt;p&gt;Another is Mozilla.ai, which has a much clearer purpose. This company produces AI products and services. So of these organizations, 3 of them need to have flagship AI products by 2028. What could that possibly look like?&lt;/p&gt;
    &lt;p&gt;There is also Mozilla Ventures, which is literally just a venture capital firm throwing money at AI projects that align with Mozilla's Manifesto.&lt;/p&gt;
    &lt;p&gt;Mozilla.ai has the easiest and clearest road, as their Agent Platformis already in early access and is absolutely a commercial product. MZLA has...Thunderbird? So AI-powered Thunderbird? That's what I can figure, although Thunderbird is not exactly known as an AI platform. Their new paid Thunderbird Pro service currently makes no mention of AI integration. That's a headscratcher. Mozilla VenturesAnd finally, we have the Corporation and Firefox.&lt;/p&gt;
    &lt;p&gt;Let's be as clear as we can possibly be. Mozilla is an AI company, and Firefox will be a flagship AI product according to this strategic plan. This is the focus for Mozilla, which means users of Firefox will only get more and more AI shoved down their throat, and likely fewer ways to avoid it.&lt;/p&gt;
    &lt;head rend="h3"&gt;Community Growth&lt;/head&gt;
    &lt;p&gt;I don't have access to Mozilla's "community" numbers, however they choose to define them. But if the reaction to recent changes is any indication, expecting growth of any kind isn't just optimistic, it's delusional. They are betraying the principles of their core use base in favor of their new god. That behavior is usually not rewarded by users or customers.&lt;/p&gt;
    &lt;head rend="h3"&gt;Financials&lt;/head&gt;
    &lt;p&gt;While I don't have access to community numbers, the Mozilla Foundation must disclose its financials, so that I can review—and you can too, if you're broken like me. I don't want to think about how much time I've spent reading Mozilla's 990s.&lt;/p&gt;
    &lt;p&gt;Looking at their revenue change from 2022 to 2023, we see a drop of 3% in royalties (search deals) and almost 15% in subscriptions and advertising. Let's also note that by these counts, royalties account for about 76% of Mozilla's annual revenue. That's by my own calculation on these disclosure, but Mozilla themselves cite 85% as share of revenue from search alone.&lt;/p&gt;
    &lt;p&gt;2022's numbers show a similar drop (down 3% from 2021) in royalties, but a 25% (!!) jump in subscriptions and ad revenue. My guess is ads, since I don't think the VPN service is raking it in, nor do I think a bunch of people suddenly signed up for Pocket before it died. This would certainly explain why last year, Mozilla went hard on their "privacy-honoring" advertising acquisition.&lt;/p&gt;
    &lt;p&gt;Zooming back out: the current business model is not delivering growth. So the pivot to AI is a bet that investment is out there for alternative sources of AI technology. It's also, tacitly, a bet that the AI bubble will last long enough to get competing products off the ground and attract investment before it's too late.&lt;/p&gt;
    &lt;p&gt;I...wouldn't be so sure.&lt;/p&gt;
    &lt;p&gt;As far as their investment portfolio's performance, Mozilla has changed their strategy significantly in the last 3 years, resulting in significant increases in dividend and realized gains in investments. What's the change in strategy?&lt;/p&gt;
    &lt;quote&gt;
      &lt;p&gt;At the end of 2022, Mozilla changed our strategy for managing our financial reserves. In prior years we took a purely defensive approach, investing solely in highly liquid fixed-income securities. Our revised approach is focused on delivering a total return to Mozilla after inflation, while maintaining sufficient liquid reserves to weather economic pressures and seize growth opportunities.&lt;/p&gt;
    &lt;/quote&gt;
    &lt;p&gt;Translation: we invested more in stocks and less in bonds, T-notes, and CDs. What specifically they've invested in is unclear, but you can probably guess it rhymes with Blavidia. I'm sure they have a diversified portfolio, but if you believe (as I do) that the market is heading for a massive correction, this goal is unattainable and a dangerous target for a strategic plan.&lt;/p&gt;
    &lt;p&gt;Lastly, on revenue. Mozilla plainly has to diversify away from search, because search is dying. Google itself is trying to kill it, in favor of AI. If this succeeds, Firefox's primary revenue stream is drying up, and they know it. More than anything else, this is the reason for the pivot. As I've said before, the will to survive takes precedence over principle when choosing a path forward for any organization, even a not-for-profit with a stated mission.&lt;/p&gt;
    &lt;p&gt;These goals are not so much reasonable expectations as existential mandates. Either Mozilla approaches these targets in 3 years, or they may be staring death in the face.&lt;/p&gt;
    &lt;head rend="h2"&gt;Flawed Hypotheses&lt;/head&gt;
    &lt;p&gt;This strategy hinges on three stated hypotheses from Mozilla:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;A generational shift in human computer interaction is widening the gap between Mozilla’s products and trustworthy, user-centered experiences.&lt;/item&gt;
      &lt;item&gt;A vibrant, successful and decentralized open source AI ecosystem is essential if we want independent tech players to thrive — and for innovation to come from everywhere.&lt;/item&gt;
      &lt;item&gt;The growing need for sovereign, public interest AI which will only be met by governments and public interest tech players pooling resources and banding together.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;That's...okay. We'll take it from the top.&lt;/p&gt;
    &lt;p&gt;Would you say generative AI is a "generational shift in human computer interaction?" The Corpos want it to be, but so far this hasn't taken place. Declaring it thus is the wish becoming the father of the thought. Maybe someday a functional language model will govern our interaction with computing machines, but that is nowhere near the case now, and the fundamental flaws in the technology preclude it from being so in the foreseeable future.&lt;/p&gt;
    &lt;p&gt;Would you say generative AI is "trustworthy" or "user-centered?" The people who implicitly trust generative AI are suffering from psychosis. It's a pathology. The model creators themselves tell you not to trust them! What are we doing here?&lt;/p&gt;
    &lt;p&gt;Y'know what is trustworthy? A goddamned URL bar that takes me to the website I want to go to. A search engine that shows me sources, ideally curated for quality.&lt;/p&gt;
    &lt;p&gt;Okay so hypothesis 1 doesn't pass the sniff test. On to number 2.&lt;/p&gt;
    &lt;p&gt;Can someone please explain to me what the hell "open source AI" is? Mozilla's helpful Strategy Wiki lists Mozilla's own products and investments under this category. Remember that for LLMs, you have two major "source" components: the dataset on which a model was trained, and the resulting vectors/weights file that comprises the model. Among them is HuggingFace, which is probably best understood as GitHub for AI. HuggingFace hosts both models and datasets used in ML/AI applications. It's about as close to open source AI as I can imagine.&lt;/p&gt;
    &lt;p&gt;Some of those HuggingFace datasets are really useful. Like, for example, the OCRed version of the Epstein Files. That's rad as hell, and I'm glad there's a place to share those things. It's even a goldmine for researchers like me, since datasets containing model jailbreaking prompts are available.&lt;/p&gt;
    &lt;p&gt;But let's be clear about Mozilla's value proposition of the "transformative" generative AI. These are not small models we're talking about; these are large language models that were trained on massive corpora of text. Those corpora are the "source." We know that the training data for frontier models comes from copyrighted material and material scraped without consent. We also know that code generated from scraped sources may well violate the licenses of that source code in reproduction.&lt;/p&gt;
    &lt;p&gt;In other words, there can never be an open source large language model when the sources are themselves violate of content usage agreements. For all the talk about "ethical" AI, Mozilla fails to address this original sin of the technology.&lt;/p&gt;
    &lt;p&gt;I'm sorry, I should say "nearly fails." In the "Threats" section of their SWOT analysis of their own strategy, they identify "Open models disappear" as a threat:&lt;/p&gt;
    &lt;quote&gt;
      &lt;p&gt;Big tech / China stop releasing open models. No public open source frontier models emerge. Mozilla’s strategy is obsolete / outflanked.&lt;/p&gt;
    &lt;/quote&gt;
    &lt;p&gt;Okay so by "open source AI" you actually mean Qwen/Deepseek/Llama. Cool. Cool cool cool. These are open weight only, so the premise of open data goes out the window. And this threat gives away the fact that Mozilla can only succeed on the backs of frontier models. There is no real plan to "democratize" LLMs, nor can there be for the scale required.&lt;/p&gt;
    &lt;p&gt;This entire exercise is a farce. Yet again, Mozilla pursues a parasitical relationship with the corpos. It worked last time, right??&lt;/p&gt;
    &lt;p&gt;Hypothesis 3: the growing need for "sovereign" AI. We've already established that there is no large language model possible without corpo scale and investment, except perhaps with government support. So is that what Mozilla wants? State-sponsored LLMs? This hypothesis points in that direction, with Mozilla as the "public interest tech player" catching a percentage somewhere in the middle. Being a government intermediary is also probably not a safe position for anyone at this juncture, much less a tech company.&lt;/p&gt;
    &lt;p&gt;But also, what "need" are we talking about here? Why is there a need for any of this at all?&lt;/p&gt;
    &lt;p&gt;Again we encounter the fundamental schism of purpose between Mozilla trying to survive, and the mission its core audience believes in. You could imagine a Mozilla that decided, "Actually, the web was better without this dreck in it, and the experience of the web is not improved by moving users closer to it." You could imagine an organization that doubled down on true privacy, and a human-centered web. We'll never know what kind of funding streams such an organization could build, because Mozilla has chosen the machines over people. They have chosen quick revenue over long-term sustainability.&lt;/p&gt;
    &lt;p&gt;It's finally time you and I take the advice I offered before: let Mozilla die. It no longer serves its stated purpose.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=46017910</guid><pubDate>Sat, 22 Nov 2025 20:21:56 +0000</pubDate></item><item><title>The Go-Between</title><link>https://theamericanscholar.org/the-go-between/</link><description>&lt;doc fingerprint="7e5099718aa091f3"&gt;
  &lt;main&gt;
    &lt;head rend="h1"&gt;The Go-Between&lt;/head&gt;
    &lt;p&gt;One of America’s most celebrated women war correspondents walked a fine line between journalism and espionage&lt;/p&gt;
    &lt;p&gt;Late in August 1939, just before Germany invaded Poland, the Chicago Daily News broke an ironclad policy to make the American reporter Helen Paull Kirkpatrick its first and only woman correspondent abroad. She was nearly 30 and had been living in London since 1937 after two years in Geneva, circulating with patrician ease among the native and expat upper classes. With two English colleagues, she had cofounded The Whitehall Letter, a successful weekly digest of world affairs with a strong antifascist bent, and on her own wrote two books: one about Prime Minister Neville Chamberlain and the prewar Munich Agreement, the other about the British after the war began. She also started an American edition of the newsletter run by her younger brother, Lyman Bickford Kirkpatrick Jr., whose eventual experiences in the American intelligence apparatus would figure heavily in her own working life.&lt;/p&gt;
    &lt;p&gt;Helen Kirkpatrick’s start date in the Daily News London bureau could not have been better timed. The Duke and Duchess of Windsor had just returned to England after a period of semi-exile in France. By way of Helen’s frequent weekends with Waldorf and Nancy Astor at Cliveden and with Ronald and Nancy Tree at Ditchley Park, she happened to know something most others did not: that the Windsors were staying at South Hartfield House, the grand home of Edward Dudley Metcalfe, the duke’s former equerry, whom she also happened to know. Bill Stoneman, the Daily News London bureau chief, thought her foolish to trek the 40 miles south to Sussex in what was sure to be a failed attempt to interview the Duke of Windsor—the man who had been the nation’s king until abdicating the throne in 1936. But off she went. She arrived at twilight, buoyed with anticipation until it emerged that the duke had already declared that he would not give interviews during his stay. And yet, struck by the dismay on the face of this visitor, the duke devised a gallant way to both keep his word and salvage Helen’s hopes for a triumphant debut in the Daily News—and the many other papers that subscribed to its well-regarded foreign news service. “He seemed to have decided that even though I was not to be allowed to interview him, he would interview me,” she wrote. Her story appeared on page two, September 18, 1939, under the headline, “Duchess of Windsor to Run Hospital, Duke May Join Army.”&lt;/p&gt;
    &lt;p&gt;This flashy little royal scoop became the first of scores of exclusives during Helen’s seven years with the paper, most of them far more substantive in news value. For her first anniversary on staff, the editors featured her in a five-column promotional house ad titled “War and a Woman,” which called her articles “clear as crystal, accurate as a radio beam, prompt as the crashing impact of the happenings they record”; her dispatches arrived in Chicago by cablegram at “machine-gun tempo”—three, four, sometimes five times a day. Her beat was all of England and Ireland and General Charles de Gaulle and his London-based Free French Movement. Later, there would be lengthy forays to Algeria, Italy, France, Germany, and elsewhere in Europe—wherever war news flowed.&lt;/p&gt;
    &lt;p&gt;Least known to the public among her journalistic virtues, the ad disclosed, was how often her stories had to be “splashed across eight-columns, front page headlines, without a hint of credit to the razor-edged intelligence that rifled them home.” For example, eight days before the German blitzkrieg of May 10, 1940, Helen was alone among correspondents to report that King Leopold III of Belgium had privately informed the U.S. government that the Germans were sure to invade his country next. Clearly to avoid linking the news to Helen or revealing how or where she had obtained the information, the story ran buried in a column of items under someone else’s byline, attributed only to “private sources in Chicago.” The point was, the impeccable confidential sources cultivated by “Our Helen,” as Daily News headlines would sometimes dub her in the years to come, were either newsmakers themselves or those just as likely to know of what they spoke. “Not even now,” the ad went on, “—not until war and war’s tongue-stilling offspring, strict censorship, have lifted—can the complete story of Helen Kirkpatrick’s incredible war coverage be told.”&lt;/p&gt;
    &lt;p&gt;It is fair to say that as a class, American women correspondents during World War II were not held in particularly high regard, so Helen Kirkpatrick’s outsize ability to garner not only respect but also major governmental and military awards does conjure up questions. Of the more than 1,600 U.S.-accredited World War II correspondents, only 19 received the coveted U.S. Medal of Freedom—and of those 19, Helen was the only woman. This despite similar barrier-breaking reportage by Margaret Bourke-White, Ann Stringer, Lee Carson, Lee Miller, Iris Carpenter, Marguerite Higgins, and others, none of whose names even appear in archived military lists of suggested nominees. How did she manage to have so much swift, direct access to so many top-line political, diplomatic, military, and intelligence sources? Was it just her keen reporting, or did the close social relationships she developed with important men set her apart?&lt;/p&gt;
    &lt;p&gt;Lyman Kirkpatrick’s time in Europe during the war either ran parallel to hers or was intertwined. And yet in her lengthiest latter-day interviews, references to her brother are few and casual. In his books, Lyman’s mentions of his sister were similarly spare. Both of their names appear in the wartime memoirs of friends and colleagues, but never in the same account. Only a careful rereading of the Washington Press Club Foundation’s oral history of Helen revealed an offhand mention of a brother in the CIA. Did Lyman’s rapid rise through the U.S. intelligence ranks figure in her successes, and if so, how? Had Helen broken with journalism’s established codes of conduct and crossed the line into espionage? In a more general way, the siblings’ connectedness during the war years casts a hazy light on how the realms of intelligence-gathering and major media reportage, meant to be strictly separate, have sometimes intersected in times of war and tyranny.&lt;/p&gt;
    &lt;p&gt;In interviews, Helen’s answers to questions about how she achieved such high recognition were veiled, self-deprecating. Sometimes she’d deflect. Did she do anything heroic? No, she’d reply, adding that she could not remember why she was honored by the French and with a U.S. Medal of Freedom or if she ever even knew the reasons. Check her papers at Smith College, she would suggest. They offer little. The questions lingered. For even her nearest living relations, they linger still.&lt;/p&gt;
    &lt;p&gt;The Kirkpatricks of Rochester, New York, were a prominent family, albeit no&lt;lb/&gt; longer monied by the time Helen and Lyman’s parents married. (They later divorced, then married each other again.) On their father’s side, the siblings were mindful and proud of a Scottish lineage that pre-dated Robert the Bruce; I Mak Siccar (“I’ll make sure”) was the family motto. Their maternal heritage came via the Paulls of Wheeling, West Virginia; they often spent holidays at the family home in Hawthorne Court in Woodsdale, on Wheeling’s outskirts. Their ancestors included Virginia unionists like Colonel James Paull, a soldier in the Revolutionary War, and Colonel Joshua Fry, who, alongside the father of Thomas Jefferson, created the original map of Virginia. A long list of judges, lawyers, military men, and other public servants followed.&lt;/p&gt;
    &lt;p&gt;With tuition help from grandparents and scholarships, and after a couple of time-outs for Helen for financial hiccups, both siblings completed their education with prestigious degrees. Helen attended The Masters School in Dobbs Ferry, New York, and then studied history at Smith, graduating Phi Beta Kappa in 1931; Lyman went to Deerfield and Princeton, where he majored in politics and graduated in 1938. Helen looked after Lyman like an ambitious other mother. In letters home, she lovingly mocked her parents’ adoration of him, which she shared, referring to him as “Little Man” or “Son.”&lt;/p&gt;
    &lt;p&gt;To intimates, Lyman went by Kirk; Helen, they called Pat. Seven years apart in age, they were as tall as they were driven, smart, and talented. Lyman was a handsome six-foot-five; Helen, a stately five-foot-10. Both were appealing in style and manner, always commanding notice. Her friend and colleague Ben Robertson found her “extraordinary” and “beautiful” with “a first-class mind” that she put to use, he later wrote, in “taking up matters with people at the top, with cabinet ministers and the like.” Her only known detractor in print was General Raymond E. Lee, a U.S. military attaché in London whom she met in December 1940. He found her “rather clever,” his journals record, but “far from being as attractive and alluring as she thinks she is.”&lt;/p&gt;
    &lt;p&gt;It was during her student days that Helen first spent time in Geneva, which fed her fascination with the comings and goings of the crowd that convened around the still-promising League of Nations. “There were all kinds of operators around,” she once said, “people whose jobs were a little obscure as to what they were. They were oil merchants or they were spies for one side or another. It was a very exciting place to be.” In the summer of 1935, she returned to the city as a tour leader for a group of high-school girls, but really to flee an unhappy marriage. “Not returning,” read the two-word transatlantic cable she sent to Victor Polachek Jr., the husband of two years she’d left behind in New York City. She found work writing policy papers for the Geneva Research Center, an affiliate of the Foreign Policy Association, and as a newspaper stringer who covered the League of Nations for the New York Herald-Tribune and a few other American and British papers. That she spoke French was an enormous advantage, she said, but not monetarily. She lived on Brussels sprouts and cottage cheese.&lt;/p&gt;
    &lt;p&gt;By 1937, Helen was 28. Most journalists of her era and caliber would have advanced to staff positions with journeymen status by that age, but she had not yet hit her stride. Her working life had zigzagged a few times before she settled in Europe: There was the year she spent with her mother in a management training program at Macy’s; her nondegree graduate study on a fellowship in Geneva; the marriage to Polachek, during which they lived in a charming but oh-so-narrow three-story townhouse in Greenwich Village, once rented for a couple of years by Edna St. Vincent Millay and her husband. Through the Polacheks’ next-door neighbors, Osgood and Alice Field, Helen had taken a job helping to organize an exhibition on Soviet education at the Museum of Natural History. This was under the auspices of the Soviet All-Union Society for Cultural Relations with Foreign Countries, also called VOKS. However, the Communist Party affiliation of many of its members left her dubious and made her steer clear of any further involvement with the organization.&lt;/p&gt;
    &lt;p&gt;In Geneva, her stringer status meant that her copy appeared unsigned. Newspaper archives yield her name only once from those days: She is quoted in other reporters’ stories about the July 4, 1936, suicide of Štefan Lux, a Czech journalist who shot himself in the assembly room of the League of Nations to protest the League’s inaction on Germany’s treatment of Jews. Of the League’s reporters, only Helen—“an American girl attached to the Geneva Research Center,” The New York Times called her—was within sight of Lux and within earshot of his last words: “C’est le dernier coup.” To have no outlet that would publish her firsthand report, she later said, was especially frustrating.&lt;/p&gt;
    &lt;p&gt;Victor Gordon-Lennox, a well-born diplomatic correspondent for The Daily Telegraph, often reported from Geneva. It was he who persuaded Helen to join him and Graham Hutton of The Economist in the Whitehall Letter venture in London. For Helen, this was a fresh and appealing opportunity. In part, she owed her swift entrée into London’s sought-after social circles to “V.G.L.,” as letters home so often refer to him in reports of her weekends and glittering evenings out.&lt;/p&gt;
    &lt;p&gt;Meanwhile, the timing of Helen’s move to London coincided with intensified familial concern over young Lyman’s professional prospects. Helen was in the best position to help. The summer after his graduation from Princeton, he went biking in England with a college mate. This was when the siblings’ adult lives began to converge. Helen introduced Lyman to Kermit “Kim” Roosevelt, son of Theodore by his second marriage, who was seeking a summer tutor to prepare his son, Dirck, for admission to Groton. Helen would later say Lyman’s fine manners got him the position over several Rhodes scholars. Living with the Roosevelts meant that Lyman needed the right clothing—a tux, for example, which would have taken too long to arrive from home. Helen arranged to borrow one from someone at the U.S. Embassy. “The name escapes me,” Lyman wrote years later, “but my foggy recollection is that it might have been a tuxedo of the ambassador himself.” And yet, Ambassador Joseph P. Kennedy stood five inches shorter than Lyman, so perhaps not. Helen also sent her brother new white flannels and tennis shirts. “He’s coming to town one day soon [to] be fitted for a suit and have some tweed he got in Scotland made into another jacket,” she wrote home. Once Lyman was back in the United States that September, a Princeton connection recommended him to David Lawrence, who hired him for his company, United States News, the eventual publisher of U.S. News &amp;amp; World Report. Lyman edited the U.S. edition of The Whitehall Letter on the side, with typing and administrative help from his wife, the former Jeanne Barclay Courtney, whom he married in February 1939.&lt;/p&gt;
    &lt;p&gt;In London, Helen knew both William “Wild Bill” Donovan and David K. E. Bruce well. Donovan headed up the Office of the Coordinator of Information, known as the COI, which evolved into the Office of Strategic Services, the OSS. He once tried to recruit her to the agency, but as she later told an interviewer, her response was, “To do what?” Donovan said he didn’t know, but he would find a spot for her. She declined, telling him she thought she was as useful to the war effort doing what she was doing as she would be in the OSS. Bruce, whom she met when he first arrived in England as chief representative of the American Red Cross, served both the COI and OSS as London branch chief and deputy executive director. Published entries from his diaries mention Helen innocuously only a couple of times, but his biographer described her as Bruce’s old friend, who often joined him at the home of Nancy and Ronald Tree.&lt;/p&gt;
    &lt;p&gt;In August 1940, Bruce, then still with the Red Cross, would go with Helen and other correspondents to Shakespeare Cliff, facing the Dover Strait, to watch the RAF fighters confront the invading Luftwaffe overhead. The memoirists among them later name-dropped their colleagues in passages about these deeply affecting days. “We lived in expectation of a full German attack any night,” Vincent “Jimmy” Sheean wrote, “and the nerves of some of our friends grew so exacerbated by suspense that they actually said they would welcome it.” Not Helen; she was steely, and was in fact first to suggest the Dover vigils. Ben Robertson said that by then she had already become one of the best American journalists, woman or man, “and in the weeks that were to follow she was to add to her already established reputation.”&lt;/p&gt;
    &lt;p&gt;Another crucial contact of Helen’s was David Gray, the “openly pro-British” U.S. minister plenipotentiary to Ireland. She stayed with the Grays whenever she was in Dublin, which was often. It was Gray who told her, as she reported on June 12, 1940, how much evidence there was of German infiltration in Ireland. She mentioned the tide of fifth columnists who secretly wanted a British defeat, although she does not attribute her source. To avoid Irish censorship, she filed the story with a Dublin dateline once she got back to England. Ireland’s minister in Washington, Robert Brennan, wrote to the editor, conveying his country’s ire and calling out what he said were misstatements in the story. The Daily News published his missive promptly, adding this note: “Miss Kirkpatrick’s article was based on careful investigation in England and in Eire, and, The Daily News has no reason to doubt the accuracy of her reports. It is obvious that a diplomat in Washington cannot be better informed on London opinion than a resident correspondent in London.”&lt;/p&gt;
    &lt;p&gt;For Helen, breaking stories for the Daily News enlarged her already formidable social standing and long list of contacts and sources who cultivated her as eagerly as she cultivated them. What she gleaned during a Christmastime weekend at Ditchley Park in 1940 about secret negotiations between Britain and Vichy France almost got her thrown out of England. Another guest told her that Vichy had said it would not aid the Nazis in attacking Britain; Helen reported it, enraging Winston Churchill. “Miss Helen Kirkpatrick should be shipped out of the country at the earliest moment,” the prime minister’s minutes record. “It is very undesirable to have a person of this kind scouting about private houses for copy regardless of British interests.” Duff Cooper, the British minister of information, whom Helen considered “a great close personal friend,” vouched for her; the prime minister reconsidered.&lt;/p&gt;
    &lt;p&gt;In Dublin late in the summer of 1941, David Gray tapped Helen to take a secret message to London and hand it to Britain’s cabinet minister for the colonies. It concerned a scheme devised by Gray and Sir John Maffey, Britain’s chief diplomatic representative to Ireland, to force the Irish into the war or at least to give up some rights. Helen obliged, despite the line-crossing this involved. By Gray’s mistake, however, a copy of the memo ended up in an envelope sent to Joe Walshe, the secretary of the Irish Free State’s Department of External Affairs—Gray had meant to send him only a copy of one of Helen’s articles from Dublin. “Well, the fat was in the fire,” she recalled. Even in wartime, for a correspondent to be seen as engaging in the trading of unpublished information or in espionage of any sort was and is a clear violation of every established journalistic code of ethics. Especially in conflict situations, any insinuation of such a sideline, even a comment tossed off in jest, could be as destructive to a reporter’s reputation inside the press corps as it was potentially lethal outside it.&lt;/p&gt;
    &lt;p&gt;Gray, knowing his telephones were bugged, traveled to Belfast to call Helen about what had happened and then wrote to her to apologize for putting her in such a terrible position. He offered to resign or do whatever she suggested because, he wrote, “I never can square myself for this stupidity.” She told him she was the expendable one, not he. In the end, nothing came of the episode beyond the doubt it sowed in the minds of Dubliners that Helen “was at least an intelligence officer or a spy. And,” she recalled, “I was treated that way.” The British, she said, were especially dubious of Americans who traveled often between England and Ireland, and the IRA went so far as to accuse her of being the harbinger of an American invasion of their country. “But I continued to go regularly,” she said, “and I became quite good friends with the man in the Foreign Office.”&lt;/p&gt;
    &lt;p&gt;It remained Helen’s style, at every opportunity, to share with officials among the Allies whatever she had learned that they might be able to make good use of, sometimes preparing lengthy unrequested written memos about hard-won information, reports that just as often went nowhere. The Americans were invariably unreceptive—“We have our own sources” was the official attitude, Helen would later say—but the British and French were keen to learn whatever they could. Years later, she would reflect on the “strong feeling” she and Lyman shared about “the importance of intelligence, of knowing what’s going on, and finding out from people, asking what they’ve seen, what they’ve heard. Then you evaluate it as to whether it’s of real interest or not.”&lt;/p&gt;
    &lt;p&gt;Given these predilections, it is not surprising that Helen would see intelligence as a career route for Lyman, if not for herself. Once again, she flung a handful of sisterly pixie dust onto her brother’s job prospects. “I’ve cast a few flies in [the COI’s Bill] Donovan’s direction with no results so far,” she wrote to her brother in Washington early in January 1942, just weeks after Pearl Harbor was attacked and after the Naval Reserve Air Force rejected his enlistment because he was red-green colorblind. “Everyone in the service branches of the [U.S.] embassy has suddenly blossomed into uniform, etc., and our English friends have ceased to be polite. … Most of us here wanted to get home—or into some job other than our present ones.” However, she went on, the U.S. Ambassador, John G. Winant, “asked us all to sit still and keep on with what we’re doing for the time being.” Helen felt out David Gray to see whether he could make use of her in Dublin, but he demurred, affirming her own growing sense that she was better off where she was. From Colonel Frank Knox, her publisher, came cajoling affirmation. “I can think of no war work in which a courageous and intelligent woman could be engaged that would be more valuable to the country in the present circumstances than that you are doing for us,” he wrote. “Us” in this case seems to have meant more than the foreign news service of the Chicago Daily News: In 1941, Knox had also become the secretary of the U.S. Navy.&lt;/p&gt;
    &lt;p&gt;Two months later, Lyman, still at his publishing job in Washington, got a call from Helen’s friend David Bruce, whom Lyman had met back in 1940. Bruce offered Lyman a post with the COI. Lyman later wrote of some “flattering and undeserved attention” that had come his way, at about the same time, from Colonel Knox himself, the Navy secretary–cum–Daily News publisher. This happened via Bill Stoneman, Helen’s London bureau chief, who mentioned to Knox the Navy’s rejection of Lyman. Knox then called Lyman into his office and offered to rescind the decision, but by that point, Lyman had accepted the job with the COI. Knox cautioned Lyman against “that crazy outfit” but did not convince him otherwise. Knox further offered to help if Lyman changed his mind.&lt;/p&gt;
    &lt;p&gt;That, in essence, is how their world worked.&lt;/p&gt;
    &lt;p&gt;Lyman was soon deployed to London and later to the continent as the COI became the OSS. He was considered a master at postmortem assessments, a specialty that years later would include a seminal report on the failed Bay of Pigs invasion of 1961. Among his wartime assignments was the task of traveling with the 12th Army as General Omar Bradley’s briefer. He also worked in close liaison with the French and Belgian resistance, serving as a conduit for intelligence reports on the resistance and from OSS agents to the 12th Army Group.&lt;/p&gt;
    &lt;p&gt;His duties included giving the enemy order of battle at morning briefings each day. According to Helen, General Bradley marveled at Lyman’s ability to reel off—from memory, without notes—the entire litany of intelligence gathered about German operations across and up and down the continent from one day to the next. One of Lyman’s favorite memories, meanwhile, involved General George S. Patton, who was often at Army group headquarters. Shortly before Christmas 1944, Patton asked for a briefing on when the Russian forces would be able to resume their offenses in the East, thus taking some pressure off the western front. The Russians shared little, despite repeated requests from SHAEF, the Supreme Headquarters Allied Expeditionary Force. As Lyman explained in his memoir, most information came from listening to German and Russian communiqués about the battles in the East “and then plotting the map based upon what seemed most plausible from what they were both saying and then balancing this with what was known from our own intelligence sources.” The intelligence team prepared an answer, which they provided close to New Year’s Day, when the generals had time to hear it. As the briefing concluded, Patton asked one question: “When do you think the Russians are going to launch their next offensive?” Lyman gave the reply. The second week in January, he said, based on the case study the team had prepared of the time lags between Soviet offensives, coupled with knowledge that in Poland, the Russians were along the bank of the Vistula and that they would want the river frozen to a sufficient depth to allow tanks to cross.&lt;/p&gt;
    &lt;p&gt;The Russians indeed launched on January 11. “The next time General Patton came to a briefing,” Lyman recalled, “he marched into the room, pointed directly at me, and said, ‘Brad, you’d better watch that fellow—he must be a Communist. He knew when the Russians were going to attack!’ ” Sometime later, Lyman learned of a pair of high compliments: that Patton asked Bradley to transfer Lyman to Patton’s staff and that Bradley declined.&lt;/p&gt;
    &lt;p&gt;For the D-Day invasion, 1944, Lyman and most of the OSS did not get to Normandy until “D-Day plus 17,” or June 23. That day, the Daily News carried a story from Helen datelined “Normandy Beachhead, June 21.” It appeared on the front page with an editor’s note above it, saying that she was among the first 10 women correspondents permitted to make an in-and-out visit to Normandy. Throughout the war, women reporters were forbidden to go closer to any front than the nurses were allowed to venture, although unauthorized breaches did occur. (Martha Gellhorn, for example, stowed away on a hospital ship to report the beginning of the D-Day invasion and lost her military privileges as a result.) In this case, the women arrived on an unarmed Douglas transport to pick up the American wounded. Throughout most of the days leading up to and after the invasion, Helen’s datelines were either London or some version of “Supreme Allied Expeditionary Force Headquarters in England.” Gossips passed word, and the Daily News reported that Helen “plays bridge with Eisenhower and Churchill calls her ‘The Kirk.’ ”&lt;/p&gt;
    &lt;p&gt;Not until July 11 was she more permanently in France. Above her first Cherbourg dateline, July 19, her editors trumpeted in italics that she was the “first war correspondent”— woman or otherwise—to be assigned to the headquarters of General Marie-Pierre Koenig, commander of the French forces of the interior. All that coverage of de Gaulle and the Free French had paid off. That day, she wrote home to say she “went up” to see Pete Quesada, the commanding officer of the Tactical Air Command, and that they called Lyman to join them for dinner. Lyman had grown a mustache that she mistook for dirt on his face but otherwise looked tanned and well. “We had fun,” she wrote, “just the three of us, and the mess wasn’t hard to take …”&lt;/p&gt;
    &lt;p&gt;Helen told in interviews of how, when on the continent, she would often attach herself to OSS teams “because even in Normandy and Brittany, they would go into Gestapo headquarters and pick up stuff.” In 1945, when the military authorized a group of reporters to cross the Rhine on a glider, Helen was on the list to go. That is, until Lyman, “of all the interfering characters, somehow got wind of it and saw that my name was taken off. Now you could say that was brotherly-sisterly or male-female, but I must say later I was awfully glad because they all got shot down.”&lt;/p&gt;
    &lt;p&gt;On the night of August 24, Helen rode behind General Jacques-Philippe Leclerc’s tanks as they entered Paris to liberate the city. The following day, she left the luncheon table of Ernest Hemingway, holding court at the newly liberated Ritz, to cover the parade, which culminated at Notre Dame with a memorial service reserved for the families of those who had died in the Resistance. There, inside the cathedral, she was alone among reporters who witnessed the failed assassination attempt on Generals de Gaulle, Koenig, and Leclerc. Years later, for an oral historian, Helen recalled how she had positioned herself standing up and hanging off a grille fence for a better view, when somehow the teeming crowd shoved her into the cathedral, just as the lights went out and the organ music stopped. “Suddenly there was some shooting and a man near me was hit,” she said. “They were shooting from the clerestory balcony. A Dominican monk appeared at the altar. Well, I am not a Catholic, but I knew that monks are not cathedral priests, and he led them in the Magnificat. Then they turned around and marched out.” The day after that, she reopened the Paris office of the Daily News as its new chef de bureau.&lt;/p&gt;
    &lt;p&gt;Lyman, for his war service, received the U.S. Legion of Merit, the Bronze Star medal, the European Theater Ribbon and five battle stars, and both the French and Belgian Croix de Guerre. For Helen, her U.S. Medal of Freedom covered the period from June 6, 1944, to May 8, 1945: D-Day to V-E Day. She also earned a European Theater Ribbon. From France, she won the Médaille de la Reconnaissance in 1945 and the country’s highest award, the Légion d’Honneur, in 1947—along with three men and Janet Flanner, the Paris-based New Yorker writer known in print as Genêt.&lt;/p&gt;
    &lt;p&gt;Why, of all the women who distinguished themselves as World War II correspondents, was Helen the only one singled out for the U.S. military’s highest recognition? It could be that her consistent access to solid, privileged information and her “I-was-there” reporting are the only explanations. All of the Medal of Freedom honorees were cited “for exceptionally meritorious achievement, which aided the United States in the prosecution of the war against the enemy in continental Europe.” Helen’s citation went on to describe her courage, how she “never hesitated to face danger in the pursuance of her profession,” and how her “objective interpretation of military operations and particularly of the renaissance of occupied France not only contributed to understanding of the problem in the mind of the American public but also went far to promote good Allied relations, thereby meriting the praise and recognition of the United States.” How so exactly? Is there more to what Helen did than her citation describes?&lt;/p&gt;
    &lt;p&gt;Once asked by an oral historian about the awarding of the French Légion d’Honneur, Helen remembered the luncheon at the Quai d’Orsay, hosted by Suzanne Borel Bidault, the wife of Foreign Minister Georges Bidault, a figure in the Resistance, and the first French woman to become a diplomat. But Helen said she did not know why she had received it. “I suppose because I had been reporting on the Free French and de Gaulle was president at that point,” she said. “I was known as a strong advocate of France during the war and was in France then, had been there as a correspondent; they gave a number of them to correspondents,” she said. “It was sort of handed out, you know. An awful lot of French have them.” She said she suspected that her friend the baron Louis de Cabrol might have initiated the Médaille de la Reconnaissance because she “plucked him out of a British hospital” and got him into an American one, where a surgeon “saved his knees so that he was able to walk and ride horseback thereafter. I don’t know. I never knew, and, as a matter of fact, I don’t recall it being presented. Maybe it was.”&lt;/p&gt;
    &lt;p&gt;Lyman, after the war, returned briefly to his postcollege job in magazine publishing but then joined the CIA at its formation in 1947. In time, he would become the agency’s inspector general and after that, executive director, its number-three position, despite the polio that left him paralyzed from the waist down in 1952. When he left the agency at age 48 in 1964, he received the President’s Award for Distinguished Federal Civilian Service and the CIA’s Distinguished Intelligence Medal, an honor that had been conferred at that point no more than a dozen times. The letters of nomination, although considerably more restrained in style than the praise lavished on his sister in the Chicago Daily News, are comparable as indications of the respect and admiration he commanded. “Of all the recipients of this medal known to me,” one nominator wrote, “none has given to the CIA and the intelligence community the dedicated, selfless devotion to duty over such a long period of time as Kirk.”&lt;/p&gt;
    &lt;p&gt;The Daily News foreign service started to decline in the period after Colonel Knox’s death on April 28, 1944, so Helen and others from their Europe-based team went to the New York Post, starting late in 1946. During the transition, Helen traveled to Moscow with her good friend and the new U.S. ambassador to the Soviet Union, Walter Bedell Smith, and his wife. A long memo followed but nothing publishable, since any reporting could be tied too closely to the new ambassador. Two years later, in 1950, Smith became Lyman’s boss as director of the CIA, succeeded by Allen Dulles.&lt;/p&gt;
    &lt;p&gt;For Helen, the New York Post of 1947 could not have been a worse fit; the lighter assignments favored by editors annoyed her, as did the way they handled and displayed what she wrote. And yet, despite her stunning résumé, repeated efforts to land another newspaper job failed. No one seemed to have a place for Helen Kirkpatrick. She went to work for the U.S. State Department, first at Voice of America, then as communications director in France for the Economic Cooperation Administration, which administered the Marshall Plan. In Paris again, she worked first for her old friend David Bruce, and then for Barry Bingham when Bruce became the U.S. ambassador to France.&lt;/p&gt;
    &lt;p&gt;Back in Washington, as a since-declassified document of April 17, 1951, records, then–CIA director Allen Dulles had lunch with “Miss Helen Kirkpatrick, State Department DD/P and Mr. Lyman Kirkpatrick.” Days later, she had a new post in Washington as public affairs adviser to the U.S. assistant secretary of state for European Affairs, a job that involved frequent travel abroad.&lt;/p&gt;
    &lt;p&gt;Helen left the State Department in 1953—her appointments were always temporary, although she tried several times for civil service status—to become assistant to the president of Smith College and soon the second wife of Robbins Milbank, a widower and Smith College trustee. She continued to lecture and appear on panels about the war, staying in touch with her legions of contacts, just as she had been doing since her first of many U.S. speaking tours in 1937.&lt;/p&gt;
    &lt;p&gt;Lyman, after leaving Washington, accepted an academic appointment at Brown and wrote two books about the CIA, examining his own experiences and the agency’s structure, strengths, and weaknesses. He died at 78 in 1995, two years before Helen, who lived to 88.&lt;/p&gt;
    &lt;p&gt;A genealogical search has led me to several living Kirkpatrick descendants. Among them, John Pitner, Helen’s great-nephew and one of Lyman’s grandsons, has the greatest sense of the family’s history and lore. He remembers well his grandfather’s study with its many photographs of Lyman posed with the famous, especially the one with General Patton. Although Lyman never shared his career experiences with Pitner directly, the grandson sensed his grandfather’s august personal history all the same. Lyman’s demeanor, Pitner said, was “stern,” almost the opposite of “Aunt Pat.” He recalled a trip to Jackson Hole she organized with him and another grandnephew, both preteens, when she was about 77. Both boys were in the back seat as she careened into the passing lane of the main two-lane road into town and whizzed past an interminable line of stalled traffic as the oncoming cars came perilously close. “You’re not going to make it,” the fly-fishing guide in the front passenger seat said. “Yes, I am,” she replied.&lt;/p&gt;
    &lt;p&gt;From his grandfather’s books, Pitner knew well the paramount importance Lyman placed on “keeping secrets secret. I’m certain [Helen] would have been of the same mind,” he said. “Also, her character was such that she didn’t brag or otherwise bring up her numerous exploits and connections unless specifically asked.” His mother, one of Lyman’s four children, had the same sense. Was his Aunt Pat a spy? She never spoke of the matter, and neither Pitner nor his mother has any knowledge about the question one way or the other. However, he said, neither of them would be surprised to learn that she was.&lt;/p&gt;
    &lt;p&gt;“I do see the potential for an interesting Hollywood story,” Pitner mused. “Given the lack of factual proof (thus far), it might include ‘based on a true story’ in the opening credits. At any rate, maybe you can send me an extra ticket to the premiere!”&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=46017934</guid><pubDate>Sat, 22 Nov 2025 20:24:17 +0000</pubDate></item><item><title>A Reverse Engineer's Anatomy of the macOS Boot Chain and Security Architecture</title><link>https://stack.int.mov/a-reverse-engineers-anatomy-of-the-macos-boot-chain-security-architecture/</link><description>&lt;doc fingerprint="278ad91e45e03b04"&gt;
  &lt;main&gt;
    &lt;head rend="h1"&gt;A Reverse Engineer’s Anatomy of the macOS Boot Chain &amp;amp; Security Architecture&lt;/head&gt;
    &lt;head rend="h2"&gt;1.0 The Silicon Root of Trust: Pre-Boot &amp;amp; Hardware Primitives&lt;/head&gt;
    &lt;p&gt;The security of the macOS platform on Apple Silicon is not defined by the kernel; it is defined by the physics of the die. Before the first instruction of &lt;code&gt;kernelcache&lt;/code&gt; is fetched, a complex, cryptographic ballet has already concluded within the Application Processor (AP). This section dissects the immutable hardware logic that establishes the initial link in the Chain of Trust.&lt;/p&gt;
    &lt;head rend="h3"&gt;1.1 The Reset Vector &amp;amp; Boot ROM (SecureROM)&lt;/head&gt;
    &lt;p&gt;The Apple Silicon boot process begins in a state of absolute trust, anchored by the Boot ROM (often colloquially referred to as SecureROM). This code is mask-programmed into the silicon during fabrication. It is immutable, unpatchable, and serves as the hardware root of trust for the entire platform.&lt;/p&gt;
    &lt;head rend="h4"&gt;1.1.1 Execution at Exception Level 3 (EL3): Analyzing &lt;code&gt;RVBAR_EL3&lt;/code&gt;&lt;/head&gt;
    &lt;p&gt;Upon Power-On Reset (POR), the cores of the M-series SoC (and A-series) initialize in the highest privilege state defined by the ARMv8/v9 architecture: Exception Level 3 (EL3).&lt;/p&gt;
    &lt;p&gt;While Apple does not utilize TrustZone in the traditional sense (preferring their proprietary Secure Enclave for secure world operations), the AP Boot ROM executes at EL3 to perform the necessary low-level hardware initialization that requires access to secure configuration registers that are subsequently locked or hidden from EL2/EL1.&lt;/p&gt;
    &lt;p&gt;The execution flow begins at the address defined in the Reset Vector Base Address Register (RVBAR_EL3). On recent Apple Silicon (M1/M2/M3), the memory map places the Boot ROM at a high base address, typically &lt;code&gt;0x100000000&lt;/code&gt;.&lt;/p&gt;
    &lt;p&gt;The Initial Instruction Stream:&lt;lb/&gt; The very first instructions executed by the silicon are responsible for establishing a sane C execution environment from a raw hardware state. A disassembly of the entry point typically reveals the following sequence:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Interrupt Masking: &lt;code&gt;DAIF&lt;/code&gt;bits are set to mask all interrupts (IRQ, FIQ, SError, Debug). The Boot ROM operates in a strictly polled mode; interrupts are nondeterministic and introduce attack surface.&lt;/item&gt;
      &lt;item&gt;Cache Invalidation: The instruction and data caches are invalidated to prevent cold-boot attacks or stale data usage.&lt;/item&gt;
      &lt;item&gt;Stack Setup: The Stack Pointer (&lt;code&gt;SP_EL3&lt;/code&gt;) is initialized to point to a dedicated region of on-chip SRAM (Static RAM). Note that DRAM is not initialized at this stage. The Boot ROM runs entirely within the constraints of the SoC's internal SRAM (often referred to as L2 cache-as-RAM in older exploits, though modern SoCs have dedicated boot SRAM).&lt;/item&gt;
      &lt;item&gt;MMU Configuration: The System Control Register (&lt;code&gt;SCTLR_EL3&lt;/code&gt;) is written to enable the MMU, mapping the Boot ROM text as Read-Only/Executable and the SRAM stack/heap as Read-Write/No-Execute.&lt;/item&gt;
    &lt;/list&gt;
    &lt;quote&gt;&lt;p&gt;RE Note: Apple’s implementation of EL3 is ephemeral. Unlike Android/Qualcomm devices where EL3 hosts a persistent Secure Monitor (QSEE), Apple Silicon demotes the exception level to EL2 (Hypervisor) or EL1 (Kernel) before handing off control to the next stage. Once the Boot ROM exits, EL3 is effectively locked out, and the&lt;/p&gt;&lt;code&gt;RVBAR_EL3&lt;/code&gt;is often locked to prevent re-entry.&lt;/quote&gt;
    &lt;head rend="h4"&gt;1.1.2 The GID Key (Group ID): Hardware-entangled Decryption&lt;/head&gt;
    &lt;p&gt;The Boot ROM's primary objective is to load the Low-Level Bootloader (LLB). However, the LLB stored on the NAND flash (or NOR SPI flash in some configurations) is encrypted. To decrypt it, the Boot ROM utilizes the GID Key (Group ID Key).&lt;/p&gt;
    &lt;p&gt;The GID Key is a 256-bit AES key fused into the silicon during manufacturing. It is shared across all processors of the same class (e.g., all M3 Pro chips share a GID, but it differs from the M3 Max).&lt;/p&gt;
    &lt;p&gt;The "Black Box" AES Engine:&lt;lb/&gt; Crucially, the GID Key is not accessible via software. There is no Memory-Mapped I/O (MMIO) register that an attacker can read to dump the key. Instead, the AES engine operates as a black box:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Input: The Boot ROM writes the encrypted ciphertext (the LLB payload) into the AES engine's input FIFO.&lt;/item&gt;
      &lt;item&gt;Control: The Boot ROM sets a specific control bit in the AES configuration register (e.g., &lt;code&gt;AES_CMD_USE_GID&lt;/code&gt;).&lt;/item&gt;
      &lt;item&gt;Operation: The hardware AES engine loads the GID key from the fuses directly into the crypto core, performs the decryption, and flushes the key from the internal registers.&lt;/item&gt;
      &lt;item&gt;Output: The plaintext is written to the output FIFO, which the Boot ROM then reads into SRAM.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;This architecture ensures that even if an attacker gains arbitrary code execution within the Boot ROM (as seen in the &lt;code&gt;checkm8&lt;/code&gt; exploit on older A-series chips), they cannot extract the GID key to decrypt firmware images offline. Decryption must happen on-device.&lt;/p&gt;
    &lt;head rend="h4"&gt;1.1.3 The Public Key Accelerator (PKA): Hardware-Enforced Verification&lt;/head&gt;
    &lt;p&gt;Decryption provides confidentiality, but not integrity. To prevent the execution of malicious firmware, the Boot ROM enforces strict code signing using the Public Key Accelerator (PKA).&lt;/p&gt;
    &lt;p&gt;The PKA is a dedicated hardware block optimized for asymmetric cryptography (RSA and ECC). The verification flow is as follows:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Root of Trust Hash: The SHA-384 hash of the Apple Root CA public key is burned into the device's eFuses. This is the immutable anchor.&lt;/item&gt;
      &lt;item&gt;Manifest Parsing: The Boot ROM parses the Image4 (img4) container of the LLB. It extracts the Image4 Manifest (IM4M), which contains the payload's signature and the public key used to sign it.&lt;/item&gt;
      &lt;item&gt;Key Verification: The Boot ROM hashes the public key found in the manifest and compares it against the hash in the eFuses. If they do not match, the boot halts (DRAM is never initialized, and the device enters DFU mode).&lt;/item&gt;
      &lt;item&gt;Signature Verification: The Boot ROM offloads the signature verification to the PKA. It passes the SHA-384 hash of the payload and the RSA/ECC signature. The PKA performs the mathematical verification and returns a boolean result to a status register.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Fault Injection Hardening:&lt;lb/&gt; Modern Apple Boot ROMs employ glitch-resistant logic around the PKA check. Rather than a simple &lt;code&gt;B.EQ&lt;/code&gt; (Branch if Equal) instruction following the PKA result—which could be bypassed via voltage glitching—the code often employs redundant checks, loop invariants, or specific register values that must be populated by the PKA hardware itself to allow the boot flow to proceed.&lt;/p&gt;
    &lt;head rend="h4"&gt;1.1.4 RE Focus: Dev vs. Prod Fused Silicon&lt;/head&gt;
    &lt;p&gt;For the reverse engineer, distinguishing between Development (Dev) and Production (Prod) fused silicon is vital. The behavior of the Boot ROM changes fundamentally based on the "Security Domain" fuse.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Production (CPFM 01): The standard consumer state. JTAG is physically disabled. The GID key is locked to the production value. The Boot ROM enforces the full Apple Root CA chain.&lt;/item&gt;
      &lt;item&gt;Development (CPFM 00/03): Used internally by Apple engineers. &lt;list rend="ul"&gt;&lt;item&gt;JTAG Enablement: The &lt;code&gt;DBGEN&lt;/code&gt;signal is asserted, allowing hardware debuggers (like Lauterbach or Astris) to halt the core immediately after reset.&lt;/item&gt;&lt;item&gt;Demotion: Dev-fused chips often allow "demotion," enabling the device to boot unsigned or custom-signed firmware images.&lt;/item&gt;&lt;item&gt;GID Key Variance: Dev chips often use a different GID key, meaning firmware encrypted for Prod devices cannot be decrypted on Dev hardware, and vice versa.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;JTAG Enablement: The &lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Identifying Silicon State:&lt;lb/&gt; You can identify the fuse status by querying the &lt;code&gt;CHIP_ID&lt;/code&gt; or &lt;code&gt;MOJO&lt;/code&gt; registers via USB when the device is in DFU mode.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;0x8000...&lt;/code&gt;usually indicates a Production fuse.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;0x0000...&lt;/code&gt;or specific bitmasks in the&lt;code&gt;ECID&lt;/code&gt;response indicate Development/Debug fusing.&lt;/item&gt;
    &lt;/list&gt;
    &lt;quote&gt;&lt;p&gt;The "Un-dumpable" Region:&lt;/p&gt;&lt;lb/&gt;Once the Boot ROM prepares to jump to the next stage (LLB), it performs a lockdown sequence. It writes to the memory controller to unmap its own address range (&lt;code&gt;0x100000000&lt;/code&gt;). Any subsequent attempt by the LLB or Kernel to read the Boot ROM address space will result in a bus error or read back zeros. This "hide-and-seek" mechanism is why dumping the Boot ROM requires a vulnerability present during the Boot ROM execution window (like&lt;code&gt;checkm8&lt;/code&gt;or a voltage glitch at reset).&lt;/quote&gt;
    &lt;head rend="h3"&gt;1.2 Proprietary ISA Extensions (arm64e+)&lt;/head&gt;
    &lt;p&gt;While the M-series chips ostensibly implement the ARMv8.6-A (and increasingly ARMv9) specification, Apple has aggressively extended the Instruction Set Architecture (ISA) with proprietary logic. For the reverse engineer, standard ARM documentation is insufficient. Understanding the security posture of macOS Tahoe requires mastering these custom extensions, as they form the hardware enforcement layer for the new kernel isolation model.&lt;/p&gt;
    &lt;head rend="h4"&gt;1.2.1 Pointer Authentication (PAC): The Cryptographic Control Flow&lt;/head&gt;
    &lt;p&gt;Apple’s implementation of ARMv8.3-PAuth is the most pervasive security mitigation in the XNU kernel. It repurposes the unused high-order bits of 64-bit virtual addresses (typically bits 63–47, depending on Translation Control Register &lt;code&gt;TCR_EL1&lt;/code&gt; settings) to store a cryptographic signature, or Pointer Authentication Code (PAC).&lt;/p&gt;
    &lt;p&gt;The Key Hierarchy:&lt;lb/&gt; The hardware maintains five distinct 128-bit keys in system registers, accessible only at EL1 or higher. These keys segregate pointer types to limit the utility of a signing gadget:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;APIAKey&lt;/code&gt;/&lt;code&gt;APIBKey&lt;/code&gt;(Instruction): Signs code pointers (function pointers, return addresses).&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;APDAKey&lt;/code&gt;/&lt;code&gt;APDBKey&lt;/code&gt;(Data): Signs data pointers. Crucial for protecting C++ vtables in IOKit (&lt;code&gt;OSObject&lt;/code&gt;).&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;APGAKey&lt;/code&gt;(Generic): Signs arbitrary data blobs, effectively a hardware-accelerated MAC.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The &lt;code&gt;AUT&lt;/code&gt; Failure Mechanism (Canonical Non-Valid):&lt;lb/&gt; For the reverse engineer analyzing crash dumps, understanding the failure mode is critical. When an &lt;code&gt;AUT*&lt;/code&gt; instruction (e.g., &lt;code&gt;AUTIA&lt;/code&gt;) is executed on a corrupted or forged pointer, the CPU does not immediately raise an exception.&lt;/p&gt;
    &lt;p&gt;Instead, the hardware corrupts the pointer in a deterministic way to ensure it causes a translation fault upon dereference.&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Validation: The CPU recalculates the PAC.&lt;/item&gt;
      &lt;item&gt;Mismatch: If the calculated PAC does not match the bits in the pointer, the CPU flips specific high-order bits (typically bit 62 for data pointers, or bit 61 for instruction pointers, depending on Top Byte Ignore settings).&lt;/item&gt;
      &lt;item&gt;Result: The pointer becomes "canonical non-valid." It looks like a kernel pointer (high address) but falls into a reserved, unmapped range.&lt;/item&gt;
      &lt;item&gt;Crash: The subsequent &lt;code&gt;LDR&lt;/code&gt;or&lt;code&gt;BLR&lt;/code&gt;triggers a Data Abort or Prefetch Abort.&lt;/item&gt;
    &lt;/list&gt;
    &lt;quote&gt;&lt;p&gt;RE Tip: If you see a crash where&lt;/p&gt;&lt;code&gt;x0&lt;/code&gt;is&lt;code&gt;0x007f...&lt;/code&gt;or&lt;code&gt;0x00ff...&lt;/code&gt;(a pointer with high bits set but not fully canonical), you are looking at a PAC authentication failure, not a standard NULL dereference or heap corruption.&lt;/quote&gt;
    &lt;head rend="h4"&gt;1.2.2 Branch Target Identification (BTI): The Landing Pads&lt;/head&gt;
    &lt;p&gt;Often deployed in tandem with PAC (&lt;code&gt;-mbranch-protection=standard&lt;/code&gt;), BTI mitigates Jump-Oriented Programming (JOP). It enforces a state machine on indirect branches.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Marking Pages: The Global Page Table (GPT) or PTE entries now include a Guarded Page (&lt;code&gt;GP&lt;/code&gt;) bit.&lt;/item&gt;
      &lt;item&gt;The &lt;code&gt;BTI&lt;/code&gt;Instruction: This is a "hint" instruction (NOP on older silicon). It acts as a valid landing pad.&lt;/item&gt;
      &lt;item&gt;Enforcement: When the CPU executes an indirect branch (&lt;code&gt;BR&lt;/code&gt;,&lt;code&gt;BLR&lt;/code&gt;) targeting a Guarded Page, the very next instruction must be a&lt;code&gt;BTI&lt;/code&gt;instruction of the correct type (&lt;code&gt;c&lt;/code&gt;for call,&lt;code&gt;j&lt;/code&gt;for jump,&lt;code&gt;jc&lt;/code&gt;for both).&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;If the target is not a &lt;code&gt;BTI&lt;/code&gt; instruction, the CPU raises a Branch Target Exception. In XNU, this manifests as a &lt;code&gt;SIGILL&lt;/code&gt; with a specific subcode. For exploit development, this necessitates finding gadgets that not only perform the desired operation but are also preceded by a valid landing pad.&lt;/p&gt;
    &lt;head rend="h4"&gt;1.2.3 New in Tahoe: The Guarded Execution Feature (GXF)&lt;/head&gt;
    &lt;p&gt;This is the most significant architectural divergence in the Apple Silicon era. Standard ARM defines a vertical privilege stack (EL0 -&amp;gt; EL1 -&amp;gt; EL2). Apple has introduced Lateral Exception Levels, referred to as Guarded Levels (GL).&lt;/p&gt;
    &lt;p&gt;GXF allows the processor to switch between execution modes that share the same architectural Exception Level (EL1) but possess vastly different hardware permissions and system register views.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;GL0: The standard XNU Kernel context.&lt;/item&gt;
      &lt;item&gt;GL1: The Trusted Execution Monitor (TXM) context.&lt;/item&gt;
      &lt;item&gt;GL2: The Secure Page Table Monitor (SPTM) context.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The Proprietary Opcodes:&lt;lb/&gt; Transitions are not handled by &lt;code&gt;HVC&lt;/code&gt; or &lt;code&gt;SMC&lt;/code&gt;. Apple added custom instructions to the ISA:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;GENTER&lt;/code&gt;(Opcode&lt;code&gt;0x00201420&lt;/code&gt;): Synchronous entry into a Guarded Level. It behaves like a function call but atomically switches the hardware context (SPRR state, stack pointer, and system registers).&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;GEXIT&lt;/code&gt;(Opcode&lt;code&gt;0x00201400&lt;/code&gt;): Returns from GL to the caller.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Reverse Engineering the Transition:&lt;lb/&gt; In disassembly, &lt;code&gt;GENTER&lt;/code&gt; takes a dispatch ID (selector) in &lt;code&gt;x15&lt;/code&gt; and arguments in &lt;code&gt;x0-x7&lt;/code&gt;. The entry point for the transition is hardcoded in the proprietary system register &lt;code&gt;GXF_ENTRY_EL1&lt;/code&gt; (S3_6_C15_C8_2). This register is locked early in the boot process (by iBoot), preventing the kernel from hijacking the monitor's entry vector.&lt;/p&gt;
    &lt;head rend="h4"&gt;1.2.4 New in Tahoe: Shadow Permission Remapping Registers (SPRR)&lt;/head&gt;
    &lt;p&gt;To enforce isolation between GL0, GL1, and GL2, Apple replaced the older APRR (Access Permission Remapping Registers) with the more robust SPRR (Shadow Permission Remapping Registers).&lt;/p&gt;
    &lt;p&gt;In standard ARM MMUs, the Page Table Entry (PTE) bits &lt;code&gt;AP[2:1]&lt;/code&gt; directly define Read/Write permissions. In Apple Silicon with SPRR enabled, these bits are repurposed as an index into a hardware permission table.&lt;/p&gt;
    &lt;p&gt;The Indirection Layer:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;PTE Index: The PTE specifies a permission index (e.g., Index 5).&lt;/item&gt;
      &lt;item&gt;Context Lookup: The hardware checks the current execution mode (GL0, GL1, or GL2).&lt;/item&gt;
      &lt;item&gt;Resolution: It looks up Index 5 in the &lt;code&gt;SPRR_PERM_EL1&lt;/code&gt;register specific to that mode.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The Security Implication:&lt;lb/&gt; This allows for "View-Based" memory protection.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Index 5 in GL2 (SPTM): Resolves to Read-Write (RW).&lt;/item&gt;
      &lt;item&gt;Index 5 in GL0 (Kernel): Resolves to Read-Only (RO).&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;This is how the SPTM protects page tables. The physical pages containing the translation tables are marked with a specific SPRR index. The hardware configuration for GL0 (Kernel) maps that index to Read-Only. Even if an attacker has a kernel-level arbitrary write primitive, the MMU will reject the write to the page table because the SPRR configuration for GL0 forbids it. The only way to write to that page is to execute &lt;code&gt;GENTER&lt;/code&gt; to switch to GL2, where the SPRR configuration permits the write.&lt;/p&gt;
    &lt;head rend="h2"&gt;2.0 The Secure Enclave Processor (SEP): The Parallel Computer&lt;/head&gt;
    &lt;p&gt;If the Application Processor (AP) is the brain of the device, the Secure Enclave Processor (SEP) is its conscience. It is not merely a coprocessor; it is a fully independent computer-on-a-chip, sharing the same die but architecturally severed from the AP. It runs its own kernel (an Apple-customized L4 microkernel), manages its own peripherals, and holds the keys to the kingdom (UID/GID). In the Tahoe architecture, the SEP’s role has expanded from simple key management to becoming the root of authority for biometric intent and hardware attestation.&lt;/p&gt;
    &lt;head rend="h3"&gt;2.1 SEP Initialization &amp;amp; Boot&lt;/head&gt;
    &lt;p&gt;The SEP boot process is designed to be resilient against a fully compromised Application Processor. From the moment power is applied, the SEP assumes the AP is hostile.&lt;/p&gt;
    &lt;head rend="h4"&gt;2.1.1 The SEPROM: SRAM Execution and the Memory Protection Engine (MPE)&lt;/head&gt;
    &lt;p&gt;Like the AP, the SEP begins execution from an immutable on-die Boot ROM, the SEPROM.&lt;/p&gt;
    &lt;p&gt;The Hardware Environment:&lt;lb/&gt; The SEP core (typically a customized ARM core, historically evolving from Cortex-A7 derivatives) initializes in a highly constrained environment. It does not initially have access to the system's main DRAM. Instead, it executes strictly within a dedicated, on-die SRAM region. This isolation prevents early-boot DMA attacks from the AP or Thunderbolt peripherals.&lt;/p&gt;
    &lt;p&gt;The Memory Protection Engine (MPE):&lt;lb/&gt; As the &lt;code&gt;sepOS&lt;/code&gt; is too large to fit entirely in SRAM, it must eventually reside in the device's main DRAM (Unified Memory on M-series). To do this securely, the SEP utilizes a hardware Memory Protection Engine (MPE).&lt;/p&gt;
    &lt;p&gt;The MPE sits inline between the SEP core and the memory controller. It creates a cryptographic window into physical memory that is opaque to the rest of the SoC.&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Ephemeral Keys: Upon SEP reset, the MPE generates a random, ephemeral AES key. This key exists only in the MPE hardware registers and is never exposed to software (even &lt;code&gt;sepOS&lt;/code&gt;).&lt;/item&gt;
      &lt;item&gt;AES-XEX Encryption: Data written by the SEP to DRAM is encrypted transparently using AES in XEX (XOR-Encrypt-XOR) mode.&lt;/item&gt;
      &lt;item&gt;Authentication: The MPE calculates a CMAC tag for every cache line. This tag is stored alongside the encrypted data.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;RE Implication: If you attempt to dump the physical memory range assigned to the SEP from the AP (kernel mode), you will see high-entropy noise. Furthermore, any attempt to modify a single bit of this memory via the AP will invalidate the CMAC tag. The next time the SEP reads that line, the MPE will detect the forgery and trigger a hardware panic, locking down the Enclave until a full system reset.&lt;/p&gt;
    &lt;head rend="h4"&gt;2.1.2 The Boot Monitor: Hardware Enforcement of OS-Bound Keys&lt;/head&gt;
    &lt;p&gt;On modern silicon (A13/M1 and later), Apple introduced the Secure Enclave Boot Monitor to mitigate the risk of Boot ROM exploits (like &lt;code&gt;checkm8&lt;/code&gt;) compromising the chain of trust for key derivation.&lt;/p&gt;
    &lt;p&gt;In older architectures, the SEPROM would verify the &lt;code&gt;sepOS&lt;/code&gt; signature and then jump to it. If the SEPROM was exploited, the attacker could jump to a malicious payload while retaining access to the hardware UID key. The Boot Monitor closes this gap by enforcing System Coprocessor Integrity Protection (SCIP).&lt;/p&gt;
    &lt;p&gt;The Boot Flow:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Payload Staging: The AP (iBoot) loads the &lt;code&gt;sep-firmware.img4&lt;/code&gt;payload into a region of physical memory.&lt;/item&gt;
      &lt;item&gt;Mailbox Signal: The AP signals the SEP via a hardware mailbox register.&lt;/item&gt;
      &lt;item&gt;Verification: The SEPROM parses the Image4 container. It verifies the signature against the Apple Root CA hash fused into the SEP's eFuses.&lt;/item&gt;
      &lt;item&gt;The Handoff: Crucially, the SEPROM cannot simply jump to the loaded image. The SCIP hardware prevents execution of mutable memory.&lt;/item&gt;
      &lt;item&gt;Monitor Intervention: The SEPROM invokes the Boot Monitor hardware block. &lt;list rend="ul"&gt;&lt;item&gt;The Monitor resets the SEP core to a known clean state.&lt;/item&gt;&lt;item&gt;The Monitor calculates a cryptographic hash of the loaded &lt;code&gt;sepOS&lt;/code&gt;memory range.&lt;/item&gt;&lt;item&gt;The Monitor updates the SCIP registers to permit execution of that specific range.&lt;/item&gt;&lt;item&gt;The Monitor locks the hash into a dedicated register in the Public Key Accelerator (PKA).&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;OS-Bound Key Derivation:&lt;lb/&gt; This finalized hash is the critical component. When the &lt;code&gt;sepOS&lt;/code&gt; later requests keys (e.g., to decrypt user data), the hardware Key Derivation Function (KDF) mixes the hardware UID with this locked hash.&lt;/p&gt;
    &lt;p&gt;$$ K_{derived} = KDF(UID, Hash_{sepOS}) $$&lt;/p&gt;
    &lt;p&gt;If an attacker modifies a single byte of the &lt;code&gt;sepOS&lt;/code&gt; (even with a Boot ROM exploit), the Boot Monitor calculates a different hash. Consequently, the KDF derives a different key, and the encrypted user data remains mathematically inaccessible. This is "Bound Security"—the data is bound not just to the device, but to a specific, signed software version.&lt;/p&gt;
    &lt;head rend="h4"&gt;2.1.3 Anti-Replay Mechanisms: The Integrity Tree&lt;/head&gt;
    &lt;p&gt;A classic attack vector against secure enclaves is the Replay Attack: capturing a snapshot of the encrypted RAM (e.g., when the passcode retry counter is 0) and restoring it later after the counter has incremented.&lt;/p&gt;
    &lt;p&gt;To prevent this, the SEP implements a hardware-enforced Integrity Tree (Merkle Tree).&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;The Root of Trust: The root node of the integrity tree is stored in dedicated on-chip SRAM within the Secure Enclave complex. This memory is physically distinct from the main DRAM and cannot be addressed by the AP.&lt;/item&gt;
      &lt;item&gt;Tree Structure: The protected memory region (where &lt;code&gt;sepOS&lt;/code&gt;data and the Secure Storage Manager reside) is divided into blocks. Each block's hash is stored in a parent node, recursively up to the root.&lt;/item&gt;
      &lt;item&gt;Atomic Updates: When the SEP writes to protected memory (e.g., incrementing a failed attempt counter), the MPE updates the data, recalculates the hashes up the tree, and atomically updates the root hash in the on-chip SRAM.&lt;/item&gt;
      &lt;item&gt;Verification: On every read, the MPE verifies the path from the data block up to the SRAM root.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;If an attacker replays an old DRAM state, the hash of the replayed block will not match the current root hash stored in the internal SRAM. The MPE detects the mismatch (Anti-Replay Violation) and halts the SEP. This mechanism ensures that the SEP has a strictly monotonic view of time and state, rendering snapshot fuzzing and counter rollbacks impossible.&lt;/p&gt;
    &lt;head rend="h3"&gt;2.2 SEP Runtime Architecture&lt;/head&gt;
    &lt;p&gt;Once the &lt;code&gt;sepOS&lt;/code&gt; is bootstrapped and verified, the Secure Enclave transitions into its runtime state. At this point, it functions as a fully autonomous operating system running an Apple-customized variant of the L4 microkernel. For the reverse engineer, understanding the runtime architecture is crucial for analyzing how the SEP communicates with the hostile "Rich Execution Environment" (the AP running XNU) and how it persists sensitive state.&lt;/p&gt;
    &lt;head rend="h4"&gt;2.2.1 The Mailbox Interface: Analyzing the Shared Memory IPC&lt;/head&gt;
    &lt;p&gt;Communication between the Application Processor (AP) and the SEP is strictly asynchronous and interrupt-driven. Unlike the tight coupling of the SPTM (which uses synchronous instruction traps), the SEP interaction is mediated by a hardware mechanism known as the Mailbox, which relies on the proprietary Apple Interrupt Controller (AIC) to manage signaling.&lt;/p&gt;
    &lt;p&gt;The Physical Transport: AIC and Ring Buffers&lt;lb/&gt; There is no shared virtual memory space; the two processors exchange messages via physical memory ring buffers and hardware interrupts.&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;&lt;p&gt;The Ring Buffers (Inbox/Outbox):&lt;/p&gt;&lt;lb/&gt;The system reserves two physical memory regions in DRAM, carved out by iBoot and described in the Device Tree (typically under the&lt;code&gt;sep&lt;/code&gt;node as&lt;code&gt;inbox-size&lt;/code&gt;and&lt;code&gt;outbox-size&lt;/code&gt;). These function as circular buffers.&lt;list rend="ul"&gt;&lt;item&gt;Control Structures: Each buffer is managed by a pair of pointers (Write Head, Read Tail) stored in shared SRAM or at the start of the DRAM region.&lt;/item&gt;&lt;item&gt;Coherency: Because the SEP and AP share the same Unified Memory fabric, cache coherency is critical. The &lt;code&gt;AppleSEPDriver&lt;/code&gt;must ensure appropriate barriers (&lt;code&gt;DMB&lt;/code&gt;,&lt;code&gt;DSB&lt;/code&gt;) are used when updating the Write Head to ensure the SEP sees the payload before the interrupt fires.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;&lt;p&gt;The Doorbell (Apple Interrupt Controller):&lt;/p&gt;&lt;lb/&gt;To signal a message, the sender cannot simply write to memory; it must trigger an exception on the receiver. On Apple Silicon, this is handled by the AIC, not a standard ARM GIC.&lt;list rend="ul"&gt;&lt;item&gt;AP $\rightarrow$ SEP: The kernel writes to a specific AIC "Set" register (mapped in the AP's MMIO space). This asserts a hardware IRQ line wired to the SEP's core.&lt;/item&gt;&lt;item&gt;SEP $\rightarrow$ AP: When the SEP replies, it writes to its own AIC interface, which triggers a specific IRQ (often &lt;code&gt;IRQ 0&lt;/code&gt;or&lt;code&gt;IRQ 1&lt;/code&gt;relative to the SEP driver's view) on the AP. The kernel's interrupt handler (&lt;code&gt;AppleSEPDriver::interruptOccurred&lt;/code&gt;) acknowledges this by writing to the AIC "Clear" register.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The L4 IPC Protocol (A7IOP):&lt;lb/&gt; The data payload within the ring buffers follows a serialized format, historically referred to as the Apple A7 I/O Protocol (A7IOP), though it has evolved significantly.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Message Header: Every message begins with a 64-bit header containing: &lt;list rend="ul"&gt;&lt;item&gt;&lt;code&gt;Endpoint ID&lt;/code&gt;(8 bits): The destination service within the&lt;code&gt;sepOS&lt;/code&gt;(e.g.,&lt;code&gt;0x10&lt;/code&gt;for Biometrics,&lt;code&gt;0x14&lt;/code&gt;for Secure Storage).&lt;/item&gt;&lt;item&gt;&lt;code&gt;Tag&lt;/code&gt;(8 bits): A transaction ID used to correlate asynchronous replies.&lt;/item&gt;&lt;item&gt;&lt;code&gt;Length&lt;/code&gt;(16 bits): The size of the payload.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;The &lt;code&gt;AppleSEPDriver&lt;/code&gt;: On the XNU side, this kext manages the ring buffer logic. It serializes kernel requests (e.g., "Unlock Keybag") into the mailbox format, updates the Write Head, rings the AIC doorbell, and sleeps the calling thread on a condition variable until the SEP triggers the reply interrupt.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;RE Focus: Fuzzing the Boundary&lt;lb/&gt; The mailbox is the primary attack surface for the SEP. Vulnerabilities here (parsing malformed messages) can lead to code execution within the Enclave.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Endpoint Fuzzing: The &lt;code&gt;sepOS&lt;/code&gt;kernel dispatches messages to user-mode L4 tasks based on the Endpoint ID. Fuzzing specific endpoints (especially legacy or debug endpoints left enabled in production) is a standard methodology.&lt;/item&gt;
      &lt;item&gt;Shared Memory Hazards (DART): While the mailbox buffers are used for control messages (metadata), bulk data (like a firmware update or a large biometric template) is passed via DART-mapped shared memory. The AP maps a page, pins it, and passes the physical address to the SEP in a mailbox message. The SEP then maps this page into its own address space. &lt;list rend="ul"&gt;&lt;item&gt;TOCTOU: Race conditions here are a classic target: modifying the data in the shared buffer after the SEP has validated the header/signature but before it processes the body. The SEP attempts to mitigate this by copying data to internal SRAM before processing, but large payloads may be processed in-place, exposing a window of opportunity.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h4"&gt;2.2.2 The Secure Storage Component (xART): Encrypted Persistent Storage&lt;/head&gt;
    &lt;p&gt;The SEP has no internal non-volatile storage (NAND) of its own. It must rely on the AP's NAND flash to store persistent data (like the user's passcode hash, biometric templates, and credit card tokens). However, it cannot trust the AP to store this data securely.&lt;/p&gt;
    &lt;p&gt;To solve this, Apple introduced the Secure Storage Component, often referred to in firmware and kexts as xART (eXtended Anti-Replay Technology).&lt;/p&gt;
    &lt;p&gt;The Architecture:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;The Physical Chip: On modern devices, xART is backed by a dedicated, tamper-resistant EEPROM or NOR flash chip physically connected to the SEP via a private I2C or SPI bus. This chip is not accessible to the AP.&lt;/item&gt;
      &lt;item&gt;The Logical Volume: The SEP treats the external NAND (managed by the AP) as a "dumb" block device. It encrypts its filesystem using keys derived from the hardware UID and the anti-replay counters stored in the dedicated xART chip.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The Anti-Replay Guarantee:&lt;lb/&gt; When the SEP writes a file (e.g., updating the failed passcode attempt counter):&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;It encrypts the file data.&lt;/item&gt;
      &lt;item&gt;It generates a new random nonce or increments a counter.&lt;/item&gt;
      &lt;item&gt;It writes the encrypted file to the AP's filesystem (via the Mailbox).&lt;/item&gt;
      &lt;item&gt;Crucially, it writes the hash of the file and the new counter to the dedicated xART storage chip.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;When reading the file back:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;The SEP requests the file from the AP.&lt;/item&gt;
      &lt;item&gt;It reads the expected hash/counter from the xART chip.&lt;/item&gt;
      &lt;item&gt;It verifies the file against the xART record.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;If the AP (or an attacker with physical access to the NAND) tries to revert the file to an older version (e.g., resetting the counter to 0), the hash will not match the record in the xART chip. The SEP will detect the rollback and reject the data. This mechanism ensures that the SEP's state is strictly monotonic and immune to external storage manipulation.&lt;/p&gt;
    &lt;head rend="h4"&gt;2.2.3 RE Focus: Reverse Engineering the &lt;code&gt;sepOS&lt;/code&gt; L4 Syscall Table&lt;/head&gt;
    &lt;p&gt;For the advanced reverse engineer, the holy grail is understanding the &lt;code&gt;sepOS&lt;/code&gt; kernel itself. Since it is based on L4, it relies heavily on synchronous IPC for system calls.&lt;/p&gt;
    &lt;p&gt;Identifying the Syscall Handler:&lt;lb/&gt; In the disassembled &lt;code&gt;sepOS&lt;/code&gt; binary (which can be decrypted if you have a Boot ROM exploit for the specific device class, or by analyzing unencrypted development builds if available), the exception vector table is the starting point.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Look for the SVC (Supervisor Call) exception handler.&lt;/item&gt;
      &lt;item&gt;This handler typically branches to a dispatch table based on the immediate value in the &lt;code&gt;SVC&lt;/code&gt;instruction or a register (often&lt;code&gt;x0&lt;/code&gt;or&lt;code&gt;x8&lt;/code&gt;).&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Mapping the Endpoints:&lt;lb/&gt; The &lt;code&gt;sepOS&lt;/code&gt; is modular. It consists of the kernel and several user-mode "apps" or "tasks" running within the Enclave.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;SEPOS&lt;/code&gt;Kernel: Handles memory management, scheduling, and IPC routing.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;L4&lt;/code&gt;Apps: Distinct binaries for distinct functions.&lt;list rend="ul"&gt;&lt;item&gt;&lt;code&gt;biometrickitd&lt;/code&gt;: Handles FaceID/TouchID processing.&lt;/item&gt;&lt;item&gt;&lt;code&gt;securekeyvault&lt;/code&gt;: Manages the Keychain and Data Protection classes.&lt;/item&gt;&lt;item&gt;&lt;code&gt;sigp&lt;/code&gt;: The Secure Enclave Signal Processor (for neural network operations).&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;By tracing the IPC messages dispatched from the Mailbox handler, you can map which L4 task handles which service. For example, a message with Endpoint ID &lt;code&gt;0x10&lt;/code&gt; might route to the &lt;code&gt;biometrickitd&lt;/code&gt; task. Analyzing the message parsing logic within that specific task reveals the proprietary protocol used for biometric authentication.&lt;/p&gt;
    &lt;quote&gt;&lt;p&gt;Tooling Note: Standard tools like IDA Pro or Ghidra require custom loaders for&lt;/p&gt;&lt;code&gt;sepOS&lt;/code&gt;binaries. The memory layout is non-standard, and the binary format (Mach-O) often has stripped headers or non-standard segment protections that must be manually reconstructed based on the SCIP configuration found in the Boot Monitor logic.&lt;/quote&gt;
    &lt;head rend="h2"&gt;3.0 The Chain of Trust: Firmware &amp;amp; Bootloaders&lt;/head&gt;
    &lt;p&gt;With the hardware root of trust established and the Secure Enclave operating as a parallel authority, the Application Processor begins the process of bootstrapping the mutable software stack. This phase is governed by the Image4 serialization format and a strict chain of cryptographic handover.&lt;/p&gt;
    &lt;head rend="h3"&gt;3.1 Low-Level Bootloader (LLB)&lt;/head&gt;
    &lt;p&gt;The Low-Level Bootloader (LLB) is the first piece of mutable code executed by the Application Processor. Loaded by the Boot ROM from the boot partition of the NAND (or NOR SPI on some development boards), it executes initially within the constraints of the SoC's SRAM. Its primary directive is architectural: it must bridge the gap between the raw silicon state and the feature-rich environment required by iBoot.&lt;/p&gt;
    &lt;head rend="h4"&gt;3.1.1 Parsing the Image4 (&lt;code&gt;img4&lt;/code&gt;) Container&lt;/head&gt;
    &lt;p&gt;To the reverse engineer, "firmware" on Apple Silicon is synonymous with Image4. LLB is not a raw binary; it is encapsulated in an Image4 container, a format based on ASN.1 (Abstract Syntax Notation One) and DER (Distinguished Encoding Rules). Understanding this structure is prerequisite to any firmware analysis.&lt;/p&gt;
    &lt;p&gt;The Image4 container consists of three distinct sequences:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;&lt;code&gt;IM4P&lt;/code&gt;(Payload): The actual executable code (the LLB binary).&lt;list rend="ul"&gt;&lt;item&gt;Encryption: The payload is encrypted using AES-256. On production devices, this is wrapped with the GID Key. This means the payload is opaque to external analysis unless decrypted on-device (or via a GID oracle).&lt;/item&gt;&lt;item&gt;Compression: Once decrypted, the payload is typically compressed (LZSS or LZFSE).&lt;/item&gt;&lt;item&gt;Type Tag: A 4-character code (e.g., &lt;code&gt;ibot&lt;/code&gt;,&lt;code&gt;illb&lt;/code&gt;) identifying the component.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;IM4M&lt;/code&gt;(Manifest): The signature and constraints, commonly known as the ApTicket.&lt;list rend="ul"&gt;&lt;item&gt;The Signature: An RSA or ECDSA signature over the SHA-384 hash of the payload.&lt;/item&gt;&lt;item&gt;The Body: A set of entitlements and constraints (tags) that dictate where and how this payload can run.&lt;/item&gt;&lt;item&gt;Certificate Chain: The manifest includes the certificate chain leading back to the Apple Root CA (burned into the PKA fuses).&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;IM4R&lt;/code&gt;(Restore Info): (Optional) Contains hardware-specific personalization data used during the restore process, such as the unique nonce generated by the SEP.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The Validation Logic:&lt;lb/&gt; When the Boot ROM loads LLB (and when LLB subsequently loads iBoot), it performs the following &lt;code&gt;image4_validate&lt;/code&gt; routine:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Parse the ASN.1 structure to separate &lt;code&gt;IM4M&lt;/code&gt;and&lt;code&gt;IM4P&lt;/code&gt;.&lt;/item&gt;
      &lt;item&gt;Hash the &lt;code&gt;IM4P&lt;/code&gt;(ciphertext).&lt;/item&gt;
      &lt;item&gt;Locate the corresponding hash in the &lt;code&gt;IM4M&lt;/code&gt;(under the specific tag, e.g.,&lt;code&gt;illb&lt;/code&gt;).&lt;/item&gt;
      &lt;item&gt;Verify the &lt;code&gt;IM4M&lt;/code&gt;signature using the PKA.&lt;/item&gt;
      &lt;item&gt;If valid, decrypt the &lt;code&gt;IM4P&lt;/code&gt;using the AES engine (GID context).&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h4"&gt;3.1.2 DRAM Training and Memory Controller Configuration&lt;/head&gt;
    &lt;p&gt;The most critical hardware initialization task performed by LLB is DRAM Training.&lt;/p&gt;
    &lt;p&gt;When LLB starts, the system is running on internal SRAM (a few megabytes at most). The external LPDDR4X/LPDDR5 Unified Memory is inaccessible because the Memory Controller (MCU) is uninitialized. The physical characteristics of RAM—signal timing, voltage margins, and skew—vary slightly between every physical device due to manufacturing tolerances.&lt;/p&gt;
    &lt;p&gt;The Training Sequence:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Reading SPD/Calibration Data: LLB reads calibration data from the device tree or dedicated EEPROM areas.&lt;/item&gt;
      &lt;item&gt;PHY Configuration: It configures the Physical Layer (PHY) interface of the memory controller.&lt;/item&gt;
      &lt;item&gt;Training Loop: LLB executes a complex algorithm that writes patterns to DRAM and reads them back, adjusting delay lines (DLLs) and drive strengths until the signal is stable.&lt;/item&gt;
      &lt;item&gt;Remapping: Once training is complete, the MCU is brought online. LLB then reconfigures the Memory Management Unit (MMU) to map the vast expanse of DRAM into the address space.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;RE Implication:&lt;lb/&gt; If you are attempting to exploit the Boot ROM or early LLB, you are constrained to SRAM. You cannot load large payloads or use heap spraying techniques that require gigabytes of memory until after LLB has successfully trained the DRAM. This creates a "choke point" for early-boot exploits.&lt;/p&gt;
    &lt;head rend="h4"&gt;3.1.3 Verifying the Exclusive Chip ID (ECID) and Board ID&lt;/head&gt;
    &lt;p&gt;Apple utilizes a mechanism called Personalization (or Taming) to prevent firmware replay attacks. You cannot simply take a valid, signed LLB from one iPhone and run it on another, nor can you downgrade to an older, vulnerable LLB version.&lt;/p&gt;
    &lt;p&gt;This enforcement happens inside the Image4 parser logic within LLB (checking the next stage) and the Boot ROM (checking LLB).&lt;/p&gt;
    &lt;p&gt;The Constraint Tags:&lt;lb/&gt; The &lt;code&gt;IM4M&lt;/code&gt; manifest contains specific tags that bind the signature to the hardware:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;ECID&lt;/code&gt;(Exclusive Chip ID): A 64-bit unique integer derived from the silicon die's coordinates on the wafer.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;BORD&lt;/code&gt;(Board ID): Identifies the PCB model (e.g.,&lt;code&gt;0x10&lt;/code&gt;for a specific iPhone logic board).&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;CHIP&lt;/code&gt;(Chip ID): Identifies the SoC model (e.g.,&lt;code&gt;0x8101&lt;/code&gt;for M1).&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;SDOM&lt;/code&gt;(Security Domain):&lt;code&gt;0x1&lt;/code&gt;for Production,&lt;code&gt;0x0&lt;/code&gt;for Development.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The Check:&lt;lb/&gt; During boot, the executing code reads the actual values from the hardware fuses and compares them against the values present in the signed &lt;code&gt;IM4M&lt;/code&gt;.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;If &lt;code&gt;Hardware.ECID != Manifest.ECID&lt;/code&gt;, the boot halts.&lt;/item&gt;
      &lt;item&gt;If &lt;code&gt;Hardware.BORD != Manifest.BORD&lt;/code&gt;, the boot halts.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;This mechanism, combined with the Nonce (a random value generated by the SEP during updates and baked into the &lt;code&gt;IM4M&lt;/code&gt;), ensures that the firmware is:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Authentic: Signed by Apple.&lt;/item&gt;
      &lt;item&gt;Targeted: Valid only for this specific device.&lt;/item&gt;
      &lt;item&gt;Fresh: Valid only for this specific boot/update cycle (preventing downgrades).&lt;/item&gt;
    &lt;/list&gt;
    &lt;quote&gt;&lt;p&gt;Note: In the "Tahoe" architecture, this verification logic is hardened against fault injection. The comparison is often performed using redundant variables and bitwise checks that resist simple instruction skipping (e.g., glitching a&lt;/p&gt;&lt;code&gt;B.NE&lt;/code&gt;instruction).&lt;/quote&gt;
    &lt;head rend="h3"&gt;3.2 iBoot (Stage 2 Bootloader)&lt;/head&gt;
    &lt;p&gt;Once LLB has initialized the DRAM and verified the next stage, it hands off execution to iBoot. While LLB is a hardware-focused shim, iBoot is a sophisticated, single-threaded operating system in its own right. It contains a full USB stack, a display driver (for the Apple logo), a filesystem driver (APFS/HFS+), and the logic required to bootstrap the XNU kernel. In the Tahoe architecture, iBoot's role has expanded to become the orchestrator of the new security domains.&lt;/p&gt;
    &lt;head rend="h4"&gt;3.2.1 Device Tree (DT) Flattening&lt;/head&gt;
    &lt;p&gt;The hardware configuration of an Apple Silicon device is not discoverable via standard buses like PCI enumeration alone. Instead, iBoot relies on a Device Tree (DT)—a hierarchical data structure (similar to OpenFirmware or Linux FDT) that describes the SoC's topology.&lt;/p&gt;
    &lt;p&gt;The Source:&lt;lb/&gt; The raw Device Tree is embedded within the iBoot binary (or loaded as a separate &lt;code&gt;devicetree.img4&lt;/code&gt; payload). It contains nodes describing CPUs, memory maps, interrupt controllers (AIC), and peripherals.&lt;/p&gt;
    &lt;p&gt;The Flattening Process:&lt;lb/&gt; Before jumping to the kernel, iBoot "flattens" this tree into a binary format (FDT) and populates the &lt;code&gt;/chosen&lt;/code&gt; node with runtime parameters.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;kaslr-seed&lt;/code&gt;: A high-entropy random value generated by the TRNG. The kernel uses this to randomize its slide.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;memory-map&lt;/code&gt;: A critical array of structures defining physical memory regions. iBoot marks regions used by the Boot ROM, LLB, and itself as reserved, ensuring the kernel does not overwrite them.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;boot-args&lt;/code&gt;: The command-line arguments passed to the kernel (e.g.,&lt;code&gt;debug=0x14e&lt;/code&gt;,&lt;code&gt;-v&lt;/code&gt;). On production devices, these are strictly filtered; only specific flags are allowed unless the device is "demoted" or in a specific research state.&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h4"&gt;3.2.2 New in Tahoe: Loading the Security Monitors&lt;/head&gt;
    &lt;p&gt;In pre-Tahoe architectures (iOS 14 / macOS 11), iBoot would simply load the kernelcache and jump to it. In the Tahoe era (A15/M2+), iBoot must construct the Guarded Execution Environment before the kernel can exist.&lt;/p&gt;
    &lt;p&gt;Allocation and Reservation:&lt;lb/&gt; iBoot parses the device tree to identify physical memory ranges reserved for the new monitors. It carves these out of the available DRAM:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;SPTM Region: Reserved for the Secure Page Table Monitor.&lt;/item&gt;
      &lt;item&gt;TXM Region: Reserved for the Trusted Execution Monitor.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Payload Loading:&lt;lb/&gt; iBoot locates the specific Image4 payloads within the kernelcache container:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;Ap,SecurePageTableMonitor&lt;/code&gt;: The GL2 binary.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;Ap,TrustedExecutionMonitor&lt;/code&gt;: The GL1 binary.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;It decrypts and verifies these payloads just like any other firmware component. However, instead of loading them into standard memory, it loads them into the reserved physical regions identified above.&lt;/p&gt;
    &lt;p&gt;Locking SPRR Regions:&lt;lb/&gt; This is the critical security pivot. Before handing off control, iBoot configures the Shadow Permission Remapping Registers (SPRR) for the initial state.&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;It configures the GL2 (SPTM) SPRR view to have Read/Write/Execute access to its own memory region.&lt;/item&gt;
      &lt;item&gt;It configures the GL1 (TXM) SPRR view to have access to its region.&lt;/item&gt;
      &lt;item&gt;Crucially, it configures the GL0 (Kernel) SPRR view to mark the SPTM and TXM regions as Inaccessible (No-Access).&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;This ensures that when the processor eventually drops to EL1 (GL0) to run XNU, the kernel is physically incapable of reading or modifying the monitor code, even though it resides in the same physical DRAM.&lt;/p&gt;
    &lt;head rend="h4"&gt;3.2.3 LocalPolicy &amp;amp; BAA: The Shift to Local Signing&lt;/head&gt;
    &lt;p&gt;For macOS, Apple introduced a mechanism to allow users to boot older OS versions or custom kernels (Permissive Security) without breaking the hardware chain of trust. This is managed via LocalPolicy.&lt;/p&gt;
    &lt;p&gt;The Problem:&lt;lb/&gt; The Boot ROM and LLB enforce strict signature checks against Apple's global signing server (TSS). If you want to boot a custom kernel, you can't get a valid signature from Apple.&lt;/p&gt;
    &lt;p&gt;The Solution:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;LocalPolicy: A policy file stored on the Data Volume (in the &lt;code&gt;iSCPreboot&lt;/code&gt;volume). It specifies the security mode (Full, Reduced, Permissive) and the hash of the custom kernel collection.&lt;/item&gt;
      &lt;item&gt;BAA (Basic Attestation Authority): When a user authorizes a downgrade (via Recovery Mode authentication), the Secure Enclave generates a Local Signing Key.&lt;/item&gt;
      &lt;item&gt;Re-Signing: The LocalPolicy is signed by this Local Key (inside the SEP).&lt;/item&gt;
      &lt;item&gt;Boot Time: iBoot fetches the LocalPolicy. It asks the SEP to verify the signature. If the SEP confirms the policy is valid (and matches the user's intent), iBoot proceeds to load the custom kernel hash specified in the policy, effectively "blessing" it for this boot cycle.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;This allows "Permissive Security" to exist while keeping the Boot ROM and LLB strictly locked down.&lt;/p&gt;
    &lt;head rend="h4"&gt;3.2.4 RE Focus: Decrypting iBoot Payloads via the AES MMIO Interface&lt;/head&gt;
    &lt;p&gt;To analyze iBoot, one must decrypt it. Since the GID key is fused into the silicon and physically disconnected from the CPU's register file, it cannot be extracted via software. Reverse engineers must instead turn the device into a Decryption Oracle by manipulating the dedicated AES hardware peripheral.&lt;/p&gt;
    &lt;p&gt;The &lt;code&gt;kbag&lt;/code&gt; Mechanism:&lt;lb/&gt; The Image4 payload (&lt;code&gt;IM4P&lt;/code&gt;) is encrypted with a random, per-file symmetric key (the target key). This target key is wrapped (encrypted) with the GID key and stored in the &lt;code&gt;IM4P&lt;/code&gt; header as a Keybag (&lt;code&gt;kbag&lt;/code&gt;). To decrypt the firmware, one must unwrap this kbag.&lt;/p&gt;
    &lt;p&gt;The Hardware Distinction (ISA vs. MMIO):&lt;lb/&gt; It is critical to distinguish between the ARMv8 Crypto Extensions (instructions like &lt;code&gt;AESE&lt;/code&gt;, &lt;code&gt;AESD&lt;/code&gt;) and the Apple AES Peripheral.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;ARMv8 Crypto: Operates on keys loaded into standard NEON/SIMD registers (&lt;code&gt;v0&lt;/code&gt;-&lt;code&gt;v31&lt;/code&gt;). Useful for TLS or disk encryption where the key is known to the OS.&lt;/item&gt;
      &lt;item&gt;Apple AES Peripheral: A memory-mapped I/O (MMIO) block, typically located at a base offset like &lt;code&gt;0x23D2C0000&lt;/code&gt;(on M1/T8103) or similar&lt;code&gt;0x2...&lt;/code&gt;ranges on newer SoCs. This peripheral has exclusive hardware access to the GID key fuses.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The Oracle Exploit:&lt;lb/&gt; Using a Boot ROM exploit (like &lt;code&gt;checkm8&lt;/code&gt; on A-series) or a specialized iBoot exploit, researchers execute a payload that drives this MMIO interface directly:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Reset: Reset the AES peripheral via the &lt;code&gt;AES_CTRL&lt;/code&gt;register to clear internal state.&lt;/item&gt;
      &lt;item&gt;Key Selection: Write to the configuration register to select the GID Key as the decryption source. This sets an internal mux; the key itself is never exposed to the bus.&lt;/item&gt;
      &lt;item&gt;FIFO Loading: Write the &lt;code&gt;kbag&lt;/code&gt;(IV + Ciphertext) into the&lt;code&gt;AES_DATA_IN&lt;/code&gt;FIFO registers.&lt;/item&gt;
      &lt;item&gt;Execution: Trigger the engine. The hardware pulls the GID key from the fuses, performs the AES-256-CBC unwrap, and pushes the result to the output buffer.&lt;/item&gt;
      &lt;item&gt;Extraction: Read the unwrapped target key (typically formatted as &lt;code&gt;iv:key&lt;/code&gt;) from the&lt;code&gt;AES_DATA_OUT&lt;/code&gt;register.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Bit-Flipping and Timing Countermeasures:&lt;lb/&gt; Modern Apple Silicon (A12+/M1+) implements countermeasures against this oracle usage. The AES engine may enforce a state machine that requires the output of a GID decryption to be immediately DMA'd to executable memory and jumped to, rather than read back into a general-purpose register. Bypassing this often requires Fault Injection (voltage glitching) to corrupt the state machine or precise timing attacks to race the hardware's "sanitize on read" logic, allowing the extraction of the plaintext key before the hardware scrubs it.&lt;/p&gt;
    &lt;head rend="h2"&gt;4.0 The Security Monitor Layer (GL1/GL2): The New Hypervisor&lt;/head&gt;
    &lt;p&gt;In the "Tahoe" architecture, the XNU kernel has been demoted. It no longer possesses the ultimate authority to define the virtual memory layout of the system. That power has been migrated to a hardware-enforced monitor running in a proprietary execution state. This section dissects the mechanics of this new layer, which effectively functions as a lightweight, silicon-enforced hypervisor for the kernel itself.&lt;/p&gt;
    &lt;head rend="h3"&gt;4.1 The Secure Page Table Monitor (SPTM) - GL2&lt;/head&gt;
    &lt;p&gt;The Secure Page Table Monitor (SPTM) operates at Guarded Level 2 (GL2). While architecturally sharing the EL1 exception level with the kernel, the Guarded Execution Feature (GXF) ensures that GL2 has a strict superset of permissions compared to the kernel's GL0. The SPTM is the sole entity permitted to write to the physical pages that constitute the translation tables (TTBR0/TTBR1).&lt;/p&gt;
    &lt;head rend="h4"&gt;4.1.1 The &lt;code&gt;GENTER&lt;/code&gt; and &lt;code&gt;GEXIT&lt;/code&gt; Instructions: Context Switching&lt;/head&gt;
    &lt;p&gt;Transitions into the SPTM are not handled by standard ARM exception vectors (&lt;code&gt;VBAR_EL1&lt;/code&gt;). Instead, they utilize the proprietary &lt;code&gt;GENTER&lt;/code&gt; instruction, which performs a synchronous, atomic context switch.&lt;/p&gt;
    &lt;p&gt;The &lt;code&gt;GENTER&lt;/code&gt; ABI:&lt;lb/&gt; To invoke the SPTM, the kernel populates specific registers and executes the opcode.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Opcode: &lt;code&gt;0x00201420&lt;/code&gt;(Little Endian).&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;x15&lt;/code&gt;(Selector): The Dispatch ID. This integer identifies which SPTM primitive to execute.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;x0&lt;/code&gt;-&lt;code&gt;x7&lt;/code&gt;(Arguments): The parameters for the call (e.g., physical addresses, permission flags).&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;x16&lt;/code&gt;/&lt;code&gt;x17&lt;/code&gt;: Often used as scratch or secondary dispatch modifiers in newer revisions.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The Hardware Transition:&lt;lb/&gt; Upon execution of &lt;code&gt;GENTER&lt;/code&gt;:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;SPRR Switch: The hardware swaps the active Shadow Permission Remapping Register configuration. The memory regions containing the SPTM code and data—previously invisible to the kernel—become Read/Write/Execute. Conversely, the kernel's own text might become Read-Only or Non-Executable depending on the monitor's logic.&lt;/item&gt;
      &lt;item&gt;Stack Switch: The Stack Pointer (&lt;code&gt;SP&lt;/code&gt;) is switched to the&lt;code&gt;SP_GL2&lt;/code&gt;register, pointing to a dedicated secure stack within the SPTM's private memory.&lt;/item&gt;
      &lt;item&gt;PC Jump: Execution jumps to the vector defined in &lt;code&gt;GXF_ENTRY_EL1&lt;/code&gt;.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The Return:&lt;lb/&gt; The SPTM returns control to the kernel using &lt;code&gt;GEXIT&lt;/code&gt; (&lt;code&gt;0x00201400&lt;/code&gt;). This restores the GL0 SPRR configuration and the kernel's stack pointer. Crucially, &lt;code&gt;GEXIT&lt;/code&gt; clears sensitive registers to prevent data leakage from the secure context.&lt;/p&gt;
    &lt;head rend="h4"&gt;4.1.2 The Frame Table (FTE): Tracking Physical Reality&lt;/head&gt;
    &lt;p&gt;To enforce security, the SPTM cannot rely on the kernel's data structures (like &lt;code&gt;vm_page_t&lt;/code&gt;), as they are mutable by a compromised kernel. Instead, the SPTM maintains its own "God View" of physical memory called the Frame Table.&lt;/p&gt;
    &lt;p&gt;The Frame Table is a linear array of Frame Table Entries (FTE), located in SPTM-private memory. There is one FTE for every 16KB page of physical RAM.&lt;/p&gt;
    &lt;p&gt;FTE Structure (Reconstructed):&lt;lb/&gt; While the exact struct evolves, it generally contains:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;Type&lt;/code&gt;(Bitfield): The strict classification of the page.&lt;list rend="ul"&gt;&lt;item&gt;&lt;code&gt;XNU_DATA&lt;/code&gt;: Generic kernel heap/stack.&lt;/item&gt;&lt;item&gt;&lt;code&gt;XNU_TEXT&lt;/code&gt;: Immutable kernel code.&lt;/item&gt;&lt;item&gt;&lt;code&gt;PAGE_TABLE&lt;/code&gt;: A page containing translation entries (TTEs).&lt;/item&gt;&lt;item&gt;&lt;code&gt;USER_DATA&lt;/code&gt;: Memory mapped to EL0 processes.&lt;/item&gt;&lt;item&gt;&lt;code&gt;SPTM_PRIVATE&lt;/code&gt;: Internal monitor structures.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;Refcount&lt;/code&gt;: Tracks how many virtual mappings point to this physical page.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;OwnerID&lt;/code&gt;: Identifies the Trust Domain (e.g., Kernel vs. Exclave).&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The Security Invariant:&lt;lb/&gt; The SPTM enforces that a physical page can only be mapped into a virtual address space if the mapping permissions are compatible with the page's &lt;code&gt;Type&lt;/code&gt;. For example, a page marked &lt;code&gt;XNU_DATA&lt;/code&gt; in the FTE cannot be mapped as Executable. A page marked &lt;code&gt;PAGE_TABLE&lt;/code&gt; cannot be mapped as Writable by the kernel.&lt;/p&gt;
    &lt;head rend="h4"&gt;4.1.3 The Dispatch Table: Reverse Engineering the Selectors&lt;/head&gt;
    &lt;p&gt;The interface between XNU and the SPTM is a strict, register-based API. However, unlike the stable syscall numbers of the BSD layer, the SPTM Dispatch IDs (Selectors) are not guaranteed to remain static across macOS versions. Apple frequently rotates these IDs between major (and occasionally minor) releases to frustrate static analysis tools and exploit chains that rely on hardcoded offsets.&lt;/p&gt;
    &lt;p&gt;The ABI:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;x15&lt;/code&gt;: The Dispatch ID (Selector).&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;x0&lt;/code&gt;-&lt;code&gt;x7&lt;/code&gt;: Arguments (Physical Addresses, Permission Bitmasks, ASIDs).&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;x16&lt;/code&gt;/&lt;code&gt;x17&lt;/code&gt;: Scratch registers, occasionally used for secondary modifiers or sub-ops.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Heuristic Identification:&lt;lb/&gt; Since relying on static IDs (e.g., &lt;code&gt;0x00&lt;/code&gt;) is brittle, reverse engineers must fingerprint the logic of the handler functions within the &lt;code&gt;Ap,SecurePageTableMonitor&lt;/code&gt; binary to identify the primitives.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;sptm_retype(ppn, old_type, new_type)&lt;/code&gt;(Often ID&lt;code&gt;0x00&lt;/code&gt;or&lt;code&gt;0x01&lt;/code&gt;):&lt;list rend="ul"&gt;&lt;item&gt;Fingerprint: Look for a function that accepts a Physical Page Number (PPN), reads the corresponding Frame Table Entry (FTE), and performs a Sanitization Loop. The SPTM must zero-fill (&lt;code&gt;bzero&lt;/code&gt;) or cache-invalidate the page before transitioning it from&lt;code&gt;XNU_DATA&lt;/code&gt;to&lt;code&gt;PAGE_TABLE&lt;/code&gt;to prevent the kernel from initializing a page table with pre-computed malicious entries.&lt;/item&gt;&lt;item&gt;Logic: &lt;code&gt;assert(refcount == 0); memset(pa, 0, PAGE_SIZE); fte-&amp;gt;type = new_type;&lt;/code&gt;&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;Fingerprint: Look for a function that accepts a Physical Page Number (PPN), reads the corresponding Frame Table Entry (FTE), and performs a Sanitization Loop. The SPTM must zero-fill (&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;sptm_map(asid, va, ppn, perms)&lt;/code&gt;:&lt;list rend="ul"&gt;&lt;item&gt;Fingerprint: Look for a function that walks the translation tables (reading physical memory) and performs a Permission Check against the FTE. It will contain logic that explicitly compares the requested &lt;code&gt;perms&lt;/code&gt;(e.g., Write) against the&lt;code&gt;fte-&amp;gt;type&lt;/code&gt;(e.g.,&lt;code&gt;XNU_TEXT&lt;/code&gt;).&lt;/item&gt;&lt;item&gt;Logic: &lt;code&gt;if (fte-&amp;gt;type == XNU_TEXT &amp;amp;&amp;amp; (perms &amp;amp; WRITE)) panic(); write_tte(...);&lt;/code&gt;&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;Fingerprint: Look for a function that walks the translation tables (reading physical memory) and performs a Permission Check against the FTE. It will contain logic that explicitly compares the requested &lt;/item&gt;
      &lt;item&gt;&lt;code&gt;sptm_unmap(asid, va)&lt;/code&gt;:&lt;list rend="ul"&gt;&lt;item&gt;Fingerprint: Look for the TLB Invalidation sequence. After clearing a TTE, the SPTM must execute &lt;code&gt;TLBI&lt;/code&gt;instructions (e.g.,&lt;code&gt;TLBI ASIDE1IS&lt;/code&gt;) to ensure the hardware translation lookaside buffer is coherent. The kernel is forbidden from executing&lt;code&gt;TLBI&lt;/code&gt;instructions that affect the secure context; it must delegate this to the SPTM.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;Fingerprint: Look for the TLB Invalidation sequence. After clearing a TTE, the SPTM must execute &lt;/item&gt;
      &lt;item&gt;&lt;code&gt;sptm_map_iommu(dart_id, context_id, dva, ppn, perms)&lt;/code&gt;:&lt;list rend="ul"&gt;&lt;item&gt;Fingerprint: Look for writes to MMIO regions associated with DART controllers, rather than standard RAM. This function validates that the &lt;code&gt;ppn&lt;/code&gt;is not a protected kernel page before mapping it into a device's IOVA space.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;Fingerprint: Look for writes to MMIO regions associated with DART controllers, rather than standard RAM. This function validates that the &lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;RE Implication:&lt;lb/&gt; Automated analysis scripts should not rely on &lt;code&gt;CMP x15, #0x1&lt;/code&gt;. Instead, they should symbolically execute the &lt;code&gt;GENTER&lt;/code&gt; handler in the SPTM binary, identifying the dispatch table jump, and then classify the target functions based on the presence of &lt;code&gt;DC ZVA&lt;/code&gt; (cache zero), &lt;code&gt;TLBI&lt;/code&gt;, or FTE array access patterns.&lt;/p&gt;
    &lt;head rend="h4"&gt;4.1.4 RE Focus: Analyzing Panic Strings and the State Machine&lt;/head&gt;
    &lt;p&gt;The SPTM is designed to be Fail-Secure. Unlike standard kernel APIs that return &lt;code&gt;KERN_FAILURE&lt;/code&gt;, the SPTM treats invalid requests as evidence of kernel compromise.&lt;/p&gt;
    &lt;p&gt;The Panic Mechanism:&lt;lb/&gt; If XNU sends a malformed request (e.g., trying to retype a page that is still mapped), the SPTM does not return. It triggers a system-wide panic.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Panic String: &lt;code&gt;"received fatal error for a selector from TXM"&lt;/code&gt;or&lt;code&gt;"invalid state transition"&lt;/code&gt;.&lt;/item&gt;
      &lt;item&gt;Analysis: These strings are gold for reverse engineers. They confirm that the SPTM enforces a strict Finite State Machine (FSM) for memory pages.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Mapping the State Machine:&lt;lb/&gt; By analyzing the panic logic, we can deduce the allowed transitions:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;&lt;code&gt;FREE&lt;/code&gt;$\rightarrow$&lt;code&gt;XNU_DATA&lt;/code&gt;(Allocation)&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;XNU_DATA&lt;/code&gt;$\rightarrow$&lt;code&gt;PAGE_TABLE&lt;/code&gt;(Retype for MMU use - requires sanitization)&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;PAGE_TABLE&lt;/code&gt;$\rightarrow$&lt;code&gt;XNU_DATA&lt;/code&gt;(Teardown - requires unmapping all entries)&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;XNU_DATA&lt;/code&gt;$\rightarrow$&lt;code&gt;XNU_TEXT&lt;/code&gt;(KEXT loading - One-way transition!)&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Any attempt to deviate from this graph (e.g., trying to turn &lt;code&gt;PAGE_TABLE&lt;/code&gt; directly into &lt;code&gt;XNU_TEXT&lt;/code&gt;) results in an immediate halt. This prevents "Page Table Spraying" and other heap manipulation techniques used to gain kernel execution.&lt;/p&gt;
    &lt;head rend="h3"&gt;4.2 The Trusted Execution Monitor (TXM) - GL1&lt;/head&gt;
    &lt;p&gt;If the SPTM is the brawn—enforcing the physics of memory mapping—the Trusted Execution Monitor (TXM) is the brains. Operating at Guarded Level 1 (GL1), the TXM is the supreme arbiter of system policy. It represents the architectural decoupling of "mechanism" from "policy." While the SPTM handles how a page is mapped, the TXM decides if it is allowed to be mapped executable.&lt;/p&gt;
    &lt;head rend="h4"&gt;4.2.1 Decoupling AMFI: Moving Code Signature Verification&lt;/head&gt;
    &lt;p&gt;Historically, the Apple Mobile File Integrity (AMFI) kernel extension was the primary enforcement point for code signing. However, as a KEXT running in EL1, AMFI was susceptible to kernel-level memory corruption. Exploits like &lt;code&gt;tfp0&lt;/code&gt; could patch &lt;code&gt;amfi_get_out_of_my_way&lt;/code&gt; or swizzle the MAC (Mandatory Access Control) hooks to bypass signature checks.&lt;/p&gt;
    &lt;p&gt;In the Tahoe architecture, the core verification logic has been lifted out of the kernel and placed into the TXM. Crucially, the TXM does not necessarily parse the full CMS blob on every request; its primary currency of trust is the Code Directory Hash (CDHash).&lt;/p&gt;
    &lt;p&gt;The Verification Flow:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Load &amp;amp; Hash: The kernel (XNU) loads a binary into memory (typed as &lt;code&gt;XNU_DATA&lt;/code&gt;). It parses the&lt;code&gt;LC_CODE_SIGNATURE&lt;/code&gt;load command and calculates the CDHash (SHA-256) of the Code Directory.&lt;/item&gt;
      &lt;item&gt;The Query: XNU issues a &lt;code&gt;GENTER&lt;/code&gt;call to the TXM. It passes the CDHash and the physical address of the memory range.&lt;/item&gt;
      &lt;item&gt;Trust Cache Lookup: The TXM first checks its internal Trust Caches (located in GL1 memory). &lt;list rend="ul"&gt;&lt;item&gt;Static Trust Cache: Contains CDHashes for all immutable OS binaries (from the Cryptex).&lt;/item&gt;&lt;item&gt;Dynamic Trust Cache: Contains CDHashes for recently verified third-party apps.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;Cold Validation: If the CDHash is not found (a cache miss), the system enters a "Cold Start" validation path. The kernel (often aided by &lt;code&gt;amfid&lt;/code&gt;in userland for complex policy checks) must provide the CMS signature blob to the TXM. The TXM performs the cryptographic verification of the blob against the Apple Root CA (or Developer ID Root) within the secure world. If valid, the CDHash is promoted to the Dynamic Trust Cache.&lt;/item&gt;
      &lt;item&gt;Bless: Once the CDHash is validated (either via Cache Hit or Cold Validation), the TXM updates its internal state to "bless" the specific physical pages associated with that CDHash.&lt;/item&gt;
      &lt;item&gt;Enforcement (GL2): When XNU subsequently asks the SPTM to map those pages as Executable (&lt;code&gt;RX&lt;/code&gt;), the SPTM queries the TXM: "Is this physical page verified?" If the TXM has not blessed the CDHash associated with those pages, the SPTM denies the Execute permission.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;RE Implication: Patching the kernel to ignore signature errors is now futile. Even if XNU "thinks" a binary is signed and attempts to set the executable bit in the PTE, it lacks the hardware authority to do so. The SPTM will simply refuse the PTE update because the TXM never validated the CDHash.&lt;/p&gt;
    &lt;head rend="h4"&gt;4.2.2 The Trust Cache: Static vs. Dynamic&lt;/head&gt;
    &lt;p&gt;To avoid the performance penalty of cryptographic verification on every page fault, the TXM manages the Trust Cache—a database of known-good CDHashes.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;p&gt;The Static Trust Cache:&lt;/p&gt;&lt;lb/&gt;This is loaded by iBoot and passed to the TXM during the GL1 initialization. It contains the hashes of every binary in the OS (now encapsulated in the immutable Cryptexes). This cache resides in GL1 memory and is strictly Read-Only.&lt;/item&gt;
      &lt;item&gt;&lt;p&gt;The Dynamic Trust Cache:&lt;/p&gt;&lt;lb/&gt;This handles third-party applications and JIT regions. When a user launches an app, the TXM verifies the signature once and adds the CDHash to the Dynamic Trust Cache.&lt;list rend="ul"&gt;&lt;item&gt;Query Interface: The kernel queries the Trust Cache via a specific &lt;code&gt;GENTER&lt;/code&gt;selector.&lt;/item&gt;&lt;item&gt;Attack Surface: The Dynamic Trust Cache is a mutable structure in GL1. A logic bug in the TXM's management of this cache (e.g., a race condition during entry removal or a hash collision attack) is a high-value target for persistence.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;Query Interface: The kernel queries the Trust Cache via a specific &lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h4"&gt;4.2.3 Developer Mode Enforcement and Downgrade Protection&lt;/head&gt;
    &lt;p&gt;The TXM is also the guardian of the device's security posture, specifically Developer Mode.&lt;/p&gt;
    &lt;p&gt;In previous iterations, enabling debugging capabilities was often a matter of setting &lt;code&gt;nvram&lt;/code&gt; variables or &lt;code&gt;boot-args&lt;/code&gt; (like &lt;code&gt;cs_enforcement_disable=1&lt;/code&gt;). In Tahoe, these states are managed by the TXM.&lt;/p&gt;
    &lt;p&gt;The State Transition:&lt;lb/&gt; Enabling Developer Mode requires a reboot and explicit user authorization (Secure Intent via physical buttons). The TXM persists this state (likely via the Secure Enclave's secure storage).&lt;/p&gt;
    &lt;p&gt;Downgrade Protection:&lt;lb/&gt; The TXM enforces that the system cannot transition from a "Production" state to a "Developer" state without a full reboot and authentication ceremony. This prevents a kernel-level attacker from dynamically relaxing security policies to load unsigned modules.&lt;/p&gt;
    &lt;p&gt;Furthermore, the TXM validates the LocalPolicy (signed by the SEP) to determine if the system is booting in "Permissive Security" mode. If the LocalPolicy signature is invalid or missing, the TXM defaults to "Full Security," rejecting any code not signed by the Apple Root CA, regardless of what the kernel requests.&lt;/p&gt;
    &lt;head rend="h2"&gt;5.0 XNU Kernel Initialization: Entering EL1&lt;/head&gt;
    &lt;p&gt;The handoff from iBoot to the XNU kernel marks the transition from a single-threaded bootloader to a symmetric multiprocessing (SMP) operating system. However, in the Tahoe architecture, this is no longer a handover of absolute power. The kernel enters Exception Level 1 (EL1) not as a master, but as a client of the Guarded Level 2 (GL2) monitor.&lt;/p&gt;
    &lt;p&gt;The entry point is defined in &lt;code&gt;osfmk/arm64/start.s&lt;/code&gt;. At this precise moment, the system state is fragile: the MMU is likely disabled (or running on an identity map provided by iBoot), interrupts are masked (&lt;code&gt;DAIF&lt;/code&gt; bits set), and the stack pointer is essentially arbitrary. The kernel's first objective is to orient itself within physical memory, calculate the KASLR slide, and establish the virtual memory structures required to turn on the lights.&lt;/p&gt;
    &lt;head rend="h3"&gt;5.1 The &lt;code&gt;start&lt;/code&gt; routine and KASLR&lt;/head&gt;
    &lt;p&gt;The &lt;code&gt;_start&lt;/code&gt; symbol is the architectural entry point. Unlike x86_64, where the kernel might handle its own decompression and relocation, the Apple Silicon kernel is loaded as a raw Mach-O executable (within the &lt;code&gt;kernelcache&lt;/code&gt; container) directly into physical memory by iBoot.&lt;/p&gt;
    &lt;p&gt;The Register State at Entry:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;x0&lt;/code&gt;: Physical address of the&lt;code&gt;boot_args&lt;/code&gt;structure (version 2).&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;x1&lt;/code&gt;: Physical address of the Device Tree base (if not inside&lt;code&gt;boot_args&lt;/code&gt;).&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;x2&lt;/code&gt;: 0 (Reserved).&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;x3&lt;/code&gt;: 0 (Reserved).&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;sp&lt;/code&gt;: Invalid/Temporary.&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h4"&gt;5.1.1 Deriving the Kernel Slide: The Dual-Slide Paradigm&lt;/head&gt;
    &lt;p&gt;Kernel Address Space Layout Randomization (KASLR) on Apple Silicon is a cooperative effort between iBoot and XNU. Unlike x86_64, where the kernel might handle its own relocation, the Apple Silicon kernel is loaded as a raw Mach-O executable directly into physical memory by iBoot. However, in the Tahoe architecture, KASLR has evolved from a simple obfuscation technique into a compartmentalized security boundary.&lt;/p&gt;
    &lt;p&gt;The &lt;code&gt;boot_args&lt;/code&gt; Structure:&lt;lb/&gt; Upon entry at &lt;code&gt;_start&lt;/code&gt;, the kernel immediately parses the &lt;code&gt;boot_args&lt;/code&gt; structure (version 2) pointed to by &lt;code&gt;x0&lt;/code&gt;. This structure acts as the handover manifest, containing the &lt;code&gt;virtBase&lt;/code&gt; (the static link address, typically &lt;code&gt;0xFFFFFFF007004000&lt;/code&gt;) and the &lt;code&gt;physBase&lt;/code&gt; (the actual physical load address in DRAM).&lt;/p&gt;
    &lt;p&gt;The Slide Calculation:&lt;lb/&gt; The slide is not generated by the kernel at runtime; it is consumed. iBoot generates a high-entropy value from the TRNG, populates the &lt;code&gt;/chosen/kaslr-seed&lt;/code&gt; property in the Device Tree, and physically relocates the kernel text in DRAM to match this slide.&lt;/p&gt;
    &lt;p&gt;The kernel calculates its own slide using the delta between the compile-time base and the runtime physical base (adjusted for the static virtual-to-physical offset):&lt;/p&gt;
    &lt;p&gt;$$ \texttt{vm\_kernel\_slide} = \texttt{boot\_args.virtBase} - \texttt{CompileTimeBase} $$&lt;/p&gt;
    &lt;p&gt;The Tahoe Constraint: Entropy Decorrelation:&lt;lb/&gt; In the Tahoe architecture, the system operates under a Dual-Slide Paradigm. The SPTM (GL2) and the Kernel (GL0/EL1) reside in the same physical DRAM but operate in distinct translation regimes.&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Kernel Slide: Randomized by iBoot based on &lt;code&gt;kaslr-seed&lt;/code&gt;.&lt;/item&gt;
      &lt;item&gt;SPTM Slide: Randomized by iBoot based on a separate, decorrelated entropy source (or a cryptographic derivation of the master seed that is not exposed to EL1).&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Security Implication:&lt;lb/&gt; This decorrelation is critical. A kernel-level memory leak (e.g., an &lt;code&gt;infoleak&lt;/code&gt; revealing a kernel pointer) allows an attacker to calculate &lt;code&gt;vm_kernel_slide&lt;/code&gt;. In previous architectures, if the monitor (PPL) was mapped at a fixed offset relative to the kernel, a kernel leak would instantly reveal the monitor's location.&lt;/p&gt;
    &lt;p&gt;In Tahoe, knowing &lt;code&gt;vm_kernel_slide&lt;/code&gt; yields zero information about the virtual address of the SPTM. The SPTM's virtual mapping is established by iBoot in the GL2 translation tables (&lt;code&gt;TTBR1_EL2&lt;/code&gt; context) before the kernel executes. The kernel is aware of the SPTM's physical pages (marked as "Reserved" in the memory map to prevent the VM subsystem from overwriting them), but it is architecturally blind to the SPTM's virtual location.&lt;/p&gt;
    &lt;p&gt;RE Focus: Finding the Slide:&lt;lb/&gt; For a reverse engineer with a kernel panic log or a JTAG connection, identifying these slides requires inspecting distinct registers:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Kernel Slide: Inspect &lt;code&gt;TTBR1_EL1&lt;/code&gt;. The translation table base points to the physical location of the kernel's L1 table. The high bits of the PC (Program Counter) at the exception vector reveal the virtual slide.&lt;/item&gt;
      &lt;item&gt;SPTM Slide: This is invisible from EL1. To find it, one must inspect &lt;code&gt;TTBR1_EL2&lt;/code&gt;(or the proprietary system register aliasing the GL2 translation base) via JTAG while the core is halted in the GL2 context.&lt;/item&gt;
      &lt;item&gt;Static Analysis: The &lt;code&gt;vm_kernel_slide&lt;/code&gt;global variable in XNU is one of the first initialized. In a raw memory dump, locating the&lt;code&gt;boot_args&lt;/code&gt;struct (often at the start of a physical page aligned to 16KB) will reveal the&lt;code&gt;virtBase&lt;/code&gt;directly.&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h4"&gt;5.1.2 Initializing the MMU: &lt;code&gt;TCR_EL1&lt;/code&gt; and the SPTM Handshake&lt;/head&gt;
    &lt;p&gt;Before the kernel can execute C code safely, it must enable the Memory Management Unit (MMU). On standard ARMv8, this involves populating translation tables and writing to &lt;code&gt;TTBR0_EL1&lt;/code&gt; (User) and &lt;code&gt;TTBR1_EL1&lt;/code&gt; (Kernel), then setting &lt;code&gt;SCTLR_EL1.M&lt;/code&gt;.&lt;/p&gt;
    &lt;p&gt;On Tahoe, this process is fundamentally altered because the kernel cannot write to its own page tables.&lt;/p&gt;
    &lt;p&gt;The Bootstrap Problem:&lt;lb/&gt; How does the kernel build its initial page tables if it requires the SPTM to map pages, but the SPTM requires the kernel to make hypercalls?&lt;/p&gt;
    &lt;p&gt;The Solution: The Bootstrap Tables:&lt;lb/&gt; iBoot constructs a set of initial "Bootstrap Page Tables" before handing off control. These tables are identity-mapped (Physical == Virtual) for the PC and stack, but also contain the kernel's high-virtual mappings.&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;TCR_EL1 Setup: The kernel configures the Translation Control Register (&lt;code&gt;TCR_EL1&lt;/code&gt;).&lt;list rend="ul"&gt;&lt;item&gt;&lt;code&gt;T1SZ&lt;/code&gt;/&lt;code&gt;T0SZ&lt;/code&gt;: Defines the size of the virtual address space (typically 36-bit or 39-bit on iOS, 48-bit on macOS).&lt;/item&gt;&lt;item&gt;&lt;code&gt;TG1&lt;/code&gt;: Granule size (16KB is standard for Apple Silicon, unlike the 4KB standard of Android/Linux).&lt;/item&gt;&lt;item&gt;&lt;code&gt;IPS&lt;/code&gt;: Intermediate Physical Address Size (matches the SoC capability, e.g., 40 bits).&lt;/item&gt;&lt;item&gt;&lt;code&gt;TBI1&lt;/code&gt;(Top Byte Ignore): Critical for PAC. This bit must be set to 1. It tells the MMU to ignore the top byte (bits 63-56) during address translation, allowing PAC signatures to exist in valid pointers without causing translation faults.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The SPTM Handshake (The First &lt;code&gt;GENTER&lt;/code&gt;):&lt;lb/&gt; Once &lt;code&gt;TCR_EL1&lt;/code&gt; is configured, the kernel must transition from the iBoot-provided bootstrap tables to its own managed tables.&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Allocation: The kernel allocates physical pages for the new L1/L2/L3 translation tables from the &lt;code&gt;XNU_DATA&lt;/code&gt;pool.&lt;/item&gt;
      &lt;item&gt;Sanitization: The kernel zeroes these pages.&lt;/item&gt;
      &lt;item&gt;Retype: The kernel executes &lt;code&gt;GENTER&lt;/code&gt;(Selector&lt;code&gt;0x00&lt;/code&gt;-&lt;code&gt;sptm_retype&lt;/code&gt;) to convert these pages from&lt;code&gt;XNU_DATA&lt;/code&gt;to&lt;code&gt;PAGE_TABLE&lt;/code&gt;.&lt;/item&gt;
      &lt;item&gt;Mapping: The kernel executes &lt;code&gt;GENTER&lt;/code&gt;(Selector&lt;code&gt;0x01&lt;/code&gt;-&lt;code&gt;sptm_map&lt;/code&gt;) to populate the entries, replicating the kernel text and static data mappings.&lt;/item&gt;
      &lt;item&gt;Activation: Finally, the kernel writes the physical address of the new L1 table to &lt;code&gt;TTBR1_EL1&lt;/code&gt;.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The &lt;code&gt;SCTLR_EL1&lt;/code&gt; Lockdown:&lt;lb/&gt; The final step of &lt;code&gt;start&lt;/code&gt; is writing to the System Control Register (&lt;code&gt;SCTLR_EL1&lt;/code&gt;).&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;M&lt;/code&gt;(MMU Enable): Set to 1.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;C&lt;/code&gt;(Cache Enable): Set to 1.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;WXN&lt;/code&gt;(Write-XOR-Execute): Set to 1.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;In Tahoe, the SPTM monitors writes to &lt;code&gt;SCTLR_EL1&lt;/code&gt;. If the kernel attempts to disable &lt;code&gt;WXN&lt;/code&gt; (a common technique in older jailbreaks to patch kernel text), the SPTM intercepts the system register write and panics the device. The hardware configuration enforced by GL2 ensures that &lt;code&gt;SCTLR_EL1&lt;/code&gt; modifications are privileged operations that must comply with the system's security policy.&lt;/p&gt;
    &lt;p&gt;Once the MMU is active and the kernel is running on its own page tables (managed by SPTM), the &lt;code&gt;start&lt;/code&gt; routine branches to &lt;code&gt;arm_init&lt;/code&gt;, beginning the high-level initialization of the BSD subsystem and IOKit.&lt;/p&gt;
    &lt;head rend="h3"&gt;5.2 Hardware Security Enforcements (The "Kill Switch" Registers)&lt;/head&gt;
    &lt;p&gt;As the kernel initialization sequence progresses through &lt;code&gt;start&lt;/code&gt;, it reaches a critical inflection point. The memory management structures are initialized, and the kernel is about to transition from a setup phase to a runtime phase. To prevent a compromised runtime kernel from modifying its own logic, the initialization routine must engage the hardware "Kill Switches."&lt;/p&gt;
    &lt;p&gt;These are proprietary system registers that, once written to, become immutable until a full system reset. In the pre-Tahoe era, these registers were the primary defense against persistent kernel compromises. In the Tahoe architecture, they serve as a hardware-enforced baseline that the SPTM relies upon to maintain the invariant of Kernel Text Immutability.&lt;/p&gt;
    &lt;head rend="h4"&gt;5.2.1 KTRR (Kernel Text Read-Only Region): The Physical Lock&lt;/head&gt;
    &lt;p&gt;Kernel Text Read-Only Region (KTRR) is Apple’s hardware solution to the "W^X" (Write XOR Execute) problem at the physical memory controller level. While the MMU (via page tables) controls virtual access permissions, page tables are mutable data structures. If an attacker gains arbitrary read/write (KRW) access to the kernel, they could theoretically modify the page tables to make the kernel text writable.&lt;/p&gt;
    &lt;p&gt;KTRR bypasses the MMU entirely. It enforces permissions based on Physical Addresses (PA) directly within the Memory Controller (MCU).&lt;/p&gt;
    &lt;p&gt;The Register Interface:&lt;lb/&gt; KTRR is controlled via a set of proprietary system registers, typically accessible via &lt;code&gt;MSR&lt;/code&gt; instructions at EL1 (or GL2 in Tahoe).&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;KTRR_LOWER_EL1&lt;/code&gt;(&lt;code&gt;S3_4_c15_c2_3&lt;/code&gt;): Defines the physical start address of the protected range.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;KTRR_UPPER_EL1&lt;/code&gt;(&lt;code&gt;S3_4_c15_c2_4&lt;/code&gt;): Defines the physical end address.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;KTRR_LOCK_EL1&lt;/code&gt;(&lt;code&gt;S3_4_c15_c2_2&lt;/code&gt;): The kill switch. Writing&lt;code&gt;1&lt;/code&gt;to the lock bit enables the protection.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The "RoR" (Read-only Region) Mechanism:&lt;lb/&gt; Once the lock bit is set:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Write Protection: Any write transaction (store instruction or DMA) targeting a physical address within the &lt;code&gt;[LOWER, UPPER]&lt;/code&gt;range is dropped by the memory controller. Depending on the SoC generation, this either fails silently or triggers a synchronous external abort (SError).&lt;/item&gt;
      &lt;item&gt;Execute Protection: The memory controller ensures that instruction fetches are permitted from this region.&lt;/item&gt;
      &lt;item&gt;Immutability: The &lt;code&gt;KTRR_LOCK_EL1&lt;/code&gt;register itself becomes Read-Only. It cannot be unlocked by software.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The Tahoe Evolution (Virtualization of KTRR):&lt;lb/&gt; On M3/M4 chips running the SPTM, the kernel's interaction with KTRR changes. Since the kernel (EL1) is deprivileged, it cannot be trusted to set up KTRR correctly (it might set the range to zero, leaving itself unprotected).&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;SPTM Enforcement: The SPTM configures the physical KTRR registers during its own initialization (in &lt;code&gt;Ap,SecurePageTableMonitor&lt;/code&gt;).&lt;/item&gt;
      &lt;item&gt;Virtualization: When the XNU kernel executes the legacy instructions to write to &lt;code&gt;KTRR_LOWER/UPPER&lt;/code&gt;in&lt;code&gt;start&lt;/code&gt;, the hardware traps these accesses to GL2. The SPTM validates that the kernel is attempting to cover the correct physical range (matching the&lt;code&gt;XNU_TEXT&lt;/code&gt;entries in the Frame Table) and effectively "mocks" the success of the operation to the kernel, while ensuring the hardware is actually locked down according to the SPTM's policy.&lt;/item&gt;
    &lt;/list&gt;
    &lt;quote&gt;&lt;p&gt;RE Focus: The KTRR Slide Alignment&lt;/p&gt;&lt;lb/&gt;Because KTRR operates on physical ranges, it lacks the granularity of 4KB/16KB pages. It typically operates on larger blocks (e.g., 1MB or L2 cache line boundaries). This forces the KASLR slide to be aligned to the KTRR granularity. If you are brute-forcing the KASLR slide, knowing the KTRR alignment constraint significantly reduces the entropy search space.&lt;/quote&gt;
    &lt;head rend="h4"&gt;5.2.2 Kernel Integrity Protection (KIP): Extending the Shield&lt;/head&gt;
    &lt;p&gt;KTRR protects the static kernel binary (&lt;code&gt;kernelcache&lt;/code&gt;). However, modern macOS relies heavily on the Boot Kernel Collection (BKC) and Auxiliary Kernel Collection (AKC)—large caches of drivers and extensions loaded during boot. These reside in memory adjacent to the kernel but are technically distinct payloads.&lt;/p&gt;
    &lt;p&gt;Kernel Integrity Protection (KIP) is the architectural evolution designed to protect these dynamic-but-immutable regions.&lt;/p&gt;
    &lt;p&gt;The Mechanism:&lt;lb/&gt; Unlike KTRR, which typically defines a single contiguous range, KIP (often implemented via the GXF or APRR logic on newer chips) allows for a more flexible definition of immutable regions.&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Registration: During the &lt;code&gt;start&lt;/code&gt;routine, the kernel iterates over the loaded extensions (IOKit drivers).&lt;/item&gt;
      &lt;item&gt;Sealing: Once the extensions are linked and relocated, the kernel issues a call to "seal" the region. In Tahoe, this is a &lt;code&gt;GENTER&lt;/code&gt;call to the SPTM (Selector&lt;code&gt;sptm_retype&lt;/code&gt;or&lt;code&gt;sptm_protect&lt;/code&gt;).&lt;/item&gt;
      &lt;item&gt;Retyping: The SPTM updates the Frame Table Entries (FTE) for the physical pages backing the drivers. It transitions them from &lt;code&gt;XNU_DATA&lt;/code&gt;(Writable) to&lt;code&gt;XNU_TEXT&lt;/code&gt;(Executable/Read-Only).&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The "One-Way" Door:&lt;lb/&gt; The security invariant enforced here is that memory typed as &lt;code&gt;XNU_TEXT&lt;/code&gt; is never writable by EL1.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;If the kernel attempts to write to a KIP-protected page, the SPRR configuration for GL0 (Kernel) triggers a permission fault.&lt;/item&gt;
      &lt;item&gt;If the kernel attempts to ask the SPTM to map it as writable, the SPTM checks the FTE, sees &lt;code&gt;XNU_TEXT&lt;/code&gt;, and panics.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;This effectively turns the kernel extensions into ROM. This mitigates a massive class of rootkits that historically operated by patching IOKit vtables or function pointers in memory.&lt;/p&gt;
    &lt;head rend="h4"&gt;5.2.3 The System Control Register (&lt;code&gt;SCTLR_EL1&lt;/code&gt;) Lockdown&lt;/head&gt;
    &lt;p&gt;The final "Kill Switch" is the configuration of the ARM processor itself. The &lt;code&gt;SCTLR_EL1&lt;/code&gt; register controls the MMU, caches, and alignment checks.&lt;/p&gt;
    &lt;p&gt;Critical Bits:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;WXN&lt;/code&gt;(Write-XOR-Execute): Bit 19. When set, any memory region mapped as Writable is implicitly treated as Non-Executable (&lt;code&gt;XN&lt;/code&gt;). This prevents the execution of shellcode on the heap or stack.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;M&lt;/code&gt;(MMU Enable): Bit 0.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;A&lt;/code&gt;(Alignment Check): Bit 1.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The Trap-and-Emulate Trap:&lt;lb/&gt; In a standard ARM system, EL1 can modify &lt;code&gt;SCTLR_EL1&lt;/code&gt; at will. An attacker with code execution could simply write to &lt;code&gt;SCTLR_EL1&lt;/code&gt; to disable &lt;code&gt;WXN&lt;/code&gt;, map their shellcode, and execute it.&lt;/p&gt;
    &lt;p&gt;In the Tahoe architecture, &lt;code&gt;SCTLR_EL1&lt;/code&gt; is a trapped resource.&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;The Trap: The hardware is configured (via &lt;code&gt;HCR_EL2&lt;/code&gt;or proprietary GXF controls) to trap writes to&lt;code&gt;SCTLR_EL1&lt;/code&gt;to the monitor layer (GL2/SPTM).&lt;/item&gt;
      &lt;item&gt;The Policy: When the kernel executes &lt;code&gt;MSR SCTLR_EL1, x0&lt;/code&gt;, the CPU switches to the SPTM.&lt;/item&gt;
      &lt;item&gt;The Check: The SPTM inspects the value in &lt;code&gt;x0&lt;/code&gt;. It enforces a strict policy:&lt;code&gt;WXN&lt;/code&gt;must always be 1.&lt;/item&gt;
      &lt;item&gt;The Verdict: If the kernel attempts to clear &lt;code&gt;WXN&lt;/code&gt;, the SPTM denies the write and panics the system with a "Security Violation" code.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;This ensures that the fundamental security properties of the execution environment (W^X) cannot be disabled, even by the kernel itself. The kernel is permanently locked into a secure configuration from the moment &lt;code&gt;start&lt;/code&gt; completes.&lt;/p&gt;
    &lt;head rend="h3"&gt;5.3 Exclaves: The Microkernel within the Monolith&lt;/head&gt;
    &lt;p&gt;The introduction of Exclaves in the Tahoe architecture represents the most profound structural change to the Apple OS ecosystem since the transition from Mac OS 9 to OS X. It is an admission that the monolithic kernel architecture (XNU) has become too large, too complex, and too mutable to serve as the ultimate Trusted Computing Base (TCB) for high-value assets.&lt;/p&gt;
    &lt;p&gt;Exclaves introduce a Microkernel architecture running side-by-side with the monolithic XNU kernel on the same Application Processor cores. Unlike the Secure Enclave (which is a separate coprocessor with limited compute power), Exclaves harness the full performance of the M-series P-cores and E-cores while maintaining cryptographic isolation enforced by the SPTM.&lt;/p&gt;
    &lt;head rend="h4"&gt;5.3.1 The L4 Influence: Domains, Conclaves, and IPC&lt;/head&gt;
    &lt;p&gt;The architecture of the Exclave system is heavily indebted to the L4 microkernel family (specifically seL4). It prioritizes minimalism, capability-based security, and strict isolation.&lt;/p&gt;
    &lt;p&gt;The Hierarchy of Isolation:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;The Secure Kernel (&lt;code&gt;ExclaveOS&lt;/code&gt;): A tiny, formally verifiable kernel that manages scheduling and IPC within the secure world. It runs at a privilege level guarded by the SPTM (likely GL1 or a restricted GL2 domain).&lt;/item&gt;
      &lt;item&gt;Domains: The highest level of separation. The "Insecure Domain" hosts XNU and userland. The "Secure Domain" hosts Exclave workloads.&lt;/item&gt;
      &lt;item&gt;Conclaves: Within the Secure Domain, workloads are siloed into Conclaves. A Conclave is a lightweight container consisting of an address space, a set of capabilities (handles to resources), and threads. &lt;list rend="ul"&gt;&lt;item&gt;Example: The &lt;code&gt;FaceID&lt;/code&gt;Conclave cannot access the memory of the&lt;code&gt;Wallet&lt;/code&gt;Conclave, even though both run within the Exclave environment.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;Example: The &lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Memory Management via SPTM:&lt;lb/&gt; The isolation is enforced by the SPTM's Frame Table. Physical pages assigned to an Exclave are typed in the FTE (likely as &lt;code&gt;EXCLAVE_DATA&lt;/code&gt; or &lt;code&gt;SK_DATA&lt;/code&gt;).&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;XNU View: The kernel sees these physical pages as "reserved" or "stolen" in the device tree. Any attempt by XNU to map these pages via &lt;code&gt;sptm_map&lt;/code&gt;will result in a panic, as the SPTM forbids mapping Exclave-owned pages into the&lt;code&gt;XNU_DOMAIN&lt;/code&gt;.&lt;/item&gt;
      &lt;item&gt;Exclave View: The ExclaveOS requests mappings from the SPTM. The SPTM updates the translation tables specific to the Exclave context (a distinct &lt;code&gt;TTBR&lt;/code&gt;or context ID).&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h4"&gt;5.3.2 RE Focus: The &lt;code&gt;RingGate&lt;/code&gt; Mechanism and &lt;code&gt;XNUProxy&lt;/code&gt;&lt;/head&gt;
    &lt;p&gt;For the reverse engineer, the critical question is: How does the Kernel talk to an Exclave? They share no virtual memory, run in different hardware contexts, and the SPTM actively prevents XNU from mapping Exclave physical pages. The bridge is a mechanism internally referred to as RingGate, facilitated by a kernel extension named &lt;code&gt;XNUProxy&lt;/code&gt; (&lt;code&gt;com.apple.driver.XNUProxy&lt;/code&gt;).&lt;/p&gt;
    &lt;p&gt;The Communication Stack:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;&lt;p&gt;Tightbeam (The IDL):&lt;/p&gt;&lt;lb/&gt;Apple has introduced a new Interface Definition Language (IDL) called Tightbeam. It replaces the legacy Mach Interface Generator (MIG) for secure world communication. Unlike MIG, which is loosely typed and message-centric, Tightbeam is strongly typed and buffer-centric, designed to minimize parsing ambiguity.&lt;list rend="ul"&gt;&lt;item&gt;Userland Analysis: The serialization logic is visible in &lt;code&gt;/usr/lib/libTightbeam.dylib&lt;/code&gt;. Analyzing this library reveals the wire format: a header containing a protocol version and message ID, followed by a packed struct of arguments. Symbols like&lt;code&gt;tb_message_encode&lt;/code&gt;,&lt;code&gt;tb_client_call&lt;/code&gt;, and&lt;code&gt;tb_endpoint_create&lt;/code&gt;are the primary indicators of this traffic.&lt;/item&gt;&lt;item&gt;Kernel Analysis: In &lt;code&gt;XNUProxy&lt;/code&gt;, look for the&lt;code&gt;TBTransport&lt;/code&gt;C++ classes that wrap the raw ring buffer management.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;Userland Analysis: The serialization logic is visible in &lt;/item&gt;
      &lt;item&gt;&lt;p&gt;The Downcall (XNU $\rightarrow$ Exclave):&lt;/p&gt;&lt;lb/&gt;When XNU needs a service (e.g., "Authenticate this Passkey"), it cannot call the function directly.&lt;list rend="ul"&gt;&lt;item&gt;Marshaling: &lt;code&gt;XNUProxy&lt;/code&gt;serializes the request using Tightbeam into a shared memory ring buffer.&lt;/item&gt;&lt;item&gt;The Gate: The kernel executes a specific instruction to trigger the world switch. This is a &lt;code&gt;GENTER&lt;/code&gt;instruction targeting a specific Dispatch ID reserved for the Secure Kernel (distinct from the SPTM/TXM selectors).&lt;/item&gt;&lt;item&gt;Context Switch: The hardware (mediated by SPTM) saves the EL1 state, switches the SPRR configuration to the Exclave view, and jumps to the &lt;code&gt;ExclaveOS&lt;/code&gt;entry point.&lt;/item&gt;&lt;item&gt;Dispatch: &lt;code&gt;ExclaveOS&lt;/code&gt;inspects the ring buffer and routes the message to the appropriate Conclave's IPC port.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;Marshaling: &lt;/item&gt;
      &lt;item&gt;&lt;p&gt;The Upcall (Exclave $\rightarrow$ XNU):&lt;/p&gt;&lt;lb/&gt;Exclaves are not completely autonomous; they often rely on XNU for file system I/O or networking (since writing a full network stack in a microkernel is impractical).&lt;list rend="ul"&gt;&lt;item&gt;The Exclave writes a request to the outbound ring buffer.&lt;/item&gt;&lt;item&gt;It triggers an interrupt or executes a &lt;code&gt;GEXIT&lt;/code&gt;yield.&lt;/item&gt;&lt;item&gt;&lt;code&gt;XNUProxy&lt;/code&gt;receives the notification, reads the request (e.g., "Write this blob to disk"), performs the operation via standard VFS calls, and returns the result via a Downcall.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Analyzing the &lt;code&gt;XNUProxy&lt;/code&gt; Kext:&lt;lb/&gt; This kext is the Rosetta Stone for Exclave interaction. It maintains the mapping between Mach Ports (in XNU) and Tightbeam Endpoints (in Exclaves).&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Endpoint Mapping: Reverse engineering the &lt;code&gt;XNUProxy&lt;/code&gt;binary reveals structures that map 64-bit integer IDs to specific Exclave services. It effectively acts as a NAT (Network Address Translation) layer between Mach Ports and Exclave Endpoints.&lt;/item&gt;
      &lt;item&gt;Memory Loaning (The "DART" Window): While control messages go through ring buffers, large data transfers (like camera frames or biometric buffers) occur via Memory Loaning. &lt;list rend="ul"&gt;&lt;item&gt;&lt;code&gt;XNUProxy&lt;/code&gt;pins a userland page and retrieves its physical address.&lt;/item&gt;&lt;item&gt;It passes this Physical Page Number (PPN) to the Exclave via Tightbeam.&lt;/item&gt;&lt;item&gt;The Exclave requests the SPTM to map this specific PPN into its address space.&lt;/item&gt;&lt;item&gt;Vulnerability Class: This "Loaned Memory" is a prime target for TOCTOU (Time-of-Check to Time-of-Use) attacks. If the kernel (or a malicious user thread) modifies the content of the physical page after the Exclave has validated the header but before it processes the body, the Exclave's parser could be compromised. The SPTM likely enforces "Shared" vs "Exclusive" ownership states in the Frame Table to mitigate this, but the logic is complex and fragile.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h4"&gt;5.3.3 Use Case: Secure Control of Privacy Indicators and Passkeys&lt;/head&gt;
    &lt;p&gt;The "Killer App" for Exclaves in macOS Tahoe is the hardware-enforced privacy indicator (the green/orange dots).&lt;/p&gt;
    &lt;p&gt;The Pre-Tahoe Vulnerability:&lt;lb/&gt; In previous macOS versions, the "Green Dot" (camera active) was drawn by &lt;code&gt;WindowServer&lt;/code&gt; or the kernel. If an attacker achieved kernel-level code execution (Ring 0), they could hook the display driver and suppress the dot while recording the user.&lt;/p&gt;
    &lt;p&gt;The Tahoe Solution:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Hardware Ownership: The physical frame buffer region corresponding to the status bar indicators is not mapped in the XNU domain. It is owned exclusively by a specific Privacy Conclave.&lt;/item&gt;
      &lt;item&gt;The DART Lock: The Display Coprocessor's IOMMU (DART) is configured by the SPTM such that the main display pipe cannot write to the indicator pixels. Only the secure overlay pipe, controlled by the Exclave, can write there.&lt;/item&gt;
      &lt;item&gt;Sensor Interrupts: When the camera sensor is energized, the GPIO interrupt is routed directly to the Exclave (via the AIC - Apple Interrupt Controller).&lt;/item&gt;
      &lt;item&gt;The Drawing Path: The Exclave receives the "Camera On" interrupt. It writes directly to the secure frame buffer overlay to render the green dot.&lt;/item&gt;
      &lt;item&gt;Immutability: Because XNU cannot map the physical memory of the secure overlay, and cannot reconfigure the DART (locked by SPTM), a compromised kernel is physically incapable of erasing the indicator.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Passkeys and FIDO:&lt;lb/&gt; Similarly, the cryptographic operations for Passkeys (WebAuthn) have moved to an Exclave.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Private Keys: The private keys for Passkeys are generated and stored within the Exclave's secure storage (mediated by SEP).&lt;/item&gt;
      &lt;item&gt;Biometric Binding: The Exclave communicates directly with the SEP to verify FaceID/TouchID.&lt;/item&gt;
      &lt;item&gt;Isolation: Even if malware injects code into &lt;code&gt;LocalAuthentication&lt;/code&gt;daemon or the kernel, it cannot extract the private key material, as it resides in a memory domain that simply does not exist in the attacker's address space.&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h2"&gt;6.0 The Mach Subsystem: The Nervous System&lt;/head&gt;
    &lt;p&gt;While the SPTM and Exclaves represent the new fortress walls of the Apple Silicon architecture, the Mach subsystem remains the internal nervous system that coordinates activity within the XNU kernel. Originating from the NeXTSTEP era, Mach provides the fundamental primitives for Inter-Process Communication (IPC), thread scheduling, and virtual memory management.&lt;/p&gt;
    &lt;p&gt;For the reverse engineer, Mach is the primary vector for local privilege escalation (LPE). Despite decades of hardening, the complexity of state management in Mach messaging remains a fertile ground for logic bugs, race conditions, and reference counting errors. In the Tahoe era, Mach has been retrofitted with heavy PAC enforcement to protect its object graph.&lt;/p&gt;
    &lt;head rend="h3"&gt;6.1 Mach Ports &amp;amp; IPC Primitives&lt;/head&gt;
    &lt;p&gt;At the conceptual level, Mach is an object-oriented kernel. The fundamental unit of addressing is the Mach Port. To a userland process, a port is merely a 32-bit integer handle (&lt;code&gt;mach_port_name_t&lt;/code&gt;). To the kernel, it is a complex, reference-counted data structure (&lt;code&gt;ipc_port&lt;/code&gt;) that acts as a unidirectional communication channel.&lt;/p&gt;
    &lt;head rend="h4"&gt;6.1.1 Port Rights: Receive, Send, Send-Once, and Dead Names&lt;/head&gt;
    &lt;p&gt;The security model of Mach is capability-based. Possessing a port name is meaningless without the associated Port Right. The kernel tracks these rights in the process's IPC space.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;MACH_PORT_RIGHT_RECEIVE&lt;/code&gt;: The ownership right. Only one task can hold the Receive right for a specific port at any given time. This task is the destination for messages sent to the port.&lt;list rend="ul"&gt;&lt;item&gt;Kernel Structure: The &lt;code&gt;ipc_port&lt;/code&gt;struct contains a pointer (&lt;code&gt;ip_receiver&lt;/code&gt;) to the&lt;code&gt;ipc_space&lt;/code&gt;of the task holding this right.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;Kernel Structure: The &lt;/item&gt;
      &lt;item&gt;&lt;code&gt;MACH_PORT_RIGHT_SEND&lt;/code&gt;: The ability to queue messages into the port. Multiple tasks can hold send rights to the same port. This is the standard "client" handle.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;MACH_PORT_RIGHT_SEND_ONCE&lt;/code&gt;: A "fire-and-forget" right that vanishes after a single message is sent. This is critical for the Request/Reply pattern (RPC). When a client sends a message, it typically includes a&lt;code&gt;MAKE_SEND_ONCE&lt;/code&gt;right to its own reply port. The server uses this to send exactly one reply, preventing the server from spamming the client later.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;MACH_PORT_RIGHT_DEAD_NAME&lt;/code&gt;: If the task holding the Receive right dies or destroys the port, all outstanding Send rights in other tasks are instantly transmuted into Dead Names. Any attempt to send a message to a dead name returns&lt;code&gt;MACH_SEND_INVALID_DEST&lt;/code&gt;.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;RE Focus: The &lt;code&gt;ipc_port&lt;/code&gt; Structure and PAC:&lt;lb/&gt; In previous generations, a common exploit technique involved "Fake Ports"—spraying the heap with crafted data that looked like an &lt;code&gt;ipc_port&lt;/code&gt; struct and then tricking the kernel into using it.&lt;/p&gt;
    &lt;p&gt;In the arm64e/Tahoe architecture, the &lt;code&gt;ipc_port&lt;/code&gt; structure is heavily fortified:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;&lt;code&gt;ip_object&lt;/code&gt;: The base header of the port.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;ip_kobject&lt;/code&gt;: A pointer to the underlying kernel object (e.g., a task, a thread, or a user-client). This pointer is PAC-signed.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;ip_context&lt;/code&gt;: A 64-bit context value, also PAC-signed.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;If an attacker attempts to forge a port, they must generate a valid signature for the &lt;code&gt;ip_kobject&lt;/code&gt; pointer. Without the &lt;code&gt;APDAKey&lt;/code&gt; (Data Key A), the kernel will panic upon &lt;code&gt;AUT&lt;/code&gt; execution during message delivery.&lt;/p&gt;
    &lt;head rend="h4"&gt;6.1.2 The IPC Space (&lt;code&gt;ipc_space&lt;/code&gt;) and the Global Name Server&lt;/head&gt;
    &lt;p&gt;Every task (process) in macOS has an associated IPC Space (&lt;code&gt;ipc_space&lt;/code&gt;). This structure acts as the translation layer between the userland integer handles (&lt;code&gt;mach_port_name_t&lt;/code&gt;) and the kernel pointers (&lt;code&gt;ipc_port *&lt;/code&gt;).&lt;/p&gt;
    &lt;p&gt;The Translation Table (&lt;code&gt;is_table&lt;/code&gt;):&lt;lb/&gt; The IPC space is implemented as a dynamic table (or radix tree for large spaces) of IPC Entries (&lt;code&gt;ipc_entry&lt;/code&gt;).&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Index: The userland handle (e.g., &lt;code&gt;0x103&lt;/code&gt;) is essentially an index into this table.&lt;/item&gt;
      &lt;item&gt;Entry: The &lt;code&gt;ipc_entry&lt;/code&gt;struct contains:&lt;list rend="ul"&gt;&lt;item&gt;&lt;code&gt;ie_object&lt;/code&gt;: A pointer to the actual&lt;code&gt;ipc_port&lt;/code&gt;(or&lt;code&gt;ipc_pset&lt;/code&gt;). Crucially, in Tahoe, this pointer is signed with PAC.&lt;/item&gt;&lt;item&gt;&lt;code&gt;ie_bits&lt;/code&gt;: A bitfield storing the rights (Receive, Send, etc.) and the generation number (to detect stale handles).&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The Lookup Process (&lt;code&gt;ipc_right_lookup_write&lt;/code&gt;):&lt;lb/&gt; When a user executes &lt;code&gt;mach_msg()&lt;/code&gt;, the kernel:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Retrieves the &lt;code&gt;current_task()-&amp;gt;itk_space&lt;/code&gt;.&lt;/item&gt;
      &lt;item&gt;Uses the handle passed in &lt;code&gt;msgh_remote_port&lt;/code&gt;to index into the&lt;code&gt;is_table&lt;/code&gt;.&lt;/item&gt;
      &lt;item&gt;Validates the &lt;code&gt;ie_bits&lt;/code&gt;to ensure the task actually possesses the required right (e.g.,&lt;code&gt;MACH_PORT_RIGHT_SEND&lt;/code&gt;).&lt;/item&gt;
      &lt;item&gt;Authenticates the &lt;code&gt;ie_object&lt;/code&gt;pointer using&lt;code&gt;AUT&lt;/code&gt;.&lt;/item&gt;
      &lt;item&gt;Retrieves the &lt;code&gt;ipc_port&lt;/code&gt;.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The Global Name Server:&lt;lb/&gt; Mach does not have a string-based global namespace in the kernel. "Service Discovery" is implemented in userland by &lt;code&gt;launchd&lt;/code&gt; (the Bootstrap Server).&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Special Ports: The kernel does maintain a small array of "Special Ports" attached to the Host and Task objects. &lt;list rend="ul"&gt;&lt;item&gt;&lt;code&gt;HOST_PORT&lt;/code&gt;: Represents the kernel itself.&lt;/item&gt;&lt;item&gt;&lt;code&gt;HOST_PRIV_PORT&lt;/code&gt;: The "God Mode" port (see Section 6.2).&lt;/item&gt;&lt;item&gt;&lt;code&gt;TASK_BOOTSTRAP_PORT&lt;/code&gt;: The handle to&lt;code&gt;launchd&lt;/code&gt;.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;When a process calls &lt;code&gt;bootstrap_look_up("com.apple.foo")&lt;/code&gt;, it is actually sending a Mach message to the port stored in its &lt;code&gt;TASK_BOOTSTRAP_PORT&lt;/code&gt; slot.&lt;/p&gt;
    &lt;head rend="h4"&gt;6.1.3 Copy-on-Write (CoW) optimizations in Out-of-Line (OOL) message passing&lt;/head&gt;
    &lt;p&gt;Mach messages are not limited to small scalars. They can transfer massive amounts of data using Out-of-Line (OOL) descriptors. This mechanism relies on Virtual Memory (VM) tricks rather than data copying, making it highly efficient but historically dangerous.&lt;/p&gt;
    &lt;p&gt;The Mechanism:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Sender: Includes a &lt;code&gt;mach_msg_ool_descriptor_t&lt;/code&gt;in the message, pointing to a buffer in its address space (e.g., 100MB of data).&lt;/item&gt;
      &lt;item&gt;Kernel Processing: The kernel does not copy the 100MB. Instead, it walks the sender's VM map.&lt;/item&gt;
      &lt;item&gt;Copy-on-Write (CoW): The kernel marks the physical pages backing that buffer as Read-Only in the sender's map.&lt;/item&gt;
      &lt;item&gt;Receiver: The kernel maps those same physical pages into the receiver's address space, also as Read-Only.&lt;/item&gt;
      &lt;item&gt;Faulting: If either the sender or receiver tries to write to the buffer, the MMU triggers a fault. The kernel catches this, allocates a new physical page, copies the data, and updates the mapping for the writer. This preserves the illusion of a copy.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The Tahoe/SPTM Intersection:&lt;lb/&gt; In the Tahoe architecture, this VM manipulation is complicated by the SPTM.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Permission Downgrade: When the kernel marks the pages as CoW (Read-Only), it cannot simply update the PTEs. It must issue a &lt;code&gt;GENTER&lt;/code&gt;call (&lt;code&gt;sptm_protect&lt;/code&gt;or&lt;code&gt;sptm_map&lt;/code&gt;) to the SPTM to downgrade the permissions of the physical pages in the sender's address space.&lt;/item&gt;
      &lt;item&gt;The Vulnerability Class: This complexity introduces a race window. If the kernel logic fails to correctly lock the VM map object before requesting the SPTM update, or if the SPTM state machine has a logic flaw regarding shared pages (&lt;code&gt;refcount &amp;gt; 1&lt;/code&gt;), it might be possible to modify the physical page after the message has been "sent" but before the receiver reads it. This is known as a Double Fetch or Physically-Backed-Virtually-Disjoint attack.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;RE Focus:&lt;lb/&gt; Analyze &lt;code&gt;vm_map_copyin&lt;/code&gt; and &lt;code&gt;vm_map_copyout&lt;/code&gt; in the XNU source (or binary). Look for how &lt;code&gt;vm_map_entry&lt;/code&gt; structures are flagged with &lt;code&gt;needs_copy&lt;/code&gt; and how these flags translate into SPTM calls. The interaction between Mach IPC (which assumes it controls VM) and the SPTM (which actually controls VM) is the friction point where new bugs will likely emerge.&lt;/p&gt;
    &lt;head rend="h3"&gt;6.2 The &lt;code&gt;host_priv&lt;/code&gt; Port&lt;/head&gt;
    &lt;p&gt;In the lexicon of XNU exploitation, the Host Privilege Port (&lt;code&gt;host_priv&lt;/code&gt;) has historically been synonymous with "Game Over." It is the Mach port representing the kernel task itself. Possessing a send right to this port allows a userland process to invoke the &lt;code&gt;host_priv_server&lt;/code&gt; subsystem, granting the ability to manipulate physical memory, load kernel extensions (legacy), and control processor sets.&lt;/p&gt;
    &lt;p&gt;However, in the Tahoe architecture, the omnipotence of &lt;code&gt;host_priv&lt;/code&gt; has been severely curtailed. The Secure Page Table Monitor (SPTM) and the Trusted Execution Monitor (TXM) have effectively neutered the "God Mode" capabilities traditionally associated with this handle.&lt;/p&gt;
    &lt;head rend="h4"&gt;6.2.1 The "God Mode" Handle: Generation and Restriction&lt;/head&gt;
    &lt;p&gt;The &lt;code&gt;host_priv&lt;/code&gt; port is backed by the &lt;code&gt;realhost&lt;/code&gt; kernel global structure. Unlike standard task ports, which map to a &lt;code&gt;task_t&lt;/code&gt;, the &lt;code&gt;host_priv&lt;/code&gt; port maps to the host object, but with a specific bit set in its &lt;code&gt;ip_kobject&lt;/code&gt; pointer or context indicating privileged access.&lt;/p&gt;
    &lt;p&gt;Generation at Boot:&lt;lb/&gt; During the kernel bootstrap (&lt;code&gt;osfmk/kern/host.c&lt;/code&gt;), the system initializes the host subsystem.&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;&lt;code&gt;host_init()&lt;/code&gt;: Allocates the&lt;code&gt;realhost&lt;/code&gt;structure.&lt;/item&gt;
      &lt;item&gt;Port Allocation: Calls &lt;code&gt;ipc_port_alloc_kernel()&lt;/code&gt;to create the port.&lt;/item&gt;
      &lt;item&gt;Kobject Association: The port is associated with the &lt;code&gt;realhost&lt;/code&gt;structure.&lt;list rend="ul"&gt;&lt;item&gt;PAC Enforcement: On arm64e, the &lt;code&gt;ip_kobject&lt;/code&gt;pointer stored in the port structure is signed using the&lt;code&gt;APDAKey&lt;/code&gt;(Data Key A) combined with the address of the port structure as the context. This prevents an attacker with a kernel read/write primitive from simply overwriting the&lt;code&gt;ip_kobject&lt;/code&gt;of a user port to point to&lt;code&gt;realhost&lt;/code&gt;.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;PAC Enforcement: On arm64e, the &lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Distribution:&lt;lb/&gt; The kernel is extremely stingy with this port. It is vended primarily to:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;kernel_task&lt;/code&gt;: The kernel itself holds the receive right.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;launchd&lt;/code&gt;(PID 1): Receives a send right during the userland bootstrap handoff.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;kextd&lt;/code&gt;/&lt;code&gt;kernelmanagerd&lt;/code&gt;: Required for managing kernel extensions (though this role is diminishing with DriverKit).&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The "TFP0" Fallacy in Tahoe:&lt;lb/&gt; Historically, obtaining &lt;code&gt;host_priv&lt;/code&gt; allowed an attacker to call &lt;code&gt;task_for_pid(host_priv, 0, &amp;amp;kernel_task)&lt;/code&gt;. This returned the &lt;code&gt;kernel_task&lt;/code&gt; port, granting full &lt;code&gt;vm_read&lt;/code&gt;/&lt;code&gt;vm_write&lt;/code&gt; access to the kernel's entire address space (TFP0).&lt;/p&gt;
    &lt;p&gt;In the Tahoe architecture, this chain is broken by the SPTM:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;&lt;code&gt;task_conversion_eval&lt;/code&gt;: Even if you possess&lt;code&gt;host_priv&lt;/code&gt;, the kernel checks the System Integrity Protection (SIP) policy managed by the TXM. If SIP is active,&lt;code&gt;task_for_pid(0)&lt;/code&gt;returns&lt;code&gt;KERN_FAILURE&lt;/code&gt;.&lt;/item&gt;
      &lt;item&gt;The Immutable Kernel: Even if you bypass the SIP check (e.g., via a logic bug), and obtain the &lt;code&gt;kernel_task&lt;/code&gt;port, the&lt;code&gt;vm_write&lt;/code&gt;operations are intercepted.&lt;list rend="ul"&gt;&lt;item&gt;If you attempt to write to kernel text (&lt;code&gt;XNU_TEXT&lt;/code&gt;), the SPTM panics the system (Permission Violation).&lt;/item&gt;&lt;item&gt;If you attempt to write to page tables (&lt;code&gt;PAGE_TABLE&lt;/code&gt;), the SPTM panics the system.&lt;/item&gt;&lt;item&gt;If you attempt to write to Data Const (&lt;code&gt;XNU_DATA_CONST&lt;/code&gt;), the SPTM panics.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;If you attempt to write to kernel text (&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Thus, in Tahoe, &lt;code&gt;host_priv&lt;/code&gt; degrades from a "Write-Anywhere" primitive to a "Logic Control" primitive. It allows you to invoke privileged kernel APIs, but it does not grant direct memory corruption capabilities against protected regions.&lt;/p&gt;
    &lt;head rend="h4"&gt;6.2.2 Task Special Ports: The Privileged Directory&lt;/head&gt;
    &lt;p&gt;While &lt;code&gt;host_priv&lt;/code&gt; itself is restricted, it acts as the directory service for a set of Special Ports that control specific subsystems. These are accessed via &lt;code&gt;host_get_special_port&lt;/code&gt; (MIG ID 205).&lt;/p&gt;
    &lt;p&gt;The &lt;code&gt;realhost&lt;/code&gt; structure maintains a static array of these ports: &lt;code&gt;ipc_port_t special[HOST_MAX_SPECIAL_PORT + 1]&lt;/code&gt;.&lt;/p&gt;
    &lt;p&gt;Critical Special Ports:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;HOST_KEXTD_PORT&lt;/code&gt;(ID 1): The handle used to communicate with the kernel extension manager. Historically used to force the kernel to load a malicious kext. In Tahoe, kext loading is gated by the TXM, which verifies the signature and the LocalPolicy.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;HOST_SEATBELT_PORT&lt;/code&gt;(ID 7): The control port for the Sandbox (&lt;code&gt;sandbox.kext&lt;/code&gt;). Possession of this port allows a process to query and potentially manipulate sandbox policies (though policy application is usually one-way).&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;HOST_AMFID_PORT&lt;/code&gt;(ID 18): The communication channel for&lt;code&gt;amfid&lt;/code&gt;. This port is critical for the Code Signing validation loop.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;HOST_AUTOMOUNTD_PORT&lt;/code&gt;(ID 11): Used to trigger filesystem mounts.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;RE Focus: The &lt;code&gt;host_set_special_port&lt;/code&gt; Trap:&lt;lb/&gt; A common post-exploitation technique involves overwriting one of these special ports with a port controlled by the attacker (e.g., replacing the &lt;code&gt;KEXTD&lt;/code&gt; port). This allows the attacker to intercept kernel upcalls intended for system daemons.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Mitigation: The &lt;code&gt;host_set_special_port&lt;/code&gt;routine checks the caller's entitlements. Only a process with the&lt;code&gt;com.apple.private.set-special-port&lt;/code&gt;entitlement (usually only&lt;code&gt;launchd&lt;/code&gt;) can overwrite these entries.&lt;/item&gt;
      &lt;item&gt;Bypass: Attackers look for logic bugs where a race condition allows replacing a port before the entitlement check completes, or finding a daemon that holds this entitlement and coercing it to perform the set operation (Confused Deputy).&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h4"&gt;6.2.3 RE Focus: Fuzzing Mach Message Parsing (MIG)&lt;/head&gt;
    &lt;p&gt;Since &lt;code&gt;host_priv&lt;/code&gt; exposes a wide attack surface via the Mach IPC interface, it is a primary target for fuzzing. The kernel handles these messages using the Mach Interface Generator (MIG).&lt;/p&gt;
    &lt;p&gt;The &lt;code&gt;host_priv_server&lt;/code&gt; Routine:&lt;lb/&gt; When a message is sent to &lt;code&gt;host_priv&lt;/code&gt;, the kernel's IPC dispatcher calls &lt;code&gt;host_priv_server&lt;/code&gt;. This is an auto-generated function that deserializes the Mach message and dispatches it to the implementation (e.g., &lt;code&gt;kern_host.c&lt;/code&gt;).&lt;/p&gt;
    &lt;p&gt;Vulnerability Classes in MIG:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Type Confusion: MIG relies on the message header to define the size and type of arguments. If the userland client sends a malformed message (e.g., claiming a descriptor is OOL memory when it is actually inline data), the kernel's unmarshaling logic might misinterpret the data, leading to heap corruption.&lt;/item&gt;
      &lt;item&gt;Reference Counting Leaks: If a MIG routine returns an error (e.g., &lt;code&gt;KERN_INVALID_ARGUMENT&lt;/code&gt;) after it has incremented the reference count on a port or VM object but before it consumes it, the object leaks. In the kernel, this can lead to a refcount overflow (though 64-bit refcounts make this hard) or a Use-After-Free if the cleanup logic is flawed.&lt;/item&gt;
      &lt;item&gt;TOCTOU on OOL Memory: As discussed in Section 6.1.3, if the message includes Out-of-Line memory, the kernel maps it Copy-on-Write. If the MIG handler verifies the content of the memory and then uses it later, the userland process might be able to race the kernel and modify the physical page (via a side-channel or SPTM state confusion) between the check and the use.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The Tahoe Hardening:&lt;lb/&gt; In the Tahoe kernel, MIG-generated code has been hardened with PAC.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Function Pointers: The dispatch tables used by &lt;code&gt;host_priv_server&lt;/code&gt;are signed.&lt;/item&gt;
      &lt;item&gt;Context: The &lt;code&gt;ipc_kmsg&lt;/code&gt;structure (representing the message in flight) is heavily protected to prevent modification of the message contents after validation but before processing.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;However, logic bugs in the implementation of the host calls (the C functions called by MIG) remain reachable. For example, &lt;code&gt;host_processor_set_priv&lt;/code&gt; allows manipulating CPU sets. If the logic fails to account for a processor being in a low-power state or being managed by an Exclave, it could trigger an inconsistent state in the scheduler.&lt;/p&gt;
    &lt;head rend="h2"&gt;7.0 IOKit &amp;amp; Driver Architecture&lt;/head&gt;
    &lt;p&gt;While the Mach subsystem provides the primitives for IPC and scheduling, IOKit provides the object-oriented framework for device drivers. Historically, IOKit has been the "soft underbelly" of the XNU kernel. Written in a restricted subset of C++, it relies heavily on virtual function dispatch, complex inheritance hierarchies, and manual reference counting (&lt;code&gt;OSObject::retain&lt;/code&gt;/&lt;code&gt;release&lt;/code&gt;).&lt;/p&gt;
    &lt;p&gt;In the Tahoe architecture, IOKit has undergone a radical hardening process. The transition to Apple Silicon has allowed Apple to enforce strict Control Flow Integrity (CFI) on C++ objects using PAC, while the SPTM enforces the immutability of the driver code itself.&lt;/p&gt;
    &lt;head rend="h3"&gt;7.1 IOKit Initialization&lt;/head&gt;
    &lt;p&gt;The initialization of IOKit is the bridge between the static hardware description provided by iBoot (the Device Tree) and the dynamic, runtime object graph that constitutes the macOS driver environment.&lt;/p&gt;
    &lt;head rend="h4"&gt;7.1.1 The IORegistry: Populating the Device Tree into C++ Objects&lt;/head&gt;
    &lt;p&gt;When the kernel boots, the hardware topology is described by the Flattened Device Tree (FDT) located at the physical address passed in &lt;code&gt;x1&lt;/code&gt; to &lt;code&gt;_start&lt;/code&gt;. IOKit's first major task is to hydrate this binary blob into a live graph of &lt;code&gt;IORegistryEntry&lt;/code&gt; objects.&lt;/p&gt;
    &lt;p&gt;The &lt;code&gt;IOPlatformExpert&lt;/code&gt;:&lt;lb/&gt; The bootstrap process is driven by the &lt;code&gt;IOPlatformExpert&lt;/code&gt; class (specifically &lt;code&gt;IOPlatformExpertDevice&lt;/code&gt; on Apple Silicon).&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Unflattening: The kernel parses the FDT. For every node in the tree (e.g., &lt;code&gt;arm-io&lt;/code&gt;,&lt;code&gt;uart0&lt;/code&gt;,&lt;code&gt;aic&lt;/code&gt;), it instantiates an&lt;code&gt;IORegistryEntry&lt;/code&gt;.&lt;/item&gt;
      &lt;item&gt;The &lt;code&gt;IODeviceTree&lt;/code&gt;Plane: These objects are attached to the&lt;code&gt;IODeviceTree&lt;/code&gt;plane of the Registry. This plane represents the physical topology as reported by iBoot.&lt;/item&gt;
      &lt;item&gt;Property Mapping: Properties from the FDT (like &lt;code&gt;reg&lt;/code&gt;,&lt;code&gt;interrupts&lt;/code&gt;,&lt;code&gt;compatible&lt;/code&gt;) are converted into&lt;code&gt;OSData&lt;/code&gt;,&lt;code&gt;OSString&lt;/code&gt;, or&lt;code&gt;OSNumber&lt;/code&gt;objects and attached to the registry entries.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Matching and Driver Loading:&lt;lb/&gt; Once the Registry is populated, IOKit begins the Matching phase (&lt;code&gt;IOService::startMatching&lt;/code&gt;).&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;The &lt;code&gt;compatible&lt;/code&gt;String: IOKit iterates over the registry entries. It compares the&lt;code&gt;compatible&lt;/code&gt;property (e.g.,&lt;code&gt;apple,s5l8960x-uart&lt;/code&gt;) against the&lt;code&gt;IOKitPersonalities&lt;/code&gt;dictionary defined in the&lt;code&gt;Info.plist&lt;/code&gt;of every loaded driver.&lt;/item&gt;
      &lt;item&gt;The Probe/Start Lifecycle: When a match is found, the driver's C++ class is instantiated. &lt;list rend="ul"&gt;&lt;item&gt;&lt;code&gt;init()&lt;/code&gt;: Constructor.&lt;/item&gt;&lt;item&gt;&lt;code&gt;probe()&lt;/code&gt;: The driver verifies the hardware is actually present (rarely used on SoCs where hardware is static).&lt;/item&gt;&lt;item&gt;&lt;code&gt;start()&lt;/code&gt;: The driver initializes the hardware, maps MMIO regions, and registers interrupts.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;RE Focus: The "Missing" Hardware:&lt;lb/&gt; On Tahoe systems, you will notice gaps in the IORegistry compared to the raw Device Tree.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Reserved Regions: The SPTM and TXM reserve specific hardware blocks (e.g., the Secure Storage controller or specific GPIO banks for privacy LEDs).&lt;/item&gt;
      &lt;item&gt;Filtering: During the unflattening process, the kernel checks the memory map. If a device node's &lt;code&gt;reg&lt;/code&gt;property overlaps with a physical range reserved by the SPTM, the kernel skips creating an&lt;code&gt;IORegistryEntry&lt;/code&gt;for it. This prevents the kernel from even attempting to map the MMIO registers for secure hardware, effectively making that hardware invisible to the OS.&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h4"&gt;7.1.2 Boot Kernel Collection (BKC) vs. Auxiliary Kernel Collection (AKC)&lt;/head&gt;
    &lt;p&gt;Gone are the days of loading individual &lt;code&gt;.kext&lt;/code&gt; bundles from &lt;code&gt;/System/Library/Extensions&lt;/code&gt;. To optimize boot speed and enforce immutability, macOS now uses Kernel Collections.&lt;/p&gt;
    &lt;p&gt;The Boot Kernel Collection (BKC):&lt;lb/&gt; This is a single, massive Mach-O binary contained within the &lt;code&gt;kernelcache&lt;/code&gt; Image4 payload (&lt;code&gt;Ap,BootKernelCollection&lt;/code&gt;).&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Content: It contains the XNU kernel and all "Essential" drivers required to mount the root filesystem, start &lt;code&gt;launchd&lt;/code&gt;, and initialize the display.&lt;/item&gt;
      &lt;item&gt;Linkage: All internal symbols are pre-linked. There are no external relocations required at boot time for these drivers.&lt;/item&gt;
      &lt;item&gt;Protection (KIP): This is the critical security distinction. Because the BKC is loaded by iBoot, its physical pages are known before the kernel starts. The SPTM marks these pages as &lt;code&gt;XNU_TEXT&lt;/code&gt;(Immutable) in the Frame Table. The kernel cannot modify the BKC code or read-only data, even with a write primitive. It is effectively ROM.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The Auxiliary Kernel Collection (AKC):&lt;lb/&gt; Drivers not required for early boot (e.g., Bluetooth, Wi-Fi, Audio) are packaged into the AKC.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Loading: The AKC is loaded later in the boot process by &lt;code&gt;kernelmanagerd&lt;/code&gt;(userland).&lt;/item&gt;
      &lt;item&gt;Verification: When &lt;code&gt;kernelmanagerd&lt;/code&gt;passes the AKC to the kernel, the kernel must verify its signature. In Tahoe, this verification is offloaded to the TXM. The TXM checks the signature against the LocalPolicy.&lt;/item&gt;
      &lt;item&gt;Sealing: Once verified and linked, the kernel issues a &lt;code&gt;GENTER&lt;/code&gt;call to the SPTM to "seal" the AKC memory region. The SPTM transitions the pages from&lt;code&gt;XNU_DATA&lt;/code&gt;to&lt;code&gt;XNU_TEXT&lt;/code&gt;. Once sealed, the AKC becomes just as immutable as the BKC.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;RE Implication:&lt;lb/&gt; If you are reverse engineering a driver, you must determine if it lives in the BKC or AKC.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;BKC Drivers: Their offsets are static relative to the kernel slide.&lt;/item&gt;
      &lt;item&gt;AKC Drivers: They are loaded at a randomized offset after the kernel boot. You must traverse the &lt;code&gt;kmod_info&lt;/code&gt;linked list in memory to find their load addresses.&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h4"&gt;7.1.3 RE Focus: PAC-signing of C++ Vtables (&lt;code&gt;OSObject&lt;/code&gt;) and &lt;code&gt;BLRAA&lt;/code&gt;&lt;/head&gt;
    &lt;p&gt;The &lt;code&gt;OSObject&lt;/code&gt; class is the root of the IOKit inheritance hierarchy. In C++, dynamic dispatch is handled via Virtual Tables (vtables)—arrays of function pointers. Historically, attackers would overwrite the vtable pointer in an object to point to a fake vtable controlled by the attacker (vtable hijacking).&lt;/p&gt;
    &lt;p&gt;In the arm64e architecture, Apple has fundamentally altered the C++ ABI for kernel code to mitigate this.&lt;/p&gt;
    &lt;p&gt;The Signed Vtable Pointer:&lt;lb/&gt; In a standard C++ object, the first 8 bytes are the pointer to the vtable. In XNU on arm64e, this pointer is signed.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Key: &lt;code&gt;APDAKey&lt;/code&gt;(Data Key A).&lt;/item&gt;
      &lt;item&gt;Context: The context is derived from the address of the object itself (specifically, the storage location of the vtable pointer) combined with a salt (often the type hash).&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;$$ \texttt{SignedPtr} = \texttt{PAC}(\texttt{VtableAddr}, \texttt{Key=APDA}, \texttt{Context}=\&amp;amp;Object) $$&lt;/p&gt;
    &lt;p&gt;Address Diversity:&lt;lb/&gt; Because the object's address is part of the signature context, an attacker cannot simply copy a valid vtable pointer from &lt;code&gt;Object A&lt;/code&gt; to &lt;code&gt;Object B&lt;/code&gt;. The signature for &lt;code&gt;Object A&lt;/code&gt; is valid only at &lt;code&gt;Object A&lt;/code&gt;'s address. Moving it invalidates the PAC. This kills "vtable reuse" attacks.&lt;/p&gt;
    &lt;p&gt;The &lt;code&gt;BLRAA&lt;/code&gt; Dispatch:&lt;lb/&gt; When the kernel calls a virtual function (e.g., &lt;code&gt;object-&amp;gt;release()&lt;/code&gt;), the compiler emits a specialized instruction sequence:&lt;/p&gt;
    &lt;code&gt;LDR     x0, [x20]       ; Load the object pointer
LDR     x16, [x0]       ; Load the signed vtable pointer
AUTDA   x16, x0         ; Authenticate Data Key A, Context = Object Address (x0)
LDR     x10, [x16, #0x18] ; Load the target function pointer from the vtable
BLRAA   x10, x16        ; Branch with Link, Authenticating Key A, Context = Vtable Address
&lt;/code&gt;
    &lt;p&gt;Note the two-stage authentication:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;&lt;code&gt;AUTDA&lt;/code&gt;: Authenticates that the vtable pointer belongs to this object. If the pointer was overwritten,&lt;code&gt;x16&lt;/code&gt;becomes a canonical non-valid pointer.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;BLRAA&lt;/code&gt;: The function pointers inside the vtable are also signed (using&lt;code&gt;APIAKey&lt;/code&gt;). The&lt;code&gt;BLRAA&lt;/code&gt;instruction authenticates the function pointer (using the vtable address as context) and branches.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The "Recursive" PAC:&lt;lb/&gt; This creates a chain of trust:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;The Object trusts the Vtable Pointer (via &lt;code&gt;APDAKey&lt;/code&gt;).&lt;/item&gt;
      &lt;item&gt;The Vtable trusts the Function Pointers (via &lt;code&gt;APIAKey&lt;/code&gt;).&lt;/item&gt;
      &lt;item&gt;The SPTM trusts the Vtable Memory (via &lt;code&gt;XNU_TEXT&lt;/code&gt;immutability).&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;For a reverse engineer, this means that patching a vtable in memory is impossible (SPTM), and forging an object requires the ability to sign pointers with the &lt;code&gt;APDAKey&lt;/code&gt; for an arbitrary address—a capability that requires a "Signing Oracle" gadget, which BTI aims to eliminate.&lt;/p&gt;
    &lt;head rend="h3"&gt;7.2 DriverKit (dexts)&lt;/head&gt;
    &lt;p&gt;The introduction of DriverKit represents a strategic retreat for the XNU kernel. For decades, the kernel’s attack surface was effectively the sum of the core kernel plus every third-party driver loaded into the address space. A vulnerability in a Wacom tablet driver or a USB-to-Serial adapter was functionally identical to a vulnerability in the scheduler: both yielded &lt;code&gt;EL1&lt;/code&gt; code execution.&lt;/p&gt;
    &lt;p&gt;DriverKit bifurcates this model by moving hardware drivers into userland, executing as System Extensions (&lt;code&gt;.dext&lt;/code&gt;). While they look and feel like drivers to the developer (using a C++ subset similar to Embedded C++), architecturally they are unprivileged processes. In the Tahoe architecture, this isolation is not merely a sandbox; it is a hardware-enforced chasm guarded by the TXM and SPTM.&lt;/p&gt;
    &lt;head rend="h4"&gt;7.2.1 Moving drivers to userland: &lt;code&gt;IOUserClient&lt;/code&gt; and Entitlement Checks&lt;/head&gt;
    &lt;p&gt;A &lt;code&gt;dext&lt;/code&gt; does not have direct access to the kernel's task port, nor does it run with root privileges by default. It operates within a tightly constrained sandbox, communicating with the kernel via a specialized IPC bridge.&lt;/p&gt;
    &lt;p&gt;The &lt;code&gt;IOUserServer&lt;/code&gt; Proxy:&lt;lb/&gt; When a &lt;code&gt;dext&lt;/code&gt; is matched and loaded (managed by &lt;code&gt;kernelmanagerd&lt;/code&gt;), the kernel instantiates a shadow object known as &lt;code&gt;IOUserServer&lt;/code&gt;. This kernel-side object acts as the proxy for the userland driver.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;The Shim: When the kernel needs to call a function in the driver (e.g., &lt;code&gt;Start()&lt;/code&gt;), it calls a method on&lt;code&gt;IOUserServer&lt;/code&gt;.&lt;/item&gt;
      &lt;item&gt;Serialization: &lt;code&gt;IOUserServer&lt;/code&gt;serializes the arguments into a specialized Mach message format (distinct from standard MIG).&lt;/item&gt;
      &lt;item&gt;The Upcall: The message is sent to the &lt;code&gt;dext&lt;/code&gt;process. The DriverKit runtime (linked into the&lt;code&gt;dext&lt;/code&gt;) deserializes the message and invokes the implementation of the&lt;code&gt;IOService&lt;/code&gt;subclass in userland.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The &lt;code&gt;IOUserClient&lt;/code&gt; Interface:&lt;lb/&gt; Conversely, when the &lt;code&gt;dext&lt;/code&gt; needs to talk to the kernel (e.g., to register an interrupt handler or map memory), it cannot call kernel APIs directly. It uses &lt;code&gt;IOUserClient&lt;/code&gt;.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Restricted API Surface: The &lt;code&gt;dext&lt;/code&gt;can only invoke a specific subset of kernel functionality exposed via&lt;code&gt;IOUserClient&lt;/code&gt;traps. These traps are heavily scrutinized.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;OSAction&lt;/code&gt;: Interrupts are no longer handled via ISRs (Interrupt Service Routines) in the driver. Instead, the kernel handles the physical IRQ, masks it, and dispatches an&lt;code&gt;OSAction&lt;/code&gt;event to the&lt;code&gt;dext&lt;/code&gt;via a Mach notification. This eliminates the entire class of vulnerabilities related to interrupt context safety and spinlock deadlocks in third-party code.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Entitlements as the Gatekeeper (TXM Enforcement):&lt;lb/&gt; In Tahoe, the ability of a &lt;code&gt;dext&lt;/code&gt; to bind to specific hardware is governed by Entitlements.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Hardware Binding: A &lt;code&gt;dext&lt;/code&gt;cannot simply&lt;code&gt;mmap&lt;/code&gt;any MMIO region. It must possess specific entitlements (e.g.,&lt;code&gt;com.apple.developer.driverkit.transport.usb&lt;/code&gt;) to access specific device families.&lt;/item&gt;
      &lt;item&gt;TXM Verification: When &lt;code&gt;kernelmanagerd&lt;/code&gt;launches the&lt;code&gt;dext&lt;/code&gt;, the signature and entitlements are validated by the Trusted Execution Monitor (TXM).&lt;list rend="ul"&gt;&lt;item&gt;The TXM verifies the CDHash against the Trust Cache.&lt;/item&gt;&lt;item&gt;The TXM validates that the provisioning profile allows the specific HID or USB entitlements requested.&lt;/item&gt;&lt;item&gt;If the TXM returns a failure, the kernel refuses to establish the &lt;code&gt;IOUserServer&lt;/code&gt;link, and the driver fails to start. This prevents a compromised&lt;code&gt;kernelmanagerd&lt;/code&gt;from launching a rogue driver with elevated hardware access.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;RE Focus: The &lt;code&gt;IOUserClass&lt;/code&gt; Metaclass:&lt;lb/&gt; Reverse engineering a &lt;code&gt;dext&lt;/code&gt; requires understanding the &lt;code&gt;OSMetaClass&lt;/code&gt; infrastructure in userland. The &lt;code&gt;dext&lt;/code&gt; binary contains &lt;code&gt;OSMetaClass&lt;/code&gt; information that describes the RPC interface. By parsing the &lt;code&gt;__DATA,__const&lt;/code&gt; sections, one can reconstruct the vtables and the mapping between the kernel-side dispatch IDs and the userland C++ methods.&lt;/p&gt;
    &lt;head rend="h4"&gt;7.2.2 Memory Mapping Constraints and IOMMU (DART) Protection&lt;/head&gt;
    &lt;p&gt;The most dangerous capability of a driver is Direct Memory Access (DMA). A malicious or buggy driver could program a peripheral (like a GPU or Network Card) to write data to physical address &lt;code&gt;0x0&lt;/code&gt; (or wherever the kernel text resides), bypassing CPU-enforced protections like KTRR.&lt;/p&gt;
    &lt;p&gt;To mitigate this, Apple Silicon employs a pervasive IOMMU architecture known as DART (Device Address Resolution Table).&lt;/p&gt;
    &lt;p&gt;The DART Architecture:&lt;lb/&gt; Every DMA-capable peripheral on the SoC sits behind a DART. The device does not see Physical Addresses (PA); it sees I/O Virtual Addresses (IOVA). The DART translates IOVA $\rightarrow$ PA, enforcing permissions (Read/Write) at the page level.&lt;/p&gt;
    &lt;p&gt;DriverKit Memory Model:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;&lt;code&gt;IOMemoryDescriptor&lt;/code&gt;: When a&lt;code&gt;dext&lt;/code&gt;allocates a buffer for DMA, it creates an&lt;code&gt;IOMemoryDescriptor&lt;/code&gt;.&lt;/item&gt;
      &lt;item&gt;Mapping: The &lt;code&gt;dext&lt;/code&gt;calls&lt;code&gt;IOMemoryDescriptor::CreateMapping&lt;/code&gt;. This triggers a call into the kernel.&lt;/item&gt;
      &lt;item&gt;The Kernel's Role: The kernel allocates physical pages (&lt;code&gt;XNU_DATA&lt;/code&gt;) and pins them.&lt;/item&gt;
      &lt;item&gt;DART Programming: The kernel programs the DART associated with the specific hardware device controlled by the &lt;code&gt;dext&lt;/code&gt;. It maps the physical pages to an IOVA range visible to that device.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The Tahoe/SPTM Enforcement:&lt;lb/&gt; In the Tahoe architecture, the kernel is no longer trusted to program the DARTs directly. If the kernel could write to DART registers, it could map the kernel's own text segment as writable to the GPU, then tell the GPU to overwrite it (a DMA attack).&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;SPTM Ownership: The physical pages containing the DART translation tables (or the MMIO registers controlling the DART) are typed as &lt;code&gt;SPTM_PRIVATE&lt;/code&gt;or a specific hardware-protected type in the Frame Table.&lt;/item&gt;
      &lt;item&gt;The &lt;code&gt;sptm_map_iommu&lt;/code&gt;Selector: When the kernel needs to map a buffer for a&lt;code&gt;dext&lt;/code&gt;, it issues a&lt;code&gt;GENTER&lt;/code&gt;call to the SPTM.&lt;list rend="ul"&gt;&lt;item&gt;Validation: The SPTM verifies that the physical pages being mapped are owned by the &lt;code&gt;dext&lt;/code&gt;(or are valid shared memory). It strictly forbids mapping any page typed&lt;code&gt;XNU_TEXT&lt;/code&gt;,&lt;code&gt;PAGE_TABLE&lt;/code&gt;, or&lt;code&gt;SPTM_PRIVATE&lt;/code&gt;into a DART.&lt;/item&gt;&lt;item&gt;Execution: The SPTM performs the write to the DART hardware.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;Validation: The SPTM verifies that the physical pages being mapped are owned by the &lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;MMIO Mapping Restrictions:&lt;lb/&gt; Similarly, when a &lt;code&gt;dext&lt;/code&gt; needs to control hardware registers (MMIO), it requests a mapping.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;The kernel cannot simply map physical device memory into the &lt;code&gt;dext&lt;/code&gt;'s address space.&lt;/item&gt;
      &lt;item&gt;The SPTM validates the physical address against a Device Allow List (embedded in the Device Tree and signed/verified by iBoot).&lt;/item&gt;
      &lt;item&gt;This ensures that a USB driver can only map the USB controller's registers, and cannot map the registers for the Secure Enclave Mailbox or the KTRR controller.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;RE Implication:&lt;lb/&gt; Exploiting a &lt;code&gt;dext&lt;/code&gt; to gain kernel privileges is exponentially harder in Tahoe. Even if you gain code execution in the &lt;code&gt;dext&lt;/code&gt; (Userland), you cannot issue arbitrary syscalls (sandbox), you cannot map kernel memory (VM isolation), and you cannot use the hardware device to perform DMA attacks against the kernel (SPTM-enforced DART). The attacker is contained within a hardware-enforced cage, limited to the specific capabilities of that one peripheral.&lt;/p&gt;
    &lt;head rend="h3"&gt;7.3 The Graphics Stack (AGX)&lt;/head&gt;
    &lt;p&gt;If the XNU kernel is the central nervous system, the Apple Graphics (AGX) stack is a secondary, alien brain grafted onto the SoC. On M-series silicon, the GPU is not merely a peripheral; it is a massive, autonomous compute cluster running its own proprietary operating system, managing its own memory translation, and executing a command stream that is almost entirely opaque to the main OS.&lt;/p&gt;
    &lt;p&gt;For the reverse engineer, AGX represents the largest and most complex attack surface in the kernel. The driver (&lt;code&gt;AGX.kext&lt;/code&gt;) is enormous, the firmware is encrypted (until load), and the hardware interface is undocumented. In the Tahoe architecture, Apple has moved to aggressively sandbox this beast, wrapping the GPU's memory access in strict DART (Device Address Resolution Table) policies enforced by the SPTM to prevent DMA-based kernel compromises.&lt;/p&gt;
    &lt;head rend="h4"&gt;7.3.1 RTKit: The Proprietary RTOS running on the GPU Coprocessor (ASC)&lt;/head&gt;
    &lt;p&gt;The GPU does not execute driver commands directly. Instead, the M-series SoC includes a dedicated Apple Silicon Coprocessor (ASC)—typically a hardened ARMv8-R or Cortex-M class core—that manages the GPU hardware. This coprocessor runs RTKit, Apple’s proprietary Real-Time Operating System.&lt;/p&gt;
    &lt;p&gt;The Firmware Blob:&lt;lb/&gt; The kernel driver does not contain the logic to drive the GPU hardware registers directly. Instead, upon initialization (&lt;code&gt;AGX::start&lt;/code&gt;), it loads a firmware payload from the filesystem (e.g., &lt;code&gt;/usr/share/firmware/agx.bin&lt;/code&gt; or embedded in the kext).&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Format: The firmware is a standard Mach-O binary, often multi-architecture.&lt;/item&gt;
      &lt;item&gt;Sections: It contains &lt;code&gt;__TEXT&lt;/code&gt;and&lt;code&gt;__DATA&lt;/code&gt;segments just like a userland program.&lt;/item&gt;
      &lt;item&gt;RTKit Structure: Reverse engineering the firmware reveals a microkernel architecture. It has a scheduler, an IPC mechanism, and a set of "Endpoints" (services).&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The RTKit IPC Protocol:&lt;lb/&gt; Communication between the XNU kernel (&lt;code&gt;AGX.kext&lt;/code&gt;) and the ASC (&lt;code&gt;RTKit&lt;/code&gt;) occurs via a shared memory mailbox protocol.&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Mailbox Registers: The AP writes to a specific MMIO register to ring the doorbell of the ASC.&lt;/item&gt;
      &lt;item&gt;Message Buffer: The message payload is placed in a shared memory ring buffer.&lt;/item&gt;
      &lt;item&gt;Endpoints: The protocol is endpoint-based. The kernel sends messages to specific service IDs running on the ASC: &lt;list rend="ul"&gt;&lt;item&gt;&lt;code&gt;EP_PM&lt;/code&gt;: Power Management (Voltage/Clock gating).&lt;/item&gt;&lt;item&gt;&lt;code&gt;EP_GR&lt;/code&gt;: Graphics Rendering (Command submission).&lt;/item&gt;&lt;item&gt;&lt;code&gt;EP_COMP&lt;/code&gt;: Compute (GPGPU/Metal).&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;RE Focus: The &lt;code&gt;RTKit&lt;/code&gt; State Machine:&lt;lb/&gt; The &lt;code&gt;AGX.kext&lt;/code&gt; contains extensive logging strings and state tracking for RTKit. By analyzing the &lt;code&gt;RTKit&lt;/code&gt; class in the kext, one can reconstruct the message structures.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Crash Logs: When the GPU hangs, RTKit writes a "Coredump" to a shared buffer. The kernel captures this. Analyzing these logs reveals the internal memory layout of the ASC and the state of the GPU pipeline at the time of the crash.&lt;/item&gt;
      &lt;item&gt;Filter Bypass: Historically, vulnerabilities existed where the kernel could send malformed IPC messages to the ASC, causing memory corruption inside the GPU firmware. While this doesn't directly yield Kernel R/W, compromising the ASC allows an attacker to use the GPU as a confused deputy for DMA attacks (see 7.3.3).&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h4"&gt;7.3.2 &lt;code&gt;IOMobileFramebuffer&lt;/code&gt; (IOMFB): Secure Framebuffers and Exclave Compositing&lt;/head&gt;
    &lt;p&gt;While &lt;code&gt;AGX.kext&lt;/code&gt; handles rendering, &lt;code&gt;IOMobileFramebuffer.kext&lt;/code&gt; (IOMFB) handles the display controller (DCP). This driver is responsible for the "Swap Chain"—taking the rendered frames and scanning them out to the display panel.&lt;/p&gt;
    &lt;p&gt;The Unified Memory Architecture (UMA):&lt;lb/&gt; On Apple Silicon, the Framebuffer is just a region of system DRAM. &lt;code&gt;WindowServer&lt;/code&gt; (userland) renders into an &lt;code&gt;IOSurface&lt;/code&gt;. The physical pages backing this surface are passed to IOMFB, which programs the Display Coprocessor (DCP) to read from them.&lt;/p&gt;
    &lt;p&gt;The Security Criticality:&lt;lb/&gt; IOMFB is a high-value target because it handles complex shared memory structures (&lt;code&gt;IOMFBSharedMemory&lt;/code&gt;) mapped into both the kernel and userland (&lt;code&gt;WindowServer&lt;/code&gt;).&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Fuzzing Surface: The &lt;code&gt;Connect&lt;/code&gt;method and external methods of&lt;code&gt;IOMobileFramebufferUserClient&lt;/code&gt;have historically been riddled with race conditions and bounds-checking errors.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Tahoe and the "Secure Overlay":&lt;lb/&gt; In the Tahoe architecture, IOMFB's control over the display is no longer absolute. To support the Hardware Privacy Indicators (Green/Orange dots), the display pipeline has been bifurcated.&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Standard Pipe: Managed by IOMFB/WindowServer. Draws the desktop/apps.&lt;/item&gt;
      &lt;item&gt;Secure Pipe: Managed by an Exclave. Draws the privacy indicators.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Hardware Compositing:&lt;lb/&gt; The compositing of these two pipes happens in the display hardware, not in memory.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;The Exclave owns a small, reserved framebuffer region.&lt;/item&gt;
      &lt;item&gt;The Display Controller overlays this region on top of the standard framebuffer during scanout.&lt;/item&gt;
      &lt;item&gt;Immutability: Because the Secure Pipe's framebuffer memory is owned by the Exclave (and protected by the SPTM), neither the kernel nor the GPU can write to it. This guarantees that if the camera is on, the green dot will be visible, even if the kernel is compromised.&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h4"&gt;7.3.3 DART: The IOMMU Wall and DMA Containment&lt;/head&gt;
    &lt;p&gt;The GPU is effectively a DMA engine with the capability to read and write vast swathes of system memory. Without restriction, a compromised GPU firmware (or a malicious shader exploiting a GPU hardware bug) could overwrite kernel text or page tables.&lt;/p&gt;
    &lt;p&gt;To prevent this, the AGX hardware—and indeed every DMA-capable peripheral on the Apple Silicon SoC—sits behind a strict IOMMU known as the DART (Device Address Resolution Table).&lt;/p&gt;
    &lt;p&gt;DART Architecture and Stream IDs (SIDs):&lt;lb/&gt; The DART translates Device Virtual Addresses (DVA) used by the peripheral into Physical Addresses (PA) in DRAM. However, the translation is not monolithic; it is segmented by the source of the traffic.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Stream IDs (SIDs): Every transaction on the SoC's Network-on-Chip (NoC) carries a hardware-generated Stream ID identifying the initiator (e.g., GPU Firmware, Vertex Fetcher, Display Controller).&lt;/item&gt;
      &lt;item&gt;Context Banks: The DART maintains multiple translation contexts (similar to distinct &lt;code&gt;TTBR&lt;/code&gt;roots).&lt;/item&gt;
      &lt;item&gt;SID Matching: The DART hardware is configured to map specific SIDs to specific Context Banks. This allows isolation between different workloads on the same peripheral (e.g., isolating &lt;code&gt;WindowServer&lt;/code&gt;rendering commands from a background compute shader).&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The Tahoe Enforcement (SPTM):&lt;lb/&gt; In pre-Tahoe systems, the kernel (&lt;code&gt;AGX.kext&lt;/code&gt; or &lt;code&gt;IOMapper&lt;/code&gt;) managed the DART page tables and the SID configuration registers directly. This meant a kernel attacker could disable DART, remap SIDs to privileged contexts, or map kernel memory into the GPU's address space to bypass KTRR.&lt;/p&gt;
    &lt;p&gt;In Tahoe, DART management is privileged to the SPTM.&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Ownership: The physical pages containing the DART translation tables (L1/L2 TTEs) and the MMIO registers controlling SID configuration are typed as &lt;code&gt;SPTM_PRIVATE&lt;/code&gt;(or a specific&lt;code&gt;IOMMU_TABLE&lt;/code&gt;type) in the Frame Table.&lt;/item&gt;
      &lt;item&gt;Mapping Requests: When &lt;code&gt;AGX.kext&lt;/code&gt;needs to map a user's&lt;code&gt;IOSurface&lt;/code&gt;for GPU access:&lt;list rend="ul"&gt;&lt;item&gt;It pins the user pages.&lt;/item&gt;&lt;item&gt;It issues a &lt;code&gt;GENTER&lt;/code&gt;call (Selector&lt;code&gt;sptm_map_iommu&lt;/code&gt;).&lt;/item&gt;&lt;item&gt;It passes the DART ID, the Context ID, the DVA, and the PA.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;Validation: The SPTM verifies: &lt;list rend="ul"&gt;&lt;item&gt;The PA is valid &lt;code&gt;USER_DATA&lt;/code&gt;(not Kernel Text, not Page Tables).&lt;/item&gt;&lt;item&gt;The DART ID corresponds to the GPU.&lt;/item&gt;&lt;item&gt;SID Integrity: Crucially, the SPTM enforces the immutable binding between SIDs and Contexts. It ensures that the kernel cannot reconfigure the DART to allow an untrusted SID (e.g., the Neural Engine) to write to a Context Bank reserved for the Secure Enclave or Display Pipe.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;The PA is valid &lt;/item&gt;
      &lt;item&gt;Execution: The SPTM writes the DART PTE.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;RE Focus: The "GART" Attack Surface:&lt;lb/&gt; Despite SPTM protection, the logic requesting the mapping still resides in the kernel.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Aliasing: Can the kernel trick the SPTM into mapping the same physical page to two different DART contexts with different permissions?&lt;/item&gt;
      &lt;item&gt;Stale TLBs: Does the SPTM correctly flush the DART TLB (&lt;code&gt;tlb_flush&lt;/code&gt;) immediately after unmapping? If not, the GPU might retain access to a page that has been freed and reallocated to the kernel, leading to a Use-After-Free via DMA.&lt;/item&gt;
      &lt;item&gt;Side Channels: The DART configuration registers (e.g., &lt;code&gt;TCR&lt;/code&gt;,&lt;code&gt;TTBR&lt;/code&gt;, and SID match registers) are trapped by the hardware to GL2. Attempting to write to the DART control base address from EL1 should trigger a synchronous exception. Reverse engineering the&lt;code&gt;IOMapper&lt;/code&gt;class in IOKit will reveal the specific&lt;code&gt;GENTER&lt;/code&gt;trampolines used to bridge these operations.&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h2"&gt;8.0 Userland Bootstrap: The Birth of PID 1&lt;/head&gt;
    &lt;p&gt;The initialization of the XNU kernel concludes with the mounting of the root filesystem (the Signed System Volume) and the spawning of the first userland process. In the UNIX tradition, this is &lt;code&gt;init&lt;/code&gt; (PID 1). In macOS, this is &lt;code&gt;launchd&lt;/code&gt;.&lt;/p&gt;
    &lt;p&gt;However, &lt;code&gt;launchd&lt;/code&gt; is far more than a SysV init replacement. It is the Mach Port Broker, the central registry for the operating system's IPC namespace, and the gatekeeper for service lifecycle management. In the Tahoe architecture, &lt;code&gt;launchd&lt;/code&gt;'s role is further hardened; it is the first process to run under the full scrutiny of the Trusted Execution Monitor (TXM), and its ability to bootstrap the rest of the system relies on a complex dance of entitlements and port rights.&lt;/p&gt;
    &lt;head rend="h3"&gt;8.1 &lt;code&gt;launchd&lt;/code&gt;: The Mach Port Broker&lt;/head&gt;
    &lt;p&gt;The transition from kernel mode to user mode is a singularity. The kernel thread executing &lt;code&gt;bsd_init&lt;/code&gt; constructs a user context and never returns. From this point forward, the system's security relies on the correct enforcement of Mach port rights and the immutability of the bootstrap namespace.&lt;/p&gt;
    &lt;head rend="h4"&gt;8.1.1 Transition from kernel to userland: The first &lt;code&gt;execve&lt;/code&gt;&lt;/head&gt;
    &lt;p&gt;The kernel routine &lt;code&gt;bsd_init&lt;/code&gt; (in &lt;code&gt;bsd/kern/bsd_init.c&lt;/code&gt;) is responsible for hand-crafting the first process.&lt;/p&gt;
    &lt;p&gt;The Loading Sequence:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Path Resolution: The kernel looks for the init binary. Historically &lt;code&gt;/sbin/launchd&lt;/code&gt;, in the Tahoe/Cryptex era, this path is a firmlink or symlink resolving into the OS Cryptex (e.g.,&lt;code&gt;/System/Cryptexes/OS/sbin/launchd&lt;/code&gt;).&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;load_init_program&lt;/code&gt;: This kernel function mimics an&lt;code&gt;execve&lt;/code&gt;syscall from within the kernel. It allocates a&lt;code&gt;proc_t&lt;/code&gt;structure and a&lt;code&gt;task_t&lt;/code&gt;structure.&lt;/item&gt;
      &lt;item&gt;TXM Validation (The First Check):&lt;lb/&gt;Before the kernel can map&lt;code&gt;launchd&lt;/code&gt;into memory, it must validate the code signature.&lt;list rend="ul"&gt;&lt;item&gt;XNU parses the &lt;code&gt;launchd&lt;/code&gt;binary to extract the CDHash.&lt;/item&gt;&lt;item&gt;XNU issues a &lt;code&gt;GENTER&lt;/code&gt;to the TXM.&lt;/item&gt;&lt;item&gt;The TXM verifies that the &lt;code&gt;launchd&lt;/code&gt;CDHash exists in the Static Trust Cache (loaded by iBoot). Since&lt;code&gt;launchd&lt;/code&gt;is part of the immutable OS, it must be in the static cache. If it is not, the system panics immediately (integrity violation).&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;XNU parses the &lt;/item&gt;
      &lt;item&gt;SPTM Mapping:&lt;lb/&gt;Once validated, XNU requests the SPTM to map the physical pages containing the&lt;code&gt;launchd&lt;/code&gt;text segment.&lt;list rend="ul"&gt;&lt;item&gt;The SPTM updates the Frame Table Entries (FTE) for these pages to &lt;code&gt;USER_DATA&lt;/code&gt;(or a specific immutable user type).&lt;/item&gt;&lt;item&gt;The SPTM writes the translation table entries (TTEs) for the new process's address space, marking the text segment as &lt;code&gt;RX&lt;/code&gt;(Read-Execute) and the data segment as&lt;code&gt;RW&lt;/code&gt;(Read-Write).&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;The SPTM updates the Frame Table Entries (FTE) for these pages to &lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The &lt;code&gt;host_priv&lt;/code&gt; Handoff:&lt;lb/&gt; Crucially, &lt;code&gt;launchd&lt;/code&gt; is the only process in the system that receives the Host Privilege Port (&lt;code&gt;host_priv&lt;/code&gt;) directly from the kernel without asking for it.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;During &lt;code&gt;load_init_program&lt;/code&gt;, the kernel calls&lt;code&gt;ipc_port_alloc_kernel&lt;/code&gt;to retrieve the&lt;code&gt;host_priv&lt;/code&gt;port.&lt;/item&gt;
      &lt;item&gt;It inserts a send right to this port into &lt;code&gt;launchd&lt;/code&gt;'s IPC space (&lt;code&gt;ipc_space&lt;/code&gt;).&lt;/item&gt;
      &lt;item&gt;This right is placed at a fixed, known port name (often &lt;code&gt;mach_task_self_ + n&lt;/code&gt;), or retrieved by&lt;code&gt;launchd&lt;/code&gt;immediately upon startup via&lt;code&gt;task_get_special_port&lt;/code&gt;.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;This handle gives &lt;code&gt;launchd&lt;/code&gt; the authority to configure the rest of the system, including setting the system clock, loading kernel extensions (via &lt;code&gt;kernelmanagerd&lt;/code&gt;), and shutting down the system.&lt;/p&gt;
    &lt;head rend="h4"&gt;8.1.2 Initializing the Bootstrap Port (subset of the Name Service)&lt;/head&gt;
    &lt;p&gt;Mach does not have a global, string-based name service in the kernel. If Process A wants to talk to "com.apple.windowserver", the kernel has no idea what that string means. The mapping of &lt;code&gt;String -&amp;gt; Mach Port&lt;/code&gt; is the responsibility of the Bootstrap Server. &lt;code&gt;launchd&lt;/code&gt; is the Bootstrap Server.&lt;/p&gt;
    &lt;p&gt;The Bootstrap Port:&lt;lb/&gt; Every task in XNU has a special port slot called &lt;code&gt;TASK_BOOTSTRAP_PORT&lt;/code&gt;.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Initialization: When &lt;code&gt;launchd&lt;/code&gt;starts, it allocates a receive right for a new port. It calls&lt;code&gt;task_set_special_port(mach_task_self(), TASK_BOOTSTRAP_PORT, new_port)&lt;/code&gt;to register this port as the bootstrap port for itself.&lt;/item&gt;
      &lt;item&gt;Inheritance: When &lt;code&gt;launchd&lt;/code&gt;spawns a child process (e.g.,&lt;code&gt;syslogd&lt;/code&gt;), the child inherits this bootstrap port handle. This connects every process in the system back to&lt;code&gt;launchd&lt;/code&gt;.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The Namespace Hierarchy:&lt;lb/&gt; The bootstrap namespace is not flat; it is hierarchical to support security domains and user separation.&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Startup Domain: The root domain, populated by &lt;code&gt;LaunchDaemons&lt;/code&gt;(system-wide services running as root or specific users).&lt;/item&gt;
      &lt;item&gt;User Domain: Created when a user logs in. Populated by &lt;code&gt;LaunchAgents&lt;/code&gt;.&lt;/item&gt;
      &lt;item&gt;Session Domain: Specific to a GUI login session (Aqua).&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;RE Focus: The &lt;code&gt;bootstrap_check_in&lt;/code&gt; Routine:&lt;lb/&gt; When a daemon starts (e.g., &lt;code&gt;locationd&lt;/code&gt;), it must retrieve the receive rights for the Mach ports it is supposed to service.&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;The daemon calls &lt;code&gt;bootstrap_check_in(bootstrap_port, "com.apple.locationd", &amp;amp;service_port)&lt;/code&gt;.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;launchd&lt;/code&gt;receives this message.&lt;/item&gt;
      &lt;item&gt;Security Check: &lt;code&gt;launchd&lt;/code&gt;inspects the Audit Token (appended to the Mach message trailer by the kernel). It verifies that the PID sending the check-in request matches the PID that&lt;code&gt;launchd&lt;/code&gt;just spawned for that label.&lt;/item&gt;
      &lt;item&gt;Port Transfer: If the check passes, &lt;code&gt;launchd&lt;/code&gt;moves the Receive Right for the service port (which it created earlier) into the daemon's IPC space.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;This prevents "Port Squatting," where a malicious process tries to register "com.apple.password-server" before the real daemon starts. Only the process spawned by &lt;code&gt;launchd&lt;/code&gt; as that service can claim the port.&lt;/p&gt;
    &lt;head rend="h4"&gt;8.1.3 Parsing &lt;code&gt;launchd.plist&lt;/code&gt; and the binary protocol for XPC service lookups&lt;/head&gt;
    &lt;p&gt;&lt;code&gt;launchd&lt;/code&gt; configuration is driven by Property Lists (&lt;code&gt;.plist&lt;/code&gt;) located in &lt;code&gt;/System/Library/LaunchDaemons&lt;/code&gt;, &lt;code&gt;/Library/LaunchDaemons&lt;/code&gt;, etc. However, &lt;code&gt;launchd&lt;/code&gt; does not simply read these files at runtime; it compiles them into an internal graph.&lt;/p&gt;
    &lt;p&gt;The MachService Dictionary:&lt;lb/&gt; The key element for reverse engineers is the &lt;code&gt;MachServices&lt;/code&gt; dictionary in the plist.&lt;/p&gt;
    &lt;code&gt;&amp;lt;key&amp;gt;MachServices&amp;lt;/key&amp;gt;
&amp;lt;dict&amp;gt;
    &amp;lt;key&amp;gt;com.apple.securityd&amp;lt;/key&amp;gt;
    &amp;lt;true/&amp;gt;
&amp;lt;/dict&amp;gt;
&lt;/code&gt;
    &lt;p&gt;This entry tells &lt;code&gt;launchd&lt;/code&gt;: "Allocate a Mach port. Associate it with the string 'com.apple.securityd'. If anyone sends a message to this port, launch this binary."&lt;/p&gt;
    &lt;p&gt;Demand Launching (The Lazy Allocation):&lt;code&gt;launchd&lt;/code&gt; does not start all daemons at boot. It creates the ports and listens on them.&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;The Lookup: A client (e.g., Safari) calls &lt;code&gt;xpc_connection_create_mach_service("com.apple.securityd", ...)&lt;/code&gt;.&lt;/item&gt;
      &lt;item&gt;The Resolution: Under the hood, &lt;code&gt;libxpc&lt;/code&gt;sends a message to the bootstrap port asking for the send right associated with that string.&lt;/item&gt;
      &lt;item&gt;The Trigger: &lt;code&gt;launchd&lt;/code&gt;looks up the string. It sees the service is not running. It performs&lt;code&gt;posix_spawn&lt;/code&gt;to start the daemon.&lt;/item&gt;
      &lt;item&gt;The Handoff: While the daemon is launching, &lt;code&gt;launchd&lt;/code&gt;holds the client's request. Once the daemon checks in (see 8.1.2),&lt;code&gt;launchd&lt;/code&gt;hands the send right to the client.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The Binary Protocol (XPC vs. MIG):&lt;lb/&gt; Historically, &lt;code&gt;launchd&lt;/code&gt; used the Mach Interface Generator (MIG) for these lookups (&lt;code&gt;bootstrap.defs&lt;/code&gt;). In modern macOS, this has largely been superseded by the XPC protocol, which runs over raw Mach messages but uses a proprietary serialization format.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;xpc_pipe&lt;/code&gt;: This is the low-level mechanism. Messages sent to&lt;code&gt;launchd&lt;/code&gt;are often XPC dictionaries serialized into a Mach message body.&lt;/item&gt;
      &lt;item&gt;Magic Bytes: XPC messages start with a specific magic header (often &lt;code&gt;0x42774242&lt;/code&gt;- 'BwBB' in ASCII for binary blobs).&lt;/item&gt;
      &lt;item&gt;Structure: The payload is a serialized tree of objects (dictionaries, arrays, strings, file descriptors, and Mach ports).&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;RE Focus: &lt;code&gt;launchd&lt;/code&gt;'s &lt;code&gt;job_dispatch&lt;/code&gt;:&lt;lb/&gt; Reverse engineering the &lt;code&gt;launchd&lt;/code&gt; binary (which is stripped, but symbols can often be correlated from open-source releases of &lt;code&gt;liblaunch&lt;/code&gt;) reveals the &lt;code&gt;job_dispatch&lt;/code&gt; or &lt;code&gt;demux&lt;/code&gt; routine.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;This routine parses the incoming Mach message.&lt;/item&gt;
      &lt;item&gt;It identifies if it is a legacy MIG request (subsystem 400) or an XPC request.&lt;/item&gt;
      &lt;item&gt;It routes the request to the appropriate subsystem (Job Management, Service Lookup, or XPC Domain management).&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The "Domain" Concept:&lt;lb/&gt; In Tahoe, &lt;code&gt;launchd&lt;/code&gt; enforces strict Domain Isolation. A process in the "App Sandbox" domain cannot look up services in the "System" domain unless those services are explicitly allowlisted in the sandbox profile (&lt;code&gt;com.apple.security.exception.mach-lookup.global-name&lt;/code&gt;). &lt;code&gt;launchd&lt;/code&gt; enforces this by checking the sender's entitlements (via the kernel audit token) against the requested service name before returning the port right. If the check fails, &lt;code&gt;launchd&lt;/code&gt; returns &lt;code&gt;BOOTSTRAP_UNKNOWN_SERVICE&lt;/code&gt; (or effectively &lt;code&gt;0&lt;/code&gt;), and the client sees "Connection Invalid."&lt;/p&gt;
    &lt;head rend="h3"&gt;8.2 The Dynamic Linker (&lt;code&gt;dyld&lt;/code&gt;)&lt;/head&gt;
    &lt;p&gt;If &lt;code&gt;launchd&lt;/code&gt; is the architect of the userland process hierarchy, &lt;code&gt;dyld&lt;/code&gt; (the dynamic linker) is the mason that lays the bricks for every single process. In the macOS ecosystem, &lt;code&gt;dyld&lt;/code&gt; is not merely a library loader; it is a privileged extension of the kernel’s execution logic, responsible for enforcing the final mile of the platform’s security policies, including Library Validation, symbol resolution, and the application of Address Space Layout Randomization (ASLR).&lt;/p&gt;
    &lt;p&gt;On Apple Silicon and the Tahoe architecture, &lt;code&gt;dyld&lt;/code&gt; has evolved significantly. It no longer relies on legacy load commands for rebasing; it utilizes Chained Fixups to enable page-in linking, and its operations are tightly coupled with the kernel’s memory management subsystem, which is in turn subservient to the Secure Page Table Monitor (SPTM).&lt;/p&gt;
    &lt;head rend="h4"&gt;8.2.1 Mapping the Dyld Shared Cache (DSC)&lt;/head&gt;
    &lt;p&gt;The Dyld Shared Cache (DSC) is the defining characteristic of the macOS memory layout. It is a massive, pre-linked artifact (often exceeding 4GB) containing the combined text and data segments of nearly all system frameworks (&lt;code&gt;CoreFoundation&lt;/code&gt;, &lt;code&gt;libSystem&lt;/code&gt;, &lt;code&gt;Foundation&lt;/code&gt;, &lt;code&gt;UIKit&lt;/code&gt;, etc.).&lt;/p&gt;
    &lt;p&gt;The Shared Region:&lt;lb/&gt; To optimize memory usage, the kernel maintains a Shared Region. This is a reserved area of the virtual address space (typically starting at &lt;code&gt;0x180000000&lt;/code&gt; on arm64) where the DSC is mapped.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Physical Sharing: The physical pages backing the DSC are shared across all processes.&lt;/item&gt;
      &lt;item&gt;Split Segments: The DSC is split into three primary mappings to satisfy &lt;code&gt;W^X&lt;/code&gt;(Write XOR Execute) requirements:&lt;list rend="ol"&gt;&lt;item&gt;&lt;code&gt;__TEXT&lt;/code&gt;: Read-Execute (RX). Contains immutable code.&lt;/item&gt;&lt;item&gt;&lt;code&gt;__DATA_CONST&lt;/code&gt;: Read-Only (RO). Contains pointers and data that are resolved at link time and never change.&lt;/item&gt;&lt;item&gt;&lt;code&gt;__DATA_DIRTY&lt;/code&gt;: Read-Write (RW). Contains data that must be modified per-process (e.g., Objective-C class realization).&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The Tahoe/SPTM Constraint:&lt;lb/&gt; In the Tahoe architecture, the mapping of the DSC is a privileged operation guarded by the SPTM.&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Boot Load: The DSC is loaded from the OS Cryptex (&lt;code&gt;/System/Cryptexes/OS/System/Library/dyld/&lt;/code&gt;).&lt;/item&gt;
      &lt;item&gt;Immutable Mapping: When the kernel initializes the Shared Region, it issues &lt;code&gt;GENTER&lt;/code&gt;calls to the SPTM. The SPTM updates the Frame Table Entries (FTE) for the physical pages backing the DSC&lt;code&gt;__TEXT&lt;/code&gt;segment to&lt;code&gt;USER_TEXT&lt;/code&gt;(or a specific shared immutable type).&lt;/item&gt;
      &lt;item&gt;Enforcement: Once mapped, the SPTM forbids any entity (including the kernel) from writing to these physical pages. This renders the system libraries immutable even in the face of a kernel compromise. Hooking a system function like &lt;code&gt;open&lt;/code&gt;in the shared cache via kernel memory writing is physically impossible; the attacker must use&lt;code&gt;__DATA_DIRTY&lt;/code&gt;indirection or userland hooks.&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h4"&gt;8.2.2 RE Focus: Code Signature Validation (&lt;code&gt;fcntl(F_ADDFILESIGS)&lt;/code&gt;) and the Call to TXM&lt;/head&gt;
    &lt;p&gt;&lt;code&gt;dyld&lt;/code&gt; is the primary enforcer of Library Validation. This security hardening ensures that a process can only load libraries that are signed by Apple or signed by the same Team ID as the main executable.&lt;/p&gt;
    &lt;p&gt;The Validation Flow:&lt;lb/&gt; When &lt;code&gt;dyld&lt;/code&gt; loads a Mach-O image (via &lt;code&gt;dlopen&lt;/code&gt; or load command parsing):&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;&lt;code&gt;mmap&lt;/code&gt;: It maps the file into memory. At this stage, the pages are not yet executable.&lt;/item&gt;
      &lt;item&gt;Signature Registration: &lt;code&gt;dyld&lt;/code&gt;calls&lt;code&gt;fcntl(fd, F_ADDFILESIGS_RETURN, ...)&lt;/code&gt;passing a&lt;code&gt;fsignatures_t&lt;/code&gt;struct. This tells the kernel: "I want to execute code from this file. Here is the offset to the code signature (CMS blob)."&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The Kernel $\rightarrow$ TXM Handoff:&lt;lb/&gt; In previous architectures, the kernel (specifically &lt;code&gt;AMFI.kext&lt;/code&gt;) would parse the blob and verify the signature. In Tahoe, the kernel is untrusted for verification.&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Marshaling: The kernel identifies the physical pages containing the signature blob.&lt;/item&gt;
      &lt;item&gt;The Gate: The kernel executes &lt;code&gt;GENTER&lt;/code&gt;to invoke the Trusted Execution Monitor (TXM) at GL1.&lt;/item&gt;
      &lt;item&gt;TXM Verification: &lt;list rend="ul"&gt;&lt;item&gt;The TXM parses the CMS blob in the secure world.&lt;/item&gt;&lt;item&gt;It verifies the cryptographic chain of trust against the Trust Cache (for platform binaries) or the Apple Root CA (for third-party).&lt;/item&gt;&lt;item&gt;It checks for constraints (e.g., is this a restricted binary? Does it have the &lt;code&gt;com.apple.private.security.no-sandbox&lt;/code&gt;entitlement?).&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;The Verdict: The TXM returns a verdict to the kernel. Crucially, it also updates the SPTM's view of those physical pages. &lt;list rend="ul"&gt;&lt;item&gt;If valid, the TXM "blesses" the pages associated with the code directory hash (CDHash).&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;Page Fault Enforcement: &lt;list rend="ul"&gt;&lt;item&gt;When &lt;code&gt;dyld&lt;/code&gt;later jumps into the library, a page fault occurs.&lt;/item&gt;&lt;item&gt;The kernel attempts to map the page as Executable (&lt;code&gt;RX&lt;/code&gt;).&lt;/item&gt;&lt;item&gt;The SPTM intercepts the PTE update. It checks if the physical page has been blessed by the TXM.&lt;/item&gt;&lt;item&gt;If yes, the Execute bit is set. If no (e.g., the kernel lied about the signature verification), the SPTM denies the mapping, and the process crashes with &lt;code&gt;SIGKILL (Code Signature Invalid)&lt;/code&gt;.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;When &lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;RE Tip: If you are analyzing a crash where &lt;code&gt;dyld&lt;/code&gt; terminates a process immediately after loading a dylib, check the system logs for &lt;code&gt;amfid&lt;/code&gt; or &lt;code&gt;kernel&lt;/code&gt; messages related to &lt;code&gt;TXM&lt;/code&gt; rejection. The error code returned by &lt;code&gt;fcntl&lt;/code&gt; is often sanitized; the real reason (e.g., "Revoked Certificate") lies in the secure monitor logs, which may be redacted in production builds.&lt;/p&gt;
    &lt;head rend="h4"&gt;8.2.3 ASLR in Userland: Chained Fixups and the Death of &lt;code&gt;dyld_info&lt;/code&gt;&lt;/head&gt;
    &lt;p&gt;Modern &lt;code&gt;dyld&lt;/code&gt; (dyld 4.0+) on Apple Silicon has deprecated the legacy &lt;code&gt;LC_DYLD_INFO&lt;/code&gt; rebasing opcodes in favor of Chained Fixups (&lt;code&gt;LC_DYLD_CHAINED_FIXUPS&lt;/code&gt;). This architectural shift is not merely a performance optimization to reduce dirty pages; it is a fundamental change in how the binary format represents memory addresses, tightly coupling ASLR with Pointer Authentication (PAC).&lt;/p&gt;
    &lt;p&gt;The Problem with Legacy Rebasing:&lt;lb/&gt; In the legacy model, &lt;code&gt;dyld&lt;/code&gt; parsed a list of opcodes (&lt;code&gt;REBASE_OPCODE_DO_*&lt;/code&gt;) to locate pointers in the &lt;code&gt;__DATA&lt;/code&gt; segment and add the ASLR slide. This required &lt;code&gt;dyld&lt;/code&gt; to touch every page containing a pointer at launch time, triggering massive I/O and dirtying pages that might never be used.&lt;/p&gt;
    &lt;p&gt;The Chained Fixup Solution:&lt;lb/&gt; In a Chained Fixup binary, the "pointers" stored in the &lt;code&gt;__DATA&lt;/code&gt; segment on disk are not memory addresses. They are 64-bit metadata structures that form a linked list (a chain) within each 16KB page.&lt;/p&gt;
    &lt;p&gt;The On-Disk Structure:&lt;lb/&gt; The &lt;code&gt;LC_DYLD_CHAINED_FIXUPS&lt;/code&gt; load command points to a header (&lt;code&gt;dyld_chained_fixups_header&lt;/code&gt;) containing offsets to "Starts" arrays (&lt;code&gt;dyld_chained_starts_in_image&lt;/code&gt;).&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Page-Level Granularity: The metadata identifies the offset of the first fixup in every page.&lt;/item&gt;
      &lt;item&gt;The Chain: The data at that offset is a 64-bit struct (e.g., &lt;code&gt;dyld_chained_ptr_64_rebase&lt;/code&gt;).&lt;list rend="ul"&gt;&lt;item&gt;&lt;code&gt;next&lt;/code&gt;(Bits 51-62): The offset (in 4-byte strides) to the next fixup in the same page. A value of&lt;code&gt;0&lt;/code&gt;terminates the chain for that page.&lt;/item&gt;&lt;item&gt;&lt;code&gt;target&lt;/code&gt;(Bits 0-35): The offset in the&lt;code&gt;__TEXT&lt;/code&gt;segment (for rebasing) or the ordinal in the import table (for binding).&lt;/item&gt;&lt;item&gt;&lt;code&gt;high8&lt;/code&gt;(Bits 56-63): Additional attributes (e.g., auth diversity).&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Page-In Linking (Lazy Fixups):&lt;lb/&gt; When &lt;code&gt;dyld&lt;/code&gt; loads a library, it does not iterate the whole file. It sets up the memory mapping.&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;The Fault: When the process execution flow hits a pointer in &lt;code&gt;__DATA&lt;/code&gt;(e.g., a vtable entry or a global string pointer), a page fault occurs.&lt;/item&gt;
      &lt;item&gt;The Trap: The kernel (or &lt;code&gt;dyld&lt;/code&gt;via a user-fault handler) detects that the page requires fixups.&lt;/item&gt;
      &lt;item&gt;The Walk: The fixup logic looks up the "Start" offset for that specific page. It walks the linked list defined by the &lt;code&gt;next&lt;/code&gt;bits.&lt;/item&gt;
      &lt;item&gt;The Patch: For each entry in the chain: &lt;list rend="ul"&gt;&lt;item&gt;It extracts the &lt;code&gt;target&lt;/code&gt;.&lt;/item&gt;&lt;item&gt;It adds the ASLR slide (for rebase) or resolves the symbol (for bind).&lt;/item&gt;&lt;item&gt;Crucially for arm64e: It calculates the PAC signature.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;It extracts the &lt;/item&gt;
      &lt;item&gt;The Write: It overwrites the 64-bit metadata struct with the final, signed, slid pointer. The page is now "dirty" and valid.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;PAC Integration (&lt;code&gt;DYLD_CHAINED_PTR_ARM64E&lt;/code&gt;):&lt;lb/&gt; On Apple Silicon, the fixup format is often &lt;code&gt;DYLD_CHAINED_PTR_ARM64E&lt;/code&gt;. This struct contains the diversity data (salt) for the pointer.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;dyld&lt;/code&gt;does not just write&lt;code&gt;Base + Offset&lt;/code&gt;.&lt;/item&gt;
      &lt;item&gt;It writes &lt;code&gt;PAC(Base + Offset, Key, Context)&lt;/code&gt;.&lt;/item&gt;
      &lt;item&gt;This binds the ASLR slide to the process-specific PAC keys (&lt;code&gt;APIAKey&lt;/code&gt;,&lt;code&gt;APDAKey&lt;/code&gt;) at the exact moment of paging in.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;RE Implication: The "Broken" Binary:&lt;lb/&gt; For the reverse engineer, this mechanism means that static analysis of a raw Mach-O binary from disk is misleading.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;If you open a raw binary in an older disassembler (or &lt;code&gt;hexdump&lt;/code&gt;), the global pointers will look like garbage (e.g.,&lt;code&gt;0x0040...&lt;/code&gt;). These are the chain metadata structs, not addresses.&lt;/item&gt;
      &lt;item&gt;CFG Destruction: Without processing these chains, the Control Flow Graph (CFG) is broken. Virtual function calls and global callbacks point to nowhere.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Tooling Requirement:&lt;lb/&gt; To analyze these binaries statically, you must "unchain" them—simulating the &lt;code&gt;dyld&lt;/code&gt; fixup process to convert metadata back into generic, unslid pointers.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;ipsw&lt;/code&gt;: The&lt;code&gt;ipsw&lt;/code&gt;tool (specifically&lt;code&gt;ipsw dyld fixup&lt;/code&gt;) can parse the chains and output a "fixed" Mach-O where the&lt;code&gt;__DATA&lt;/code&gt;segment contains valid pointers relative to the file base.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;dyld_shared_cache_util&lt;/code&gt;: Apple's own tool (if available) or open-source equivalents must be used to extract and fixup binaries from the DSC.&lt;/item&gt;
      &lt;item&gt;IDA Pro / Ghidra: Modern versions automatically detect &lt;code&gt;LC_DYLD_CHAINED_FIXUPS&lt;/code&gt;and apply the fixups in the database view, but the underlying file on disk remains "chained."&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h3"&gt;8.3 Cryptexes (Cryptographic Extensions)&lt;/head&gt;
    &lt;p&gt;The introduction of the Signed System Volume (SSV) in macOS Big Sur solved the problem of persistence; by rooting the filesystem trust in a cryptographic hash verified by iBoot, Apple ensured that the OS partition was immutable. However, this immutability introduced a significant logistical problem: patching a single binary (e.g., &lt;code&gt;WebKit&lt;/code&gt; or &lt;code&gt;dyld&lt;/code&gt;) required a full OS update, a re-hashing of the entire volume, and a new signature from Apple’s Taming Server (TSS).&lt;/p&gt;
    &lt;p&gt;To resolve this tension between security and agility, Apple introduced Cryptexes (Cryptographic Extensions). A Cryptex is a cryptographically sealed, versioned filesystem image that is grafted onto the system hierarchy at boot or runtime. In the Tahoe architecture, the Cryptex subsystem is the primary mechanism for the "Split OS" design, decoupling the core kernel/BSD environment from the rapidly evolving userland frameworks.&lt;/p&gt;
    &lt;head rend="h4"&gt;8.3.1 The "Split OS" Architecture: &lt;code&gt;/System/Cryptexes/OS&lt;/code&gt;&lt;/head&gt;
    &lt;p&gt;In modern macOS, the root filesystem (&lt;code&gt;/&lt;/code&gt;) is essentially a skeleton. It contains configuration files and the kernel, but the vast majority of executable code—including &lt;code&gt;dyld&lt;/code&gt;, &lt;code&gt;libSystem&lt;/code&gt;, and the frameworks—resides within the OS Cryptex.&lt;/p&gt;
    &lt;p&gt;The Image4 Container:&lt;lb/&gt; A Cryptex is distributed as an Image4 (&lt;code&gt;img4&lt;/code&gt;) container.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Payload (&lt;code&gt;IM4P&lt;/code&gt;): A disk image (typically APFS or HFS+) containing the directory hierarchy.&lt;/item&gt;
      &lt;item&gt;Manifest (&lt;code&gt;IM4M&lt;/code&gt;): The signature. Crucially, the OS Cryptex is often Personalized. It is signed by TSS with the device's ECID, binding the specific version of the userland libraries to the specific silicon, preventing "library replay" attacks where a user might try to load a vulnerable&lt;code&gt;dyld&lt;/code&gt;from an older OS version on a newer kernel.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The Mounting Process (&lt;code&gt;apfs_graft&lt;/code&gt;):&lt;lb/&gt; The kernel does not mount Cryptexes using standard &lt;code&gt;mount&lt;/code&gt; syscalls. It uses a specialized mechanism within the APFS kext known as Grafting.&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;iBoot Handoff: For the OS Cryptex, iBoot loads the image into memory (or identifies its location on NAND) and verifies the &lt;code&gt;IM4M&lt;/code&gt;signature against the hardware root of trust.&lt;/item&gt;
      &lt;item&gt;Trust Cache Extraction: The Cryptex contains a &lt;code&gt;wrapper/trustcache&lt;/code&gt;file. This is a binary blob containing the CDHashes of every executable inside the Cryptex.&lt;/item&gt;
      &lt;item&gt;TXM Ingestion: Before the kernel grafts the filesystem, it extracts this Trust Cache and passes it to the Trusted Execution Monitor (TXM) via &lt;code&gt;GENTER&lt;/code&gt;. The TXM verifies the signature of the Trust Cache itself. If valid, these hashes are added to the Static Trust Cache in GL1 memory.&lt;/item&gt;
      &lt;item&gt;Grafting: The kernel calls &lt;code&gt;apfs_graft&lt;/code&gt;. This stitches the Cryptex filesystem into the Virtual File System (VFS) namespace.&lt;list rend="ul"&gt;&lt;item&gt;The OS Cryptex is grafted at &lt;code&gt;/System/Cryptexes/OS&lt;/code&gt;.&lt;/item&gt;&lt;item&gt;Firmlinks: To maintain POSIX compatibility, the system uses APFS Firmlinks. When a process accesses &lt;code&gt;/usr/lib/libSystem.B.dylib&lt;/code&gt;, the VFS transparently redirects the lookup to&lt;code&gt;/System/Cryptexes/OS/System/Library/Frameworks/...&lt;/code&gt;.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;The OS Cryptex is grafted at &lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;RE Focus: The "Real" Path:&lt;lb/&gt; For reverse engineers, this abstraction can be confusing.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;dyld&lt;/code&gt;: The dynamic linker itself lives in the Cryptex. The binary at&lt;code&gt;/usr/lib/dyld&lt;/code&gt;on the SSV is often a shim or a hardlink to the Cryptex mount.&lt;/item&gt;
      &lt;item&gt;Debugging: When attaching a debugger to &lt;code&gt;launchd&lt;/code&gt;or early boot processes, path resolution may return the&lt;code&gt;/System/Cryptexes/...&lt;/code&gt;path. Scripts that rely on hardcoded paths to&lt;code&gt;/System/Library&lt;/code&gt;must be updated to handle this redirection.&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h4"&gt;8.3.2 Rapid Security Response (RSR): Patching via Overlay Mounts&lt;/head&gt;
    &lt;p&gt;The Cryptex architecture enables Rapid Security Response (RSR), allowing Apple to ship security fixes (e.g., for a WebKit zero-day) without a full OS update.&lt;/p&gt;
    &lt;p&gt;The Patch Cryptex:&lt;lb/&gt; An RSR update is essentially a "Sparse Cryptex." It does not contain a full OS; it contains only the binaries that have changed.&lt;/p&gt;
    &lt;p&gt;The Overlay Mechanism:&lt;lb/&gt; When an RSR is applied:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;&lt;code&gt;cryptexd&lt;/code&gt;: The system daemon&lt;code&gt;cryptexd&lt;/code&gt;(running as root) manages the staging of the update.&lt;/item&gt;
      &lt;item&gt;Verification: The RSR Cryptex is verified by the TXM. Since RSRs are often generic (not personalized to ECID to allow faster distribution), the TXM verifies them against a specific "RSR Root" or a sub-CA in the Apple PKI.&lt;/item&gt;
      &lt;item&gt;Union Mounting: The kernel mounts the RSR Cryptex over the existing OS Cryptex mount point using a union-like filesystem strategy. &lt;list rend="ul"&gt;&lt;item&gt;If a file exists in the RSR Cryptex (e.g., &lt;code&gt;WebKit.framework&lt;/code&gt;), the VFS layer serves that file.&lt;/item&gt;&lt;item&gt;If it does not, the VFS falls back to the base OS Cryptex.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;If a file exists in the RSR Cryptex (e.g., &lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The "Antipatch" and Reversibility:&lt;lb/&gt; A critical security requirement for RSR is reversibility. If a security patch causes a boot loop, the system must be able to recover.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;The Antipatch: RSRs include logic to revert the state.&lt;/item&gt;
      &lt;item&gt;Pre-Boot Authentication: Because the RSR modifies the executable code of the system, its presence must be attested to during boot. The state of "RSR Applied" vs. "Base OS" is managed by &lt;code&gt;LocalPolicy&lt;/code&gt;and verified by iBoot/LLB. If the boot fails repeatedly, iBoot can discard the RSR overlay and boot the "Known Good" base OS Cryptex, effectively removing the patch.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Security Implications for the Researcher:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Atomicity: The RSR update is atomic. You cannot have a "half-patched" system. The TXM ensures that either the full RSR Trust Cache is loaded, or none of it is.&lt;/item&gt;
      &lt;item&gt;Persistence: RSRs do not modify the SSV. They persist in the &lt;code&gt;Preboot&lt;/code&gt;volume and are re-grafted at every boot.&lt;/item&gt;
      &lt;item&gt;Analysis: To analyze an RSR patch, one cannot simply &lt;code&gt;diff&lt;/code&gt;the filesystem. One must extract the RSR Cryptex (&lt;code&gt;.dmg&lt;/code&gt;inside the update payload), mount it, and compare the binaries against the base OS Cryptex. The "delta" is the patch.&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h2"&gt;9.0 The Security Daemon Hierarchy&lt;/head&gt;
    &lt;p&gt;While the kernel and the hardware monitors (SPTM/TXM) enforce the immutable laws of the system physics (memory protections, page table integrity), the complex, mutable business logic of macOS security is delegated to a hierarchy of userland daemons. These daemons operate with high privileges, often holding special ports or entitlements that allow them to influence kernel policy. For the reverse engineer, these daemons represent the "Policy Engine" of the OS—and historically, the most fertile ground for logic bugs and sandbox escapes.&lt;/p&gt;
    &lt;head rend="h3"&gt;9.1 &lt;code&gt;amfid&lt;/code&gt; (Apple Mobile File Integrity Daemon)&lt;/head&gt;
    &lt;p&gt;The Apple Mobile File Integrity Daemon (&lt;code&gt;amfid&lt;/code&gt;) is the userland arbiter of code execution policy. While the TXM (GL1) handles the cryptographic verification of platform binaries and the enforcement of the Static Trust Cache, it lacks the context to evaluate the complex web of third-party provisioning profiles, developer certificates, and MDM constraints.&lt;/p&gt;
    &lt;p&gt;In the Tahoe architecture, &lt;code&gt;amfid&lt;/code&gt; functions as the Policy Decision Point (PDP) for third-party code, while the kernel and TXM act as the Policy Enforcement Points (PEP).&lt;/p&gt;
    &lt;head rend="h4"&gt;9.1.1 The Interaction between &lt;code&gt;launchd&lt;/code&gt;, the Kernel (MACF), and &lt;code&gt;amfid&lt;/code&gt;&lt;/head&gt;
    &lt;p&gt;&lt;code&gt;amfid&lt;/code&gt; does not poll for binaries; it is interrupt-driven by the kernel via the Mandatory Access Control Framework (MACF) hooks.&lt;/p&gt;
    &lt;p&gt;The Bootstrap Race:&lt;code&gt;amfid&lt;/code&gt; is a critical system daemon launched by &lt;code&gt;launchd&lt;/code&gt; early in the boot process. Because &lt;code&gt;amfid&lt;/code&gt; is responsible for verifying signatures, it presents a bootstrap paradox: Who verifies &lt;code&gt;amfid&lt;/code&gt;?&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;The Solution: &lt;code&gt;amfid&lt;/code&gt;is a platform binary located in the OS Cryptex. Its CDHash is present in the Static Trust Cache loaded by iBoot.&lt;/item&gt;
      &lt;item&gt;TXM Verification: When &lt;code&gt;launchd&lt;/code&gt;spawns&lt;code&gt;amfid&lt;/code&gt;, the kernel consults the TXM. The TXM finds the hash in the immutable static cache and blesses the pages immediately. No upcall is required.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The Verification Upcall (The "Slow Path"):&lt;lb/&gt; When a user launches a third-party application (e.g., &lt;code&gt;/Applications/Calculator.app&lt;/code&gt;), the flow traverses the boundary between Kernel and Userland multiple times.&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;The Hook: The kernel executes &lt;code&gt;execve&lt;/code&gt;. The MACF hook&lt;code&gt;mpo_vnode_check_signature&lt;/code&gt;is triggered in&lt;code&gt;AppleMobileFileIntegrity.kext&lt;/code&gt;.&lt;/item&gt;
      &lt;item&gt;TXM Miss: The kernel queries the TXM via &lt;code&gt;GENTER&lt;/code&gt;. The TXM checks the Static Trust Cache and the Dynamic Trust Cache. For a newly launched third-party app, this lookup fails.&lt;/item&gt;
      &lt;item&gt;The Upcall: The kernel constructs a Mach message containing the file's path, the CDHash, and the detached signature blob (if applicable). It sends this message to the &lt;code&gt;HOST_AMFID_PORT&lt;/code&gt;(Special Port 18).&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;amfid&lt;/code&gt;Processing:&lt;code&gt;amfid&lt;/code&gt;receives the message. It performs the heavy lifting of parsing the CMS blob, validating the certificate chain (via IPC to&lt;code&gt;trustd&lt;/code&gt;), and checking provisioning profiles.&lt;/item&gt;
      &lt;item&gt;The Verdict: &lt;code&gt;amfid&lt;/code&gt;returns a boolean verdict to the kernel via&lt;code&gt;host_set_exception_ports&lt;/code&gt;or a dedicated MIG reply.&lt;/item&gt;
      &lt;item&gt;TXM Update: If &lt;code&gt;amfid&lt;/code&gt;approves the binary, the kernel issues a second&lt;code&gt;GENTER&lt;/code&gt;call to the TXM, instructing it to add the validated CDHash to the Dynamic Trust Cache.&lt;list rend="ul"&gt;&lt;item&gt;Security Note: In Tahoe, the TXM likely verifies the signature blob again independently to ensure the kernel/amfid didn't lie about the cryptographic validity, but it relies on &lt;code&gt;amfid&lt;/code&gt;for the policy decision (e.g., "Is this developer ID allowed on this system?").&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;Security Note: In Tahoe, the TXM likely verifies the signature blob again independently to ensure the kernel/amfid didn't lie about the cryptographic validity, but it relies on &lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;RE Focus: The MIG Interface:&lt;lb/&gt; The communication interface is defined in &lt;code&gt;mfi_server.defs&lt;/code&gt; (reverse engineered). The key routine is &lt;code&gt;verify_code_directory&lt;/code&gt;.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Input: &lt;code&gt;audit_token_t&lt;/code&gt;,&lt;code&gt;mach_port_t file_port&lt;/code&gt;,&lt;code&gt;off_t offset&lt;/code&gt;,&lt;code&gt;int64_t file_size&lt;/code&gt;.&lt;/item&gt;
      &lt;item&gt;Attack Surface: Malformed Mach messages sent to &lt;code&gt;amfid&lt;/code&gt;'s service port can trigger type confusion in the daemon. However,&lt;code&gt;amfid&lt;/code&gt;checks the sender's audit token to ensure requests originate only from the kernel (&lt;code&gt;kernel_task&lt;/code&gt;).&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h4"&gt;9.1.2 Validating Code Directories (CDHash), Entitlements, and Provisioning Profiles&lt;/head&gt;
    &lt;p&gt;The core logic of &lt;code&gt;amfid&lt;/code&gt; resides in its ability to link a binary's Code Directory (CD) to a valid Provisioning Profile. This is the mechanism that enforces the "Walled Garden" on iOS and the Notarization requirements on macOS.&lt;/p&gt;
    &lt;p&gt;The Validation Logic (&lt;code&gt;MISValidateSignatureAndCopyInfo&lt;/code&gt;):&lt;code&gt;amfid&lt;/code&gt; links against &lt;code&gt;libmis.dylib&lt;/code&gt; (Mobile Installation Service), which exports the symbol &lt;code&gt;MISValidateSignatureAndCopyInfo&lt;/code&gt;. This function is the heart of the check.&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;CDHash Extraction: &lt;code&gt;amfid&lt;/code&gt;reads the&lt;code&gt;LC_CODE_SIGNATURE&lt;/code&gt;load command from the binary. It hashes the Code Directory slots to compute the CDHash.&lt;/item&gt;
      &lt;item&gt;Entitlement Extraction: It parses the embedded entitlements (XML/plist) from the signature blob.&lt;/item&gt;
      &lt;item&gt;Profile Correlation: If the binary is signed by a developer certificate (not Apple), &lt;code&gt;amfid&lt;/code&gt;looks for an embedded&lt;code&gt;embedded.mobileprovision&lt;/code&gt;file.&lt;list rend="ul"&gt;&lt;item&gt;PKCS#7 Verification: It verifies the signature of the profile itself (signed by Apple).&lt;/item&gt;&lt;item&gt;Allowlist Check: It compares the entitlements requested by the binary against the &lt;code&gt;Entitlements&lt;/code&gt;dictionary in the profile.&lt;/item&gt;&lt;item&gt;Device Check: For development profiles, it verifies the device's UDID is present in the &lt;code&gt;ProvisionedDevices&lt;/code&gt;array.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;Constraint Enforcement: &lt;list rend="ul"&gt;&lt;item&gt;Restricted Entitlements: Certain entitlements (e.g., &lt;code&gt;com.apple.private.security.no-sandbox&lt;/code&gt;) are "Restricted." They can only be granted if the provisioning profile is signed by a specific Apple internal certificate chain.&lt;code&gt;amfid&lt;/code&gt;enforces this hierarchy.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;Restricted Entitlements: Certain entitlements (e.g., &lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The "Union" of Trust:&lt;lb/&gt; On macOS, &lt;code&gt;amfid&lt;/code&gt; also interfaces with the Ticket system (Notarization).&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;It checks if a valid Notarization Ticket is stapled to the binary or present in the system's ticket database (&lt;code&gt;/var/db/SystemPolicy&lt;/code&gt;).&lt;/item&gt;
      &lt;item&gt;If a ticket is found, &lt;code&gt;amfid&lt;/code&gt;treats the binary as "Apple-Notarized," relaxing certain constraints compared to a purely ad-hoc signed binary.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;RE Focus: &lt;code&gt;libmis.dylib&lt;/code&gt; Reversing:&lt;lb/&gt; This library is heavily obfuscated and stripped. However, analyzing the failure paths of &lt;code&gt;MISValidateSignature...&lt;/code&gt; is crucial for understanding why a specific binary is being killed.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Return Codes: The function returns an integer status. &lt;code&gt;0&lt;/code&gt;is success. Other values map to specific failures (e.g.,&lt;code&gt;MIS_PROFILE_EXPIRED&lt;/code&gt;,&lt;code&gt;MIS_ENTITLEMENT_MISMATCH&lt;/code&gt;).&lt;/item&gt;
      &lt;item&gt;Logging: &lt;code&gt;amfid&lt;/code&gt;writes detailed failure reasons to the system log (&lt;code&gt;os_log&lt;/code&gt;), but often only if a specific&lt;code&gt;boot-arg&lt;/code&gt;or configuration profile is installed (&lt;code&gt;AmfiDeveloperMode&lt;/code&gt;).&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h4"&gt;9.1.3 Exception Handling: How &lt;code&gt;get-task-allow&lt;/code&gt; and Debugging Entitlements are Processed&lt;/head&gt;
    &lt;p&gt;One of &lt;code&gt;amfid&lt;/code&gt;'s most critical roles is gating access to process debugging. The ability to attach a debugger (&lt;code&gt;task_for_pid&lt;/code&gt;) is effectively a full compromise of the target process.&lt;/p&gt;
    &lt;p&gt;The &lt;code&gt;get-task-allow&lt;/code&gt; Entitlement:&lt;lb/&gt; In a standard production environment, a process cannot be debugged unless it possesses the &lt;code&gt;com.apple.security.get-task-allow&lt;/code&gt; entitlement.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Xcode Builds: When you build and run an app from Xcode, it signs the binary with a development certificate and injects this entitlement.&lt;/item&gt;
      &lt;item&gt;App Store Builds: The App Store distribution process strips this entitlement.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The &lt;code&gt;amfid&lt;/code&gt; Decision Matrix:&lt;lb/&gt; When the kernel parses a binary, it extracts the entitlements and passes them to &lt;code&gt;amfid&lt;/code&gt;. &lt;code&gt;amfid&lt;/code&gt; validates that the &lt;code&gt;get-task-allow&lt;/code&gt; entitlement is permitted by the provisioning profile.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Valid: &lt;code&gt;amfid&lt;/code&gt;tells the kernel to set the&lt;code&gt;CS_GET_TASK_ALLOW&lt;/code&gt;flag in the process's&lt;code&gt;cs_flags&lt;/code&gt;(Code Signing Flags).&lt;/item&gt;
      &lt;item&gt;Invalid: &lt;code&gt;amfid&lt;/code&gt;strips the entitlement or rejects the signature entirely.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The &lt;code&gt;task_for_pid&lt;/code&gt; Check:&lt;lb/&gt; When &lt;code&gt;debugserver&lt;/code&gt; (or &lt;code&gt;lldb&lt;/code&gt;) calls &lt;code&gt;task_for_pid(target_pid)&lt;/code&gt;, the kernel checks the target's &lt;code&gt;cs_flags&lt;/code&gt;.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;If &lt;code&gt;CS_GET_TASK_ALLOW&lt;/code&gt;is set: Access granted (subject to root/procmod checks).&lt;/item&gt;
      &lt;item&gt;If &lt;code&gt;CS_GET_TASK_ALLOW&lt;/code&gt;is clear: Access denied (&lt;code&gt;KERN_FAILURE&lt;/code&gt;).&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Developer Mode (The Tahoe Shift):&lt;lb/&gt; In the Tahoe architecture, the mere presence of the entitlement is insufficient. The system must be in Developer Mode.&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;State Check: &lt;code&gt;amfid&lt;/code&gt;queries the TXM to determine if Developer Mode is active.&lt;/item&gt;
      &lt;item&gt;Enforcement: If Developer Mode is disabled, &lt;code&gt;amfid&lt;/code&gt;will reject the execution of any binary signed with a development certificate, even if the profile is valid. This prevents an attacker from side-loading a malicious "debuggable" app onto a user's device to inspect memory, unless the user has explicitly lowered the device's security posture via the TXM-mediated reboot ceremony.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Unrestricted Debugging (SIP Disable):&lt;lb/&gt; On macOS, disabling System Integrity Protection (SIP) historically allowed unrestricted debugging (&lt;code&gt;csrutil disable&lt;/code&gt;).&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Legacy: The kernel checked the &lt;code&gt;CSR_ALLOW_UNRESTRICTED_DEBUGGING&lt;/code&gt;bit in the NVRAM boot-args.&lt;/item&gt;
      &lt;item&gt;Tahoe: The SIP state is managed by the LocalPolicy and enforced by the TXM. &lt;code&gt;amfid&lt;/code&gt;retrieves this policy state. If SIP is disabled,&lt;code&gt;amfid&lt;/code&gt;relaxes the signature validation logic, effectively telling the kernel "Everything is valid," allowing the execution of unsigned code and the attachment of debuggers to system processes (except those protected by Exclaves).&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h3"&gt;9.2 &lt;code&gt;sandboxd&lt;/code&gt; &amp;amp; The Seatbelt Policy&lt;/head&gt;
    &lt;p&gt;If &lt;code&gt;amfid&lt;/code&gt; is the bouncer checking IDs at the door, the Seatbelt subsystem (marketed as App Sandbox) is the straightjacket strapped to the guest once they are inside. Originating from the TrustedBSD project, the macOS Sandbox is a Mandatory Access Control (MAC) mechanism that restricts a process's access to resources—files, network sockets, Mach ports, and IOKit drivers—regardless of the user's UID.&lt;/p&gt;
    &lt;p&gt;In the Tahoe architecture, the Sandbox has evolved from a path-based filter into a semantic, metadata-driven enforcement engine that is tightly coupled with the kernel's VFS layer and the new Data Vault primitives.&lt;/p&gt;
    &lt;head rend="h4"&gt;9.2.1 Compiling SBPL (Sandbox Policy Language) to Byte Code&lt;/head&gt;
    &lt;p&gt;The definition of a sandbox profile is written in SBPL (Sandbox Policy Language), a Scheme-like (LISP) dialect. However, the kernel does not contain a LISP interpreter. The translation from human-readable policy to kernel-enforceable logic is the responsibility of &lt;code&gt;sandboxd&lt;/code&gt; and the &lt;code&gt;libsandbox.dylib&lt;/code&gt; runtime.&lt;/p&gt;
    &lt;p&gt;The Compilation Pipeline:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;
        &lt;p&gt;Profile Selection:&lt;/p&gt;
        &lt;list rend="ul"&gt;
          &lt;item&gt;App Store Apps: The system applies the generic &lt;code&gt;container&lt;/code&gt;profile.&lt;/item&gt;
          &lt;item&gt;System Daemons: Daemons specify their profile name in &lt;code&gt;launchd.plist&lt;/code&gt;(e.g.,&lt;code&gt;com.apple.syslogd.sb&lt;/code&gt;).&lt;/item&gt;
          &lt;item&gt;Platform Profile: In modern macOS, individual SBPL files for system services are increasingly deprecated in favor of a monolithic Platform Profile embedded directly into the Boot Kernel Collection. This reduces the attack surface by removing the need to parse text files at runtime.&lt;/item&gt;
        &lt;/list&gt;
      &lt;/item&gt;
      &lt;item&gt;App Store Apps: The system applies the generic &lt;/item&gt;
      &lt;item&gt;&lt;p&gt;The Compiler (&lt;/p&gt;&lt;code&gt;sandboxd&lt;/code&gt;):&lt;lb/&gt;When a process initializes the sandbox (via&lt;code&gt;sandbox_init_with_parameters&lt;/code&gt;), an XPC call is made to&lt;code&gt;sandboxd&lt;/code&gt;.&lt;list rend="ul"&gt;&lt;item&gt;&lt;code&gt;sandboxd&lt;/code&gt;parses the SBPL.&lt;/item&gt;&lt;item&gt;It resolves variable expansions (e.g., &lt;code&gt;${HOME}&lt;/code&gt;,&lt;code&gt;${TemporaryDirectory}&lt;/code&gt;).&lt;/item&gt;&lt;item&gt;It compiles the rules into a proprietary Byte Code format (often referred to as "TinyScheme" or "Filter Machine" code).&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;&lt;p&gt;The Byte Code Structure:&lt;/p&gt;&lt;lb/&gt;The compiled blob is a serialized state machine. Reverse engineering this format reveals a graph of operations:&lt;list rend="ul"&gt;&lt;item&gt;Opcodes: &lt;code&gt;OP_MATCH_PATH&lt;/code&gt;,&lt;code&gt;OP_MATCH_PATTERN&lt;/code&gt;,&lt;code&gt;OP_CHECK_ENTITLEMENT&lt;/code&gt;,&lt;code&gt;OP_ALLOW&lt;/code&gt;,&lt;code&gt;OP_DENY&lt;/code&gt;.&lt;/item&gt;&lt;item&gt;Filters: The logic is optimized into a decision tree. For example, file operations are often grouped by path prefix to minimize evaluation time.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;Opcodes: &lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;RE Focus: Reversing the Binary Blob:&lt;lb/&gt; The kernel receives this blob via the &lt;code&gt;__mac_syscall&lt;/code&gt; interface (specifically the &lt;code&gt;sandbox_set_profile&lt;/code&gt; command).&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Extraction: You can intercept these blobs by hooking &lt;code&gt;sandbox_check_common&lt;/code&gt;in the kernel or&lt;code&gt;sandbox_compile_entitlements&lt;/code&gt;in userland.&lt;/item&gt;
      &lt;item&gt;Decompilation: Tools like &lt;code&gt;sbs&lt;/code&gt;(Sandbox Scrutinizer) or custom IDA scripts can lift the bytecode back into a pseudo-SBPL format.&lt;/item&gt;
      &lt;item&gt;The "Profile Validation" Check: In Tahoe, the kernel performs a sanity check on the bytecode. It verifies that the profile does not contain "impossible" instructions or infinite loops that could hang the kernel thread (a DoS vector).&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h4"&gt;9.2.2 The Sandbox Kernel Extension: Hooking Syscalls via the MAC Framework&lt;/head&gt;
    &lt;p&gt;The enforcement engine is &lt;code&gt;Sandbox.kext&lt;/code&gt;. It hooks into the XNU kernel using the Mandatory Access Control Framework (MACF).&lt;/p&gt;
    &lt;p&gt;The MACF Hooks:&lt;lb/&gt; XNU is instrumented with hundreds of &lt;code&gt;mac_&lt;/code&gt; hooks placed at critical security bottlenecks.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Filesystem: &lt;code&gt;mpo_vnode_check_open&lt;/code&gt;,&lt;code&gt;mpo_vnode_check_rename&lt;/code&gt;,&lt;code&gt;mpo_vnode_check_unlink&lt;/code&gt;.&lt;/item&gt;
      &lt;item&gt;IPC: &lt;code&gt;mpo_mach_port_check_send&lt;/code&gt;,&lt;code&gt;mpo_mach_port_check_receive&lt;/code&gt;.&lt;/item&gt;
      &lt;item&gt;IOKit: &lt;code&gt;mpo_iokit_check_open_service&lt;/code&gt;.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The Evaluation Flow:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Trigger: A sandboxed process calls &lt;code&gt;open("/etc/passwd", O_RDONLY)&lt;/code&gt;.&lt;/item&gt;
      &lt;item&gt;Hook: The kernel executes &lt;code&gt;mac_vnode_check_open&lt;/code&gt;.&lt;/item&gt;
      &lt;item&gt;Dispatch: The MAC framework iterates through registered policies. &lt;code&gt;Sandbox.kext&lt;/code&gt;claims the hook.&lt;/item&gt;
      &lt;item&gt;Credential Lookup: The kext retrieves the &lt;code&gt;kauth_cred_t&lt;/code&gt;of the calling process. Attached to this credential is the Sandbox Label, which contains the pointer to the compiled bytecode profile.&lt;/item&gt;
      &lt;item&gt;Evaluation: The Sandbox engine executes the bytecode against the request arguments. &lt;list rend="ul"&gt;&lt;item&gt;Input: Operation (&lt;code&gt;file-read&lt;/code&gt;), Path (&lt;code&gt;/etc/passwd&lt;/code&gt;).&lt;/item&gt;&lt;item&gt;Logic: The engine traverses the decision tree.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;Input: Operation (&lt;/item&gt;
      &lt;item&gt;Caching (The Performance Critical Path):&lt;lb/&gt;Evaluating bytecode on every syscall is prohibitively expensive.&lt;code&gt;Sandbox.kext&lt;/code&gt;maintains a Check Cache.&lt;list rend="ul"&gt;&lt;item&gt;If the decision is made, the result is cached in the &lt;code&gt;vnode&lt;/code&gt;'s label or a per-process cache.&lt;/item&gt;&lt;item&gt;Subsequent accesses to the same file bypass the bytecode engine and use the cached verdict.&lt;/item&gt;&lt;item&gt;RE Vulnerability: Cache invalidation bugs are critical. If a file is moved or permissions change, but the Sandbox cache remains stale, enforcement can be bypassed.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;If the decision is made, the result is cached in the &lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The Tahoe/SPTM Intersection:&lt;lb/&gt; While the Sandbox policy is software-defined, the integrity of the hooks is hardware-enforced.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Immutable Hooks: The function pointers in the &lt;code&gt;mac_policy_conf&lt;/code&gt;structure (which point to&lt;code&gt;Sandbox.kext&lt;/code&gt;functions) reside in&lt;code&gt;XNU_DATA_CONST&lt;/code&gt;.&lt;/item&gt;
      &lt;item&gt;SPTM Enforcement: If a rootkit attempts to unhook the Sandbox by overwriting these pointers, the SPTM will panic the system, as &lt;code&gt;XNU_DATA_CONST&lt;/code&gt;is read-only to EL1. This prevents the classic "unhooking" attacks used by older jailbreaks.&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h4"&gt;9.2.3 Containerization: Data Vaults and Group Containers&lt;/head&gt;
    &lt;p&gt;In the Tahoe era, Apple has moved beyond simple path-based rules (which are fragile and prone to symlink attacks) toward Semantic Containerization.&lt;/p&gt;
    &lt;p&gt;Data Vaults:&lt;lb/&gt; Data Vaults are the "Nuclear Option" for privacy. They protect sensitive user data (e.g., Messages, Photos, Health) from everyone, including the root user.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Implementation: A Data Vault is a directory flagged with a specific VFS attribute (ACL or extended attribute).&lt;/item&gt;
      &lt;item&gt;Enforcement: The kernel checks for this attribute during lookup. Access is denied unless the calling process possesses a specific, restricted entitlement (e.g., &lt;code&gt;com.apple.private.security.storage.AppDataVault&lt;/code&gt;).&lt;/item&gt;
      &lt;item&gt;The "Root" Fallacy: Even if you run as &lt;code&gt;root&lt;/code&gt;(UID 0) with&lt;code&gt;host_priv&lt;/code&gt;, you cannot&lt;code&gt;ls&lt;/code&gt;or&lt;code&gt;cat&lt;/code&gt;a Data Vault. The Sandbox check happens before the DAC (Discretionary Access Control) check.&lt;/item&gt;
      &lt;item&gt;RE Focus: Look for &lt;code&gt;rootless_check_datavault_flag&lt;/code&gt;in the kernel. This function verifies the entitlement against the vnode's flags.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Group Containers:&lt;lb/&gt; To allow IPC and data sharing between apps and their extensions (e.g., a Widget and its parent App), the Sandbox enforces Group Containers.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;The &lt;code&gt;application-group&lt;/code&gt;Entitlement: Defines the shared identifier (e.g.,&lt;code&gt;group.com.example.app&lt;/code&gt;).&lt;/item&gt;
      &lt;item&gt;Container Manager: The system daemon &lt;code&gt;containermanagerd&lt;/code&gt;manages the lifecycle of these directories (&lt;code&gt;~/Library/Group Containers/&lt;/code&gt;).&lt;/item&gt;
      &lt;item&gt;Sandbox Logic: The profile compiler automatically injects rules allowing read/write access to &lt;code&gt;${HOME}/Library/Group Containers/&amp;lt;group-id&amp;gt;&lt;/code&gt;. This injection is based on the entitlements present in the binary's code signature, binding the filesystem access directly to the cryptographic identity of the executable.&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h3"&gt;9.3 &lt;code&gt;tccd&lt;/code&gt; (Transparency, Consent, and Control)&lt;/head&gt;
    &lt;p&gt;If &lt;code&gt;amfid&lt;/code&gt; validates the code's identity and &lt;code&gt;sandboxd&lt;/code&gt; restricts the code's reach, &lt;code&gt;tccd&lt;/code&gt; is the daemon responsible for managing the most fragile component of the security model: the user.&lt;/p&gt;
    &lt;p&gt;The Transparency, Consent, and Control (TCC) subsystem is the "User Intent Oracle." It governs access to privacy-sensitive sensors (Camera, Microphone), personal data (Contacts, Calendars, Photos), and privileged system capabilities (Full Disk Access, Screen Recording). In the Tahoe architecture, &lt;code&gt;tccd&lt;/code&gt; has evolved from a simple prompt generator into a complex attribution engine that must defend against "Consent Hojacking" and "Attribution Spoofing."&lt;/p&gt;
    &lt;head rend="h4"&gt;9.3.1 The TCC Database: Schema, Integrity, and SIP&lt;/head&gt;
    &lt;p&gt;The state of user consent is persisted in SQLite databases. There is a bifurcation of state:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;System TCC: &lt;code&gt;/Library/Application Support/com.apple.TCC/TCC.db&lt;/code&gt;(Root-owned, system-wide permissions like Full Disk Access).&lt;/item&gt;
      &lt;item&gt;User TCC: &lt;code&gt;~/Library/Application Support/com.apple.TCC/TCC.db&lt;/code&gt;(User-owned, per-session permissions like Camera/Microphone).&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The Schema:&lt;lb/&gt; The core of the database is the &lt;code&gt;access&lt;/code&gt; table. For the reverse engineer, the critical columns are:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;service&lt;/code&gt;: The string identifier of the privilege (e.g.,&lt;code&gt;kTCCServiceSystemPolicyAllFiles&lt;/code&gt;,&lt;code&gt;kTCCServiceMicrophone&lt;/code&gt;).&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;client&lt;/code&gt;: The bundle identifier or path of the requesting binary.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;client_type&lt;/code&gt;:&lt;code&gt;0&lt;/code&gt;(Bundle ID) or&lt;code&gt;1&lt;/code&gt;(Absolute Path).&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;auth_value&lt;/code&gt;:&lt;code&gt;0&lt;/code&gt;(Denied),&lt;code&gt;1&lt;/code&gt;(Unknown),&lt;code&gt;2&lt;/code&gt;(Allowed),&lt;code&gt;3&lt;/code&gt;(Limited).&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;csreq&lt;/code&gt;: The Code Signing Requirement.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The &lt;code&gt;csreq&lt;/code&gt; Blob (The Cryptographic Anchor):&lt;lb/&gt; TCC does not trust paths. If it did, an attacker could simply overwrite &lt;code&gt;/Applications/TrustedApp.app&lt;/code&gt; with malware and inherit its camera permissions.&lt;lb/&gt; Instead, TCC stores a compiled Code Signing Requirement (CSReq) blob in the database.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;When a process requests access, &lt;code&gt;tccd&lt;/code&gt;obtains the process's code signature.&lt;/item&gt;
      &lt;item&gt;It validates the running code against the &lt;code&gt;csreq&lt;/code&gt;stored in the database row.&lt;/item&gt;
      &lt;item&gt;Logic: &lt;code&gt;(Current_Code_Signature) satisfies (Stored_CSReq)&lt;/code&gt;.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Protection Mechanisms:&lt;lb/&gt; While the database is a standard SQLite file, access to the file handle is heavily guarded.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;SIP (System Integrity Protection): The System TCC database is protected by SIP. Even &lt;code&gt;root&lt;/code&gt;cannot write to it. Only&lt;code&gt;tccd&lt;/code&gt;(which has the&lt;code&gt;com.apple.private.tcc.manager&lt;/code&gt;entitlement) and specific Apple-signed updaters can modify it.&lt;/item&gt;
      &lt;item&gt;Data Vaults: In newer macOS versions, the directory containing the database is often flagged as a Data Vault, requiring kernel-enforced entitlements just to traverse the directory structure.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;RE Focus: The &lt;code&gt;tccutil&lt;/code&gt; Fallacy:&lt;lb/&gt; The command-line tool &lt;code&gt;tccutil&lt;/code&gt; is often used to reset permissions. However, it communicates with &lt;code&gt;tccd&lt;/code&gt; via XPC. It does not touch the DB directly. Reverse engineering &lt;code&gt;tccd&lt;/code&gt; reveals that it holds an exclusive lock on the DB handle, and any attempt to modify the DB file directly (e.g., via a bypass) usually results in database corruption or the daemon crashing and reloading from a backup, due to WAL (Write-Ahead Log) integrity checks.&lt;/p&gt;
    &lt;head rend="h4"&gt;9.3.2 The Attribution Chain: Determining Who is Asking&lt;/head&gt;
    &lt;p&gt;The hardest problem &lt;code&gt;tccd&lt;/code&gt; solves is Attribution. When a user clicks a button in an app, and that app asks a daemon to take a photo, who is the "Client"? The App? Or the Daemon?&lt;/p&gt;
    &lt;p&gt;The XPC Audit Token:&lt;lb/&gt; When a message arrives at &lt;code&gt;tccd&lt;/code&gt; (via &lt;code&gt;com.apple.tccd.system&lt;/code&gt; or &lt;code&gt;com.apple.tccd&lt;/code&gt;), the primary identifier is the Audit Token attached to the Mach message trailer.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;tccd&lt;/code&gt;parses the token to retrieve the PID, UID, and GID.&lt;/item&gt;
      &lt;item&gt;It uses &lt;code&gt;csops&lt;/code&gt;(or the kernel-backed&lt;code&gt;CS_VALID&lt;/code&gt;flag) to ensure the PID maps to a valid, signed binary.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The "Responsible Process" Problem:&lt;lb/&gt; Consider &lt;code&gt;Terminal.app&lt;/code&gt; running a shell script that calls &lt;code&gt;curl&lt;/code&gt;. If &lt;code&gt;curl&lt;/code&gt; asks for network access, the user should see "Terminal.app would like to access...", not "curl".&lt;lb/&gt; To handle this, TCC supports Attribution Chains.&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;&lt;code&gt;responsible_pid&lt;/code&gt;: A process can designate another process as responsible for its actions (using&lt;code&gt;launchd&lt;/code&gt;attributes or specific XPC flags).&lt;/item&gt;
      &lt;item&gt;Validation: &lt;code&gt;tccd&lt;/code&gt;verifies the relationship. It checks if the requesting process is a child of the responsible process, or if the responsible process possesses the&lt;code&gt;com.apple.private.tcc.allow&lt;/code&gt;entitlement which permits it to proxy requests.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The Access Object:&lt;lb/&gt; Internally, &lt;code&gt;tccd&lt;/code&gt; creates a &lt;code&gt;TCCAccessRequest&lt;/code&gt; object.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Subject: The process requesting access.&lt;/item&gt;
      &lt;item&gt;Accessor: The process that will actually touch the resource (often the same as Subject).&lt;/item&gt;
      &lt;item&gt;Attributor: The process to be displayed in the UI.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;RE Focus: The &lt;code&gt;tccd&lt;/code&gt; State Machine:&lt;lb/&gt; By analyzing the &lt;code&gt;service_listener&lt;/code&gt; function in &lt;code&gt;tccd&lt;/code&gt;, one can map the decision logic:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Entitlement Check: Does the client have &lt;code&gt;com.apple.private.tcc.allow&lt;/code&gt;for this service? If yes, Grant immediately (no prompt).&lt;/item&gt;
      &lt;item&gt;Database Lookup: Does a row exist in &lt;code&gt;TCC.db&lt;/code&gt;?&lt;list rend="ul"&gt;&lt;item&gt;If yes, validate &lt;code&gt;csreq&lt;/code&gt;. If valid, return&lt;code&gt;auth_value&lt;/code&gt;.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;If yes, validate &lt;/item&gt;
      &lt;item&gt;User Prompt: If no record exists, construct a &lt;code&gt;UserNotification&lt;/code&gt;.&lt;list rend="ul"&gt;&lt;item&gt;Secure UI: The prompt is not drawn by &lt;code&gt;tccd&lt;/code&gt;. It is handed off to&lt;code&gt;UserNotificationCenter&lt;/code&gt;(and&lt;code&gt;CoreServicesUIAgent&lt;/code&gt;). This prevents the requesting app from drawing over the prompt (Clickjacking) because the prompt window resides in a higher window level (Shield Window) managed by WindowServer.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;Secure UI: The prompt is not drawn by &lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h4"&gt;9.3.3 RE Focus: XPC Attacks against TCC Endpoint Validation&lt;/head&gt;
    &lt;p&gt;For the vulnerability researcher, &lt;code&gt;tccd&lt;/code&gt; is a prime target. If you can trick &lt;code&gt;tccd&lt;/code&gt; into believing you are &lt;code&gt;Finder.app&lt;/code&gt;, you gain Full Disk Access.&lt;/p&gt;
    &lt;p&gt;Attack Vector 1: XPC Injection:&lt;lb/&gt; Many apps load bundles or plugins. If an app with TCC permissions (e.g., a Video Editor with Camera access) loads a malicious dylib (via dylib hijacking or unsafe &lt;code&gt;dlopen&lt;/code&gt;), that dylib runs inside the privileged process.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;TCC's View: &lt;code&gt;tccd&lt;/code&gt;sees the PID of the Video Editor. It grants access.&lt;/item&gt;
      &lt;item&gt;Mitigation: Hardened Runtime and Library Validation (enforced by &lt;code&gt;dyld&lt;/code&gt;and TXM) prevent loading unsigned dylibs. However, if the host app has the&lt;code&gt;com.apple.security.cs.disable-library-validation&lt;/code&gt;entitlement, this vector is wide open.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Attack Vector 2: The "Fake" Attributor:&lt;lb/&gt; Attackers attempt to spoof the XPC dictionary sent to &lt;code&gt;tccd&lt;/code&gt;.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;The XPC message often contains a &lt;code&gt;TCCAccessRequest&lt;/code&gt;dictionary.&lt;/item&gt;
      &lt;item&gt;Historically, researchers found they could inject a fake &lt;code&gt;target_token&lt;/code&gt;into this dictionary.&lt;/item&gt;
      &lt;item&gt;Current Hardening: &lt;code&gt;tccd&lt;/code&gt;now ignores user-supplied tokens in the XPC payload for most checks. It relies almost exclusively on the kernel-supplied Audit Token from the IPC trailer, which cannot be spoofed from userland.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Attack Vector 3: Semantic Confusion (The "Open" Trap):&lt;lb/&gt; An attacker uses the &lt;code&gt;open&lt;/code&gt; command or AppleEvents to coerce a privileged app to perform an action.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Example: Telling &lt;code&gt;Terminal&lt;/code&gt;to execute a script.&lt;/item&gt;
      &lt;item&gt;Mitigation: macOS introduced "Automation" permissions (&lt;code&gt;kTCCServiceAppleEvents&lt;/code&gt;). App A cannot send AppleEvents to App B unless explicitly authorized by the user.&lt;code&gt;tccd&lt;/code&gt;enforces this by intercepting the AppleEvent manager's IPC.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The "Tahoe" Impact:&lt;lb/&gt; On Apple Silicon, the TXM plays a subtle but vital role here. &lt;code&gt;tccd&lt;/code&gt; relies on the Code Signing flags (&lt;code&gt;CS_VALID&lt;/code&gt;, &lt;code&gt;CS_HARD&lt;/code&gt;, &lt;code&gt;CS_KILL&lt;/code&gt;) to trust the client. In Tahoe, these flags are ultimately enforced by the TXM.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;If an attacker manages to patch the kernel to set &lt;code&gt;CS_VALID&lt;/code&gt;on a malicious binary, the SPTM will still refuse to map the pages as executable if the TXM hasn't blessed the CDHash.&lt;/item&gt;
      &lt;item&gt;Therefore, &lt;code&gt;tccd&lt;/code&gt;'s reliance on code signing is anchored in the hardware root of trust. A kernel compromise does not trivially allow bypassing TCC, because the attacker cannot easily forge the immutable identity of a system binary that&lt;code&gt;tccd&lt;/code&gt;trusts.&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h2"&gt;10.0 User Session, Authentication &amp;amp; Data Protection&lt;/head&gt;
    &lt;p&gt;The transition from the system bootstrap phase to the interactive user session represents a critical boundary crossing. Up to this point, the system has operated primarily in the &lt;code&gt;Startup&lt;/code&gt; domain, managed by the root &lt;code&gt;launchd&lt;/code&gt; context. The instantiation of a user session requires the creation of a new security context—the Audit Session—and the decryption of user-specific cryptographic material anchored in the Secure Enclave.&lt;/p&gt;
    &lt;p&gt;In the Tahoe architecture, this process is not merely a check of a password hash against a file. It is a hardware-mediated ceremony involving the unwrapping of the Secure Token, the derivation of the User Keybag, and the establishment of a Kerberized identity that binds the user's biological presence (Biometrics) to their digital authority.&lt;/p&gt;
    &lt;head rend="h3"&gt;10.1 &lt;code&gt;loginwindow&lt;/code&gt; &amp;amp; &lt;code&gt;opendirectoryd&lt;/code&gt;&lt;/head&gt;
    &lt;p&gt;The graphical login experience is orchestrated by two primary userland daemons: &lt;code&gt;loginwindow&lt;/code&gt;, which manages the session lifecycle and UI, and &lt;code&gt;opendirectoryd&lt;/code&gt;, which serves as the abstraction layer for authentication and identity services. While these components are legacy codebases dating back to NeXTSTEP, their internals have been aggressively refactored to support the hardware-backed security model of Apple Silicon.&lt;/p&gt;
    &lt;head rend="h4"&gt;10.1.1 The Audit Session ID (ASID) and Kernel Tracking&lt;/head&gt;
    &lt;p&gt;In XNU, the concept of a "User" is tracked via the Audit Session ID (ASID). This is distinct from the UNIX UID/GID. The ASID identifies a specific login instance (e.g., the graphical console session vs. an SSH session).&lt;/p&gt;
    &lt;p&gt;The &lt;code&gt;setaudit_addr&lt;/code&gt; Syscall:&lt;lb/&gt; When &lt;code&gt;loginwindow&lt;/code&gt; successfully authenticates a user, it does not simply &lt;code&gt;setuid&lt;/code&gt;. It invokes the &lt;code&gt;setaudit_addr&lt;/code&gt; syscall (wrapped by &lt;code&gt;libbsm&lt;/code&gt;).&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Kernel Structure: This syscall populates the &lt;code&gt;audit_token_t&lt;/code&gt;structure associated with the process.&lt;/item&gt;
      &lt;item&gt;Immutability: Once an ASID is set for a process, it is inherited by all children. Crucially, XNU enforces that a process cannot change its ASID once set (with very specific exceptions for &lt;code&gt;sshd&lt;/code&gt;and&lt;code&gt;loginwindow&lt;/code&gt;holding the&lt;code&gt;com.apple.private.audit.session.create&lt;/code&gt;entitlement).&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The Security Implications of ASID:&lt;lb/&gt; The ASID is the primary signal used by &lt;code&gt;tccd&lt;/code&gt; and &lt;code&gt;WindowServer&lt;/code&gt; to determine "Console Ownership."&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;TCC: When a process requests Camera access, &lt;code&gt;tccd&lt;/code&gt;checks if the requesting process's ASID matches the ASID of the active graphical session. If it matches, the user is prompted. If it is a background session (e.g., SSH), the request is auto-denied or routed differently.&lt;/item&gt;
      &lt;item&gt;WindowServer: Only processes belonging to the active Console ASID are permitted to connect to the WindowServer and draw on the screen.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;RE Focus: The &lt;code&gt;security_authtrampoline&lt;/code&gt;:&lt;lb/&gt; Historically, the transition from the &lt;code&gt;loginwindow&lt;/code&gt; context (root) to the user context involved a setuid binary called &lt;code&gt;security_authtrampoline&lt;/code&gt;. In modern macOS, this logic is largely internalized within &lt;code&gt;loginwindow&lt;/code&gt;'s interaction with &lt;code&gt;launchd&lt;/code&gt;.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;loginwindow&lt;/code&gt;calls&lt;code&gt;xpc_session_create&lt;/code&gt;.&lt;/item&gt;
      &lt;item&gt;This triggers &lt;code&gt;launchd&lt;/code&gt;to spawn a new instance of itself (the User&lt;code&gt;launchd&lt;/code&gt;) running as the target user.&lt;/item&gt;
      &lt;item&gt;This User &lt;code&gt;launchd&lt;/code&gt;becomes the root of the user's process tree.&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h4"&gt;10.1.2 &lt;code&gt;loginwindow&lt;/code&gt;: The Shield Window and Session State&lt;/head&gt;
    &lt;p&gt;&lt;code&gt;loginwindow&lt;/code&gt; (located at &lt;code&gt;/System/Library/CoreServices/loginwindow.app/Contents/MacOS/loginwindow&lt;/code&gt;) is the session leader. It is responsible for drawing the login GUI, validating credentials, and managing the "Shield Window."&lt;/p&gt;
    &lt;p&gt;The Shield Window (Anti-Overlay):&lt;lb/&gt; To prevent "Clickjacking" or "Fake Login Screen" attacks where a malicious application draws a window over the login prompt to capture keystrokes, &lt;code&gt;loginwindow&lt;/code&gt; utilizes a privileged connection to SkyLight (the WindowServer framework).&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Window Level: The login UI is drawn at the &lt;code&gt;kCGShieldingWindowLevel&lt;/code&gt;(or&lt;code&gt;kCGCursorWindowLevel&lt;/code&gt;- 1). This is a Z-order reserved for the system.&lt;/item&gt;
      &lt;item&gt;Event Isolation: When the Shield Window is active, the WindowServer routes all keyboard and mouse events exclusively to &lt;code&gt;loginwindow&lt;/code&gt;, regardless of what other applications might be running in the background.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The State Machine:&lt;lb/&gt; Reverse engineering &lt;code&gt;loginwindow&lt;/code&gt; reveals a complex state machine driven by AppleEvents and Notificiations.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;LoginHook&lt;/code&gt;/&lt;code&gt;LogoutHook&lt;/code&gt;: While officially deprecated, the code paths for these legacy customization scripts still exist, though they are heavily sandboxed.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;TAL&lt;/code&gt;(Transparent App Lifecycle):&lt;code&gt;loginwindow&lt;/code&gt;manages the "Resume" feature (re-opening windows after reboot). This state is persisted in&lt;code&gt;~/Library/Preferences/ByHost/com.apple.loginwindow.*.plist&lt;/code&gt;, protected by the user's Data Protection keys.&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h4"&gt;10.1.3 &lt;code&gt;opendirectoryd&lt;/code&gt;: The Authentication Broker&lt;/head&gt;
    &lt;p&gt;&lt;code&gt;opendirectoryd&lt;/code&gt; is the daemon responsible for answering the question: "Is this password correct?" It is a modular daemon that loads plugins (bundles) to handle different directory services (LDAP, Active Directory, Local).&lt;/p&gt;
    &lt;p&gt;The Local Node (&lt;code&gt;/Local/Default&lt;/code&gt;):&lt;lb/&gt; On a standalone Mac, authentication is handled by the Local Node. The data store for this node is located at &lt;code&gt;/var/db/dslocal/nodes/Default/&lt;/code&gt;.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Users: Stored as individual Property List (&lt;code&gt;.plist&lt;/code&gt;) files in&lt;code&gt;users/&lt;/code&gt;.&lt;/item&gt;
      &lt;item&gt;Shadow Hash: The user's password hash is not stored in the plist. It is stored in a separate, restricted file structure known as the Shadow Hash, often embedded as binary data within the plist but stripped of read permissions for non-root users.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The Shadow Hash Data:&lt;lb/&gt; The &lt;code&gt;ShadowHashData&lt;/code&gt; key in the user's plist contains a binary blob. In the Tahoe era, this blob is not a simple SHA-512 hash. It is a complex structure containing:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;SALTED-SHA512-PBKDF2: A standard hash for legacy compatibility (often disabled or randomized on FileVault-enabled systems).&lt;/item&gt;
      &lt;item&gt;Secure Token Wrapper: The primary authentication secret. This is a blob encrypted by a key derived from the Secure Enclave.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The Verification Flow (&lt;code&gt;ODRecordVerifyPassword&lt;/code&gt;):&lt;lb/&gt; When &lt;code&gt;loginwindow&lt;/code&gt; passes a password to &lt;code&gt;opendirectoryd&lt;/code&gt;:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;&lt;code&gt;od_verify_password&lt;/code&gt;: The request is routed to the Local Node module.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;AppleSEPKeyStore&lt;/code&gt;Interaction:&lt;code&gt;opendirectoryd&lt;/code&gt;cannot verify the Secure Token wrapper itself. It passes the plaintext password and the wrapped blob to the kernel extension&lt;code&gt;AppleSEPKeyStore.kext&lt;/code&gt;.&lt;/item&gt;
      &lt;item&gt;SEP Round Trip: The kernel marshals this request to the Secure Enclave via the Mailbox.&lt;/item&gt;
      &lt;item&gt;Unwrapping: The SEP mixes the hardware UID with the user's password (tangling). It attempts to unwrap the blob.&lt;/item&gt;
      &lt;item&gt;Verdict: If the unwrap succeeds, the SEP returns a success signal (and potentially a derived key for FileVault). If it fails, it returns an authentication error.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;RE Implication:&lt;lb/&gt; This architecture means that offline cracking of macOS password hashes (extracted from &lt;code&gt;dslocal&lt;/code&gt;) is effectively impossible for FileVault-enabled users on Apple Silicon. The hash is not mathematically complete without the hardware UID of the specific SEP that created it.&lt;/p&gt;
    &lt;head rend="h4"&gt;10.1.4 Kerberos and the Local KDC (Heimdal)&lt;/head&gt;
    &lt;p&gt;A little-known fact about modern macOS is that every machine runs a Local Key Distribution Center (LKDC). This is a stripped-down Heimdal Kerberos KDC running within &lt;code&gt;opendirectoryd&lt;/code&gt;.&lt;/p&gt;
    &lt;p&gt;Why Kerberos on a Laptop?&lt;lb/&gt; Apple uses Kerberos to handle "Single Sign-On" between system services without passing the plaintext password around.&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Initial Login: When the user logs in, &lt;code&gt;opendirectoryd&lt;/code&gt;obtains a Ticket Granting Ticket (TGT) from the Local KDC using the user's password.&lt;/item&gt;
      &lt;item&gt;Credential Cache: This TGT is stored in the kernel-managed credential cache (accessible via the CCACHE server).&lt;/item&gt;
      &lt;item&gt;Service Auth: When the user tries to unlock a System Preference pane, use Screen Sharing, or access the Keychain, the system requests a Service Ticket from the Local KDC.&lt;/item&gt;
      &lt;item&gt;Validation: The service verifies the ticket. If valid, access is granted.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The "Smart Card" Enforcement:&lt;lb/&gt; In high-security environments (and increasingly the default in Tahoe), the Local KDC is backed by PKINIT.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;If the user logs in with a Smart Card (or the built-in PIV token backed by the Secure Enclave), the KDC validates the x.509 certificate chain instead of a password hash.&lt;/item&gt;
      &lt;item&gt;The TXM plays a role here by enforcing that the Smart Card driver (running as a &lt;code&gt;dext&lt;/code&gt;) is valid and has not been tampered with, ensuring the certificate presented to the KDC is authentic.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;RE Focus: &lt;code&gt;Heimdal&lt;/code&gt; Framework:&lt;lb/&gt; The &lt;code&gt;Heimdal.framework&lt;/code&gt; in the PrivateFrameworks directory contains the logic for this. Hooking &lt;code&gt;krb5_get_init_creds_password&lt;/code&gt; in &lt;code&gt;loginwindow&lt;/code&gt; is a common technique for Red Teams to intercept plaintext credentials before they are hashed, though this requires bypassing SIP and the hardened runtime.&lt;/p&gt;
    &lt;head rend="h3"&gt;10.2 Biometric Unlock (Touch ID / Face ID / Optic ID)&lt;/head&gt;
    &lt;p&gt;Biometric authentication on Apple platforms is frequently misunderstood as a replacement for the passcode. Architecturally, it is a convenience mechanism that authorizes the Secure Enclave to perform a cryptographic operation (unwrapping a key) that would otherwise require the user's manual secret entry.&lt;/p&gt;
    &lt;p&gt;In the Tahoe architecture, the biometric stack is a high-stakes interplay between userland daemons, kernel drivers, the Secure Enclave, and—in the case of Face ID and Optic ID—the Secure Neural Engine (SNE).&lt;/p&gt;
    &lt;head rend="h4"&gt;10.2.1 The Daemon Hierarchy: &lt;code&gt;coreauthd&lt;/code&gt; $\rightarrow$ &lt;code&gt;biometrickitd&lt;/code&gt; $\rightarrow$ SEP&lt;/head&gt;
    &lt;p&gt;The userland implementation is split into two primary daemons to enforce separation of concerns: &lt;code&gt;coreauthd&lt;/code&gt; (Policy) and &lt;code&gt;biometrickitd&lt;/code&gt; (Mechanism).&lt;/p&gt;
    &lt;p&gt;&lt;code&gt;coreauthd&lt;/code&gt; (The Policy Engine):&lt;lb/&gt; Located at &lt;code&gt;/System/Library/Frameworks/LocalAuthentication.framework/Support/coreauthd&lt;/code&gt;, this daemon manages the Local Authentication (LA) context.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Context Management: When an app calls &lt;code&gt;LAContext.evaluatePolicy&lt;/code&gt;,&lt;code&gt;coreauthd&lt;/code&gt;creates a unique context ID (&lt;code&gt;ACMContext&lt;/code&gt;).&lt;/item&gt;
      &lt;item&gt;ACL Evaluation: It parses the Access Control Lists (ACLs) attached to Keychain items. It determines what is required (e.g., "Biometry OR Passcode").&lt;/item&gt;
      &lt;item&gt;The ACM (Access Control Module): Inside &lt;code&gt;coreauthd&lt;/code&gt;, the ACM is a library that mirrors the logic of the Secure Enclave. It prepares the request structures that will eventually be sent to the SEP.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;&lt;code&gt;biometrickitd&lt;/code&gt; (The Hardware Manager):&lt;lb/&gt; Located at &lt;code&gt;/usr/libexec/biometrickitd&lt;/code&gt;, this daemon is responsible for the physical sensors.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Sensor Abstraction: It loads the specific plugin for the device's hardware (Mesa for Touch ID, Pearl for Face ID, Jade for Optic ID).&lt;/item&gt;
      &lt;item&gt;Hardware State: It manages the power state of the sensor and the emitter (e.g., the Flood Illuminator or IR Projector).&lt;/item&gt;
      &lt;item&gt;Data Relay: Crucially, &lt;code&gt;biometrickitd&lt;/code&gt;does not process biometric data. It acts as a dumb pipe. It sets up a Direct Memory Access (DMA) channel or a shared memory buffer between the sensor hardware and the Secure Enclave.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The Handshake:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;&lt;code&gt;coreauthd&lt;/code&gt;receives a request and validates the PID/ASID.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;coreauthd&lt;/code&gt;sends an XPC request to&lt;code&gt;biometrickitd&lt;/code&gt;to "Arm" the sensor.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;biometrickitd&lt;/code&gt;issues an&lt;code&gt;IOConnectCall&lt;/code&gt;to the kernel driver (&lt;code&gt;AppleBiometricSensor.kext&lt;/code&gt;).&lt;/item&gt;
      &lt;item&gt;The kernel driver wakes the SEP via the Mailbox and prepares the hardware interface.&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h4"&gt;10.2.2 The Hardware Path: Sensor-to-SEP Pairing&lt;/head&gt;
    &lt;p&gt;A critical security property of the biometric stack is the Hardware Pairing between the sensor and the SEP. This prevents "Evil Maid" attacks where an attacker replaces the fingerprint sensor with a malicious FPGA that replays a stored "match" signal.&lt;/p&gt;
    &lt;p&gt;The Factory Pairing:&lt;lb/&gt; During manufacturing, the sensor (e.g., the Touch ID button or the TrueDepth camera module) and the SEP exchange public keys. A shared secret is established and burned into the sensor's controller.&lt;/p&gt;
    &lt;p&gt;The Encrypted Channel:&lt;lb/&gt; When the sensor captures an image (fingerprint ridge map or IR depth map):&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Encryption: The sensor hardware encrypts the raw image data using the shared pairing key before it leaves the sensor module.&lt;/item&gt;
      &lt;item&gt;Transport: The encrypted data travels over the SPI or MIPI bus to the Application Processor.&lt;/item&gt;
      &lt;item&gt;Passthrough: The AP (kernel) writes this encrypted blob into a physical memory buffer shared with the SEP. The AP cannot decrypt this data; it sees only high-entropy noise.&lt;/item&gt;
      &lt;item&gt;Decryption: The SEP reads the buffer, decrypts it using the pairing key, and processes the raw biometric data.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;RE Implication:&lt;lb/&gt; If you hook the &lt;code&gt;AppleBiometricSensor&lt;/code&gt; kext and dump the data buffers, you will not get a fingerprint image. You will get ciphertext. Furthermore, if you replace the sensor with a component from another iPhone (without running the Apple System Configuration tool to re-pair), the SEP will fail to decrypt the data, and biometrics will be disabled.&lt;/p&gt;
    &lt;head rend="h4"&gt;10.2.3 The Secure Neural Engine (SNE) &amp;amp; Optic ID&lt;/head&gt;
    &lt;p&gt;With the advent of Face ID and Optic ID (Vision Pro), the computational cost of biometric matching exceeded the capabilities of the general-purpose SEP core. Apple introduced the Secure Neural Engine (SNE).&lt;/p&gt;
    &lt;p&gt;Architecture:&lt;lb/&gt; The Neural Engine (ANE) on the SoC is partitioned.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Standard Mode: Accessible to userland (CoreML) for standard ML tasks.&lt;/item&gt;
      &lt;item&gt;Secure Mode: A dedicated slice of the ANE is reserved for the SEP.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The Optic ID Flow (Tahoe/Vision Pro):&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Capture: The iris cameras capture spatiotemporally modulated IR images.&lt;/item&gt;
      &lt;item&gt;Transfer: The encrypted images are DMA'd to the SEP's protected memory.&lt;/item&gt;
      &lt;item&gt;SNE Handoff: The SEP sanitizes the ANE (flushing previous weights/data) and loads the Optic ID neural network model.&lt;/item&gt;
      &lt;item&gt;Processing: The SEP feeds the image data into the SNE. The SNE performs the feature extraction (generating the mathematical representation of the iris).&lt;/item&gt;
      &lt;item&gt;Matching: The SNE returns the feature vector to the SEP. The SEP compares this vector against the enrolled templates stored in the Secure Storage Component (xART).&lt;/item&gt;
      &lt;item&gt;Liveness: Simultaneously, the SEP analyzes the "spatiotemporal modulation" (the reaction of the pupil to light pulses) to ensure the subject is a living eye and not a contact lens or high-res display.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Memory Protection:&lt;lb/&gt; On M3/M4 chips, the memory used by the SNE during this process is protected by a dedicated Hardware Security Controller. If the AP attempts to read SNE memory while it is in Secure Mode, the transaction is blocked, and a system panic is triggered.&lt;/p&gt;
    &lt;head rend="h4"&gt;10.2.4 Secure Intent: The GPIO Hardline&lt;/head&gt;
    &lt;p&gt;For high-value transactions (Apple Pay, Smart Card pairing), biometric matching is insufficient. Malware could theoretically trick the user into looking at the phone (Face ID match) to authorize a background payment.&lt;/p&gt;
    &lt;p&gt;To solve this, Apple implements Secure Intent via a physical side-channel.&lt;/p&gt;
    &lt;p&gt;The Physical Button:&lt;lb/&gt; The power button (or side button) is wired to the Always-On Processor (AOP) and the AP, but it also has a dedicated GPIO line connected directly to the Secure Enclave.&lt;/p&gt;
    &lt;p&gt;The Logic:&lt;lb/&gt; When a transaction requires Secure Intent (flagged in the &lt;code&gt;LAContext&lt;/code&gt;):&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;The SEP performs the biometric match.&lt;/item&gt;
      &lt;item&gt;If successful, the SEP holds the authorization. It does not release the token.&lt;/item&gt;
      &lt;item&gt;The SEP monitors its private GPIO pin.&lt;/item&gt;
      &lt;item&gt;The Window: The user must double-click the physical button within a specific time window (usually &amp;lt; 2 seconds) of the biometric match.&lt;/item&gt;
      &lt;item&gt;Release: Only when the SEP detects the electrical signal of the double-click on its private line does it sign the payment token or release the key.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;RE Focus:&lt;lb/&gt; This mechanism renders UI spoofing attacks ineffective for Apple Pay. Even if an attacker controls &lt;code&gt;WindowServer&lt;/code&gt; and draws a fake "Double Click to Pay" overlay, and even if the user looks at the phone (satisfying Face ID), the attacker cannot generate the electrical signal on the SEP's GPIO pin.&lt;/p&gt;
    &lt;head rend="h4"&gt;10.2.5 The &lt;code&gt;LAC&lt;/code&gt; (Local Authentication Context) and Token Binding&lt;/head&gt;
    &lt;p&gt;When authentication succeeds, the SEP does not simply return &lt;code&gt;true&lt;/code&gt;. It returns a cryptographic token.&lt;/p&gt;
    &lt;p&gt;The &lt;code&gt;ACMHandle&lt;/code&gt;:&lt;code&gt;coreauthd&lt;/code&gt; receives an opaque handle from the SEP. This handle refers to a session in the SEP's memory.&lt;/p&gt;
    &lt;p&gt;Token Binding:&lt;lb/&gt; When accessing a Keychain item protected by &lt;code&gt;kSecAccessControlUserPresence&lt;/code&gt;:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;&lt;code&gt;securityd&lt;/code&gt;(Keychain daemon) sends the encrypted keyblob (wrapped key) and the&lt;code&gt;ACMHandle&lt;/code&gt;to the SEP.&lt;/item&gt;
      &lt;item&gt;The SEP verifies the &lt;code&gt;ACMHandle&lt;/code&gt;is valid and associated with a recent biometric match.&lt;/item&gt;
      &lt;item&gt;The SEP uses its internal hardware key to unwrap the keyblob.&lt;/item&gt;
      &lt;item&gt;The SEP returns the raw AES key to &lt;code&gt;securityd&lt;/code&gt;(or performs the crypto operation internally if the key is non-extractable).&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The "Backoff" Strategy:&lt;lb/&gt; The SEP enforces the retry policy in hardware.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Counter: Stored in &lt;code&gt;xART&lt;/code&gt;.&lt;/item&gt;
      &lt;item&gt;Logic: &lt;list rend="ul"&gt;&lt;item&gt;1-2 failures: Retry allowed immediately.&lt;/item&gt;&lt;item&gt;3+ failures: Force delay.&lt;/item&gt;&lt;item&gt;5 failures: Biometrics disabled. Passcode required.&lt;/item&gt;&lt;item&gt;Global Reset: If the device is rebooted, or if 48 hours pass, the SEP invalidates the biometric keys in memory, forcing a passcode entry to re-derive the master keys. This logic is encoded in the &lt;code&gt;sepOS&lt;/code&gt;and cannot be patched by the kernel.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h3"&gt;10.3 Data Protection &amp;amp; FileVault&lt;/head&gt;
    &lt;p&gt;On Intel Macs, FileVault was a distinct full-disk encryption layer (CoreStorage) that operated below the filesystem. On Apple Silicon, this distinction has vanished. FileVault is simply Data Protection applied to the Volume Key.&lt;/p&gt;
    &lt;p&gt;The architecture of macOS Tahoe unifies the security model of iOS and macOS. Every file on the SSD is individually encrypted with a per-file key, wrapped by a class key, protected by the Secure Enclave. "Turning on FileVault" merely changes the protection policy of the Volume Encryption Key (VEK) from "Protected by Hardware UID" to "Protected by User Password."&lt;/p&gt;
    &lt;p&gt;This section dissects the cryptographic hierarchy, the hardware-accelerated AES path that keeps keys out of RAM, and the Sealed Key Protection (SKP) mechanism that binds data availability to the system's boot measurement.&lt;/p&gt;
    &lt;head rend="h4"&gt;10.3.1 Unwrapping the User Keybag: The Class Key Hierarchy&lt;/head&gt;
    &lt;p&gt;The central data structure for Data Protection is the Keybag. It is a binary property list stored on disk (typically in &lt;code&gt;/private/var/db/UserKeyStash&lt;/code&gt; or similar locations depending on the boot volume layout), containing the wrapped class keys.&lt;/p&gt;
    &lt;p&gt;The Hierarchy:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Hardware UID: The root of trust, fused into the SEP. Accessible only to the SEP's AES engine.&lt;/item&gt;
      &lt;item&gt;User Password: The user's login secret.&lt;/item&gt;
      &lt;item&gt;Passcode Derived Key (PDK): The SEP mixes the UID and the User Password using a proprietary KDF (Tangling).&lt;lb/&gt;$$ \text{PDK} = \text{Tangle}(\text{UID}, \text{PBKDF2}(\text{Password}, \text{Salt})) $$&lt;/item&gt;
      &lt;item&gt;Class Keys: The Keybag contains the keys for specific protection classes (A, B, C, D), wrapped by the PDK.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The Classes:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Class A (Complete Protection): Keys are evicted from SEP memory immediately upon device lock.&lt;/item&gt;
      &lt;item&gt;Class B (Protected Unless Open): Keys are evicted on lock, but open file handles retain an ephemeral unwrapped key in the AES engine context to allow background writes to finish.&lt;/item&gt;
      &lt;item&gt;Class C (First Unlock): Keys remain in SEP memory after the first successful authentication until reboot. This is the class used for the FileVault Volume Key.&lt;/item&gt;
      &lt;item&gt;Class D (No Protection): Keys are wrapped only by the UID. They are accessible as long as the device is booted, even without a password. Used for system daemons that must start before login.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The Unwrapping Ceremony:&lt;lb/&gt; When the user logs in:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;&lt;code&gt;loginwindow&lt;/code&gt;passes the password to the kernel (&lt;code&gt;AppleSEPKeyStore&lt;/code&gt;).&lt;/item&gt;
      &lt;item&gt;The kernel passes the password and the Keybag blob to the SEP via Mailbox.&lt;/item&gt;
      &lt;item&gt;The SEP performs the Tangle operation to derive the PDK.&lt;/item&gt;
      &lt;item&gt;The SEP attempts to unwrap the Class Keys in the Keybag using the PDK.&lt;/item&gt;
      &lt;item&gt;Crucially: The unwrapped Class Keys are never returned to the kernel. They remain resident in the SEP's protected SRAM. The SEP returns a "Handle" (Key ID) to the kernel.&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h4"&gt;10.3.2 Sealed Key Protection (SKP): Binding Data to Measurement&lt;/head&gt;
    &lt;p&gt;In the Tahoe architecture, Apple introduced Sealed Key Protection (SKP) to mitigate "Evil Maid" attacks where an attacker boots a malicious operating system (or a vulnerable older version) to brute-force the keybag.&lt;/p&gt;
    &lt;p&gt;SKP binds the availability of the keys to the Measurement of the boot chain.&lt;/p&gt;
    &lt;p&gt;The Measurement Flow:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Boot Monitor: Measures the &lt;code&gt;sepOS&lt;/code&gt;.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;sepOS&lt;/code&gt;: Measures the KernelCache and the LocalPolicy.&lt;/item&gt;
      &lt;item&gt;PCR Extension: These measurements are extended into registers within the SEP (conceptually similar to TPM PCRs).&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The SKP Key:&lt;lb/&gt; When the Volume Encryption Key (VEK) is generated (at install time), it is wrapped not just by the UID/PDK, but by a key derived from the Current System Measurement.&lt;/p&gt;
    &lt;p&gt;$$ \text{WrappedVEK} = \text{Encrypt}(\text{VEK}, \text{KDF}(\text{UID}, \text{PDK}, \text{Measurement})) $$&lt;/p&gt;
    &lt;p&gt;The Security Guarantee:&lt;lb/&gt; If an attacker attempts to boot a custom kernel (Permissive Security) or a downgraded kernel to attack the Data Protection implementation:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;The Boot Monitor/&lt;code&gt;sepOS&lt;/code&gt;calculates a different measurement hash.&lt;/item&gt;
      &lt;item&gt;The KDF derives a different wrapping key.&lt;/item&gt;
      &lt;item&gt;The SEP fails to unwrap the VEK.&lt;/item&gt;
      &lt;item&gt;The Data Volume remains inaccessible.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;This forces the attacker to possess the user's credentials and boot a signed, measured, and authorized operating system to access the data.&lt;/p&gt;
    &lt;head rend="h4"&gt;10.3.3 The Hardware AES Engine &amp;amp; The "Wrapped Key" Path&lt;/head&gt;
    &lt;p&gt;A common misconception is that the kernel decrypts file data. In reality, the XNU kernel never sees the raw AES keys for file contents. Apple Silicon utilizes a dedicated AES DMA Engine that sits between the Memory Controller and the Storage Controller (ANS2).&lt;/p&gt;
    &lt;p&gt;The Inline Encryption Path:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;File I/O: When a user process reads a file, the kernel looks up the file's metadata to find the Per-File Key (wrapped by a Class Key).&lt;/item&gt;
      &lt;item&gt;The Request: The kernel sends the Wrapped Per-File Key and the Class Key Handle to the SEP.&lt;/item&gt;
      &lt;item&gt;SEP Translation: The SEP unwraps the Per-File Key using the resident Class Key.&lt;/item&gt;
      &lt;item&gt;The Side Channel: The SEP does not return the raw key to the kernel. Instead, it programs the AES Engine's key registers directly via a dedicated hardware bus (or re-wraps the key with an ephemeral key known only to the AES Engine).&lt;/item&gt;
      &lt;item&gt;DMA: The kernel initiates the DMA transfer from NAND.&lt;/item&gt;
      &lt;item&gt;Decryption: The AES Engine decrypts the data on-the-fly as it flows into DRAM. The data lands in the page cache as plaintext, but the key that decrypted it effectively vanishes.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;RE Implication:&lt;lb/&gt; Memory forensics on a running macOS kernel cannot recover the file encryption keys. They simply do not exist in kernel memory. To recover the keys, one must compromise the SEP firmware and dump its SRAM.&lt;/p&gt;
    &lt;head rend="h4"&gt;10.3.4 RE Focus: Analyzing the &lt;code&gt;AppleSEPKeyStore&lt;/code&gt; Kernel Extension&lt;/head&gt;
    &lt;p&gt;The interface between the kernel and the SEP's key management logic is the &lt;code&gt;AppleSEPKeyStore&lt;/code&gt; kext. This binary is a prime target for understanding the proprietary IPC protocol.&lt;/p&gt;
    &lt;p&gt;Key Symbols:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;aks_unwrap_key&lt;/code&gt;: The primary function for unwrapping a keybag element.&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;aks_get_lock_state&lt;/code&gt;: Queries the SEP for the current lock state (Locked/Unlocked).&lt;/item&gt;
      &lt;item&gt;&lt;code&gt;sep_key_store_client_handle_message&lt;/code&gt;: The demuxer for messages received from the SEP.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The Attack Surface:&lt;lb/&gt; The communication protocol involves complex Type-Length-Value (TLV) structures.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Handle Confusion: The kernel refers to keys by 32-bit integer handles. A potential vulnerability class involves guessing or forging a handle to trick the SEP into using a key belonging to a different security domain (e.g., using a System Key to unwrap User Data).&lt;/item&gt;
      &lt;item&gt;Race Conditions: The &lt;code&gt;AppleSEPKeyStore&lt;/code&gt;maintains a shadow state of the lock status. Discrepancies between the kernel's view of the lock state and the SEP's actual state can lead to logic bugs where the kernel allows an operation that the SEP should have blocked, or vice versa.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Tahoe Hardening:&lt;lb/&gt; In Tahoe, &lt;code&gt;AppleSEPKeyStore&lt;/code&gt; operations are increasingly gated by the TXM. Critical key operations (like enabling FileVault or changing the recovery key) require a &lt;code&gt;GENTER&lt;/code&gt; transition to GL1 to verify the policy before the request is forwarded to the SEP, adding an additional layer of authorization check that cannot be bypassed by kernel patching.&lt;/p&gt;
    &lt;head rend="h2"&gt;11.0 Conclusion: The Attack Surface Landscape&lt;/head&gt;
    &lt;p&gt;The architectural transformation introduced with macOS Tahoe and the M3/M4 silicon generation signifies the end of the "Kernel is King" era. We have moved from a monolithic trust model, where &lt;code&gt;uid=0&lt;/code&gt; and &lt;code&gt;tfp0&lt;/code&gt; were the ultimate objectives, to a federated security model where the kernel is merely a highly privileged, yet strictly supervised, tenant within a hardware-enforced hypervisor.&lt;/p&gt;
    &lt;p&gt;For the vulnerability researcher, this necessitates a shift in methodology. Fuzzing syscalls is no longer sufficient to compromise the system's root of trust. The new frontier lies in the Boundary Crossings—the specific, hardware-mediated bridges that allow data and execution flow to traverse the isolated domains.&lt;/p&gt;
    &lt;head rend="h3"&gt;11.1 Summary of Boundary Crossings&lt;/head&gt;
    &lt;p&gt;The following matrix details the architectural boundaries, the mechanisms used to traverse them, and the specific attack surface exposed at each junction.&lt;/p&gt;
    &lt;head rend="h4"&gt;11.1.1 Userland (EL0) $\leftrightarrow$ Kernel (EL1)&lt;/head&gt;
    &lt;p&gt;The Traditional Boundary, Hardened by Silicon.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Transition Mechanism: &lt;list rend="ul"&gt;&lt;item&gt;Entry: &lt;code&gt;SVC&lt;/code&gt;(Supervisor Call) instruction triggering a synchronous exception to&lt;code&gt;VBAR_EL1 + 0x400&lt;/code&gt;.&lt;/item&gt;&lt;item&gt;Exit: &lt;code&gt;ERET&lt;/code&gt;(Exception Return) restoring&lt;code&gt;PC&lt;/code&gt;and&lt;code&gt;PSTATE&lt;/code&gt;from&lt;code&gt;ELR_EL1&lt;/code&gt;and&lt;code&gt;SPSR_EL1&lt;/code&gt;.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;Entry: &lt;/item&gt;
      &lt;item&gt;Hardware Enforcement: &lt;list rend="ul"&gt;&lt;item&gt;PAC: Entry points are signed. The kernel verifies the thread state signature (&lt;code&gt;kauth_thread_state&lt;/code&gt;) on return.&lt;/item&gt;&lt;item&gt;PPL/SPTM: The kernel cannot modify its own text or page tables to disable SMEP/SMAP equivalents (&lt;code&gt;PAN&lt;/code&gt;/&lt;code&gt;PXN&lt;/code&gt;).&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;PAC: Entry points are signed. The kernel verifies the thread state signature (&lt;/item&gt;
      &lt;item&gt;The Tahoe Shift: &lt;list rend="ul"&gt;&lt;item&gt;The kernel is no longer the final arbiter of virtual memory. When a user process requests &lt;code&gt;mmap(RWX)&lt;/code&gt;, the kernel cannot simply write to the translation table. It must request the SPTM to map the page.&lt;/item&gt;&lt;item&gt;Attack Surface: &lt;list rend="ul"&gt;&lt;item&gt;Logic Bugs: Standard memory corruption (UAF, Heap Overflow) in kernel extensions still yields EL1 execution.&lt;/item&gt;&lt;item&gt;PAC Bypasses: Forging pointers to survive the &lt;code&gt;ERET&lt;/code&gt;or function pointer authentication.&lt;/item&gt;&lt;item&gt;Argument Sanitization: The kernel must sanitize user pointers before passing them to the SPTM. A "Confused Deputy" attack where the kernel is tricked into asking the SPTM to map a privileged page into user space is the new &lt;code&gt;tfp0&lt;/code&gt;.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;The kernel is no longer the final arbiter of virtual memory. When a user process requests &lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h4"&gt;11.1.2 Kernel (EL1) $\leftrightarrow$ Secure Page Table Monitor (GL2)&lt;/head&gt;
    &lt;p&gt;The "Mechanism" Boundary: The New Hypervisor.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Transition Mechanism: &lt;list rend="ul"&gt;&lt;item&gt;Entry: &lt;code&gt;GENTER&lt;/code&gt;(Opcode&lt;code&gt;0x00201420&lt;/code&gt;) with Selector ID in&lt;code&gt;x15&lt;/code&gt;.&lt;/item&gt;&lt;item&gt;Exit: &lt;code&gt;GEXIT&lt;/code&gt;(Opcode&lt;code&gt;0x00201400&lt;/code&gt;).&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;Entry: &lt;/item&gt;
      &lt;item&gt;Hardware Enforcement: &lt;list rend="ul"&gt;&lt;item&gt;GXF: Hardware context switch of &lt;code&gt;SP_EL1&lt;/code&gt;$\rightarrow$&lt;code&gt;SP_GL2&lt;/code&gt;.&lt;/item&gt;&lt;item&gt;SPRR: Atomic switch of permission views. Kernel text becomes RO/NX; SPTM text becomes RX.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;GXF: Hardware context switch of &lt;/item&gt;
      &lt;item&gt;Data Exchange: &lt;list rend="ul"&gt;&lt;item&gt;Registers: &lt;code&gt;x0&lt;/code&gt;-&lt;code&gt;x7&lt;/code&gt;carry physical addresses (PPNs) and permission bitmaps.&lt;/item&gt;&lt;item&gt;Shared Memory: None. The SPTM reads physical memory directly via its own linear map.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;Registers: &lt;/item&gt;
      &lt;item&gt;Attack Surface: &lt;list rend="ul"&gt;&lt;item&gt;State Machine Confusion: The SPTM enforces a Finite State Machine (FSM) on every physical page (Frame Table). The primary attack vector is finding a sequence of &lt;code&gt;retype&lt;/code&gt;/&lt;code&gt;map&lt;/code&gt;/&lt;code&gt;unmap&lt;/code&gt;calls that desynchronizes the SPTM's view of a page from the hardware's actual state (e.g., aliasing a&lt;code&gt;PAGE_TABLE&lt;/code&gt;as&lt;code&gt;XNU_DATA&lt;/code&gt;).&lt;/item&gt;&lt;item&gt;Input Validation: Passing invalid physical addresses or edge-case permission combinations to &lt;code&gt;sptm_map&lt;/code&gt;.&lt;/item&gt;&lt;item&gt;Panic-as-Oracle: Since SPTM panics on failure, timing side-channels or fault injection during the &lt;code&gt;GENTER&lt;/code&gt;window are potential vectors to infer the memory layout of GL2.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;State Machine Confusion: The SPTM enforces a Finite State Machine (FSM) on every physical page (Frame Table). The primary attack vector is finding a sequence of &lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h4"&gt;11.1.3 Kernel (EL1) $\leftrightarrow$ Trusted Execution Monitor (GL1)&lt;/head&gt;
    &lt;p&gt;The "Policy" Boundary: The Signature Oracle.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Transition Mechanism: &lt;list rend="ul"&gt;&lt;item&gt;Entry: &lt;code&gt;GENTER&lt;/code&gt;(Targeting the TXM Dispatch Table).&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;Entry: &lt;/item&gt;
      &lt;item&gt;Hardware Enforcement: &lt;list rend="ul"&gt;&lt;item&gt;SPRR: TXM memory is visible only in GL1 context.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;Data Exchange: &lt;list rend="ul"&gt;&lt;item&gt;Physical Pointers: The kernel passes the physical address of a Code Directory or CMS blob.&lt;/item&gt;&lt;item&gt;Trust Cache: The kernel requests updates to the Dynamic Trust Cache.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;Attack Surface: &lt;list rend="ul"&gt;&lt;item&gt;Parsing Complexity: The TXM must parse complex, legacy formats (ASN.1, CMS, Mach-O headers) to verify signatures. This parsing happens in the highest privilege level. A buffer overflow in the TXM's ASN.1 parser is a "God Mode" exploit.&lt;/item&gt;&lt;item&gt;TOCTOU: The kernel loads the signature into memory, passes the physical address to TXM, and then TXM verifies it. If the kernel (or a DMA device) can modify that memory during the TXM's verification window, the signature check can be bypassed.&lt;/item&gt;&lt;item&gt;Logic Downgrades: Tricking the TXM into believing the device is in "Developer Mode" or "Permissive Mode" via corrupted NVRAM or LocalPolicy parsing.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h4"&gt;11.1.4 Kernel (EL1) $\leftrightarrow$ Secure Enclave (SEP)&lt;/head&gt;
    &lt;p&gt;The "Air Gap" Boundary: The Parallel Computer.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Transition Mechanism: &lt;list rend="ul"&gt;&lt;item&gt;Asynchronous IPC: Mailbox Registers (Doorbell) + Shared Memory Buffers (DART-mapped).&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;Hardware Enforcement: &lt;list rend="ul"&gt;&lt;item&gt;Physical Isolation: Distinct CPU core, distinct MMU.&lt;/item&gt;&lt;item&gt;Memory Protection Engine: SEP memory is encrypted/authenticated inline.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;Data Exchange: &lt;list rend="ul"&gt;&lt;item&gt;Serialized Messages: L4 IPC format (Endpoints, TLV payloads).&lt;/item&gt;&lt;item&gt;Wrapped Keys: Keys are passed as opaque blobs; raw key material never crosses this boundary.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;Attack Surface: &lt;list rend="ul"&gt;&lt;item&gt;Message Parsing: Fuzzing the &lt;code&gt;sepOS&lt;/code&gt;endpoint handlers (e.g.,&lt;code&gt;biometrickitd&lt;/code&gt;,&lt;code&gt;securekeyvault&lt;/code&gt;).&lt;/item&gt;&lt;item&gt;Shared Memory Races: Modifying the contents of a DART-mapped buffer after the SEP has validated the header but before it processes the payload.&lt;/item&gt;&lt;item&gt;Anti-Replay Logic: Attempting to rollback the &lt;code&gt;xART&lt;/code&gt;storage state to force the SEP to reuse old nonces or counters.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;Message Parsing: Fuzzing the &lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h4"&gt;11.1.5 Kernel (EL1) $\leftrightarrow$ Exclaves (Secure Domain)&lt;/head&gt;
    &lt;p&gt;The "Microkernel" Boundary: The RingGate.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Transition Mechanism: &lt;list rend="ul"&gt;&lt;item&gt;RingGate: &lt;code&gt;XNUProxy&lt;/code&gt;kext marshals data $\rightarrow$&lt;code&gt;GENTER&lt;/code&gt;(to Secure Kernel) $\rightarrow$ IPC to Conclave.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;RingGate: &lt;/item&gt;
      &lt;item&gt;Hardware Enforcement: &lt;list rend="ul"&gt;&lt;item&gt;SPTM: Enforces physical memory isolation between &lt;code&gt;XNU_DOMAIN&lt;/code&gt;and&lt;code&gt;SK_DOMAIN&lt;/code&gt;.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;SPTM: Enforces physical memory isolation between &lt;/item&gt;
      &lt;item&gt;Data Exchange: &lt;list rend="ul"&gt;&lt;item&gt;Tightbeam: A strongly-typed IDL serialization format.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;Attack Surface: &lt;list rend="ul"&gt;&lt;item&gt;Proxy Confusion: Exploiting &lt;code&gt;XNUProxy&lt;/code&gt;to route messages to the wrong Conclave.&lt;/item&gt;&lt;item&gt;IDL Deserialization: Bugs in the Tightbeam generated code within the Exclave.&lt;/item&gt;&lt;item&gt;Resource Exhaustion: Flooding the Secure Kernel with Downcalls to starve secure workloads (DoS).&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;Proxy Confusion: Exploiting &lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h3"&gt;11.2 The "Intel Gap": Security Disparities between x86 and Apple Silicon&lt;/head&gt;
    &lt;p&gt;While macOS Tahoe presents a unified user experience across architectures, the underlying security reality is a tale of two operating systems. On Apple Silicon, macOS is a hypervisor-managed, hardware-attested fortress. On Intel (x86_64), it remains a traditional monolithic kernel relying on legacy protection mechanisms. This divergence has created a massive "Intel Gap"—a disparity in exploit mitigation so severe that the same vulnerability often yields a trivial root shell on Intel while resulting in a harmless panic on Apple Silicon.&lt;/p&gt;
    &lt;p&gt;For the reverse engineer, understanding this gap is essential for targeting. The Intel architecture represents the "Soft Target," lacking the silicon-enforced boundaries of the SPTM, TXM, and PAC.&lt;/p&gt;
    &lt;head rend="h4"&gt;11.2.1 The Absence of Lateral Privilege (Ring 0 is King)&lt;/head&gt;
    &lt;p&gt;The most profound difference lies in the privilege hierarchy.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Apple Silicon: As detailed in Section 4.0, the kernel (EL1) is deprivileged. It is subservient to the SPTM (GL2) and TXM (GL1). Achieving arbitrary kernel read/write (KRW) is merely the first step in a long chain of exploitation. The attacker must still bypass the hardware-enforced page table protection and code signing logic.&lt;/item&gt;
      &lt;item&gt;Intel x86: The kernel runs in Ring 0 (Supervisor Mode). There is no "Ring -1" hypervisor enforcing integrity on the host macOS kernel. Apple never implemented a Windows VBS/HVCI-equivalent on Intel Macs. &lt;list rend="ul"&gt;&lt;item&gt;Consequence: On Intel, KRW is Game Over. If an attacker can write to kernel memory, they can disable SIP, unhook the Sandbox, patch &lt;code&gt;amfid&lt;/code&gt;, and overwrite page tables directly. There is no hardware entity above Ring 0 to say "No."&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;Consequence: On Intel, KRW is Game Over. If an attacker can write to kernel memory, they can disable SIP, unhook the Sandbox, patch &lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h4"&gt;11.2.2 Static vs. Dynamic Kernel Integrity (KTRR vs. SPTM)&lt;/head&gt;
    &lt;p&gt;Both architectures attempt to enforce Kernel Text Read-Only Region (KTRR), but the implementation differs fundamentally in flexibility and robustness.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Intel (Hardware KTRR): On recent Intel Macs, KTRR is implemented via proprietary memory controller registers (configured via &lt;code&gt;MSR&lt;/code&gt;).&lt;list rend="ul"&gt;&lt;item&gt;Mechanism: The firmware locks a physical range of memory as Read-Only/Executable.&lt;/item&gt;&lt;item&gt;Limitation: This is Static. Once the range is locked at boot, it cannot change. This forces the kernel to fit all immutable code into a contiguous block. It cannot protect dynamically loaded drivers (KEXTs) with the same hardware rigor. KEXTs rely on software-managed page tables (&lt;code&gt;CR0.WP&lt;/code&gt;bit), which a compromised kernel can disable.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;Apple Silicon (SPTM): &lt;list rend="ul"&gt;&lt;item&gt;Mechanism: The SPTM manages the Frame Table.&lt;/item&gt;&lt;item&gt;Advantage: This is Dynamic. The kernel can load a new extension (AKC), link it, and then ask the SPTM to "Seal" it. The SPTM transitions those specific pages to &lt;code&gt;XNU_TEXT&lt;/code&gt;. This allows the "Immutable Kernel" coverage to extend to late-loaded drivers, a feat impossible on the static Intel KTRR implementation.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h4"&gt;11.2.3 The CFI Chasm: PAC vs. CET&lt;/head&gt;
    &lt;p&gt;Control Flow Integrity (CFI) is the primary defense against ROP/JOP.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Apple Silicon: Pointer Authentication (PAC) is ubiquitous. It protects return addresses (stack), function pointers (heap/data), and C++ vtables. It provides cryptographic diversity based on pointer context.&lt;/item&gt;
      &lt;item&gt;Intel x86: Intel Macs support Control-flow Enforcement Technology (CET), specifically Shadow Stacks (&lt;code&gt;IBT&lt;/code&gt;support is limited).&lt;list rend="ul"&gt;&lt;item&gt;The Gap: CET Shadow Stacks protect return addresses effectively, but they do not protect Forward-Edge transfers (function pointers) with the same granularity as PAC.&lt;/item&gt;&lt;item&gt;Data Pointers: Crucially, Intel has no equivalent to &lt;code&gt;APDAKey&lt;/code&gt;(Data Key). An attacker on Intel can still perform Data-Oriented Programming (DOP)—swapping valid object pointers or corrupting decision-making flags—without triggering a hardware fault. On Apple Silicon, these pointers are signed; forging them requires a signing gadget.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h4"&gt;11.2.4 The Root of Trust: T2 vs. On-Die Boot ROM&lt;/head&gt;
    &lt;p&gt;The boot chain trust anchor differs physically.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Intel: The Root of Trust is the Apple T2 Security Chip (on models 2018-2020). &lt;list rend="ul"&gt;&lt;item&gt;The Weakness: The T2 is a discrete bridge. It verifies the &lt;code&gt;boot.efi&lt;/code&gt;and kernelcache signature before the Intel CPU starts. However, once the Intel CPU is executing, the T2 is effectively a peripheral connected via USB/PCIe. It cannot introspect the Intel CPU's execution state. It cannot stop a runtime kernel exploit.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;The Weakness: The T2 is a discrete bridge. It verifies the &lt;/item&gt;
      &lt;item&gt;Apple Silicon: The Root of Trust is the AP Boot ROM. &lt;list rend="ul"&gt;&lt;item&gt;The Strength: The security logic (SEP, PKA, Boot Monitor) is on the same die. The Secure Enclave can monitor the power and clock lines of the AP. The SPTM (running on the AP) enforces the boot measurements continuously. The trust chain is not "handed off"; it is maintained throughout the runtime lifecycle.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h4"&gt;11.2.5 I/O Security: VT-d vs. DART&lt;/head&gt;
    &lt;p&gt;DMA attacks are a classic method to bypass CPU memory protections.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Intel: Uses VT-d (Intel Virtualization Technology for Directed I/O). &lt;list rend="ul"&gt;&lt;item&gt;Configuration: The kernel configures the IOMMU tables.&lt;/item&gt;&lt;item&gt;Vulnerability: If the kernel is compromised, it can reconfigure VT-d to allow a malicious Thunderbolt device to overwrite kernel memory (unless strict "DMA Protection" is enabled and locked, which relies on the kernel's integrity).&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;Apple Silicon: Uses DART (Device Address Resolution Table). &lt;list rend="ul"&gt;&lt;item&gt;Enforcement: As detailed in Section 7.2.2, the kernel cannot write to DART registers. Only the SPTM can map I/O memory.&lt;/item&gt;&lt;item&gt;Result: Even a compromised kernel cannot weaponize a peripheral to perform a DMA attack against the monitor or the kernel text, because the SPTM will reject the mapping request.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h4"&gt;11.2.6 Summary Table: The Security Disparity&lt;/head&gt;
    &lt;table&gt;
      &lt;row span="3"&gt;
        &lt;cell role="head"&gt;Feature&lt;/cell&gt;
        &lt;cell role="head"&gt;Intel Mac (x86_64)&lt;/cell&gt;
        &lt;cell role="head"&gt;Apple Silicon (arm64e)&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;Highest Privilege&lt;/cell&gt;
        &lt;cell&gt;Ring 0 (Kernel)&lt;/cell&gt;
        &lt;cell&gt;GL2 (SPTM)&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;Page Table Protection&lt;/cell&gt;
        &lt;cell&gt;Software (&lt;code&gt;CR0.WP&lt;/code&gt;)&lt;/cell&gt;
        &lt;cell&gt;Hardware (SPRR + SPTM)&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;Kernel Integrity&lt;/cell&gt;
        &lt;cell&gt;Static KTRR (Boot only)&lt;/cell&gt;
        &lt;cell&gt;Dynamic KIP (Runtime Sealing)&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;CFI&lt;/cell&gt;
        &lt;cell&gt;CET (Shadow Stack)&lt;/cell&gt;
        &lt;cell&gt;PAC (Cryptographic Signatures)&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;Vtable Protection&lt;/cell&gt;
        &lt;cell&gt;None (Plaintext Pointers)&lt;/cell&gt;
        &lt;cell&gt;Signed Pointers (&lt;code&gt;APDAKey&lt;/code&gt;)&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;Code Signing&lt;/cell&gt;
        &lt;cell&gt;Kernel-enforced (&lt;code&gt;AMFI.kext&lt;/code&gt;)&lt;/cell&gt;
        &lt;cell&gt;Monitor-enforced (TXM)&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;DMA Protection&lt;/cell&gt;
        &lt;cell&gt;Kernel-managed VT-d&lt;/cell&gt;
        &lt;cell&gt;Monitor-managed DART&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row span="3"&gt;
        &lt;cell&gt;Secure Enclave&lt;/cell&gt;
        &lt;cell&gt;Discrete (T2 Chip)&lt;/cell&gt;
        &lt;cell&gt;Integrated (On-Die)&lt;/cell&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;cell&gt;Exploit Consequence&lt;/cell&gt;
        &lt;cell&gt;Persistent Rootkit Possible&lt;/cell&gt;
        &lt;cell&gt;System Panic / Non-Persistence&lt;/cell&gt;
      &lt;/row&gt;
    &lt;/table&gt;
    &lt;p&gt;Conclusion for the Researcher:&lt;lb/&gt; The "Intel Gap" means that legacy Intel Macs are essentially running a different, far more vulnerable operating system, despite sharing the macOS version number. Exploits that require complex, multi-stage chains on M3 (e.g., bypassing PAC, confusing SPTM, racing TXM) can often be reduced to a single Use-After-Free and a ROP chain on Intel. As Apple phases out Intel support, the "easy mode" of macOS exploitation is rapidly vanishing.&lt;/p&gt;
    &lt;head rend="h3"&gt;11.3 Future Trends: The expansion of Exclaves and the death of Kernel Extensions&lt;/head&gt;
    &lt;p&gt;The trajectory of macOS security architecture is not asymptotic; it is directional. Apple is not merely patching vulnerabilities in XNU; they are actively architecting its obsolescence as a security boundary. The "Tahoe" architecture provides the silicon primitives (SPTM, TXM, GL2) required to execute a long-term strategy of Architectural Attrition.&lt;/p&gt;
    &lt;p&gt;The future of macOS exploitation lies in understanding two concurrent trends: the ossification of the XNU kernel into a static, immutable appliance, and the migration of high-value logic into the opaque, hardware-isolated world of Exclaves.&lt;/p&gt;
    &lt;head rend="h4"&gt;11.3.1 The Deprecation of &lt;code&gt;kmod_load&lt;/code&gt;: The Static Kernel&lt;/head&gt;
    &lt;p&gt;For decades, the ability to load Kernel Extensions (KEXTs) was a defining feature of macOS. It was also its Achilles' heel. KEXTs run at EL1, share the kernel's address space, and historically lacked the rigorous code review applied to the core kernel.&lt;/p&gt;
    &lt;p&gt;The mechanism for this—the &lt;code&gt;kmod_load&lt;/code&gt; syscall (and the associated &lt;code&gt;kmod_control&lt;/code&gt; traps)—represents a massive attack surface. It requires the kernel to possess a runtime linker (&lt;code&gt;kld&lt;/code&gt;), capable of resolving symbols, applying relocations, and modifying executable memory.&lt;/p&gt;
    &lt;p&gt;The DriverKit End-Game:&lt;lb/&gt; Apple has systematically introduced userland replacements for kernel drivers: &lt;code&gt;USBDriverKit&lt;/code&gt;, &lt;code&gt;HIDDriverKit&lt;/code&gt;, &lt;code&gt;AudioDriverKit&lt;/code&gt;, and &lt;code&gt;NetworkingDriverKit&lt;/code&gt;.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Current State: In Tahoe, third-party KEXTs are deprecated. The userland tool &lt;code&gt;kmutil&lt;/code&gt;manages the policy, but the actual loading still relies on the kernel's ability to link code. Loading a legacy KEXT now requires reducing system security (disabling SIP/Secure Boot) and interacting with the TXM via LocalPolicy to explicitly authorize the hash.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Future State: The Death of the Runtime Linker:&lt;lb/&gt; We are approaching a point where the kernel will effectively lose the ability to load dynamic code entirely in "Full Security" mode. The goal is to remove the &lt;code&gt;kmod_load&lt;/code&gt; logic from the kernel entirely.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;The "Sealed" Kernel: The Boot Kernel Collection (BKC) (loaded by iBoot) and the Auxiliary Kernel Collection (AKC) (loaded early by &lt;code&gt;kernelmanagerd&lt;/code&gt;) will be the only permitted executable kernel code.&lt;/item&gt;
      &lt;item&gt;Pre-Linked Immutability: By moving all linking to build-time (kernelcache generation) or boot-time (iBoot verification), Apple can strip the dynamic linker logic (&lt;code&gt;kld&lt;/code&gt;) from the runtime kernel. If the kernel doesn't know how to link a Mach-O, it cannot load a rootkit.&lt;/item&gt;
      &lt;item&gt;SPTM Enforcement: The SPTM already enforces that &lt;code&gt;XNU_TEXT&lt;/code&gt;is immutable. The logical next step is for the SPTM to reject any&lt;code&gt;sptm_retype&lt;/code&gt;request that attempts to create new&lt;code&gt;XNU_TEXT&lt;/code&gt;pages after the initial boot sealing phase is complete.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;RE Implication:&lt;lb/&gt; The era of the "Rootkit" is ending. If you cannot introduce new code into EL1 via &lt;code&gt;kmod_load&lt;/code&gt;, and you cannot modify existing code due to KTRR/SPTM, persistence in the kernel becomes impossible. Attackers will be forced to live entirely within data-only attacks (DOP) or move their persistence to userland (which is easier to detect) or firmware (which is harder to achieve).&lt;/p&gt;
    &lt;head rend="h4"&gt;11.3.2 Exclave Expansion: Eating the Monolith&lt;/head&gt;
    &lt;p&gt;If XNU is the "Insecure World," Exclaves are the "Secure World." Currently, Exclaves are used for high-sensitivity, low-complexity tasks (Privacy Indicators, Passkeys). However, the architecture is designed to scale. Apple is effectively strangling the monolithic kernel by slowly migrating critical subsystems out of EL1 and into Exclaves.&lt;/p&gt;
    &lt;p&gt;Candidates for Migration:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;The Network Stack (&lt;code&gt;skywalk&lt;/code&gt;):&lt;lb/&gt;Apple has already introduced&lt;code&gt;skywalk&lt;/code&gt;, a userland networking subsystem. The logical evolution is to move the TCP/IP stack and packet filtering logic into an Exclave.&lt;list rend="ul"&gt;&lt;item&gt;Benefit: A remote code execution vulnerability in the Wi-Fi firmware or the TCP stack would compromise an isolated Exclave, not the entire kernel. The SPTM would prevent the compromised network stack from touching system memory.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;Filesystem Encryption (APFS):&lt;lb/&gt;Currently,&lt;code&gt;AppleSEPKeyStore&lt;/code&gt;handles key wrapping, but the bulk encryption happens via the AES Engine managed by the kernel. Moving the filesystem driver's cryptographic logic to an Exclave would ensure that even a kernel compromise cannot exfiltrate file keys, as the keys would exist only within the Exclave's memory domain.&lt;/item&gt;
      &lt;item&gt;Audio and Media Processing:&lt;lb/&gt;To protect DRM content and prevent microphone eavesdropping, the entire CoreAudio engine could be moved to a "Media Conclave."&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The "Dark Matter" OS:&lt;lb/&gt; As more logic moves to Exclaves, a significant portion of the OS execution flow becomes invisible to standard introspection tools.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;No DTrace: You cannot DTrace an Exclave.&lt;/item&gt;
      &lt;item&gt;No kdebug: Kernel tracing will show a "black hole" where the request enters &lt;code&gt;XNUProxy&lt;/code&gt;and vanishes until the result returns.&lt;/item&gt;
      &lt;item&gt;Opaque State: The memory of an Exclave is physically unmappable by the kernel. A kernel memory dump (coredump) will contain gaps where the Exclave memory resides.&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h4"&gt;11.3.3 The "Hollow Kernel" Hypothesis&lt;/head&gt;
    &lt;p&gt;Extrapolating these trends leads to the Hollow Kernel Hypothesis.&lt;/p&gt;
    &lt;p&gt;In this future architecture, XNU (EL1) is demoted to a Compatibility Shim. Its primary role is to:&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Provide POSIX system call semantics for legacy userland applications.&lt;/item&gt;
      &lt;item&gt;Manage coarse-grained scheduling of CPU resources.&lt;/item&gt;
      &lt;item&gt;Act as a message bus (via &lt;code&gt;XNUProxy&lt;/code&gt;) between userland applications and the real system logic running in Exclaves.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;The Security Inversion:&lt;lb/&gt; In the traditional model, the Kernel protects the User. In the Hollow Kernel model, the Hardware (SPTM/TXM) protects the System from the Kernel.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;The kernel is treated as untrusted code.&lt;/item&gt;
      &lt;item&gt;The TCB (Trusted Computing Base) shrinks from "The entire Kernel" to "The SPTM, TXM, and specific Exclaves."&lt;/item&gt;
      &lt;item&gt;A kernel compromise becomes a "Local DoS" or "Privacy Violation" rather than a "System Compromise."&lt;/item&gt;
    &lt;/list&gt;
    &lt;head rend="h4"&gt;11.3.4 The Visibility Gap: The End of Passive Analysis&lt;/head&gt;
    &lt;p&gt;For the reverse engineer, this shift is catastrophic for visibility.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Tightbeam IDL: The interface between XNU and Exclaves is defined by Tightbeam. Unlike MIG, which was relatively static, Tightbeam protocols can evolve rapidly. Reverse engineering the system will require constantly reconstructing these serialization formats.&lt;/item&gt;
      &lt;item&gt;The "Intel Gap" Closure: As Apple phases out Intel support completely, they will likely remove the legacy code paths in XNU that supported the "un-isolated" model. This will make the kernel source code (if still released) increasingly divergent from the binary reality running on M-series chips.&lt;/item&gt;
      &lt;item&gt;Hardware-Locked Debugging: Debugging an Exclave likely requires "Red" (Development) fused silicon. Researchers working on retail "Green" (Production) hardware will be effectively locked out of analyzing the internal logic of these secure subsystems, forced to treat them as black boxes and fuzz their inputs via &lt;code&gt;XNUProxy&lt;/code&gt;.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Final Thought:&lt;lb/&gt; macOS is no longer just a Unix system. It is a distributed system running on a single die, governed by a hypervisor that doesn't exist in software. The kernel is dead; long live the Monitor.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=46018158</guid><pubDate>Sat, 22 Nov 2025 20:54:02 +0000</pubDate></item><item><title>Show HN: Build the habit of writing meaningful commit messages</title><link>https://github.com/arpxspace/smartcommit</link><description>&lt;doc fingerprint="f45415cfb8b2bbdb"&gt;
  &lt;main&gt;
    &lt;p&gt;smartcommit is an intelligent, AI-powered CLI tool that helps you write semantic, Conventional Commits messages effortlessly. It analyzes your staged changes, asks clarifying questions to understand the "why" behind your code, and generates a structured commit message for you.&lt;/p&gt;
    &lt;p&gt;Future you will thank you for deciding to use &lt;code&gt;smartcommit&lt;/code&gt;!&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;AI-Powered Analysis: Automatically analyzes your staged &lt;code&gt;git diff&lt;/code&gt;to understand what changed.&lt;/item&gt;
      &lt;item&gt;Interactive Q&amp;amp;A: Asks you specific, relevant questions to gather context that isn't obvious from the code alone (the "why" and "intent").&lt;/item&gt;
      &lt;item&gt;Multi-Provider Support: &lt;list rend="ul"&gt;&lt;item&gt;OpenAI (GPT-4o): For top-tier accuracy and performance.&lt;/item&gt;&lt;item&gt;Ollama (Llama 3.1): Run locally and privately for free.&lt;/item&gt;&lt;/list&gt;&lt;/item&gt;
      &lt;item&gt;Conventional Commits: strictly enforces the Conventional Commits specification (&lt;code&gt;feat&lt;/code&gt;,&lt;code&gt;fix&lt;/code&gt;,&lt;code&gt;chore&lt;/code&gt;, etc.).&lt;/item&gt;
      &lt;item&gt;Beautiful TUI: A responsive, easy-to-use Terminal User Interface built with Bubble Tea.&lt;/item&gt;
    &lt;/list&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Go (1.21 or later)&lt;/item&gt;
      &lt;item&gt;Git installed and available in your PATH.&lt;/item&gt;
      &lt;item&gt;(Optional) Ollama installed locally if you plan to use the local model.&lt;/item&gt;
    &lt;/list&gt;
    &lt;code&gt;go install github.com/arpxspace/smartcommit@latest&lt;/code&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;
        &lt;p&gt;Clone the repository:&lt;/p&gt;
        &lt;code&gt;git clone https://github.com/arpxspace/smartcommit.git cd smartcommit&lt;/code&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Build the binary:&lt;/p&gt;
        &lt;quote&gt;go build -o smartcommit&lt;/quote&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Move to your PATH (optional):&lt;/p&gt;
        &lt;quote&gt;mv smartcommit /usr/local/bin/&lt;/quote&gt;
      &lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;To use &lt;code&gt;smartcommit&lt;/code&gt; as your default &lt;code&gt;git commit&lt;/code&gt; command, run:&lt;/p&gt;
    &lt;code&gt;git config --global alias.ci '!smartcommit'&lt;/code&gt;
    &lt;p&gt;Or for this repository only:&lt;/p&gt;
    &lt;code&gt;git config alias.ci '!smartcommit'&lt;/code&gt;
    &lt;p&gt;Usage:&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;To commit with smartcommit: &lt;code&gt;git ci&lt;/code&gt;&lt;/item&gt;
    &lt;/list&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;
        &lt;p&gt;Stage your changes:&lt;/p&gt;
        &lt;code&gt;git add .&lt;/code&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Run smartcommit:&lt;/p&gt;
        &lt;quote&gt;smartcommit&lt;/quote&gt;
      &lt;/item&gt;
      &lt;item&gt;
        &lt;p&gt;Follow the TUI:&lt;/p&gt;
        &lt;list rend="ul"&gt;
          &lt;item&gt;First Run: You'll be asked to choose your AI provider (OpenAI or Ollama) and configure it.&lt;/item&gt;
          &lt;item&gt;Analysis: The AI will analyze your changes.&lt;/item&gt;
          &lt;item&gt;Questions: Answer a few questions to provide context.&lt;/item&gt;
          &lt;item&gt;Review: The AI generates a commit message. You can edit it or confirm it to commit immediately.&lt;/item&gt;
        &lt;/list&gt;
      &lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;If you already know what you want to write, you can select "I already know what to write" from the main menu to open your default git editor.&lt;/p&gt;
    &lt;p&gt;smartcommit stores its configuration in a local file (usually &lt;code&gt;~/.smartcommit/config.json&lt;/code&gt;).&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;&lt;code&gt;OPENAI_API_KEY&lt;/code&gt;: If set, smartcommit can detect this during setup and ask if you want to use it, saving you from pasting it manually.&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Contributions are welcome! Please feel free to submit a Pull Request.&lt;/p&gt;
    &lt;list rend="ol"&gt;
      &lt;item&gt;Fork the project&lt;/item&gt;
      &lt;item&gt;Create your feature branch (&lt;code&gt;git checkout -b feature/AmazingFeature&lt;/code&gt;)&lt;/item&gt;
      &lt;item&gt;Commit your changes (&lt;code&gt;git commit -m 'feat: Add some AmazingFeature'&lt;/code&gt;)&lt;/item&gt;
      &lt;item&gt;Push to the branch (&lt;code&gt;git push origin feature/AmazingFeature&lt;/code&gt;)&lt;/item&gt;
      &lt;item&gt;Open a Pull Request&lt;/item&gt;
    &lt;/list&gt;
    &lt;p&gt;Distributed under the MIT License. See &lt;code&gt;LICENSE&lt;/code&gt; for more information.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=46018165</guid><pubDate>Sat, 22 Nov 2025 20:54:35 +0000</pubDate></item><item><title>Show HN: I built a wizard to turn ideas into AI coding agent-ready specs</title><link>https://vibescaffold.dev/</link><description>&lt;doc fingerprint="9afda2d7230d1e70"&gt;
  &lt;main&gt;
    &lt;p&gt;AI-Powered Spec Generator&lt;/p&gt;
    &lt;head rend="h1"&gt;Turn your messy ideas into &lt;lb/&gt;crystal clear specs._&lt;/head&gt;
    &lt;p&gt;Stop writing vague prompt iterations. Generate detailed technical specifications, architecture diagrams, and agent directives from a single structured conversation.&lt;/p&gt;
    &lt;p&gt;spec_generator.exe&lt;/p&gt;
    &lt;p&gt;01&lt;lb/&gt;02&lt;lb/&gt;03&lt;lb/&gt;04&lt;lb/&gt;05&lt;/p&gt;
    &lt;p&gt;02&lt;/p&gt;
    &lt;p&gt;03&lt;/p&gt;
    &lt;p&gt;04&lt;/p&gt;
    &lt;p&gt;05&lt;/p&gt;
    &lt;p&gt;function generateSpec(input) {&lt;lb/&gt;// Analysis in progress...&lt;lb/&gt;const architecture = new SystemDesign(input);&lt;lb/&gt;return architecture.compile();&lt;lb/&gt;}&lt;/p&gt;
    &lt;p&gt;// Analysis in progress...&lt;/p&gt;
    &lt;p&gt;const architecture = new SystemDesign(input);&lt;/p&gt;
    &lt;p&gt;return architecture.compile();&lt;/p&gt;
    &lt;p&gt;}&lt;/p&gt;
    &lt;p&gt;OUTPUT GENERATED&lt;/p&gt;
    &lt;p&gt;ONE_PAGER.md&lt;/p&gt;
    &lt;p&gt;DEV_SPEC.md&lt;/p&gt;
    &lt;p&gt;PROMPT_PLAN.md&lt;/p&gt;
    &lt;p&gt;AGENTS.md&lt;/p&gt;
    &lt;head rend="h2"&gt;=CAPABILITIES&lt;/head&gt;
    &lt;head rend="h3"&gt;Reason over your requirements&lt;/head&gt;
    &lt;head rend="h4"&gt;Product Definition&lt;/head&gt;
    &lt;p&gt;Converts abstract ideas into concrete MVP requirements and user stories.&lt;/p&gt;
    &lt;head rend="h4"&gt;Tech Architecture&lt;/head&gt;
    &lt;p&gt;Drafts complete schema designs, API routes, and security protocols.&lt;/p&gt;
    &lt;head rend="h4"&gt;Development Plan&lt;/head&gt;
    &lt;p&gt;Breaks complexity into sequential, LLM-testable prompt chains.&lt;/p&gt;
    &lt;head rend="h4"&gt;Agent Directives&lt;/head&gt;
    &lt;p&gt;Generates system prompts (AGENTS.md) for autonomous coding agents.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=46018229</guid><pubDate>Sat, 22 Nov 2025 21:02:34 +0000</pubDate></item><item><title>Kids who own smartphones before age 13 have worse mental health outcomes: Study</title><link>https://abcnews.go.com/GMA/Family/kids-smartphones-age-13-worse-mental-health-outcomes/story?id=123961082</link><description>&lt;doc fingerprint="3f6003ff0ecd9e19"&gt;
  &lt;main&gt;
    &lt;head rend="h1"&gt;Kids who own smartphones before age 13 have worse mental health outcomes: Study&lt;/head&gt;
    &lt;p&gt;Early smartphone use was linked to low self-image in girls and boys.&lt;/p&gt;
    &lt;p&gt;Children, especially girls, who own smartphones before they are 13 years old may have worse mental health outcomes when they're older, a new study suggests.&lt;/p&gt;
    &lt;p&gt;The study, published Sunday in the Journal of Human Development and Capabilities, analyzed self-reported questionnaire results from more than 100,000 young adults between the ages of 18 and 24.&lt;/p&gt;
    &lt;p&gt;The questionnaire asked respondents about mental health symptoms, such as having aggression, feelings of detachment, hallucinations and suicidal thoughts. Those who were given smartphones at an earlier age were associated with worse mental health outcomes for every year of smartphone ownership before the age of 13.&lt;/p&gt;
    &lt;p&gt;Early smartphone ownership was associated with feelings of lower self-image and lower self-worth in both girls and boys. Girls reported lower emotional resilience and lower confidence, while boys reported feeling less calm, less stable and less empathetic.&lt;/p&gt;
    &lt;p&gt;"The younger the child gets a smartphone, the more exposure to all this impacts them psychologically and shapes the way they think and view the world," Tara Thiagarajan, one of the study's authors, told ABC News in an emailed statement.&lt;/p&gt;
    &lt;p&gt;About 48% of young women who had smartphones by 5 or 6 years old reported having severe suicidal thoughts, compared to 28% of females who had smartphones by 13 or older.&lt;/p&gt;
    &lt;p&gt;In young men, 31% of those who had smartphones by 5 or 6 years old reported having severe suicidal thoughts and 20% of males who had smartphones by 13 or older reported having severe suicidal thoughts.&lt;/p&gt;
    &lt;p&gt;Study authors attributed the differences between young women's and young men's mental health symptoms to social media usage. Other factors that seemed to impact mental health outcomes were cyberbullying, poor sleep and poor family relationships.&lt;/p&gt;
    &lt;p&gt;The study's authors recommended restricting smartphone and social media access for kids under 13, promoting digital literacy education and corporate accountability.&lt;/p&gt;
    &lt;p&gt;"Ideally, children should not have a smartphone until age 14, and when they do get a smartphone, parents should take the time to discuss with their children how to interact on the Internet and explain the consequences of doing various things," Thiagarajan added.&lt;/p&gt;
    &lt;p&gt;ABC News' Dr. Tara Narula also said on "Good Morning America" Monday that limiting kids' access to social media appears to be a key step in protecting children and their mental health outcomes.&lt;/p&gt;
    &lt;p&gt;"The longer we can push off allowing our kids to be on social media, we are learning, the better," Narula said. "I think lots of families are getting creative … landlines …. flip phones for kids [are] maybe an option so that they can have access to communicating without all the other things that come with smartphones."&lt;/p&gt;
    &lt;p&gt;The study's findings come amid an effort led by social psychologist Jonathan Haidt, author of "Anxious Generation," to limit kids' smartphone use due to the impact on their mental health. Haidt has proposed setting nationwide "norms" or guidelines, including not giving children a smartphone before high school, no social media before age 16 and establishing schools as phone-free zones.&lt;/p&gt;
    &lt;p&gt;Pediatrician Dr. Natasha Burgert also recommended that parents demonstrate to children how to use smartphones responsibly.&lt;/p&gt;
    &lt;p&gt;"Children watch everything you do -- and that doesn't stop until they leave your house," Burgert told ABC News via email. "Connect authentically and meaningfully for a few minutes every day, and show your children that the humans we live with are more important and worthy of our attention than our phones."&lt;/p&gt;
    &lt;p&gt;The American Academy of Pediatrics also recommends families follow the 5 C's of media use, including teaching kids and teens how to be safe online, since content and advertisements may be targeting an older audience.&lt;/p&gt;
    &lt;list rend="ul"&gt;
      &lt;item&gt;Child - Consider your child and their personality. What media are they drawn to and how do they react to it?&lt;/item&gt;
      &lt;item&gt;Content - Consider the content of the media your child consumes. Encourage them to consider good media sources.&lt;/item&gt;
      &lt;item&gt;Calm - Help your child learn how to manage their emotions, including without the help of media.&lt;/item&gt;
      &lt;item&gt;Crowding out - Consider what your family would like to spend more quality time doing, besides consuming media.&lt;/item&gt;
      &lt;item&gt;Communication - Discuss media with children early and often and encourage learning digital literacy.&lt;/item&gt;
    &lt;/list&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=46018292</guid><pubDate>Sat, 22 Nov 2025 21:11:15 +0000</pubDate></item><item><title>WorldGen – Text to Immersive 3D Worlds</title><link>https://www.meta.com/en-gb/blog/worldgen-3d-world-generation-reality-labs-generative-ai-research/</link><description></description><guid isPermaLink="false">https://news.ycombinator.com/item?id=46018380</guid><pubDate>Sat, 22 Nov 2025 21:20:24 +0000</pubDate></item><item><title>Windows ARM64 Internals: Deconstructing Pointer Authentication</title><link>https://www.preludesecurity.com/blog/windows-arm64-internals-deconstructing-pointer-authentication</link><description>&lt;doc fingerprint="90909313a42a7241"&gt;
  &lt;main&gt;
    &lt;p&gt;Pointer Authentication Code, or PAC, is an anti-exploit/memory-corruption feature that signs pointers so their use (as code or data) can be validated at runtime. PAC is available on Armv8.3-A and Armv9.0-A (and later) ARM architectures and leverages virtual addressing in order to store a small cryptographic signature alongside the pointer value.&lt;/p&gt;
    &lt;p&gt;On a typical 64-bit processor a pointer is considered a "user-mode" pointer if bit 47 of a 64-bit address is set to 0 (meaning, then, bits 48-63 are also 0). This is known as a canonical user-mode address. If bit 47 is set to 1, bits 48-63 are also set to 1, with this being considered a canonical kernel-mode address. Additionally, LA57, ARM 52 or 56 bit, or similar processors extend the most significant bit out even further (and PAC can also be enabled in the ARM-specific scenarios). For our purposes, however, we will be looking at a typical 64-bit processor with the most significant bit being bit 47.&lt;/p&gt;
    &lt;p&gt;It has always been an "accepted" standard that the setting of the most significant bit denotes a user-mode or kernel-mode address â with even some hardware vendors, like Intel, formalizing this architecture in actual hardware with CPU features like Linear Address Space Separation (LASS). This means that bits 48-63 are unused on a current, standard 64-bit processor, as the OS typically ignores them. Because they are unused, this allows PAC to store the aforementioned signature in these unused bits alongside the pointer itself.&lt;/p&gt;
    &lt;p&gt;As mentioned, these âunusedâ bits are now used to store signing information about a particular pointer in order to validate and verify execution and/or data access to the target memory address. Special CPU instructions are used to both generate and validate cryptographic signatures associated with a particular pointer value. This blog post will examine the Windows implementation of PAC on ARM64 installations of Windows, which, as we will see, supports a very specific implementation of PAC in both user-mode and kernel-mode.&lt;/p&gt;
    &lt;head rend="h2"&gt;PAC Enablement on Windows&lt;/head&gt;
    &lt;p&gt;PAC enablement on Windows begins at the entry point of ntoskrnl.exe, KiSystemStartup. KiSystemStartup is responsible for determining if PAC is supported on Windows and also for initializing basic PAC support. KiSystemStartup receives the loader parameter block (LOADER_PARAMETER_BLOCK) from winload.efi, the Windows boot loader. The loader block denotes if PAC is supported. Specifically, the loader parameter block extension (LOADER_PARAMETER_EXTENSION) portion of the loader block defines a bitmask of various features which are present/supported, so say the boot loader. The PointerAuthKernelIpEnabled bit of this bitmask denotes if PAC is supported. If PAC is supported, the loader parameter block extension is also responsible for providing the initial PAC signing key (PointerAuthKernelIpKey) used to sign and authenticate all kernel-mode pointers (we will see later that the "current" signing key is updated many times). When execution is occurring in kernel-mode, this is the key used to sign kernel-mode pointers. The bootloader generates the key in OslPrepareTarget by calling the function SymCryptRngAesGenerate to generate the initial kernel pointer signing key passed via the loader parameter block.&lt;/p&gt;
    &lt;p&gt;The ARM architecture supports having multiple signing keys for different scenarios, like signing instruction pointers or data pointers with different keys. Typically, "key A" and "key B" (as they are referred to), which are stored in specific system registers, are used for signing pointers used in instruction executions (like return addresses). Windows currently only uses PAC for "instruction pointers" (more on this later) and it also it only uses "key B" for cryptographic signatures and, therefore, loads the target pointer signing value into the APIBKeyLo_EL1 and APIBKeyHi_EL AArch64 system registers. These "key registers" are specific system registers, which are special registers on ARM systems which control various behaviors/controls/statuses for the system, and are responsible for maintaining the current keys used for signing and authenticating pointers. These two registers ("lo" and hi") each hold a single 64-bit value, which results in a concatenated 128-bit key. EL1, in this case, refers to exception level â1â - which denotes the ARM-equivalent of âprivilege levelâ the CPU is running in (as ARM-based CPUs are âexception-oritentedâ, meaning system calls, interrupts, etc. are all treated as âexceptionsâ). Typically EL1 is associated with kernel-mode. User-mode and kernel-mode, for Windows, share EL1âs signing key register (although the "current" signing key in the register changes depending on if a processor is executing in kernel-mode or user-mode). It should be noted that although the signing key for user-mode is stored in an EL1 register, the register itself (e.g., reading/writing) is inaccessible from user-mode (EL 0).&lt;/p&gt;
    &lt;p&gt;It is possible to examine the current signing key values using WinDbg. Although WinDbg, on ARM systems, has no extension to read from these system registers, it was discovered through trial-and-error that it is possible to leverage the rdmsr command in WinDbg to read from ARM system registers using the encoding values provided by the ARM documentation. The two PAC key system registers used by Windows have the following encodings:&lt;/p&gt;
    &lt;p&gt;â&lt;/p&gt;
    &lt;p&gt;&lt;code&gt;1. APIBKeyLo_EL1&lt;/code&gt;&lt;lb/&gt;- op0: 0b11 (3)&lt;lb/&gt;- op1: 0b000 (0)&lt;lb/&gt;- CRn: 0b0010 (2)&lt;lb/&gt;- CRm: 0b0001 (1)&lt;lb/&gt;- op2: 0b010 (2)&lt;/p&gt;
    &lt;p&gt;&lt;code&gt;2. APIBKeyHigh_EL1&lt;/code&gt;&lt;lb/&gt;- op0: 0b11 (3)&lt;lb/&gt;- op1: 0b000 (0)&lt;lb/&gt;- CRn: 0b0010 (2)&lt;lb/&gt;- CRm: 0b0001 (1)&lt;lb/&gt;- op2: 0b011 (3)&lt;/p&gt;
    &lt;p&gt;â&lt;/p&gt;
    &lt;p&gt;Concatenating these binary values into their hexadecimal values, it is then possible to leverage the rdmsr command to view the current signing key values:&lt;/p&gt;
    &lt;p&gt;After the initial signing key value has been configured, the kernel continues executing its entry point in order to continue to fill out some of the basic functionality of the kernel (although the kernel is not done yet being fully initialized). Almost immediately after performing basic PAC initialization, the function KiInitializeBootStructures is called from the kernel entry point, which also receives the loader parameter block and initializes various items such as the feature settings bitmask, setting the proper stack sizes (especially for "special" stacks like ISR stacks and DPC stacks), etc. One of those crucial things that this function does is call into KiDetectPointerAuthSupport, which is responsible for the bulk of the PAC initialization. This function is responsible for reading from the appropriate PAC-related ARM system registers in order to determine what specific PAC features the current CPU is capable of supporting.&lt;/p&gt;
    &lt;p&gt;After the current CPU's supported options are configured, "phase 0" of the system initialization process (achieved via KeInitsystem) will fully enable PAC. Currently, on Windows 11 24H2 and 25H2 preview builds, enablement is gated through a feature flag called Feature_Pointer_Auth_User__private_featureState. If the feature flag is enabled, a secondary check is performed to determine if a registry override option to disable PAC was present. Additionally, if the PAC feature flag is disabled, a check is performed to see if a registry override to enable PAC is present. The applicable registry paths are:&lt;/p&gt;
    &lt;p&gt;
      &lt;code&gt;- HKLM\System\CurrentControlSet\Control\Session Manager\Kernel\PointerAuthUserIpEnabled&lt;/code&gt;
    &lt;/p&gt;
    &lt;p&gt;
      &lt;code&gt;- HKLM\System\CurrentControlSet\Control\Session Manager\Kernel\PointerAuthUserIpForceDisabled&lt;/code&gt;
    &lt;/p&gt;
    &lt;p&gt;Note that the "enablement" flags are not directly tied one-to-one to the "supported flags". As previously seen, KePointerAuthEnabled is masked with the value 4 in KiSystemStartup before the "supported" options are even evaluated. Additionally, note that the KePointerAuthEnabled variable is marked as read-only and is present in the CFGRO section, which is also read-only in the VTL 0 guest page tables (known in ARM as the âStage 2 tablesâ with âStage 2â tables being the final level of translation from guest memory to system memory) thanks to the services of Hypervisor-Protected Code Integrity (HVCI), along with KePointerAuthKernelIpKey and KePointerAuthMask. As seen below, even using WinDbg, it is impossible to overwrite these global variables as they are read-only in the âStage 2â page tables.&lt;/p&gt;
    &lt;p&gt;As an aside, the supported and enabled PAC features can be queried via NtQuerySystemInformation through the SystemPointerAuthInformation class.&lt;/p&gt;
    &lt;p&gt;â&lt;/p&gt;
    &lt;p&gt;&lt;code&gt;C:\&amp;gt;C:\WindowsPAC.exe&lt;/code&gt;&lt;lb/&gt;[+] System Pointer Authentication Control (PAC) settings:&lt;lb/&gt;Â Â [&amp;gt;] SupportedFlags: 0x1F&lt;lb/&gt;Â Â [&amp;gt;] EnabledFlags: 0x101&lt;lb/&gt;Â Â Â Â [*] AddressAuthFaulting: TRUE&lt;lb/&gt;Â Â Â Â [*] AddressAuthQarma: TRUE&lt;lb/&gt;Â Â Â Â [*] AddressAuthSupported: TRUE&lt;lb/&gt;Â Â Â Â [*] GenericAuthQarma: TRUE&lt;lb/&gt;Â Â Â Â [*] GenericAuthSupported: TRUE&lt;lb/&gt;Â Â Â Â [*] KernelIpAuthEnabled: TRUE&lt;lb/&gt;Â Â Â Â [*] UserGlobalIpAuthEnabled: FALSE&lt;lb/&gt;Â Â Â Â [*] UserPerProcessIpAuthEnabled: TRUE&lt;/p&gt;
    &lt;p&gt;â&lt;/p&gt;
    &lt;p&gt;Once the appropriate PAC-related initialization flags have been set, PAC is then enabled on a per-process basis (if per-process PAC is supported, which currently on Windows it is). For user-mode PAC, the enablement process begins at process creation, specifically during the allocation of the new process object. If PAC is enabled, each user-mode process (meaning EPROCESS-&amp;gt;Flags3.SystemProcess is not set) is unconditionally opted-in to PAC (as all kernel-mode code shares a global signing key).&lt;/p&gt;
    &lt;p&gt;Additionally, likely as a side effect of Intel CET enablement on x86-based installations of Windows, the mitigation value CetDynamicApisOutOfProcOnly is also set unconditionally for every process except for the Idle process on Windows.&lt;/p&gt;
    &lt;p&gt;For the sake of completeness, the CET dynamic address range feature is not actually supported as the PROCESSINFOCLASS enum value ProcessDynamicEnforcedCetCompatibleRanges, for the NtSetInformationProcess system service, always returns STATUS_NOT_SUPPORTED on Windows ARM systems.&lt;/p&gt;
    &lt;p&gt;Returning to user-mode PAC, Windows SDK contains two documented ways to enable/disable PAC for user-mode processes. For extended process creation parameters, the following parameters are available in the SDK:&lt;/p&gt;
    &lt;p&gt;â&lt;/p&gt;
    &lt;p&gt;&lt;code&gt;//&lt;/code&gt;&lt;lb/&gt;// Define the ARM64 user-mode per-process instruction pointer authentication&lt;lb/&gt;// mitigation policy options.&lt;lb/&gt;//&lt;/p&gt;
    &lt;p&gt;
      &lt;code&gt;â&lt;/code&gt;
    &lt;/p&gt;
    &lt;p&gt;
      &lt;code&gt;#define PROCESS_CREATION_MITIGATION_POLICY2_POINTER_AUTH_USER_IP_MASKÂ  Â  Â  (0x00000003ui64 &amp;lt;&amp;lt; 44)&lt;/code&gt;
    &lt;/p&gt;
    &lt;p&gt;
      &lt;code&gt;#define PROCESS_CREATION_MITIGATION_POLICY2_POINTER_AUTH_USER_IP_DEFER Â  Â  (0x00000000ui64 &amp;lt;&amp;lt; 44)&lt;/code&gt;
    &lt;/p&gt;
    &lt;p&gt;
      &lt;code&gt;#define PROCESS_CREATION_MITIGATION_POLICY2_POINTER_AUTH_USER_IP_ALWAYS_ON (0x00000001ui64 &amp;lt;&amp;lt; 44)&lt;/code&gt;
    &lt;/p&gt;
    &lt;p&gt;&lt;code&gt;#define PROCESS_CREATION_MITIGATION_POLICY2_POINTER_AUTH_USER_IP_ALWAYS_OFF&lt;/code&gt;&lt;lb/&gt;(0x00000002ui64 &amp;lt;&amp;lt; 44)&lt;/p&gt;
    &lt;p&gt;
      &lt;code&gt;#define PROCESS_CREATION_MITIGATION_POLICY2_POINTER_AUTH_USER_IP_RESERVEDÂ  (0x00000003ui64 &amp;lt;&amp;lt; 44)&lt;/code&gt;
    &lt;/p&gt;
    &lt;p&gt;â&lt;/p&gt;
    &lt;p&gt;Additionally, for runtime enablement/disablement, the following structure can be supplied with the ProcessUserPointerAuthPolicy:&lt;/p&gt;
    &lt;p&gt;â&lt;/p&gt;
    &lt;p&gt;&lt;code&gt;typedef struct _PROCESS_MITIGATION_USER_POINTER_AUTH_POLICY {&lt;/code&gt;&lt;lb/&gt;Â Â Â Â union {&lt;lb/&gt;Â Â Â Â Â Â Â Â DWORD Flags&lt;lb/&gt;Â Â Â Â Â Â Â Â struct {&lt;lb/&gt;Â Â Â Â Â Â Â Â Â Â Â Â DWORD EnablePointerAuthUserIp : 1;&lt;lb/&gt;Â Â Â Â Â Â Â Â Â Â Â Â DWORD ReservedFlags : 31;&lt;lb/&gt;Â Â Â Â Â Â Â Â } DUMMYSTRUCTNAME;&lt;lb/&gt;Â Â Â Â } DUMMYUNIONNAME;&lt;lb/&gt;} PROCESS_MITIGATION_USER_POINTER_AUTH_POLICY,&lt;lb/&gt;*PPROCESS_MITIGATION_USER_POINTER_AUTH_POLICY;&lt;/p&gt;
    &lt;p&gt;â&lt;/p&gt;
    &lt;p&gt;However, testing and reverse engineering revealed that PAC is unconditionally enabled on user-mode processes (as shown above) with no way to disable the mitigation either at process creation (e.g., creating a child process with extended parameters) or by calling SetProcessMitigationPolicy at runtime. The only other supported way to enable a process mitigation at process creation is to use the ImageFileExecutionOptions (IFEO) registry key. This functionality is wrapped by the "Exploit Protection" UI on Windows systems, but the registry value can be set manually. Unfortunately, there is no PAC Exploit Protection setting in the UI.&lt;/p&gt;
    &lt;p&gt;Outside of the exploit mitigation policy for PAC, there is also an audit-mode exploit mitigation policy option in the ImageFileExecutionOptions policy map. This can be confirmed through the presence of the mitigation flag values of AuditPointerAuthUserIp and AuditPointerAuthUserIpLogged in the MitigationFlags2Values field of a process object on Windows.&lt;/p&gt;
    &lt;p&gt;The IFEO registry key contains a list of processes that have IFEO values. One of the items encapsulated in the IFEO key, as mentioned, is both the mitigation policy settings and audit-mode mitigation policy settings (meaning that an ETW event is logged but the target operation is not blocked/process is not terminated by a mitigation violation) for a target process. These per-process mitigation values are used in making considerations about what mitigation policies will be applied to a particular target process at process creation time. On a default installation of Windows 11 24H2 running an ARM build of Windows, no processes have the audit-mode PAC flags set.&lt;/p&gt;
    &lt;p&gt;Further investigation reveals that this is because there is no way to set the PAC audit-mode exploit policy value on a per-process basis, even through the IFEO key. This is because if pointer authentication is enabled, for example, the slot in the map (represented by the 0x000000000000X000 nibble) in which audit-mode PAC may be enabled is explicitly overridden by PspAllocateProcess (and no ETW event exists in the manifest of the Microsoft-Windows-Security-Mitigations ETW provider for PAC violations).&lt;/p&gt;
    &lt;p&gt;Once PAC support has been instantiated for the process, the per-process signing key is configured. Yes, this means that each process has its own key it can use to sign pointers. This occurs in PspAllocateProcess and, if a process has not opted in to inheriting the signing key, a random key is generated with BCryptGenRandom.&lt;/p&gt;
    &lt;p&gt;The "per-process" signing key differs from the initial (kernel) signing key that was configured in KiSystemStartup. This is because, obviously, execution is in kernel mode when the initial signing key is instantiated. However, the implementation of PAC on Windows (as we can see above) instruments a per-process signing key (along with a single kernel key). When execution transitions into user mode, the signing key system register(s) are updated to the current process signing key (which is maintained through a process object). The example below outlines the current PAC signing key being updated to that of a user-mode process, specifically when a return into user-mode happens after a system call is handled by the kernel (KiSystemServiceExit).&lt;/p&gt;
    &lt;p&gt;This is how the necessary PAC infrastructure is updated for user-to-kernel and kernel-to-user transitions and how kernel-mode and user-mode PAC on Windows is set up. Let's now examine what Windows does when the proper infrastructure is in place.&lt;/p&gt;
    &lt;head rend="h2"&gt;Windows PAC As An Exploit Mitigation&lt;/head&gt;
    &lt;p&gt;Windows currently offers an implementation of PAC (with the ability to expand in the future). Windows currently supports PAC for signing and authenticating "instruction pointers". The way that this manifests itself, however, really results in the signing of return addresses. On Windows, for both user-mode and kernel-mode ARM64 code, one can specify the /guard:signret(-) compiler flag to either explicitly enable or disable the signing of return addresses. Enabling this flag instruments the pacibsp and autibsp instructions into the prologue and epilogue of each function, which are "PAC" instructions used to both sign and subsequently validate return addresses.&lt;/p&gt;
    &lt;p&gt;In the ARM64 architecture, the semantics of preserving return addresses across call boundaries slightly differ from Intel x86. On x86-based systems, a call instruction will also push the target return address onto the stack. Then, right before a return, the aforementioned return address is "popped" off of the stack and loaded into the instruction pointer. On ARM64 the bl (Branch with Link, similar to a call) instruction will instead place the current, in-scope return address an architectural register (lr, or "link register") with a typical operating system, like Windows, also storing this value on the stack to preserve the return address so the lr register can be used for the next call's return address (meaning the return addresses are still stored on the stack on ARM, even with the presence of lr).&lt;/p&gt;
    &lt;p&gt;The pacibsp instruction will use "key b" (APIBKeyLo_EL1 and APIBKeyHi_EL1) and the value of the in-scope stack pointer to sign the return address. The target return address will remain in this state, with the upper bits (non-canonical) being transformed through the signing.&lt;/p&gt;
    &lt;p&gt;This assumes, however, that there is already a return address to process. What if a user-mode thread, for example, is just entering its initial execution, and there is no return address? Windows has two functions (for user-mode and kernel-mode) that will generate the necessary "first" signed return address via KiGenerateSignedReturnAddressForStartUserThread. These functions accept the initial stack value as the value to use in the signing of the return address, using instead the pacib instruction, which is capable of using a general-purpose architectural register in the signing process instead of just defaulting to "the current stack pointer".&lt;/p&gt;
    &lt;p&gt;At this point, the return address (stored in lr, but also present on the stack) has been signed. The in-scope function performs its work and eventually the epilogue of a function is reached (which is responsible for returning to the caller for the current function). When the epilogue is reached, but before the ret has been executed, the autibsp instruction is used to authenticate the return address (in lr) before performing the return control-flow transfer. This will result in transforming the value in lr back to the "original" return address so that the return occurs back into a valid memory address.&lt;/p&gt;
    &lt;p&gt;The effectiveness of PAC, however, relies on what happens if a return address has been corrupted with a malicious return address, like a ROP gadget or the corruption of a return address through a stack-based buffer overflow. In the example below, this is outlined by corrupting a return address on the stack with another return address on the stack. Both of these addresses used in this memory corruption example are signed, but, as we can recall from earlier, return addresses are signed with the considerations of the current in-scope stack pointer (meaning they are tied to a stack frame). Because the corrupted return address does not correspond to an "in-scope" stack frame, the authentication of the in-scope return address (which has been corrupted) results in a fastfail with the code FAST_FAIL_POINTER_AUTH_INVALID_RETURN_ADDRESS - and the application crashes. One interesting note, as you can see, is that WinDbg can convert a signed return address on the stack to its actual unsigned value (and appropriate symbol name).Â&lt;/p&gt;
    &lt;p&gt;Shifting focus slightly, when a kernel-mode PAC violation, identical to the previous scenario, occurs, a KERNEL_SECURITY_CHECK_FAILURE ensues, with the type of memory safety violation being FAST_FAIL_POINTER_AUTH_INVALID_RETURN_ADDRESS.&lt;/p&gt;
    &lt;head rend="h2"&gt;Secure Kernel And PAC&lt;/head&gt;
    &lt;p&gt;The curious reader may notice that the kernel itself is responsible for managing the key values for PAC. Additionally, we already covered the fact that the in-memory variable which tracks the kernelâs PAC signing key (used to sign kernel pointers) is read-only in VTL 0 memory thanks to the services of HVCI. However, the in-memory representation is simply a reflection of the system register value(s) we have talked about before - the APIBKeyLo_EL1 and APIBKeyHi_EL AArch64 registers (specifically when execution is in kernel-mode, loading the per-boot kernel-mode PAC key). What is preventing an attacker, in kernel-mode, from modifying the contents of this system register at any given time? After all, the register is writable from kernel-mode because the configuration is not delegated to a higher security boundary? To help alleviate this problem, Secure Kernel Patch Guard, more commonly referred to as âHyperGuardâ - a security feature promulgated by the Secure Kernel - is used! HyperGuard achieves much of what PatchGuard attempts to defend against (modification of kernel data structures, MSRs on x86 systems, control registers, etc.) but it does so deterministically, as opposed to PatchGuard, because HyperGuard runs at a higher security boundary than the code it is attempting to defend (VTL 0âs kernel).&lt;/p&gt;
    &lt;p&gt;HyperGuard uses what is known as extents, which are definitions of what components/code/data/etc. should be protected by HyperGuard. On ARM64 installations of Windows, an ARM64-specific HyperGuard extent exists - the PAC system register extent. This extent is used by HyperGuard to ask the hypervisor to intercept certain items of interest - such as modifications to an MSR (or ARM64 system register), certain memory access operations, etc. Specifically for the ARM64 version of the Secure Kernel, an extent is registered for monitoring modifications to the PAC key system registers. This is done in securekernel!SkpgxInitializeInterceptMasks.&lt;/p&gt;
    &lt;p&gt;Although ARM-based hypervisors do not have âVirtual Machine Control Structureâ, or VMCS (in the âcanonicalâ sense that x86-based systems do, such as having dedicated instructions in the ISA for reading/writing to the VMCS), ARM hypervisors still must maintain the âstateâ of a guest. This, obviously, is used in situations like when a processor starts executing in context of the hypervisor software (due to a hypervisor call (HVC call), or other exceptions into the hypervisor), or when a guest starts resuming its execution. Part of this state - as is the case with x86-based systems - is the set of virtual registers (e.g., registers which are preserved across exception level changes into/out of the hypervisor and are specific to a guest). Among the virtual registers which are configurable by the hypervisor are, as you may have guessed, the âloâ and âhiâ PAC signing key registers! This is what the function from the screenshot above intends to achieve - securekernel!SkpgArm64ReadRegister64.&lt;/p&gt;
    &lt;p&gt;Microsoft documents many of the 64-bit virtualized-registers. Among the undocumented registers, however, are the ARM-based virtualized registers. However, we can see above that values 0x4002E and 0x4002F correspond to the virtual/private PAC signing registers. For completeness sake, 0x40002 corresponds to SCTLR_EL1. This was determined by examining the bit being processed (bit 30, via the 0x40000000 mask). This was previously seen, in the beginning of our analysis, by the toggling of SCTLR_EL1.EnIB bit (bit 30).&lt;/p&gt;
    &lt;p&gt;This entire configuration allows the Secure Kernel to intercept, via HyperGuard, any unauthorized modification of the PAC signing key register.&lt;/p&gt;
    &lt;head rend="h1"&gt;Conclusion&lt;/head&gt;
    &lt;p&gt;ARM-based processors, without the presence of backwards-edge control flow integrity (CFI) mitigations like CET, are able to effectively leverage PAC to defend against return address corruption. Windows, as we have seen, currently leverages PAC only in limited circumstances (like the protection of return addresses), which is standard on many mainstream implementations of PAC (with the ability in the future, if feasible, to expand into protection of data accesses). PAC provides a viable solution to protect non-x86-based processors from certain classes of memory corruption exploits. In addition, current-generation ARM64 Microsoft devices, like the Surface Pro, are not shipped with chips that can support the Memory Tagging Extension (MTE) feature. Although not implemented today on Windows systems, the implementation of both PAC and MTE in the future would serve to greatly increase the cost of memory corruption exploits. Given the protections afforded by the hypervisor, plus the current implementation of PAC, ARM-based Windows provides both user-mode and kernel-mode code with additional security against memory corruption exploits.&lt;/p&gt;
  &lt;/main&gt;
  &lt;comments/&gt;
&lt;/doc&gt;</description><guid isPermaLink="false">https://news.ycombinator.com/item?id=46018664</guid><pubDate>Sat, 22 Nov 2025 22:03:29 +0000</pubDate></item></channel></rss>